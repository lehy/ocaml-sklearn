
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.7">
    
    
      
        <title>Cluster - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.19753c6b.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.196e0c26.min.css">
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#affinitypropagation" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Cluster
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" >
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Cluster/" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Conftest/" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Constants/" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Fft/" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Fftpack/" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Integrate/" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Interpolate/" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Io/" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Linalg/" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Misc/" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Ndimage/" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Odr/" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Optimize/" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Setup/" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Signal/" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Sparse/" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Spatial/" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Special/" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Stats/" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/Version/" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../scipy/wrap_version/" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Base/" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Calibration/" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Cluster
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      Cluster
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#affinitypropagation" class="md-nav__link">
    AffinityPropagation
  </a>
  
    <nav class="md-nav" aria-label="AffinityPropagation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers_indices_" class="md-nav__link">
    cluster_centers_indices_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers_" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels_" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_matrix_" class="md-nav__link">
    affinity_matrix_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter_" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#agglomerativeclustering" class="md-nav__link">
    AgglomerativeClustering
  </a>
  
    <nav class="md-nav" aria-label="AgglomerativeClustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_1" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_1" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_1" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_1" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_1" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_clusters_" class="md-nav__link">
    n_clusters_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__1" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_leaves_" class="md-nav__link">
    n_leaves_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_connected_components_" class="md-nav__link">
    n_connected_components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children_" class="md-nav__link">
    children_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_1" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_1" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_1" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#birch" class="md-nav__link">
    Birch
  </a>
  
    <nav class="md-nav" aria-label="Birch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_2" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_2" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_2" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_2" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partial_fit" class="md-nav__link">
    partial_fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_1" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_2" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#root_" class="md-nav__link">
    root_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dummy_leaf_" class="md-nav__link">
    dummy_leaf_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subcluster_centers_" class="md-nav__link">
    subcluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subcluster_labels_" class="md-nav__link">
    subcluster_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__2" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_2" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_2" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_2" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dbscan" class="md-nav__link">
    DBSCAN
  </a>
  
    <nav class="md-nav" aria-label="DBSCAN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_3" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_3" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_3" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_3" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_3" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core_sample_indices_" class="md-nav__link">
    core_sample_indices_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#components_" class="md-nav__link">
    components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__3" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_3" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_3" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_3" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#featureagglomeration" class="md-nav__link">
    FeatureAgglomeration
  </a>
  
    <nav class="md-nav" aria-label="FeatureAgglomeration">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_4" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_4" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_1" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_4" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inverse_transform" class="md-nav__link">
    inverse_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_4" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_1" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_clusters__1" class="md-nav__link">
    n_clusters_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__4" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_leaves__1" class="md-nav__link">
    n_leaves_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_connected_components__1" class="md-nav__link">
    n_connected_components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children__1" class="md-nav__link">
    children_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distances_" class="md-nav__link">
    distances_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_4" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_4" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_4" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kmeans" class="md-nav__link">
    KMeans
  </a>
  
    <nav class="md-nav" aria-label="KMeans">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_5" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_5" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_4" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_2" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_5" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_2" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#score" class="md-nav__link">
    score
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_5" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_2" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__1" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__5" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inertia_" class="md-nav__link">
    inertia_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter__1" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_5" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_5" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_5" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meanshift" class="md-nav__link">
    MeanShift
  </a>
  
    <nav class="md-nav" aria-label="MeanShift">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_6" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_6" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_5" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_6" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_3" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_6" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__2" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__6" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter__2" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_6" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_6" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_6" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#minibatchkmeans" class="md-nav__link">
    MiniBatchKMeans
  </a>
  
    <nav class="md-nav" aria-label="MiniBatchKMeans">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_7" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_7" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_6" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_3" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_7" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partial_fit_1" class="md-nav__link">
    partial_fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_4" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#score_1" class="md-nav__link">
    score
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_7" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_3" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__3" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__7" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inertia__1" class="md-nav__link">
    inertia_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_7" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_7" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_7" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optics" class="md-nav__link">
    OPTICS
  </a>
  
    <nav class="md-nav" aria-label="OPTICS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_8" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_8" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_7" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_8" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_8" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__8" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reachability_" class="md-nav__link">
    reachability_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ordering_" class="md-nav__link">
    ordering_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core_distances_" class="md-nav__link">
    core_distances_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predecessor_" class="md-nav__link">
    predecessor_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_hierarchy_" class="md-nav__link">
    cluster_hierarchy_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_8" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_8" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_8" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralbiclustering" class="md-nav__link">
    SpectralBiclustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralBiclustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_9" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_9" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_indices" class="md-nav__link">
    get_indices
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_9" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_shape" class="md-nav__link">
    get_shape
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submatrix" class="md-nav__link">
    get_submatrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_9" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rows_" class="md-nav__link">
    rows_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#columns_" class="md-nav__link">
    columns_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_labels_" class="md-nav__link">
    row_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_labels_" class="md-nav__link">
    column_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_9" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_9" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_9" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralclustering" class="md-nav__link">
    SpectralClustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralClustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_10" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_10" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_8" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_10" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_10" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_matrix__1" class="md-nav__link">
    affinity_matrix_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__9" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_10" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_10" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_10" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralcoclustering" class="md-nav__link">
    SpectralCoclustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralCoclustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_11" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_11" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_indices_1" class="md-nav__link">
    get_indices
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_11" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_shape_1" class="md-nav__link">
    get_shape
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submatrix_1" class="md-nav__link">
    get_submatrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_11" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rows__1" class="md-nav__link">
    rows_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#columns__1" class="md-nav__link">
    columns_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_labels__1" class="md-nav__link">
    row_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_labels__1" class="md-nav__link">
    column_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_11" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_11" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_11" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_propagation" class="md-nav__link">
    affinity_propagation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_optics_dbscan" class="md-nav__link">
    cluster_optics_dbscan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_optics_xi" class="md-nav__link">
    cluster_optics_xi
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compute_optics_graph" class="md-nav__link">
    compute_optics_graph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbscan_1" class="md-nav__link">
    dbscan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estimate_bandwidth" class="md-nav__link">
    estimate_bandwidth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bin_seeds" class="md-nav__link">
    get_bin_seeds
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k_means" class="md-nav__link">
    k_means
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkage_tree" class="md-nav__link">
    linkage_tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mean_shift" class="md-nav__link">
    mean_shift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spectral_clustering" class="md-nav__link">
    spectral_clustering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ward_tree" class="md-nav__link">
    ward_tree
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Compose/" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Covariance/" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cross_decomposition/" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Datasets/" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Decomposition/" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Discriminant_analysis/" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Dummy/" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ensemble/" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Exceptions/" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Experimental/" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Externals/" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Feature_extraction/" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Feature_selection/" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Gaussian_process/" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Impute/" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Inspection/" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Isotonic/" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kernel_approximation/" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kernel_ridge/" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linear_model/" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Manifold/" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Metrics/" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Mixture/" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Model_selection/" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Multiclass/" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Multioutput/" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Naive_bayes/" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Neighbors/" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Neural_network/" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Pipeline/" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Preprocessing/" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Random_projection/" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Semi_supervised/" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Svm/" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Tests/" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Tree/" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Utils/" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../arr/" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../dict/" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#affinitypropagation" class="md-nav__link">
    AffinityPropagation
  </a>
  
    <nav class="md-nav" aria-label="AffinityPropagation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers_indices_" class="md-nav__link">
    cluster_centers_indices_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers_" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels_" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_matrix_" class="md-nav__link">
    affinity_matrix_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter_" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#agglomerativeclustering" class="md-nav__link">
    AgglomerativeClustering
  </a>
  
    <nav class="md-nav" aria-label="AgglomerativeClustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_1" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_1" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_1" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_1" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_1" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_clusters_" class="md-nav__link">
    n_clusters_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__1" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_leaves_" class="md-nav__link">
    n_leaves_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_connected_components_" class="md-nav__link">
    n_connected_components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children_" class="md-nav__link">
    children_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_1" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_1" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_1" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#birch" class="md-nav__link">
    Birch
  </a>
  
    <nav class="md-nav" aria-label="Birch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_2" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_2" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_2" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_2" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partial_fit" class="md-nav__link">
    partial_fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_1" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_2" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#root_" class="md-nav__link">
    root_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dummy_leaf_" class="md-nav__link">
    dummy_leaf_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subcluster_centers_" class="md-nav__link">
    subcluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subcluster_labels_" class="md-nav__link">
    subcluster_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__2" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_2" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_2" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_2" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dbscan" class="md-nav__link">
    DBSCAN
  </a>
  
    <nav class="md-nav" aria-label="DBSCAN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_3" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_3" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_3" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_3" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_3" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core_sample_indices_" class="md-nav__link">
    core_sample_indices_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#components_" class="md-nav__link">
    components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__3" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_3" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_3" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_3" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#featureagglomeration" class="md-nav__link">
    FeatureAgglomeration
  </a>
  
    <nav class="md-nav" aria-label="FeatureAgglomeration">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_4" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_4" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_1" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_4" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inverse_transform" class="md-nav__link">
    inverse_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_4" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_1" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_clusters__1" class="md-nav__link">
    n_clusters_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__4" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_leaves__1" class="md-nav__link">
    n_leaves_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_connected_components__1" class="md-nav__link">
    n_connected_components_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children__1" class="md-nav__link">
    children_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distances_" class="md-nav__link">
    distances_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_4" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_4" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_4" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kmeans" class="md-nav__link">
    KMeans
  </a>
  
    <nav class="md-nav" aria-label="KMeans">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_5" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_5" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_4" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_2" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_5" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_2" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#score" class="md-nav__link">
    score
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_5" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_2" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__1" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__5" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inertia_" class="md-nav__link">
    inertia_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter__1" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_5" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_5" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_5" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meanshift" class="md-nav__link">
    MeanShift
  </a>
  
    <nav class="md-nav" aria-label="MeanShift">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_6" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_6" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_5" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_6" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_3" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_6" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__2" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__6" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n_iter__2" class="md-nav__link">
    n_iter_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_6" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_6" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_6" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#minibatchkmeans" class="md-nav__link">
    MiniBatchKMeans
  </a>
  
    <nav class="md-nav" aria-label="MiniBatchKMeans">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_7" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_7" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_6" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_transform_3" class="md-nav__link">
    fit_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_7" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partial_fit_1" class="md-nav__link">
    partial_fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_4" class="md-nav__link">
    predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#score_1" class="md-nav__link">
    score
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_7" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transform_3" class="md-nav__link">
    transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_centers__3" class="md-nav__link">
    cluster_centers_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__7" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inertia__1" class="md-nav__link">
    inertia_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_7" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_7" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_7" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#optics" class="md-nav__link">
    OPTICS
  </a>
  
    <nav class="md-nav" aria-label="OPTICS">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_8" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_8" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_7" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_8" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_8" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__8" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reachability_" class="md-nav__link">
    reachability_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ordering_" class="md-nav__link">
    ordering_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core_distances_" class="md-nav__link">
    core_distances_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predecessor_" class="md-nav__link">
    predecessor_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_hierarchy_" class="md-nav__link">
    cluster_hierarchy_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_8" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_8" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_8" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralbiclustering" class="md-nav__link">
    SpectralBiclustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralBiclustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_9" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_9" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_indices" class="md-nav__link">
    get_indices
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_9" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_shape" class="md-nav__link">
    get_shape
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submatrix" class="md-nav__link">
    get_submatrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_9" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rows_" class="md-nav__link">
    rows_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#columns_" class="md-nav__link">
    columns_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_labels_" class="md-nav__link">
    row_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_labels_" class="md-nav__link">
    column_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_9" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_9" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_9" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralclustering" class="md-nav__link">
    SpectralClustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralClustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_10" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_10" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_predict_8" class="md-nav__link">
    fit_predict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_10" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_10" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_matrix__1" class="md-nav__link">
    affinity_matrix_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#labels__9" class="md-nav__link">
    labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_10" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_10" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_10" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spectralcoclustering" class="md-nav__link">
    SpectralCoclustering
  </a>
  
    <nav class="md-nav" aria-label="SpectralCoclustering">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create_11" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fit_11" class="md-nav__link">
    fit
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_indices_1" class="md-nav__link">
    get_indices
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_params_11" class="md-nav__link">
    get_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_shape_1" class="md-nav__link">
    get_shape
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submatrix_1" class="md-nav__link">
    get_submatrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_params_11" class="md-nav__link">
    set_params
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rows__1" class="md-nav__link">
    rows_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#columns__1" class="md-nav__link">
    columns_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#row_labels__1" class="md-nav__link">
    row_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_labels__1" class="md-nav__link">
    column_labels_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_11" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_11" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_11" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#affinity_propagation" class="md-nav__link">
    affinity_propagation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_optics_dbscan" class="md-nav__link">
    cluster_optics_dbscan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cluster_optics_xi" class="md-nav__link">
    cluster_optics_xi
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compute_optics_graph" class="md-nav__link">
    compute_optics_graph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dbscan_1" class="md-nav__link">
    dbscan
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estimate_bandwidth" class="md-nav__link">
    estimate_bandwidth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_bin_seeds" class="md-nav__link">
    get_bin_seeds
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k_means" class="md-nav__link">
    k_means
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linkage_tree" class="md-nav__link">
    linkage_tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mean_shift" class="md-nav__link">
    mean_shift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spectral_clustering" class="md-nav__link">
    spectral_clustering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ward_tree" class="md-nav__link">
    ward_tree
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/sklearn/Cluster.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>Cluster</h1>
                
                <h2 id="affinitypropagation">AffinityPropagation<a class="headerlink" href="#affinitypropagation" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.AffinityPropagation</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AffinityPropagation.html"><code>sklearn.cluster.AffinityPropagation</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create">create<a class="headerlink" href="#create" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">damping</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">convergence_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">preference</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">affinity</span><span class="o">:[`</span><span class="nc">Euclidean</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Precomputed</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform Affinity Propagation Clustering of data.</p>
<p>Read more in the :ref:<code>User Guide &lt;affinity_propagation&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>damping : float, default=0.5</strong>
    Damping factor (between 0.5 and 1) is the extent to
    which the current value is maintained relative to
    incoming values (weighted 1 - damping). This in order
    to avoid numerical oscillations when updating these
    values (messages).</p>
</li>
<li>
<p><strong>max_iter : int, default=200</strong>
    Maximum number of iterations.</p>
</li>
<li>
<p><strong>convergence_iter : int, default=15</strong>
    Number of iterations with no change in the number
    of estimated clusters that stops the convergence.</p>
</li>
<li>
<p><strong>copy : bool, default=True</strong>
    Make a copy of input data.</p>
</li>
<li>
<p><strong>preference : array-like of shape (n_samples,) or float, default=None</strong>
    Preferences for each point - points with larger values of
    preferences are more likely to be chosen as exemplars. The number
    of exemplars, ie of clusters, is influenced by the input
    preferences value. If the preferences are not passed as arguments,
    they will be set to the median of the input similarities.</p>
</li>
<li>
<p><strong>affinity : {'euclidean', 'precomputed'}, default='euclidean'</strong>
    Which affinity to use. At the moment 'precomputed' and
    <code>euclidean</code> are supported. 'euclidean' uses the
    negative squared euclidean distance between points.</p>
</li>
<li>
<p><strong>verbose : bool, default=False</strong>
    Whether to be verbose.</p>
</li>
<li>
<p><strong>random_state : int or np.random.RandomStateInstance, default: 0</strong>
    Pseudo-random number generator to control the starting state.
    Use an int for reproducible results across function calls.
    See the :term:<code>Glossary &lt;random_state&gt;</code>.</p>
<p>.. versionadded:: 0.23
    this parameter was previously hardcoded as 0.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>cluster_centers_indices_ : ndarray of shape (n_clusters,)</strong>
    Indices of cluster centers</p>
</li>
<li>
<p><strong>cluster_centers_ : ndarray of shape (n_clusters, n_features)</strong>
    Cluster centers (if affinity != <code>precomputed</code>).</p>
</li>
<li>
<p><strong>labels_ : ndarray of shape (n_samples,)</strong>
    Labels of each point</p>
</li>
<li>
<p><strong>affinity_matrix_ : ndarray of shape (n_samples, n_samples)</strong>
    Stores the affinity matrix used in <code>fit</code>.</p>
</li>
<li>
<p><strong>n_iter_ : int</strong>
    Number of iterations taken to converge.</p>
</li>
</ul>
<h4>Notes</h4>
<p>For an example, see :ref:<code>examples/cluster/plot_affinity_propagation.py
&lt;sphx_glr_auto_examples_cluster_plot_affinity_propagation.py&gt;</code>.</p>
<p>The algorithmic complexity of affinity propagation is quadratic
in the number of points.</p>
<p>When <code>fit</code> does not converge, <code>cluster_centers_</code> becomes an empty
array and all training samples will be labelled as <code>-1</code>. In addition,
<code>predict</code> will then label every sample as <code>-1</code>.</p>
<p>When all training samples have equal similarities and equal preferences,
the assignment of cluster centers and labels depends on the preference.
If the preference is smaller than the similarities, <code>fit</code> will result in
a single cluster center and label <code>0</code> for every sample. Otherwise, every
training sample becomes its own cluster center and is assigned a unique
label.</p>
<h4>References</h4>
<p>Brendan J. Frey and Delbert Dueck, 'Clustering by Passing Messages
Between Data Points', Science Feb. 2007</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">AffinityPropagation</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">AffinityPropagation</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">AffinityPropagation</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">cluster_centers_</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="fit">fit<a class="headerlink" href="#fit" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Fit the clustering from features, or affinity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like or sparse matrix, shape (n_samples, n_features), or             array-like, shape (n_samples, n_samples)</strong>
    Training instances to cluster, or similarities / affinities between
    instances if <code>affinity='precomputed'</code>. If a sparse feature matrix
    is provided, it will be converted into a sparse <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_predict">fit_predict<a class="headerlink" href="#fit_predict" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fit the clustering from features or affinity matrix, and return
cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like or sparse matrix, shape (n_samples, n_features), or             array-like, shape (n_samples, n_samples)</strong>
    Training instances to cluster, or similarities / affinities between
    instances if <code>affinity='precomputed'</code>. If a sparse feature matrix
    is provided, it will be converted into a sparse <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray, shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="get_params">get_params<a class="headerlink" href="#get_params" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="predict">predict<a class="headerlink" href="#predict" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predict</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Predict the closest cluster each sample in X belongs to.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : array-like or sparse matrix, shape (n_samples, n_features)</strong>
    New data to predict. If a sparse matrix is provided, it will be
    converted into a sparse <code>csr_matrix</code>.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray, shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="set_params">set_params<a class="headerlink" href="#set_params" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="cluster_centers_indices_">cluster_centers_indices_<a class="headerlink" href="#cluster_centers_indices_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_centers_indices_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_centers_indices_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_centers_indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="cluster_centers_">cluster_centers_<a class="headerlink" href="#cluster_centers_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_centers_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_centers_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_centers_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels_">labels_<a class="headerlink" href="#labels_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="affinity_matrix_">affinity_matrix_<a class="headerlink" href="#affinity_matrix_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute affinity_matrix_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">affinity_matrix_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">affinity_matrix_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_iter_">n_iter_<a class="headerlink" href="#n_iter_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_iter_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_iter_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_iter_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string">to_string<a class="headerlink" href="#to_string" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show">show<a class="headerlink" href="#show" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp">pp<a class="headerlink" href="#pp" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="agglomerativeclustering">AgglomerativeClustering<a class="headerlink" href="#agglomerativeclustering" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.AgglomerativeClustering</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html"><code>sklearn.cluster.AgglomerativeClustering</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_1">create<a class="headerlink" href="#create_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">affinity</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">memory</span><span class="o">:[`</span><span class="nc">Object_with_the_joblib_Memory_interface</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">connectivity</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_full_tree</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">linkage</span><span class="o">:[`</span><span class="nc">Ward</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complete</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Average</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Single</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">distance_threshold</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Agglomerative Clustering</p>
<p>Recursively merges the pair of clusters that minimally increases
a given linkage distance.</p>
<p>Read more in the :ref:<code>User Guide &lt;hierarchical_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int or None, default=2</strong>
    The number of clusters to find. It must be <code>None</code> if
    <code>distance_threshold</code> is not <code>None</code>.</p>
</li>
<li>
<p><strong>affinity : str or callable, default='euclidean'</strong>
    Metric used to compute the linkage. Can be 'euclidean', 'l1', 'l2',
    'manhattan', 'cosine', or 'precomputed'.
    If linkage is 'ward', only 'euclidean' is accepted.
    If 'precomputed', a distance matrix (instead of a similarity matrix)
    is needed as input for the fit method.</p>
</li>
<li>
<p><strong>memory : str or object with the joblib.Memory interface, default=None</strong>
    Used to cache the output of the computation of the tree.
    By default, no caching is done. If a string is given, it is the
    path to the caching directory.</p>
</li>
<li>
<p><strong>connectivity : array-like or callable, default=None</strong>
    Connectivity matrix. Defines for each sample the neighboring
    samples following a given structure of the data.
    This can be a connectivity matrix itself or a callable that transforms
    the data into a connectivity matrix, such as derived from
    kneighbors_graph. Default is None, i.e, the
    hierarchical clustering algorithm is unstructured.</p>
</li>
<li>
<p><strong>compute_full_tree : 'auto' or bool, default='auto'</strong>
    Stop early the construction of the tree at n_clusters. This is useful
    to decrease computation time if the number of clusters is not small
    compared to the number of samples. This option is useful only when
    specifying a connectivity matrix. Note also that when varying the
    number of clusters and using caching, it may be advantageous to compute
    the full tree. It must be <code>True</code> if <code>distance_threshold</code> is not
    <code>None</code>. By default <code>compute_full_tree</code> is 'auto', which is equivalent
    to <code>True</code> when <code>distance_threshold</code> is not <code>None</code> or that <code>n_clusters</code>
    is inferior to the maximum between 100 or <code>0.02 * n_samples</code>.
    Otherwise, 'auto' is equivalent to <code>False</code>.</p>
</li>
<li>
<p><strong>linkage : {'ward', 'complete', 'average', 'single'}, default='ward'</strong>
    Which linkage criterion to use. The linkage criterion determines which
    distance to use between sets of observation. The algorithm will merge
    the pairs of cluster that minimize this criterion.</p>
<ul>
<li>ward minimizes the variance of the clusters being merged.</li>
<li>average uses the average of the distances of each observation of
  the two sets.</li>
<li>complete or maximum linkage uses the maximum distances between
  all observations of the two sets.</li>
<li>single uses the minimum of the distances between all observations
  of the two sets.</li>
</ul>
<p>.. versionadded:: 0.20
    Added the 'single' option</p>
</li>
<li>
<p><strong>distance_threshold : float, default=None</strong>
    The linkage distance threshold above which, clusters will not be
    merged. If not <code>None</code>, <code>n_clusters</code> must be <code>None</code> and
    <code>compute_full_tree</code> must be <code>True</code>.</p>
<p>.. versionadded:: 0.21</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>n_clusters_ : int</strong>
    The number of clusters found by the algorithm. If
    <code>distance_threshold=None</code>, it will be equal to the given
    <code>n_clusters</code>.</p>
</li>
<li>
<p><strong>labels_ : ndarray of shape (n_samples)</strong>
    cluster labels for each point</p>
</li>
<li>
<p><strong>n_leaves_ : int</strong>
    Number of leaves in the hierarchical tree.</p>
</li>
<li>
<p><strong>n_connected_components_ : int</strong>
    The estimated number of connected components in the graph.</p>
<p>.. versionadded:: 0.21
    <code>n_connected_components_</code> was added to replace <code>n_components_</code>.</p>
</li>
<li>
<p><strong>children_ : array-like of shape (n_samples-1, 2)</strong>
    The children of each non-leaf node. Values less than <code>n_samples</code>
    correspond to leaves of the tree which are the original samples.
    A node <code>i</code> greater than or equal to <code>n_samples</code> is a non-leaf
    node and has children <code>children_[i - n_samples]</code>. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node <code>n_samples + i</code></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">AgglomerativeClustering</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="fit_1">fit<a class="headerlink" href="#fit_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Fit the hierarchical clustering from features, or distance matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like, shape (n_samples, n_features) or (n_samples, n_samples)</strong>
    Training instances to cluster, or distances between instances if
    <code>affinity='precomputed'</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_predict_1">fit_predict<a class="headerlink" href="#fit_predict_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fit the hierarchical clustering from features or distance matrix,
and return cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like, shape (n_samples, n_features) or (n_samples, n_samples)</strong>
    Training instances to cluster, or distances between instances if
    <code>affinity='precomputed'</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray, shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="get_params_1">get_params<a class="headerlink" href="#get_params_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="set_params_1">set_params<a class="headerlink" href="#set_params_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="n_clusters_">n_clusters_<a class="headerlink" href="#n_clusters_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_clusters_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_clusters_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_clusters_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__1">labels_<a class="headerlink" href="#labels__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_leaves_">n_leaves_<a class="headerlink" href="#n_leaves_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_leaves_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_leaves_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_leaves_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_connected_components_">n_connected_components_<a class="headerlink" href="#n_connected_components_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_connected_components_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_connected_components_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_connected_components_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="children_">children_<a class="headerlink" href="#children_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute children_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">children_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">children_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_1">to_string<a class="headerlink" href="#to_string_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_1">show<a class="headerlink" href="#show_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_1">pp<a class="headerlink" href="#pp_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="birch">Birch<a class="headerlink" href="#birch" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.Birch</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Birch.html"><code>sklearn.cluster.Birch</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_2">create<a class="headerlink" href="#create_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">threshold</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">branching_factor</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:[`</span><span class="nc">None</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ClusterMixin</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ClusterMixin</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_labels</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Implements the Birch clustering algorithm.</p>
<p>It is a memory-efficient, online-learning algorithm provided as an
alternative to :class:<code>MiniBatchKMeans</code>. It constructs a tree
data structure with the cluster centroids being read off the leaf.
These can be either the final cluster centroids or can be provided as input
to another clustering algorithm such as :class:<code>AgglomerativeClustering</code>.</p>
<p>Read more in the :ref:<code>User Guide &lt;birch&gt;</code>.</p>
<p>.. versionadded:: 0.16</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>threshold : float, default=0.5</strong>
    The radius of the subcluster obtained by merging a new sample and the
    closest subcluster should be lesser than the threshold. Otherwise a new
    subcluster is started. Setting this value to be very low promotes
    splitting and vice-versa.</p>
</li>
<li>
<p><strong>branching_factor : int, default=50</strong>
    Maximum number of CF subclusters in each node. If a new samples enters
    such that the number of subclusters exceed the branching_factor then
    that node is split into two nodes with the subclusters redistributed
    in each. The parent subcluster of that node is removed and two new
    subclusters are added as parents of the 2 split nodes.</p>
</li>
<li>
<p><strong>n_clusters : int, instance of sklearn.cluster model, default=3</strong>
    Number of clusters after the final clustering step, which treats the
    subclusters from the leaves as new samples.</p>
<ul>
<li>
<p><code>None</code> : the final clustering step is not performed and the
  subclusters are returned as they are.</p>
</li>
<li>
<p>:mod:<code>sklearn.cluster</code> Estimator : If a model is provided, the model
  is fit treating the subclusters as new samples and the initial data
  is mapped to the label of the closest subcluster.</p>
</li>
<li>
<p><code>int</code> : the model fit is :class:<code>AgglomerativeClustering</code> with
  <code>n_clusters</code> set to be equal to the int.</p>
</li>
</ul>
</li>
<li>
<p><strong>compute_labels : bool, default=True</strong>
    Whether or not to compute labels for each fit.</p>
</li>
<li>
<p><strong>copy : bool, default=True</strong>
    Whether or not to make a copy of the given data. If set to False,
    the initial data will be overwritten.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>root_ : _CFNode</strong>
    Root of the CFTree.</p>
</li>
<li>
<p><strong>dummy_leaf_ : _CFNode</strong>
    Start pointer to all the leaves.</p>
</li>
<li>
<p><strong>subcluster_centers_ : ndarray</strong>
    Centroids of all subclusters read directly from the leaves.</p>
</li>
<li>
<p><strong>subcluster_labels_ : ndarray</strong>
    Labels assigned to the centroids of the subclusters after
    they are clustered globally.</p>
</li>
<li>
<p><strong>labels_ : ndarray of shape (n_samples,)</strong>
    Array of labels assigned to the input data.
    if partial_fit is used instead of fit, they are assigned to the
    last batch of data.</p>
</li>
</ul>
<h4>See Also</h4>
<p>MiniBatchKMeans
    Alternative  implementation that does incremental updates
    of the centers' positions using mini-batches.</p>
<h4>Notes</h4>
<p>The tree data structure consists of nodes with each node consisting of
a number of subclusters. The maximum number of subclusters in a node
is determined by the branching factor. Each subcluster maintains a
linear sum, squared sum and the number of samples in that subcluster.
In addition, each subcluster can also have a node as its child, if the
subcluster is not a member of a leaf node.</p>
<p>For a new point entering the root, it is merged with the subcluster closest
to it and the linear sum, squared sum and the number of samples of that
subcluster are updated. This is done recursively till the properties of
the leaf node are updated.</p>
<h4>References</h4>
<ul>
<li>
<p>Tian Zhang, Raghu Ramakrishnan, Maron Livny</p>
</li>
<li>
<p><strong>BIRCH: An efficient data clustering method for large databases.</strong></p>
</li>
<li>
<p><strong>https://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf</strong></p>
</li>
<li>
<p>Roberto Perdisci
  JBirch - Java implementation of BIRCH clustering algorithm</p>
</li>
<li>
<p><strong>https://code.google.com/archive/p/jbirch</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">Birch</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">brc</span> <span class="o">=</span> <span class="n">Birch</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">brc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">Birch</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">brc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="fit_2">fit<a class="headerlink" href="#fit_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Build a CF Tree for the input data.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    Input data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self
    Fitted estimator.</p>
</details>
<h3 id="fit_predict_2">fit_predict<a class="headerlink" href="#fit_predict_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform clustering on X and returns cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="fit_transform">fit_transform<a class="headerlink" href="#fit_transform" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_transform</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">fit_params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix, dataframe} of shape                 (n_samples, n_features)</strong></p>
</li>
<li>
<p><strong>y : ndarray of shape (n_samples,), default=None</strong>
    Target values.</p>
</li>
<li>
<p><strong>**fit_params : dict</strong>
    Additional fit parameters.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : ndarray array of shape (n_samples, n_features_new)</strong>
    Transformed array.</li>
</ul>
</details>
<h3 id="get_params_2">get_params<a class="headerlink" href="#get_params_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="partial_fit">partial_fit<a class="headerlink" href="#partial_fit" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method partial_fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">partial_fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Online learning. Prevents rebuilding of CFTree from scratch.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features),             default=None</strong>
    Input data. If X is not provided, only the global clustering
    step is done.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self
    Fitted estimator.</p>
</details>
<h3 id="predict_1">predict<a class="headerlink" href="#predict_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predict</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Predict data using the <code>centroids_</code> of subclusters.</p>
<p>Avoid computation of the row norms of X.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    Input data.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape(n_samples,)</strong>
    Labelled data.</li>
</ul>
</details>
<h3 id="set_params_2">set_params<a class="headerlink" href="#set_params_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="transform">transform<a class="headerlink" href="#transform" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform X into subcluster centroids dimension.</p>
<p>Each dimension represents the distance from the sample point to each
cluster centroid.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    Input data.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_trans : {array-like, sparse matrix} of shape (n_samples, n_clusters)</strong>
    Transformed data.</li>
</ul>
</details>
<h3 id="root_">root_<a class="headerlink" href="#root_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute root_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">root_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">root_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="dummy_leaf_">dummy_leaf_<a class="headerlink" href="#dummy_leaf_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute dummy_leaf_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dummy_leaf_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">dummy_leaf_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="subcluster_centers_">subcluster_centers_<a class="headerlink" href="#subcluster_centers_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute subcluster_centers_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subcluster_centers_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">subcluster_centers_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="subcluster_labels_">subcluster_labels_<a class="headerlink" href="#subcluster_labels_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute subcluster_labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subcluster_labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">subcluster_labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__2">labels_<a class="headerlink" href="#labels__2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_2">to_string<a class="headerlink" href="#to_string_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_2">show<a class="headerlink" href="#show_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_2">pp<a class="headerlink" href="#pp_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="dbscan">DBSCAN<a class="headerlink" href="#dbscan" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.DBSCAN</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html"><code>sklearn.cluster.DBSCAN</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_3">create<a class="headerlink" href="#create_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">min_samples</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric_params</span><span class="o">:</span><span class="nn">Dict</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ball_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Kd_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Brute</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">leaf_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform DBSCAN clustering from vector array or distance matrix.</p>
<p>DBSCAN - Density-Based Spatial Clustering of Applications with Noise.
Finds core samples of high density and expands clusters from them.
Good for data which contains clusters of similar density.</p>
<p>Read more in the :ref:<code>User Guide &lt;dbscan&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>eps : float, default=0.5</strong>
    The maximum distance between two samples for one to be considered
    as in the neighborhood of the other. This is not a maximum bound
    on the distances of points within a cluster. This is the most
    important DBSCAN parameter to choose appropriately for your data set
    and distance function.</p>
</li>
<li>
<p><strong>min_samples : int, default=5</strong>
    The number of samples (or total weight) in a neighborhood for a point
    to be considered as a core point. This includes the point itself.</p>
</li>
<li>
<p><strong>metric : string, or callable, default='euclidean'</strong>
    The metric to use when calculating distance between instances in a
    feature array. If metric is a string or callable, it must be one of
    the options allowed by :func:<code>sklearn.metrics.pairwise_distances</code> for
    its metric parameter.
    If metric is 'precomputed', X is assumed to be a distance matrix and
    must be square. X may be a :term:<code>Glossary &lt;sparse graph&gt;</code>, in which
    case only 'nonzero' elements may be considered neighbors for DBSCAN.</p>
<p>.. versionadded:: 0.17
   metric <em>precomputed</em> to accept precomputed sparse matrix.</p>
</li>
<li>
<p><strong>metric_params : dict, default=None</strong>
    Additional keyword arguments for the metric function.</p>
<p>.. versionadded:: 0.19</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto'</strong>
    The algorithm to be used by the NearestNeighbors module
    to compute pointwise distances and find nearest neighbors.
    See NearestNeighbors module documentation for details.</p>
</li>
<li>
<p><strong>leaf_size : int, default=30</strong>
    Leaf size passed to BallTree or cKDTree. This can affect the speed
    of the construction and query, as well as the memory required
    to store the tree. The optimal value depends
    on the nature of the problem.</p>
</li>
<li>
<p><strong>p : float, default=None</strong>
    The power of the Minkowski metric to be used to calculate distance
    between points.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of parallel jobs to run.
    <code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
    <code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
    for more details.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>core_sample_indices_ : ndarray of shape (n_core_samples,)</strong>
    Indices of core samples.</p>
</li>
<li>
<p><strong>components_ : ndarray of shape (n_core_samples, n_features)</strong>
    Copy of each core sample found by training.</p>
</li>
<li>
<p><strong>labels_ : ndarray of shape (n_samples)</strong>
    Cluster labels for each point in the dataset given to fit().
    Noisy samples are given the label -1.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">80</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<h4>See also</h4>
<p>OPTICS
    A similar clustering at multiple values of eps. Our implementation
    is optimized for memory usage.</p>
<h4>Notes</h4>
<p>For an example, see :ref:<code>examples/cluster/plot_dbscan.py
&lt;sphx_glr_auto_examples_cluster_plot_dbscan.py&gt;</code>.</p>
<p>This implementation bulk-computes all neighborhood queries, which increases
the memory complexity to O(n.d) where d is the average number of neighbors,
while original DBSCAN had memory complexity O(n). It may attract a higher
memory complexity when querying these nearest neighborhoods, depending
on the <code>algorithm</code>.</p>
<p>One way to avoid the query complexity is to pre-compute sparse
neighborhoods in chunks using
:func:<code>NearestNeighbors.radius_neighbors_graph
&lt;sklearn.neighbors.NearestNeighbors.radius_neighbors_graph&gt;</code> with
<code>mode='distance'</code>, then using <code>metric='precomputed'</code> here.</p>
<p>Another way to reduce memory and computation time is to remove
(near-)duplicate points and use <code>sample_weight</code> instead.</p>
<p>:class:<code>cluster.OPTICS</code> provides a similar clustering with lower memory
usage.</p>
<h4>References</h4>
<p>Ester, M., H. P. Kriegel, J. Sander, and X. Xu, 'A Density-Based
Algorithm for Discovering Clusters in Large Spatial Databases with Noise'.</p>
<ul>
<li><strong>In: Proceedings of the 2nd International Conference on Knowledge Discovery</strong>
and Data Mining, Portland, OR, AAAI Press, pp. 226-231. 1996</li>
</ul>
<p>Schubert, E., Sander, J., Ester, M., Kriegel, H. P., &amp; Xu, X. (2017).
DBSCAN revisited, revisited: why and how you should (still) use DBSCAN.
ACM Transactions on Database Systems (TODS), 42(3), 19.</p>
</details>
<h3 id="fit_3">fit<a class="headerlink" href="#fit_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform DBSCAN clustering from features, or distance matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features), or             (n_samples, n_samples)</strong>
    Training instances to cluster, or distances between instances if
    <code>metric='precomputed'</code>. If a sparse matrix is provided, it will
    be converted into a sparse <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    Weight of each sample, such that a sample with a weight of at least
    <code>min_samples</code> is by itself a core sample; a sample with a
    negative weight may inhibit its eps-neighbor from being core.
    Note that weights are absolute, and default to 1.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_predict_3">fit_predict<a class="headerlink" href="#fit_predict_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform DBSCAN clustering from features or distance matrix,
and return cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features), or             (n_samples, n_samples)</strong>
    Training instances to cluster, or distances between instances if
    <code>metric='precomputed'</code>. If a sparse matrix is provided, it will
    be converted into a sparse <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    Weight of each sample, such that a sample with a weight of at least
    <code>min_samples</code> is by itself a core sample; a sample with a
    negative weight may inhibit its eps-neighbor from being core.
    Note that weights are absolute, and default to 1.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Cluster labels. Noisy samples are given the label -1.</li>
</ul>
</details>
<h3 id="get_params_3">get_params<a class="headerlink" href="#get_params_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="set_params_3">set_params<a class="headerlink" href="#set_params_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="core_sample_indices_">core_sample_indices_<a class="headerlink" href="#core_sample_indices_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute core_sample_indices_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">core_sample_indices_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">core_sample_indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="components_">components_<a class="headerlink" href="#components_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute components_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">components_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">components_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__3">labels_<a class="headerlink" href="#labels__3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_3">to_string<a class="headerlink" href="#to_string_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_3">show<a class="headerlink" href="#show_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_3">pp<a class="headerlink" href="#pp_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="featureagglomeration">FeatureAgglomeration<a class="headerlink" href="#featureagglomeration" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.FeatureAgglomeration</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.FeatureAgglomeration.html"><code>sklearn.cluster.FeatureAgglomeration</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_4">create<a class="headerlink" href="#create_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">affinity</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">memory</span><span class="o">:[`</span><span class="nc">Object_with_the_joblib_Memory_interface</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">connectivity</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_full_tree</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">linkage</span><span class="o">:[`</span><span class="nc">Ward</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complete</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Average</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Single</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">pooling_func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">distance_threshold</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Agglomerate features.</p>
<p>Similar to AgglomerativeClustering, but recursively merges features
instead of samples.</p>
<p>Read more in the :ref:<code>User Guide &lt;hierarchical_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int, default=2</strong>
    The number of clusters to find. It must be <code>None</code> if
    <code>distance_threshold</code> is not <code>None</code>.</p>
</li>
<li>
<p><strong>affinity : str or callable, default='euclidean'</strong>
    Metric used to compute the linkage. Can be 'euclidean', 'l1', 'l2',
    'manhattan', 'cosine', or 'precomputed'.
    If linkage is 'ward', only 'euclidean' is accepted.</p>
</li>
<li>
<p><strong>memory : str or object with the joblib.Memory interface, default=None</strong>
    Used to cache the output of the computation of the tree.
    By default, no caching is done. If a string is given, it is the
    path to the caching directory.</p>
</li>
<li>
<p><strong>connectivity : array-like or callable, default=None</strong>
    Connectivity matrix. Defines for each feature the neighboring
    features following a given structure of the data.
    This can be a connectivity matrix itself or a callable that transforms
    the data into a connectivity matrix, such as derived from
    kneighbors_graph. Default is None, i.e, the
    hierarchical clustering algorithm is unstructured.</p>
</li>
<li>
<p><strong>compute_full_tree : 'auto' or bool, optional, default='auto'</strong>
    Stop early the construction of the tree at n_clusters. This is useful
    to decrease computation time if the number of clusters is not small
    compared to the number of features. This option is useful only when
    specifying a connectivity matrix. Note also that when varying the
    number of clusters and using caching, it may be advantageous to compute
    the full tree. It must be <code>True</code> if <code>distance_threshold</code> is not
    <code>None</code>. By default <code>compute_full_tree</code> is 'auto', which is equivalent
    to <code>True</code> when <code>distance_threshold</code> is not <code>None</code> or that <code>n_clusters</code>
    is inferior to the maximum between 100 or <code>0.02 * n_samples</code>.
    Otherwise, 'auto' is equivalent to <code>False</code>.</p>
</li>
<li>
<p><strong>linkage : {'ward', 'complete', 'average', 'single'}, default='ward'</strong>
    Which linkage criterion to use. The linkage criterion determines which
    distance to use between sets of features. The algorithm will merge
    the pairs of cluster that minimize this criterion.</p>
<ul>
<li>ward minimizes the variance of the clusters being merged.</li>
<li>average uses the average of the distances of each feature of
  the two sets.</li>
<li>complete or maximum linkage uses the maximum distances between
  all features of the two sets.</li>
<li>single uses the minimum of the distances between all observations
  of the two sets.</li>
</ul>
</li>
<li>
<p><strong>pooling_func : callable, default=np.mean</strong>
    This combines the values of agglomerated features into a single
    value, and should accept an array of shape [M, N] and the keyword
    argument <code>axis=1</code>, and reduce it to an array of size [M].</p>
</li>
<li>
<p><strong>distance_threshold : float, default=None</strong>
    The linkage distance threshold above which, clusters will not be
    merged. If not <code>None</code>, <code>n_clusters</code> must be <code>None</code> and
    <code>compute_full_tree</code> must be <code>True</code>.</p>
<p>.. versionadded:: 0.21</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>n_clusters_ : int</strong>
    The number of clusters found by the algorithm. If
    <code>distance_threshold=None</code>, it will be equal to the given
    <code>n_clusters</code>.</p>
</li>
<li>
<p><strong>labels_ : array-like of (n_features,)</strong>
    cluster labels for each feature.</p>
</li>
<li>
<p><strong>n_leaves_ : int</strong>
    Number of leaves in the hierarchical tree.</p>
</li>
<li>
<p><strong>n_connected_components_ : int</strong>
    The estimated number of connected components in the graph.</p>
<p>.. versionadded:: 0.21
    <code>n_connected_components_</code> was added to replace <code>n_components_</code>.</p>
</li>
<li>
<p><strong>children_ : array-like of shape (n_nodes-1, 2)</strong>
    The children of each non-leaf node. Values less than <code>n_features</code>
    correspond to leaves of the tree which are the original samples.
    A node <code>i</code> greater than or equal to <code>n_features</code> is a non-leaf
    node and has children <code>children_[i - n_features]</code>. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node <code>n_features + i</code></p>
</li>
<li>
<p><strong>distances_ : array-like of shape (n_nodes-1,)</strong>
    Distances between nodes in the corresponding place in <code>children_</code>.
    Only computed if distance_threshold is not None.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">cluster</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_digits</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="n">digits</span><span class="o">.</span><span class="n">images</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">agglo</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">FeatureAgglomeration</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">agglo</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">FeatureAgglomeration</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X_reduced</span> <span class="o">=</span> <span class="n">agglo</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X_reduced</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="fit_4">fit<a class="headerlink" href="#fit_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Fit the hierarchical clustering on the data</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    The data</p>
</li>
<li>
<p><strong>y : Ignored</strong></p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_transform_1">fit_transform<a class="headerlink" href="#fit_transform_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_transform</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">fit_params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix, dataframe} of shape                 (n_samples, n_features)</strong></p>
</li>
<li>
<p><strong>y : ndarray of shape (n_samples,), default=None</strong>
    Target values.</p>
</li>
<li>
<p><strong>**fit_params : dict</strong>
    Additional fit parameters.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : ndarray array of shape (n_samples, n_features_new)</strong>
    Transformed array.</li>
</ul>
</details>
<h3 id="get_params_4">get_params<a class="headerlink" href="#get_params_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="inverse_transform">inverse_transform<a class="headerlink" href="#inverse_transform" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method inverse_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inverse_transform</span> <span class="o">:</span>
  <span class="n">xred</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Inverse the transformation.
Return a vector of size nb_features with the values of Xred assigned
to each group of features</p>
<h4>Parameters</h4>
<ul>
<li><strong>Xred : array-like of shape (n_samples, n_clusters) or (n_clusters,)</strong>
    The values to be assigned to each cluster of samples</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X : array, shape=[n_samples, n_features] or [n_features]</strong>
    A vector of size n_samples with the values of Xred assigned to
    each of the cluster of samples.</li>
</ul>
</details>
<h3 id="set_params_4">set_params<a class="headerlink" href="#set_params_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="transform_1">transform<a class="headerlink" href="#transform_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform a new matrix using the built clustering</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : array-like of shape (n_samples, n_features) or (n_samples,)</strong>
    A M by N array of M observations in N dimensions or a length
    M array of M one-dimensional observations.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>Y : array, shape = [n_samples, n_clusters] or [n_clusters]</strong>
    The pooled values for each feature cluster.</li>
</ul>
</details>
<h3 id="n_clusters__1">n_clusters_<a class="headerlink" href="#n_clusters__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_clusters_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_clusters_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_clusters_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__4">labels_<a class="headerlink" href="#labels__4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_leaves__1">n_leaves_<a class="headerlink" href="#n_leaves__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_leaves_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_leaves_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_leaves_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_connected_components__1">n_connected_components_<a class="headerlink" href="#n_connected_components__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_connected_components_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_connected_components_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_connected_components_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="children__1">children_<a class="headerlink" href="#children__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute children_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">children_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">children_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="distances_">distances_<a class="headerlink" href="#distances_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute distances_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distances_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">distances_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_4">to_string<a class="headerlink" href="#to_string_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_4">show<a class="headerlink" href="#show_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_4">pp<a class="headerlink" href="#pp_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="kmeans">KMeans<a class="headerlink" href="#kmeans" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.KMeans</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html"><code>sklearn.cluster.KMeans</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_5">create<a class="headerlink" href="#create_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K_means_</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Random</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">precompute_distances</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Elkan</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>K-Means clustering.</p>
<p>Read more in the :ref:<code>User Guide &lt;k_means&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int, default=8</strong>
    The number of clusters to form as well as the number of
    centroids to generate.</p>
</li>
<li>
<p><strong>init : {'k-means++', 'random', ndarray, callable}, default='k-means++'</strong>
    Method for initialization:</p>
<p>'k-means++' : selects initial cluster centers for k-mean
clustering in a smart way to speed up convergence. See section
Notes in k_init for more details.</p>
<p>'random': choose <code>n_clusters</code> observations (rows) at random from data
for the initial centroids.</p>
<p>If an ndarray is passed, it should be of shape (n_clusters, n_features)
and gives the initial centers.</p>
<p>If a callable is passed, it should take arguments X, n_clusters and a
random state and return an initialization.</p>
</li>
<li>
<p><strong>n_init : int, default=10</strong>
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.</p>
</li>
<li>
<p><strong>max_iter : int, default=300</strong>
    Maximum number of iterations of the k-means algorithm for a
    single run.</p>
</li>
<li>
<p><strong>tol : float, default=1e-4</strong>
    Relative tolerance with regards to Frobenius norm of the difference
    in the cluster centers of two consecutive iterations to declare
    convergence.</p>
</li>
<li>
<p><strong>precompute_distances : {'auto', True, False}, default='auto'</strong>
    Precompute distances (faster but takes more memory).</p>
<p>'auto' : do not precompute distances if n_samples * n_clusters &gt; 12
million. This corresponds to about 100MB overhead per job using
double precision.</p>
</li>
<li>
<p><strong>True : always precompute distances.</strong></p>
</li>
<li>
<p><strong>False : never precompute distances.</strong></p>
<p>.. deprecated:: 0.23
    'precompute_distances' was deprecated in version 0.22 and will be
    removed in 0.25. It has no effect.</p>
</li>
<li>
<p><strong>verbose : int, default=0</strong>
    Verbosity mode.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    Determines random number generation for centroid initialization. Use
    an int to make the randomness deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>copy_x : bool, default=True</strong>
    When pre-computing distances it is more numerically accurate to center
    the data first. If copy_x is True (default), then the original data is
    not modified. If False, the original data is modified, and put back
    before the function returns, but small numerical differences may be
    introduced by subtracting and then adding the data mean. Note that if
    the original data is not C-contiguous, a copy will be made even if
    copy_x is False. If the original data is sparse, but not in CSR format,
    a copy will be made even if copy_x is False.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of OpenMP threads to use for the computation. Parallelism is
    sample-wise on the main cython loop which assigns each sample to its
    closest center.</p>
<p><code>None</code> or <code>-1</code> means using all processors.</p>
<p>.. deprecated:: 0.23
    <code>n_jobs</code> was deprecated in version 0.23 and will be removed in
    0.25.</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'full', 'elkan'}, default='auto'</strong>
    K-means algorithm to use. The classical EM-style algorithm is 'full'.
    The 'elkan' variation is more efficient on data with well-defined
    clusters, by using the triangle inequality. However it's more memory
    intensive due to the allocation of an extra array of shape
    (n_samples, n_clusters).</p>
<p>For now 'auto' (kept for backward compatibiliy) chooses 'elkan' but it
might change in the future for a better heuristic.</p>
<p>.. versionchanged:: 0.18
    Added Elkan algorithm</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>cluster_centers_ : ndarray of shape (n_clusters, n_features)</strong>
    Coordinates of cluster centers. If the algorithm stops before fully
    converging (see <code>tol</code> and <code>max_iter</code>), these will not be
    consistent with <code>labels_</code>.</p>
</li>
<li>
<p><strong>labels_ : ndarray of shape (n_samples,)</strong>
    Labels of each point</p>
</li>
<li>
<p><strong>inertia_ : float</strong>
    Sum of squared distances of samples to their closest cluster center.</p>
</li>
<li>
<p><strong>n_iter_ : int</strong>
    Number of iterations run.</p>
</li>
</ul>
<h4>See also</h4>
<p>MiniBatchKMeans
    Alternative online implementation that does incremental updates
    of the centers positions using mini-batches.
    For large scale learning (say n_samples &gt; 10k) MiniBatchKMeans is
    probably much faster than the default batch implementation.</p>
<h4>Notes</h4>
<p>The k-means problem is solved using either Lloyd's or Elkan's algorithm.</p>
<p>The average complexity is given by O(k n T), were n is the number of
samples and T is the number of iteration.</p>
<p>The worst case complexity is given by O(n^(k+2/p)) with
n = n_samples, p = n_features. (D. Arthur and S. Vassilvitskii,
'How slow is the k-means method?' SoCG2006)</p>
<p>In practice, the k-means algorithm is very fast (one of the fastest
clustering algorithms available), but it falls in local minima. That's why
it can be useful to restart it several times.</p>
<p>If the algorithm stops before fully converging (because of <code>tol</code> or
<code>max_iter</code>), <code>labels_</code> and <code>cluster_centers_</code> will not be consistent,
i.e. the <code>cluster_centers_</code> will not be the means of the points in each
cluster. Also, the estimator will reassign <code>labels_</code> after the last
iteration to make <code>labels_</code> consistent with <code>predict</code> on the training
set.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">10.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="fit_5">fit<a class="headerlink" href="#fit_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Compute k-means clustering.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    Training instances to cluster. It must be noted that the data
    will be converted to C ordering, which will cause a memory
    copy if the given data is not C-contiguous.
    If a sparse matrix is passed, a copy will be made if it's not in
    CSR format.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
<p>.. versionadded:: 0.20</p>
</li>
</ul>
<h4>Returns</h4>
<p>self
    Fitted estimator.</p>
</details>
<h3 id="fit_predict_4">fit_predict<a class="headerlink" href="#fit_predict_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute cluster centers and predict cluster index for each sample.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Index of the cluster each sample belongs to.</li>
</ul>
</details>
<h3 id="fit_transform_2">fit_transform<a class="headerlink" href="#fit_transform_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_transform</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute clustering and transform X to cluster-distance space.</p>
<p>Equivalent to fit(X).transform(X), but more efficiently implemented.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : array of shape (n_samples, n_clusters)</strong>
    X transformed in the new space.</li>
</ul>
</details>
<h3 id="get_params_5">get_params<a class="headerlink" href="#get_params_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="predict_2">predict<a class="headerlink" href="#predict_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Predict the closest cluster each sample in X belongs to.</p>
<p>In the vector quantization literature, <code>cluster_centers_</code> is called
the code book and each value returned by <code>predict</code> is the index of
the closest code in the code book.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to predict.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Index of the cluster each sample belongs to.</li>
</ul>
</details>
<h3 id="score">score<a class="headerlink" href="#score" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method score</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">score</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>Opposite of the value of X on the K-means objective.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>score : float</strong>
    Opposite of the value of X on the K-means objective.</li>
</ul>
</details>
<h3 id="set_params_5">set_params<a class="headerlink" href="#set_params_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="transform_2">transform<a class="headerlink" href="#transform_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform X to a cluster-distance space.</p>
<p>In the new space, each dimension is the distance to the cluster
centers.  Note that even if X is sparse, the array returned by
<code>transform</code> will typically be dense.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : ndarray of shape (n_samples, n_clusters)</strong>
    X transformed in the new space.</li>
</ul>
</details>
<h3 id="cluster_centers__1">cluster_centers_<a class="headerlink" href="#cluster_centers__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_centers_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_centers_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_centers_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__5">labels_<a class="headerlink" href="#labels__5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="inertia_">inertia_<a class="headerlink" href="#inertia_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute inertia_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inertia_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
<span class="k">val</span> <span class="n">inertia_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_iter__1">n_iter_<a class="headerlink" href="#n_iter__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_iter_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_iter_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_iter_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_5">to_string<a class="headerlink" href="#to_string_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_5">show<a class="headerlink" href="#show_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_5">pp<a class="headerlink" href="#pp_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="meanshift">MeanShift<a class="headerlink" href="#meanshift" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.MeanShift</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MeanShift.html"><code>sklearn.cluster.MeanShift</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_6">create<a class="headerlink" href="#create_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">bandwidth</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">seeds</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">bin_seeding</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">min_bin_freq</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">cluster_all</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Mean shift clustering using a flat kernel.</p>
<p>Mean shift clustering aims to discover 'blobs' in a smooth density of
samples. It is a centroid-based algorithm, which works by updating
candidates for centroids to be the mean of the points within a given
region. These candidates are then filtered in a post-processing stage to
eliminate near-duplicates to form the final set of centroids.</p>
<p>Seeding is performed using a binning technique for scalability.</p>
<p>Read more in the :ref:<code>User Guide &lt;mean_shift&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>bandwidth : float, default=None</strong>
    Bandwidth used in the RBF kernel.</p>
<p>If not given, the bandwidth is estimated using
sklearn.cluster.estimate_bandwidth; see the documentation for that
function for hints on scalability (see also the Notes, below).</p>
</li>
<li>
<p><strong>seeds : array-like of shape (n_samples, n_features), default=None</strong>
    Seeds used to initialize kernels. If not set,
    the seeds are calculated by clustering.get_bin_seeds
    with bandwidth as the grid size and default values for
    other parameters.</p>
</li>
<li>
<p><strong>bin_seeding : bool, default=False</strong>
    If true, initial kernel locations are not locations of all
    points, but rather the location of the discretized version of
    points, where points are binned onto a grid whose coarseness
    corresponds to the bandwidth. Setting this option to True will speed
    up the algorithm because fewer seeds will be initialized.
    The default value is False.
    Ignored if seeds argument is not None.</p>
</li>
<li>
<p><strong>min_bin_freq : int, default=1</strong>
   To speed up the algorithm, accept only those bins with at least
   min_bin_freq points as seeds.</p>
</li>
<li>
<p><strong>cluster_all : bool, default=True</strong>
    If true, then all points are clustered, even those orphans that are
    not within any kernel. Orphans are assigned to the nearest kernel.
    If false, then orphans are given cluster label -1.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of jobs to use for the computation. This works by computing
    each of the n_init runs in parallel.</p>
<p><code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
<code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
for more details.</p>
</li>
<li>
<p><strong>max_iter : int, default=300</strong>
    Maximum number of iterations, per seed point before the clustering
    operation terminates (for that seed point), if has not converged yet.</p>
<p>.. versionadded:: 0.22</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>cluster_centers_ : array, [n_clusters, n_features]</strong>
    Coordinates of cluster centers.</p>
</li>
<li>
<p><strong>labels_ : array of shape (n_samples,)</strong>
    Labels of each point.</p>
</li>
<li>
<p><strong>n_iter_ : int</strong>
    Maximum number of iterations performed on each seed.</p>
<p>.. versionadded:: 0.22</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MeanShift</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">MeanShift</span><span class="p">(</span><span class="n">bandwidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">MeanShift</span><span class="p">(</span><span class="n">bandwidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<h4>Notes</h4>
<p>Scalability:</p>
<p>Because this implementation uses a flat kernel and
a Ball Tree to look up members of each kernel, the complexity will tend
towards O(T<em>n</em>log(n)) in lower dimensions, with n the number of samples
and T the number of points. In higher dimensions the complexity will
tend towards O(T*n^2).</p>
<p>Scalability can be boosted by using fewer seeds, for example by using
a higher value of min_bin_freq in the get_bin_seeds function.</p>
<p>Note that the estimate_bandwidth function is much less scalable than the
mean shift algorithm and will be the bottleneck if it is used.</p>
<h4>References</h4>
<p>Dorin Comaniciu and Peter Meer, 'Mean Shift: A robust approach toward
feature space analysis'. IEEE Transactions on Pattern Analysis and
Machine Intelligence. 2002. pp. 603-619.</p>
</details>
<h3 id="fit_6">fit<a class="headerlink" href="#fit_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform clustering.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Samples to cluster.</p>
</li>
<li>
<p><strong>y : Ignored</strong></p>
</li>
</ul>
</details>
<h3 id="fit_predict_5">fit_predict<a class="headerlink" href="#fit_predict_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform clustering on X and returns cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="get_params_6">get_params<a class="headerlink" href="#get_params_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="predict_3">predict<a class="headerlink" href="#predict_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predict</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Predict the closest cluster each sample in X belongs to.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : {array-like, sparse matrix}, shape=[n_samples, n_features]</strong>
    New data to predict.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : array, shape [n_samples,]</strong>
    Index of the cluster each sample belongs to.</li>
</ul>
</details>
<h3 id="set_params_6">set_params<a class="headerlink" href="#set_params_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="cluster_centers__2">cluster_centers_<a class="headerlink" href="#cluster_centers__2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_centers_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_centers_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_centers_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__6">labels_<a class="headerlink" href="#labels__6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="n_iter__2">n_iter_<a class="headerlink" href="#n_iter__2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute n_iter_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_iter_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">n_iter_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_6">to_string<a class="headerlink" href="#to_string_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_6">show<a class="headerlink" href="#show_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_6">pp<a class="headerlink" href="#pp_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="minibatchkmeans">MiniBatchKMeans<a class="headerlink" href="#minibatchkmeans" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.MiniBatchKMeans</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MiniBatchKMeans.html"><code>sklearn.cluster.MiniBatchKMeans</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_7">create<a class="headerlink" href="#create_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K_means_</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Random</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">batch_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_labels</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_no_improvement</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">reassignment_ratio</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Mini-Batch K-Means clustering.</p>
<p>Read more in the :ref:<code>User Guide &lt;mini_batch_kmeans&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int, default=8</strong>
    The number of clusters to form as well as the number of
    centroids to generate.</p>
</li>
<li>
<p><strong>init : {'k-means++', 'random'} or ndarray of shape             (n_clusters, n_features), default='k-means++'</strong>
    Method for initialization</p>
<p>'k-means++' : selects initial cluster centers for k-mean
clustering in a smart way to speed up convergence. See section
Notes in k_init for more details.</p>
<p>'random': choose k observations (rows) at random from data for
the initial centroids.</p>
<p>If an ndarray is passed, it should be of shape (n_clusters, n_features)
and gives the initial centers.</p>
</li>
<li>
<p><strong>max_iter : int, default=100</strong>
    Maximum number of iterations over the complete dataset before
    stopping independently of any early stopping criterion heuristics.</p>
</li>
<li>
<p><strong>batch_size : int, default=100</strong>
    Size of the mini batches.</p>
</li>
<li>
<p><strong>verbose : int, default=0</strong>
    Verbosity mode.</p>
</li>
<li>
<p><strong>compute_labels : bool, default=True</strong>
    Compute label assignment and inertia for the complete dataset
    once the minibatch optimization has converged in fit.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    Determines random number generation for centroid initialization and
    random reassignment. Use an int to make the randomness deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>tol : float, default=0.0</strong>
    Control early stopping based on the relative center changes as
    measured by a smoothed, variance-normalized of the mean center
    squared position changes. This early stopping heuristics is
    closer to the one used for the batch variant of the algorithms
    but induces a slight computational and memory overhead over the
    inertia heuristic.</p>
<p>To disable convergence detection based on normalized center
change, set tol to 0.0 (default).</p>
</li>
<li>
<p><strong>max_no_improvement : int, default=10</strong>
    Control early stopping based on the consecutive number of mini
    batches that does not yield an improvement on the smoothed inertia.</p>
<p>To disable convergence detection based on inertia, set
max_no_improvement to None.</p>
</li>
<li>
<p><strong>init_size : int, default=None</strong>
    Number of samples to randomly sample for speeding up the
    initialization (sometimes at the expense of accuracy): the
    only algorithm is initialized by running a batch KMeans on a
    random subset of the data. This needs to be larger than n_clusters.</p>
<p>If <code>None</code>, <code>init_size= 3 * batch_size</code>.</p>
</li>
<li>
<p><strong>n_init : int, default=3</strong>
    Number of random initializations that are tried.
    In contrast to KMeans, the algorithm is only run once, using the
    best of the <code>n_init</code> initializations as measured by inertia.</p>
</li>
<li>
<p><strong>reassignment_ratio : float, default=0.01</strong>
    Control the fraction of the maximum number of counts for a
    center to be reassigned. A higher value means that low count
    centers are more easily reassigned, which means that the
    model will take longer to converge, but should converge in a
    better clustering.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>cluster_centers_ : ndarray of shape (n_clusters, n_features)</strong>
    Coordinates of cluster centers</p>
</li>
<li>
<p><strong>labels_ : int</strong>
    Labels of each point (if compute_labels is set to True).</p>
</li>
<li>
<p><strong>inertia_ : float</strong>
    The value of the inertia criterion associated with the chosen
    partition (if compute_labels is set to True). The inertia is
    defined as the sum of square distances of samples to their nearest
    neighbor.</p>
</li>
</ul>
<h4>See Also</h4>
<p>KMeans
    The classic implementation of the clustering method based on the
    Lloyd's algorithm. It consumes the whole set of input data at each
    iteration.</p>
<h4>Notes</h4>
<p>See https://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># manually fit on batches</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="o">...</span>                          <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="o">...</span>                          <span class="n">batch_size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">6</span><span class="p">,:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">12</span><span class="p">,:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">2.</span> <span class="p">,</span> <span class="mf">1.</span> <span class="p">],</span>
       <span class="p">[</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># fit on the whole data</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="o">...</span>                          <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="o">...</span>                          <span class="n">batch_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
<span class="o">...</span>                          <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.95918367</span><span class="p">,</span> <span class="mf">2.40816327</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.12195122</span><span class="p">,</span> <span class="mf">1.3902439</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="fit_7">fit<a class="headerlink" href="#fit_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Compute the centroids on X by chunking it into mini-batches.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like or sparse matrix, shape=(n_samples, n_features)</strong>
    Training instances to cluster. It must be noted that the data
    will be converted to C ordering, which will cause a memory copy
    if the given data is not C-contiguous.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like, shape (n_samples,), optional</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight (default: None).</p>
<p>.. versionadded:: 0.20</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_predict_6">fit_predict<a class="headerlink" href="#fit_predict_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute cluster centers and predict cluster index for each sample.</p>
<p>Convenience method; equivalent to calling fit(X) followed by
predict(X).</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Index of the cluster each sample belongs to.</li>
</ul>
</details>
<h3 id="fit_transform_3">fit_transform<a class="headerlink" href="#fit_transform_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_transform</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute clustering and transform X to cluster-distance space.</p>
<p>Equivalent to fit(X).transform(X), but more efficiently implemented.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : array of shape (n_samples, n_clusters)</strong>
    X transformed in the new space.</li>
</ul>
</details>
<h3 id="get_params_7">get_params<a class="headerlink" href="#get_params_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="partial_fit_1">partial_fit<a class="headerlink" href="#partial_fit_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method partial_fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">partial_fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Update k means estimate on a single mini-batch X.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Coordinates of the data points to cluster. It must be noted that
    X will be copied if it is not C-contiguous.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like, shape (n_samples,), optional</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight (default: None).</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="predict_4">predict<a class="headerlink" href="#predict_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Predict the closest cluster each sample in X belongs to.</p>
<p>In the vector quantization literature, <code>cluster_centers_</code> is called
the code book and each value returned by <code>predict</code> is the index of
the closest code in the code book.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to predict.</p>
</li>
<li>
<p><strong>sample_weight : array-like, shape (n_samples,), optional</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight (default: None).</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : array, shape [n_samples,]</strong>
    Index of the cluster each sample belongs to.</li>
</ul>
</details>
<h3 id="score_1">score<a class="headerlink" href="#score_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method score</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">score</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>Opposite of the value of X on the K-means objective.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>score : float</strong>
    Opposite of the value of X on the K-means objective.</li>
</ul>
</details>
<h3 id="set_params_7">set_params<a class="headerlink" href="#set_params_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="transform_3">transform<a class="headerlink" href="#transform_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform X to a cluster-distance space.</p>
<p>In the new space, each dimension is the distance to the cluster
centers.  Note that even if X is sparse, the array returned by
<code>transform</code> will typically be dense.</p>
<h4>Parameters</h4>
<ul>
<li><strong>X : {array-like, sparse matrix} of shape (n_samples, n_features)</strong>
    New data to transform.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X_new : ndarray of shape (n_samples, n_clusters)</strong>
    X transformed in the new space.</li>
</ul>
</details>
<h3 id="cluster_centers__3">cluster_centers_<a class="headerlink" href="#cluster_centers__3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_centers_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_centers_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_centers_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__7">labels_<a class="headerlink" href="#labels__7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="inertia__1">inertia_<a class="headerlink" href="#inertia__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute inertia_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inertia_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
<span class="k">val</span> <span class="n">inertia_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_7">to_string<a class="headerlink" href="#to_string_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_7">show<a class="headerlink" href="#show_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_7">pp<a class="headerlink" href="#pp_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="optics">OPTICS<a class="headerlink" href="#optics" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.OPTICS</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html"><code>sklearn.cluster.OPTICS</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_8">create<a class="headerlink" href="#create_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">min_samples</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric_params</span><span class="o">:</span><span class="nn">Dict</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">cluster_method</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">xi</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Between_0_and_1</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">predecessor_correction</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">min_cluster_size</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ball_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Kd_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Brute</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">leaf_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Estimate clustering structure from vector array.</p>
<p>OPTICS (Ordering Points To Identify the Clustering Structure), closely
related to DBSCAN, finds core sample of high density and expands clusters
from them [1]_. Unlike DBSCAN, keeps cluster hierarchy for a variable
neighborhood radius. Better suited for usage on large datasets than the
current sklearn implementation of DBSCAN.</p>
<p>Clusters are then extracted using a DBSCAN-like method
(cluster_method = 'dbscan') or an automatic
technique proposed in [1]_ (cluster_method = 'xi').</p>
<p>This implementation deviates from the original OPTICS by first performing
k-nearest-neighborhood searches on all points to identify core sizes, then
computing only the distances to unprocessed points when constructing the
cluster order. Note that we do not employ a heap to manage the expansion
candidates, so the time complexity will be O(n^2).</p>
<p>Read more in the :ref:<code>User Guide &lt;optics&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>min_samples : int &gt; 1 or float between 0 and 1 (default=5)</strong>
    The number of samples in a neighborhood for a point to be considered as
    a core point. Also, up and down steep regions can't have more then
    <code>min_samples</code> consecutive non-steep points. Expressed as an absolute
    number or a fraction of the number of samples (rounded to be at least
    2).</p>
</li>
<li>
<p><strong>max_eps : float, optional (default=np.inf)</strong>
    The maximum distance between two samples for one to be considered as
    in the neighborhood of the other. Default value of <code>np.inf</code> will
    identify clusters across all scales; reducing <code>max_eps</code> will result
    in shorter run times.</p>
</li>
<li>
<p><strong>metric : str or callable, optional (default='minkowski')</strong>
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.</p>
<p>If metric is a callable function, it is called on each
pair of instances (rows) and the resulting value recorded. The callable
should take two arrays as input and return one value indicating the
distance between them. This works for Scipy's metrics, but is less
efficient than passing the metric name as a string. If metric is
'precomputed', X is assumed to be a distance matrix and must be square.</p>
<p>Valid values for metric are:</p>
<ul>
<li>
<p>from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
  'manhattan']</p>
</li>
<li>
<p>from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
  'yule']</p>
</li>
</ul>
<p>See the documentation for scipy.spatial.distance for details on these
metrics.</p>
</li>
<li>
<p><strong>p : int, optional (default=2)</strong>
    Parameter for the Minkowski metric from
    :class:<code>sklearn.metrics.pairwise_distances</code>. When p = 1, this is
    equivalent to using manhattan_distance (l1), and euclidean_distance
    (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.</p>
</li>
<li>
<p><strong>metric_params : dict, optional (default=None)</strong>
    Additional keyword arguments for the metric function.</p>
</li>
<li>
<p><strong>cluster_method : str, optional (default='xi')</strong>
    The extraction method used to extract clusters using the calculated
    reachability and ordering. Possible values are 'xi' and 'dbscan'.</p>
</li>
<li>
<p><strong>eps : float, optional (default=None)</strong>
    The maximum distance between two samples for one to be considered as
    in the neighborhood of the other. By default it assumes the same value
    as <code>max_eps</code>.
    Used only when <code>cluster_method='dbscan'</code>.</p>
</li>
<li>
<p><strong>xi : float, between 0 and 1, optional (default=0.05)</strong>
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.
    Used only when <code>cluster_method='xi'</code>.</p>
</li>
<li>
<p><strong>predecessor_correction : bool, optional (default=True)</strong>
    Correct clusters according to the predecessors calculated by OPTICS
    [2]_. This parameter has minimal effect on most datasets.
    Used only when <code>cluster_method='xi'</code>.</p>
</li>
<li>
<p><strong>min_cluster_size : int &gt; 1 or float between 0 and 1 (default=None)</strong>
    Minimum number of samples in an OPTICS cluster, expressed as an
    absolute number or a fraction of the number of samples (rounded to be
    at least 2). If <code>None</code>, the value of <code>min_samples</code> is used instead.
    Used only when <code>cluster_method='xi'</code>.</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, optional</strong>
    Algorithm used to compute the nearest neighbors:</p>
<ul>
<li>'ball_tree' will use :class:<code>BallTree</code></li>
<li>'kd_tree' will use :class:<code>KDTree</code></li>
<li>'brute' will use a brute-force search.</li>
<li>'auto' will attempt to decide the most appropriate algorithm
  based on the values passed to :meth:<code>fit</code> method. (default)</li>
</ul>
</li>
<li>
<p><strong>Note: fitting on sparse input will override the setting of</strong>
    this parameter, using brute force.</p>
</li>
<li>
<p><strong>leaf_size : int, optional (default=30)</strong>
    Leaf size passed to :class:<code>BallTree</code> or :class:<code>KDTree</code>. This can
    affect the speed of the construction and query, as well as the memory
    required to store the tree. The optimal value depends on the
    nature of the problem.</p>
</li>
<li>
<p><strong>n_jobs : int or None, optional (default=None)</strong>
    The number of parallel jobs to run for neighbors search.
    <code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
    <code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
    for more details.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>labels_ : array, shape (n_samples,)</strong>
    Cluster labels for each point in the dataset given to fit().
    Noisy samples and points which are not included in a leaf cluster
    of <code>cluster_hierarchy_</code> are labeled as -1.</p>
</li>
<li>
<p><strong>reachability_ : array, shape (n_samples,)</strong>
    Reachability distances per sample, indexed by object order. Use
    <code>clust.reachability_[clust.ordering_]</code> to access in cluster order.</p>
</li>
<li>
<p><strong>ordering_ : array, shape (n_samples,)</strong>
    The cluster ordered list of sample indices.</p>
</li>
<li>
<p><strong>core_distances_ : array, shape (n_samples,)</strong>
    Distance at which each sample becomes a core point, indexed by object
    order. Points which will never be core have a distance of inf. Use
    <code>clust.core_distances_[clust.ordering_]</code> to access in cluster order.</p>
</li>
<li>
<p><strong>predecessor_ : array, shape (n_samples,)</strong>
    Point that a sample was reached from, indexed by object order.
    Seed points have a predecessor of -1.</p>
</li>
<li>
<p><strong>cluster_hierarchy_ : array, shape (n_clusters, 2)</strong>
    The list of clusters in the form of <code>[start, end]</code> in each row, with
    all indices inclusive. The clusters are ordered according to
    <code>(end, -start)</code> (ascending) so that larger clusters encompassing
    smaller clusters come after those smaller ones. Since <code>labels_</code> does
    not reflect the hierarchy, usually
    <code>len(cluster_hierarchy_) &gt; np.unique(optics.labels_)</code>. Please also
    note that these indices are of the <code>ordering_</code>, i.e.
    <code>X[ordering_][start:end + 1]</code> form a cluster.
    Only available when <code>cluster_method='xi'</code>.</p>
</li>
</ul>
<h4>See Also</h4>
<p>DBSCAN
    A similar clustering for a specified neighborhood radius (eps).
    Our implementation is optimized for runtime.</p>
<h4>References</h4>
<p>.. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel,
   and Jrg Sander. 'OPTICS: ordering points to identify the clustering
   structure.' ACM SIGMOD Record 28, no. 2 (1999): 49-60.</p>
<p>.. [2] Schubert, Erich, Michael Gertz.
   'Improving the Cluster Structure Extracted from OPTICS Plots.' Proc. of
   the Conference 'Lernen, Wissen, Daten, Analysen' (LWDA) (2018): 318-329.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">OPTICS</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">OPTICS</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="fit_8">fit<a class="headerlink" href="#fit_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform OPTICS clustering.</p>
<p>Extracts an ordered list of points and reachability distances, and
performs initial clustering using <code>max_eps</code> distance specified at
OPTICS object instantiation.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array, shape (n_samples, n_features), or (n_samples, n_samples)          if metric=precomputed</strong>
    A feature array, or array of distances between samples if
    metric='precomputed'.</p>
</li>
<li>
<p><strong>y : ignored</strong>
    Ignored.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : instance of OPTICS</strong>
    The instance.</li>
</ul>
</details>
<h3 id="fit_predict_7">fit_predict<a class="headerlink" href="#fit_predict_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform clustering on X and returns cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input data.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray of shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="get_params_8">get_params<a class="headerlink" href="#get_params_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="set_params_8">set_params<a class="headerlink" href="#set_params_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="labels__8">labels_<a class="headerlink" href="#labels__8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="reachability_">reachability_<a class="headerlink" href="#reachability_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute reachability_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reachability_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">reachability_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="ordering_">ordering_<a class="headerlink" href="#ordering_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute ordering_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ordering_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">ordering_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="core_distances_">core_distances_<a class="headerlink" href="#core_distances_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute core_distances_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">core_distances_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">core_distances_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="predecessor_">predecessor_<a class="headerlink" href="#predecessor_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute predecessor_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">predecessor_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">predecessor_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="cluster_hierarchy_">cluster_hierarchy_<a class="headerlink" href="#cluster_hierarchy_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute cluster_hierarchy_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_hierarchy_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">cluster_hierarchy_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_8">to_string<a class="headerlink" href="#to_string_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_8">show<a class="headerlink" href="#show_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_8">pp<a class="headerlink" href="#pp_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="spectralbiclustering">SpectralBiclustering<a class="headerlink" href="#spectralbiclustering" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.SpectralBiclustering</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralBiclustering.html"><code>sklearn.cluster.SpectralBiclustering</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_9">create<a class="headerlink" href="#create_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Bistochastic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scale</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Log</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_components</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_best</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">svd_method</span><span class="o">:[`</span><span class="nc">Randomized</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Arpack</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_svd_vecs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mini_batch</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K_means_</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Random</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Spectral biclustering (Kluger, 2003).</p>
<p>Partitions rows and columns under the assumption that the data has
an underlying checkerboard structure. For instance, if there are
two row partitions and three column partitions, each row will
belong to three biclusters, and each column will belong to two
biclusters. The outer product of the corresponding row and column
label vectors gives this checkerboard structure.</p>
<p>Read more in the :ref:<code>User Guide &lt;spectral_biclustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int or tuple (n_row_clusters, n_column_clusters), default=3</strong>
    The number of row and column clusters in the checkerboard
    structure.</p>
</li>
<li>
<p><strong>method : {'bistochastic', 'scale', 'log'}, default='bistochastic'</strong>
    Method of normalizing and converting singular vectors into
    biclusters. May be one of 'scale', 'bistochastic', or 'log'.
    The authors recommend using 'log'. If the data is sparse,
    however, log normalization will not work, which is why the
    default is 'bistochastic'.</p>
<p>.. warning::
   if <code>method='log'</code>, the data must be sparse.</p>
</li>
<li>
<p><strong>n_components : int, default=6</strong>
    Number of singular vectors to check.</p>
</li>
<li>
<p><strong>n_best : int, default=3</strong>
    Number of best singular vectors to which to project the data
    for clustering.</p>
</li>
<li>
<p><strong>svd_method : {'randomized', 'arpack'}, default='randomized'</strong>
    Selects the algorithm for finding singular vectors. May be
    'randomized' or 'arpack'. If 'randomized', uses
    :func:<code>~sklearn.utils.extmath.randomized_svd</code>, which may be faster
    for large matrices. If 'arpack', uses
    <code>scipy.sparse.linalg.svds</code>, which is more accurate, but
    possibly slower in some cases.</p>
</li>
<li>
<p><strong>n_svd_vecs : int, default=None</strong>
    Number of vectors to use in calculating the SVD. Corresponds
    to <code>ncv</code> when <code>svd_method=arpack</code> and <code>n_oversamples</code> when
    <code>svd_method</code> is 'randomized`.</p>
</li>
<li>
<p><strong>mini_batch : bool, default=False</strong>
    Whether to use mini-batch k-means, which is faster but may get
    different results.</p>
</li>
<li>
<p><strong>init : {'k-means++', 'random'} or ndarray of (n_clusters, n_features),             default='k-means++'</strong>
    Method for initialization of k-means algorithm; defaults to
    'k-means++'.</p>
</li>
<li>
<p><strong>n_init : int, default=10</strong>
    Number of random initializations that are tried with the
    k-means algorithm.</p>
<p>If mini-batch k-means is used, the best initialization is
chosen and the algorithm runs once. Otherwise, the algorithm
is run for each initialization and the best solution chosen.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of jobs to use for the computation. This works by breaking
    down the pairwise matrix into n_jobs even slices and computing them in
    parallel.</p>
<p><code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
<code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
for more details.</p>
<p>.. deprecated:: 0.23
    <code>n_jobs</code> was deprecated in version 0.23 and will be removed in
    0.25.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    Used for randomizing the singular value decomposition and the k-means
    initialization. Use an int to make the randomness deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>rows_ : array-like of shape (n_row_clusters, n_rows)</strong>
    Results of the clustering. <code>rows[i, r]</code> is True if
    cluster <code>i</code> contains row <code>r</code>. Available only after calling <code>fit</code>.</p>
</li>
<li>
<p><strong>columns_ : array-like of shape (n_column_clusters, n_columns)</strong>
    Results of the clustering, like <code>rows</code>.</p>
</li>
<li>
<p><strong>row_labels_ : array-like of shape (n_rows,)</strong>
    Row partition labels.</p>
</li>
<li>
<p><strong>column_labels_ : array-like of shape (n_cols,)</strong>
    Column partition labels.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">SpectralBiclustering</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">SpectralBiclustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">row_labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">column_labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">SpectralBiclustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h4>References</h4>
<ul>
<li>
<p>Kluger, Yuval, et. al., 2003. `Spectral biclustering of microarray</p>
</li>
<li>
<p><strong>data: coclustering genes and conditions</strong>
  <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.135.1608">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.135.1608</a>`__.</p>
</li>
</ul>
</details>
<h3 id="fit_9">fit<a class="headerlink" href="#fit_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Creates a biclustering for X.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like, shape (n_samples, n_features)</strong></p>
</li>
<li>
<p><strong>y : Ignored</strong></p>
</li>
</ul>
</details>
<h3 id="get_indices">get_indices<a class="headerlink" href="#get_indices" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_indices</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_indices</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Row and column indices of the i'th bicluster.</p>
<p>Only works if <code>rows_</code> and <code>columns_</code> attributes exist.</p>
<h4>Parameters</h4>
<ul>
<li><strong>i : int</strong>
    The index of the cluster.</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>row_ind : ndarray, dtype=np.intp</strong>
    Indices of rows in the dataset that belong to the bicluster.</p>
</li>
<li>
<p><strong>col_ind : ndarray, dtype=np.intp</strong>
    Indices of columns in the dataset that belong to the bicluster.</p>
</li>
</ul>
</details>
<h3 id="get_params_9">get_params<a class="headerlink" href="#get_params_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="get_shape">get_shape<a class="headerlink" href="#get_shape" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_shape</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shape of the i'th bicluster.</p>
<h4>Parameters</h4>
<ul>
<li><strong>i : int</strong>
    The index of the cluster.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>shape : tuple (int, int)</strong>
    Number of rows and columns (resp.) in the bicluster.</li>
</ul>
</details>
<h3 id="get_submatrix">get_submatrix<a class="headerlink" href="#get_submatrix" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_submatrix</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_submatrix</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the submatrix corresponding to bicluster <code>i</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>i : int</strong>
    The index of the cluster.</p>
</li>
<li>
<p><strong>data : array-like</strong>
    The data.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>submatrix : ndarray</strong>
    The submatrix corresponding to bicluster i.</li>
</ul>
<h4>Notes</h4>
<p>Works with sparse matrices. Only works if <code>rows_</code> and
<code>columns_</code> attributes exist.</p>
</details>
<h3 id="set_params_9">set_params<a class="headerlink" href="#set_params_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="rows_">rows_<a class="headerlink" href="#rows_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute rows_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rows_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">rows_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="columns_">columns_<a class="headerlink" href="#columns_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute columns_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">columns_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">columns_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="row_labels_">row_labels_<a class="headerlink" href="#row_labels_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute row_labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">row_labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">row_labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="column_labels_">column_labels_<a class="headerlink" href="#column_labels_" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute column_labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">column_labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">column_labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_9">to_string<a class="headerlink" href="#to_string_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_9">show<a class="headerlink" href="#show_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_9">pp<a class="headerlink" href="#pp_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="spectralclustering">SpectralClustering<a class="headerlink" href="#spectralclustering" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.SpectralClustering</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html"><code>sklearn.cluster.SpectralClustering</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_10">create<a class="headerlink" href="#create_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigen_solver</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Arpack</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lobpcg</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_components</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">gamma</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">affinity</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_neighbors</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigen_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">assign_labels</span><span class="o">:[`</span><span class="nc">Kmeans</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Discretize</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">degree</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">coef0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">kernel_params</span><span class="o">:</span><span class="nn">Dict</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Apply clustering to a projection of the normalized Laplacian.</p>
<p>In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster. For instance when clusters are
nested circles on the 2D plane.</p>
<p>If affinity is the adjacency matrix of a graph, this method can be
used to find normalized graph cuts.</p>
<p>When calling <code>fit</code>, an affinity matrix is constructed using either
kernel function such the Gaussian (aka RBF) kernel of the euclidean
distanced <code>d(X, X)</code>::</p>
<div class="codehilite"><pre><span></span><code>    np.exp(-gamma * d(X,X) ** 2)
</code></pre></div>


<p>or a k-nearest neighbors connectivity matrix.</p>
<p>Alternatively, using <code>precomputed</code>, a user-provided affinity
matrix can be used.</p>
<p>Read more in the :ref:<code>User Guide &lt;spectral_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : integer, optional</strong>
    The dimension of the projection subspace.</p>
</li>
<li>
<p><strong>eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'}</strong>
    The eigenvalue decomposition strategy to use. AMG requires pyamg
    to be installed. It can be faster on very large, sparse problems,
    but may also lead to instabilities.</p>
</li>
<li>
<p><strong>n_components : integer, optional, default=n_clusters</strong>
    Number of eigen vectors to use for the spectral embedding</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    A pseudo random number generator used for the initialization of the
    lobpcg eigen vectors decomposition when <code>eigen_solver='amg'</code> and by
    the K-Means initialization. Use an int to make the randomness
    deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>n_init : int, optional, default: 10</strong>
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.</p>
</li>
<li>
<p><strong>gamma : float, default=1.0</strong>
    Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels.
    Ignored for <code>affinity='nearest_neighbors'</code>.</p>
</li>
<li>
<p><strong>affinity : string or callable, default 'rbf'</strong>
    How to construct the affinity matrix.</p>
<ul>
<li>'nearest_neighbors' : construct the affinity matrix by computing a
   graph of nearest neighbors.</li>
<li>'rbf' : construct the affinity matrix using a radial basis function
   (RBF) kernel.</li>
<li>'precomputed' : interpret <code>X</code> as a precomputed affinity matrix.</li>
<li>'precomputed_nearest_neighbors' : interpret <code>X</code> as a sparse graph
   of precomputed nearest neighbors, and constructs the affinity matrix
   by selecting the <code>n_neighbors</code> nearest neighbors.</li>
<li>one of the kernels supported by
   :func:<code>~sklearn.metrics.pairwise_kernels</code>.</li>
</ul>
<p>Only kernels that produce similarity scores (non-negative values that
increase with similarity) should be used. This property is not checked
by the clustering algorithm.</p>
</li>
<li>
<p><strong>n_neighbors : integer</strong>
    Number of neighbors to use when constructing the affinity matrix using
    the nearest neighbors method. Ignored for <code>affinity='rbf'</code>.</p>
</li>
<li>
<p><strong>eigen_tol : float, optional, default: 0.0</strong>
    Stopping criterion for eigendecomposition of the Laplacian matrix
    when <code>eigen_solver='arpack'</code>.</p>
</li>
<li>
<p><strong>assign_labels : {'kmeans', 'discretize'}, default: 'kmeans'</strong>
    The strategy to use to assign labels in the embedding
    space. There are two ways to assign labels after the laplacian
    embedding. k-means can be applied and is a popular choice. But it can
    also be sensitive to initialization. Discretization is another approach
    which is less sensitive to random initialization.</p>
</li>
<li>
<p><strong>degree : float, default=3</strong>
    Degree of the polynomial kernel. Ignored by other kernels.</p>
</li>
<li>
<p><strong>coef0 : float, default=1</strong>
    Zero coefficient for polynomial and sigmoid kernels.
    Ignored by other kernels.</p>
</li>
<li>
<p><strong>kernel_params : dictionary of string to any, optional</strong>
    Parameters (keyword arguments) and values for kernel passed as
    callable object. Ignored by other kernels.</p>
</li>
<li>
<p><strong>n_jobs : int or None, optional (default=None)</strong>
    The number of parallel jobs to run.
    <code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
    <code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
    for more details.</p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>affinity_matrix_ : array-like, shape (n_samples, n_samples)</strong>
    Affinity matrix used for clustering. Available only if after calling
    <code>fit</code>.</p>
</li>
<li>
<p><strong>labels_ : array, shape (n_samples,)</strong>
    Labels of each point</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">SpectralClustering</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">SpectralClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="o">...</span>         <span class="n">assign_labels</span><span class="o">=</span><span class="s1">&#39;discretize&#39;</span><span class="p">,</span>
<span class="o">...</span>         <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">SpectralClustering</span><span class="p">(</span><span class="n">assign_labels</span><span class="o">=</span><span class="s1">&#39;discretize&#39;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h4>Notes</h4>
<p>If you have an affinity matrix, such as a distance matrix,
for which 0 means identical elements, and high values means
very dissimilar elements, it can be transformed in a
similarity matrix that is well suited for the algorithm by
applying the Gaussian (RBF, heat) kernel::</p>
<div class="codehilite"><pre><span></span><code>np.exp(- dist_matrix ** 2 / (2. * delta ** 2))
</code></pre></div>


<p>Where <code>delta</code> is a free parameter representing the width of the Gaussian
kernel.</p>
<p>Another alternative is to take a symmetric version of the k
nearest neighbors connectivity matrix of the points.</p>
<p>If the pyamg package is installed, it is used: this greatly
speeds up computation.</p>
<h4>References</h4>
<ul>
<li>
<p>Normalized cuts and image segmentation, 2000
  Jianbo Shi, Jitendra Malik</p>
</li>
<li>
<p><strong>http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</strong></p>
</li>
<li>
<p>A Tutorial on Spectral Clustering, 2007
  Ulrike von Luxburg</p>
</li>
<li>
<p><strong>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</strong></p>
</li>
<li>
<p>Multiclass spectral clustering, 2003
  Stella X. Yu, Jianbo Shi</p>
</li>
<li>
<p><strong>https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</strong></p>
</li>
</ul>
</details>
<h3 id="fit_10">fit<a class="headerlink" href="#fit_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Perform spectral clustering from features, or affinity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like or sparse matrix, shape (n_samples, n_features), or             array-like, shape (n_samples, n_samples)</strong>
    Training instances to cluster, or similarities / affinities between
    instances if <code>affinity='precomputed'</code>. If a sparse matrix is
    provided in a format other than <code>csr_matrix</code>, <code>csc_matrix</code>,
    or <code>coo_matrix</code>, it will be converted into a sparse
    <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<p>self</p>
</details>
<h3 id="fit_predict_8">fit_predict<a class="headerlink" href="#fit_predict_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit_predict</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit_predict</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform spectral clustering from features, or affinity matrix,
and return cluster labels.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like or sparse matrix, shape (n_samples, n_features), or             array-like, shape (n_samples, n_samples)</strong>
    Training instances to cluster, or similarities / affinities between
    instances if <code>affinity='precomputed'</code>. If a sparse matrix is
    provided in a format other than <code>csr_matrix</code>, <code>csc_matrix</code>,
    or <code>coo_matrix</code>, it will be converted into a sparse
    <code>csr_matrix</code>.</p>
</li>
<li>
<p><strong>y : Ignored</strong>
    Not used, present here for API consistency by convention.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : ndarray, shape (n_samples,)</strong>
    Cluster labels.</li>
</ul>
</details>
<h3 id="get_params_10">get_params<a class="headerlink" href="#get_params_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="set_params_10">set_params<a class="headerlink" href="#set_params_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="affinity_matrix__1">affinity_matrix_<a class="headerlink" href="#affinity_matrix__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute affinity_matrix_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">affinity_matrix_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">affinity_matrix_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="labels__9">labels_<a class="headerlink" href="#labels__9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_10">to_string<a class="headerlink" href="#to_string_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_10">show<a class="headerlink" href="#show_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_10">pp<a class="headerlink" href="#pp_10" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="spectralcoclustering">SpectralCoclustering<a class="headerlink" href="#spectralcoclustering" title="Permanent link">&para;</a></h2>
<p>Module <code>Sklearn.Cluster.SpectralCoclustering</code> wraps Python class <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralCoclustering.html"><code>sklearn.cluster.SpectralCoclustering</code></a>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create_11">create<a class="headerlink" href="#create_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">svd_method</span><span class="o">:[`</span><span class="nc">Randomized</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Arpack</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_svd_vecs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mini_batch</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Random</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_k_means_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Spectral Co-Clustering algorithm (Dhillon, 2001).</p>
<p>Clusters rows and columns of an array <code>X</code> to solve the relaxed
normalized cut of the bipartite graph created from <code>X</code> as follows:
the edge between row vertex <code>i</code> and column vertex <code>j</code> has weight
<code>X[i, j]</code>.</p>
<p>The resulting bicluster structure is block-diagonal, since each
row and each column belongs to exactly one bicluster.</p>
<p>Supports sparse matrices, as long as they are nonnegative.</p>
<p>Read more in the :ref:<code>User Guide &lt;spectral_coclustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n_clusters : int, default=3</strong>
    The number of biclusters to find.</p>
</li>
<li>
<p><strong>svd_method : {'randomized', 'arpack'}, default='randomized'</strong>
    Selects the algorithm for finding singular vectors. May be
    'randomized' or 'arpack'. If 'randomized', use
    :func:<code>sklearn.utils.extmath.randomized_svd</code>, which may be faster
    for large matrices. If 'arpack', use
    :func:<code>scipy.sparse.linalg.svds</code>, which is more accurate, but
    possibly slower in some cases.</p>
</li>
<li>
<p><strong>n_svd_vecs : int, default=None</strong>
    Number of vectors to use in calculating the SVD. Corresponds
    to <code>ncv</code> when <code>svd_method=arpack</code> and <code>n_oversamples</code> when
    <code>svd_method</code> is 'randomized`.</p>
</li>
<li>
<p><strong>mini_batch : bool, default=False</strong>
    Whether to use mini-batch k-means, which is faster but may get
    different results.</p>
</li>
<li>
<p><strong>init : {'k-means++', 'random', or ndarray of shape             (n_clusters, n_features), default='k-means++'</strong>
    Method for initialization of k-means algorithm; defaults to
    'k-means++'.</p>
</li>
<li>
<p><strong>n_init : int, default=10</strong>
    Number of random initializations that are tried with the
    k-means algorithm.</p>
<p>If mini-batch k-means is used, the best initialization is
chosen and the algorithm runs once. Otherwise, the algorithm
is run for each initialization and the best solution chosen.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of jobs to use for the computation. This works by breaking
    down the pairwise matrix into n_jobs even slices and computing them in
    parallel.</p>
<p><code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
<code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
for more details.</p>
<p>.. deprecated:: 0.23
    <code>n_jobs</code> was deprecated in version 0.23 and will be removed in
    0.25.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    Used for randomizing the singular value decomposition and the k-means
    initialization. Use an int to make the randomness deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
</ul>
<h4>Attributes</h4>
<ul>
<li>
<p><strong>rows_ : array-like of shape (n_row_clusters, n_rows)</strong>
    Results of the clustering. <code>rows[i, r]</code> is True if
    cluster <code>i</code> contains row <code>r</code>. Available only after calling <code>fit</code>.</p>
</li>
<li>
<p><strong>columns_ : array-like of shape (n_column_clusters, n_columns)</strong>
    Results of the clustering, like <code>rows</code>.</p>
</li>
<li>
<p><strong>row_labels_ : array-like of shape (n_rows,)</strong>
    The bicluster label of each row.</p>
</li>
<li>
<p><strong>column_labels_ : array-like of shape (n_cols,)</strong>
    The bicluster label of each column.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">SpectralCoclustering</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span> <span class="o">=</span> <span class="n">SpectralCoclustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">row_labels_</span> <span class="c1">#doctest: +SKIP</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span><span class="o">.</span><span class="n">column_labels_</span> <span class="c1">#doctest: +SKIP</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clustering</span>
<span class="n">SpectralCoclustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h4>References</h4>
<ul>
<li>Dhillon, Inderjit S, 2001. <code>Co-clustering documents and words using
  bipartite spectral graph partitioning
  &lt;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.3011&gt;</code>__.</li>
</ul>
</details>
<h3 id="fit_11">fit<a class="headerlink" href="#fit_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method fit</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fit</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Creates a biclustering for X.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like, shape (n_samples, n_features)</strong></p>
</li>
<li>
<p><strong>y : Ignored</strong></p>
</li>
</ul>
</details>
<h3 id="get_indices_1">get_indices<a class="headerlink" href="#get_indices_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_indices</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_indices</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Row and column indices of the i'th bicluster.</p>
<p>Only works if <code>rows_</code> and <code>columns_</code> attributes exist.</p>
<h4>Parameters</h4>
<ul>
<li><strong>i : int</strong>
    The index of the cluster.</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>row_ind : ndarray, dtype=np.intp</strong>
    Indices of rows in the dataset that belong to the bicluster.</p>
</li>
<li>
<p><strong>col_ind : ndarray, dtype=np.intp</strong>
    Indices of columns in the dataset that belong to the bicluster.</p>
</li>
</ul>
</details>
<h3 id="get_params_11">get_params<a class="headerlink" href="#get_params_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">deep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Dict</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get parameters for this estimator.</p>
<h4>Parameters</h4>
<ul>
<li><strong>deep : bool, default=True</strong>
    If True, will return the parameters for this estimator and
    contained subobjects that are estimators.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>params : mapping of string to any</strong>
    Parameter names mapped to their values.</li>
</ul>
</details>
<h3 id="get_shape_1">get_shape<a class="headerlink" href="#get_shape_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_shape</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_shape</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shape of the i'th bicluster.</p>
<h4>Parameters</h4>
<ul>
<li><strong>i : int</strong>
    The index of the cluster.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>shape : tuple (int, int)</strong>
    Number of rows and columns (resp.) in the bicluster.</li>
</ul>
</details>
<h3 id="get_submatrix_1">get_submatrix<a class="headerlink" href="#get_submatrix_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method get_submatrix</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_submatrix</span> <span class="o">:</span>
  <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the submatrix corresponding to bicluster <code>i</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>i : int</strong>
    The index of the cluster.</p>
</li>
<li>
<p><strong>data : array-like</strong>
    The data.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>submatrix : ndarray</strong>
    The submatrix corresponding to bicluster i.</li>
</ul>
<h4>Notes</h4>
<p>Works with sparse matrices. Only works if <code>rows_</code> and
<code>columns_</code> attributes exist.</p>
</details>
<h3 id="set_params_11">set_params<a class="headerlink" href="#set_params_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method set_params</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_params</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">params</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Set the parameters of this estimator.</p>
<p>The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each
component of a nested object.</p>
<h4>Parameters</h4>
<ul>
<li><strong>**params : dict</strong>
    Estimator parameters.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>self : object</strong>
    Estimator instance.</li>
</ul>
</details>
<h3 id="rows__1">rows_<a class="headerlink" href="#rows__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute rows_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rows_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">rows_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="columns__1">columns_<a class="headerlink" href="#columns__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute columns_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">columns_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">columns_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="row_labels__1">row_labels_<a class="headerlink" href="#row_labels__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute row_labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">row_labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">row_labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="column_labels__1">column_labels_<a class="headerlink" href="#column_labels__1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>attribute column_labels_</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">column_labels_</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">column_labels_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>This attribute is documented in <code>create</code> above. The first version raises Not_found
if the attribute is None. The _opt version returns an option.</p>
</details>
<h3 id="to_string_11">to_string<a class="headerlink" href="#to_string_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_11">show<a class="headerlink" href="#show_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_11">pp<a class="headerlink" href="#pp_11" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h3 id="affinity_propagation">affinity_propagation<a class="headerlink" href="#affinity_propagation" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function affinity_propagation</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">affinity_propagation</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">preference</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">convergence_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">damping</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_n_iter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">s</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Perform Affinity Propagation Clustering of data</p>
<p>Read more in the :ref:<code>User Guide &lt;affinity_propagation&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>S : array-like, shape (n_samples, n_samples)</strong>
    Matrix of similarities between points</p>
</li>
<li>
<p><strong>preference : array-like, shape (n_samples,) or float, optional</strong>
    Preferences for each point - points with larger values of
    preferences are more likely to be chosen as exemplars. The number of
    exemplars, i.e. of clusters, is influenced by the input preferences
    value. If the preferences are not passed as arguments, they will be
    set to the median of the input similarities (resulting in a moderate
    number of clusters). For a smaller amount of clusters, this can be set
    to the minimum value of the similarities.</p>
</li>
<li>
<p><strong>convergence_iter : int, optional, default: 15</strong>
    Number of iterations with no change in the number
    of estimated clusters that stops the convergence.</p>
</li>
<li>
<p><strong>max_iter : int, optional, default: 200</strong>
    Maximum number of iterations</p>
</li>
<li>
<p><strong>damping : float, optional, default: 0.5</strong>
    Damping factor between 0.5 and 1.</p>
</li>
<li>
<p><strong>copy : boolean, optional, default: True</strong>
    If copy is False, the affinity matrix is modified inplace by the
    algorithm, for memory efficiency</p>
</li>
<li>
<p><strong>verbose : boolean, optional, default: False</strong>
    The verbosity level</p>
</li>
<li>
<p><strong>return_n_iter : bool, default False</strong>
    Whether or not to return the number of iterations.</p>
</li>
<li>
<p><strong>random_state : int or np.random.RandomStateInstance, default: 0</strong>
    Pseudo-random number generator to control the starting state.
    Use an int for reproducible results across function calls.
    See the :term:<code>Glossary &lt;random_state&gt;</code>.</p>
<p>.. versionadded:: 0.23
    this parameter was previously hardcoded as 0.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>cluster_centers_indices : array, shape (n_clusters,)</strong>
    index of clusters centers</p>
</li>
<li>
<p><strong>labels : array, shape (n_samples,)</strong>
    cluster labels for each point</p>
</li>
<li>
<p><strong>n_iter : int</strong>
    number of iterations run. Returned only if <code>return_n_iter</code> is
    set to True.</p>
</li>
</ul>
<h4>Notes</h4>
<p>For an example, see :ref:<code>examples/cluster/plot_affinity_propagation.py
&lt;sphx_glr_auto_examples_cluster_plot_affinity_propagation.py&gt;</code>.</p>
<p>When the algorithm does not converge, it returns an empty array as
<code>cluster_center_indices</code> and <code>-1</code> as label for each training sample.</p>
<p>When all training samples have equal similarities and equal preferences,
the assignment of cluster centers and labels depends on the preference.
If the preference is smaller than the similarities, a single cluster center
and label <code>0</code> for every sample will be returned. Otherwise, every
training sample becomes its own cluster center and is assigned a unique
label.</p>
<h4>References</h4>
<p>Brendan J. Frey and Delbert Dueck, 'Clustering by Passing Messages
Between Data Points', Science Feb. 2007</p>
</details>
<h3 id="cluster_optics_dbscan">cluster_optics_dbscan<a class="headerlink" href="#cluster_optics_dbscan" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cluster_optics_dbscan</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_optics_dbscan</span> <span class="o">:</span>
  <span class="n">reachability</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">core_distances</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">ordering</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Performs DBSCAN extraction for an arbitrary epsilon.</p>
<p>Extracting the clusters runs in linear time. Note that this results in
<code>labels_</code> which are close to a :class:<code>~sklearn.cluster.DBSCAN</code> with
similar settings and <code>eps</code>, only if <code>eps</code> is close to <code>max_eps</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>reachability : array, shape (n_samples,)</strong>
    Reachability distances calculated by OPTICS (<code>reachability_</code>)</p>
</li>
<li>
<p><strong>core_distances : array, shape (n_samples,)</strong>
    Distances at which points become core (<code>core_distances_</code>)</p>
</li>
<li>
<p><strong>ordering : array, shape (n_samples,)</strong>
    OPTICS ordered point indices (<code>ordering_</code>)</p>
</li>
<li>
<p><strong>eps : float</strong>
    DBSCAN <code>eps</code> parameter. Must be set to &lt; <code>max_eps</code>. Results
    will be close to DBSCAN algorithm if <code>eps</code> and <code>max_eps</code> are close
    to one another.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels_ : array, shape (n_samples,)</strong>
    The estimated labels.</li>
</ul>
</details>
<h3 id="cluster_optics_xi">cluster_optics_xi<a class="headerlink" href="#cluster_optics_xi" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cluster_optics_xi</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cluster_optics_xi</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">min_cluster_size</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">xi</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Between_0_and_1</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">predecessor_correction</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">reachability</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">predecessor</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">ordering</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">min_samples</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Automatically extract clusters according to the Xi-steep method.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>reachability : array, shape (n_samples,)</strong>
    Reachability distances calculated by OPTICS (<code>reachability_</code>)</p>
</li>
<li>
<p><strong>predecessor : array, shape (n_samples,)</strong>
    Predecessors calculated by OPTICS.</p>
</li>
<li>
<p><strong>ordering : array, shape (n_samples,)</strong>
    OPTICS ordered point indices (<code>ordering_</code>)</p>
</li>
<li>
<p><strong>min_samples : int &gt; 1 or float between 0 and 1</strong>
    The same as the min_samples given to OPTICS. Up and down steep regions
    can't have more then <code>min_samples</code> consecutive non-steep points.
    Expressed as an absolute number or a fraction of the number of samples
    (rounded to be at least 2).</p>
</li>
<li>
<p><strong>min_cluster_size : int &gt; 1 or float between 0 and 1 (default=None)</strong>
    Minimum number of samples in an OPTICS cluster, expressed as an
    absolute number or a fraction of the number of samples (rounded to be
    at least 2). If <code>None</code>, the value of <code>min_samples</code> is used instead.</p>
</li>
<li>
<p><strong>xi : float, between 0 and 1, optional (default=0.05)</strong>
    Determines the minimum steepness on the reachability plot that
    constitutes a cluster boundary. For example, an upwards point in the
    reachability plot is defined by the ratio from one point to its
    successor being at most 1-xi.</p>
</li>
<li>
<p><strong>predecessor_correction : bool, optional (default=True)</strong>
    Correct clusters based on the calculated predecessors.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>labels : array, shape (n_samples)</strong>
    The labels assigned to samples. Points which are not included
    in any cluster are labeled as -1.</p>
</li>
<li>
<p><strong>clusters : array, shape (n_clusters, 2)</strong>
    The list of clusters in the form of <code>[start, end]</code> in each row, with
    all indices inclusive. The clusters are ordered according to <code>(end,
    -start)</code> (ascending) so that larger clusters encompassing smaller
    clusters come after such nested smaller clusters. Since <code>labels</code> does
    not reflect the hierarchy, usually <code>len(clusters) &gt;
    np.unique(labels)</code>.</p>
</li>
</ul>
</details>
<h3 id="compute_optics_graph">compute_optics_graph<a class="headerlink" href="#compute_optics_graph" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function compute_optics_graph</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">compute_optics_graph</span> <span class="o">:</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">min_samples</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">max_eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">metric</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">metric_params</span><span class="o">:</span><span class="nn">Dict</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ball_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Kd_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Brute</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">leaf_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">n_jobs</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Computes the OPTICS reachability graph.</p>
<p>Read more in the :ref:<code>User Guide &lt;optics&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array, shape (n_samples, n_features), or (n_samples, n_samples)  if metric=precomputed.</strong>
    A feature array, or array of distances between samples if
    metric='precomputed'</p>
</li>
<li>
<p><strong>min_samples : int &gt; 1 or float between 0 and 1</strong>
    The number of samples in a neighborhood for a point to be considered
    as a core point. Expressed as an absolute number or a fraction of the
    number of samples (rounded to be at least 2).</p>
</li>
<li>
<p><strong>max_eps : float, optional (default=np.inf)</strong>
    The maximum distance between two samples for one to be considered as
    in the neighborhood of the other. Default value of <code>np.inf</code> will
    identify clusters across all scales; reducing <code>max_eps</code> will result
    in shorter run times.</p>
</li>
<li>
<p><strong>metric : string or callable, optional (default='minkowski')</strong>
    Metric to use for distance computation. Any metric from scikit-learn
    or scipy.spatial.distance can be used.</p>
<p>If metric is a callable function, it is called on each
pair of instances (rows) and the resulting value recorded. The callable
should take two arrays as input and return one value indicating the
distance between them. This works for Scipy's metrics, but is less
efficient than passing the metric name as a string. If metric is
'precomputed', X is assumed to be a distance matrix and must be square.</p>
<p>Valid values for metric are:</p>
<ul>
<li>
<p>from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
  'manhattan']</p>
</li>
<li>
<p>from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
  'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
  'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
  'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
  'yule']</p>
</li>
</ul>
<p>See the documentation for scipy.spatial.distance for details on these
metrics.</p>
</li>
<li>
<p><strong>p : integer, optional (default=2)</strong>
    Parameter for the Minkowski metric from
    :class:<code>sklearn.metrics.pairwise_distances</code>. When p = 1, this is
    equivalent to using manhattan_distance (l1), and euclidean_distance
    (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.</p>
</li>
<li>
<p><strong>metric_params : dict, optional (default=None)</strong>
    Additional keyword arguments for the metric function.</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, optional</strong>
    Algorithm used to compute the nearest neighbors:</p>
<ul>
<li>'ball_tree' will use :class:<code>BallTree</code></li>
<li>'kd_tree' will use :class:<code>KDTree</code></li>
<li>'brute' will use a brute-force search.</li>
<li>'auto' will attempt to decide the most appropriate algorithm
  based on the values passed to :meth:<code>fit</code> method. (default)</li>
</ul>
</li>
<li>
<p><strong>Note: fitting on sparse input will override the setting of</strong>
    this parameter, using brute force.</p>
</li>
<li>
<p><strong>leaf_size : int, optional (default=30)</strong>
    Leaf size passed to :class:<code>BallTree</code> or :class:<code>KDTree</code>. This can
    affect the speed of the construction and query, as well as the memory
    required to store the tree. The optimal value depends on the
    nature of the problem.</p>
</li>
<li>
<p><strong>n_jobs : int or None, optional (default=None)</strong>
    The number of parallel jobs to run for neighbors search.
    <code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
    <code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
    for more details.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>ordering_ : array, shape (n_samples,)</strong>
    The cluster ordered list of sample indices.</p>
</li>
<li>
<p><strong>core_distances_ : array, shape (n_samples,)</strong>
    Distance at which each sample becomes a core point, indexed by object
    order. Points which will never be core have a distance of inf. Use
    <code>clust.core_distances_[clust.ordering_]</code> to access in cluster order.</p>
</li>
<li>
<p><strong>reachability_ : array, shape (n_samples,)</strong>
    Reachability distances per sample, indexed by object order. Use
    <code>clust.reachability_[clust.ordering_]</code> to access in cluster order.</p>
</li>
<li>
<p><strong>predecessor_ : array, shape (n_samples,)</strong>
    Point that a sample was reached from, indexed by object order.
    Seed points have a predecessor of -1.</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel,
   and Jrg Sander. 'OPTICS: ordering points to identify the clustering
   structure.' ACM SIGMOD Record 28, no. 2 (1999): 49-60.</p>
</details>
<h3 id="dbscan_1">dbscan<a class="headerlink" href="#dbscan_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dbscan</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dbscan</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">min_samples</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">metric_params</span><span class="o">:</span><span class="nn">Dict</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ball_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Kd_tree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Brute</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">leaf_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Perform DBSCAN clustering from vector array or distance matrix.</p>
<p>Read more in the :ref:<code>User Guide &lt;dbscan&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse (CSR) matrix} of shape (n_samples, n_features) or             (n_samples, n_samples)</strong>
    A feature array, or array of distances between samples if
    <code>metric='precomputed'</code>.</p>
</li>
<li>
<p><strong>eps : float, default=0.5</strong>
    The maximum distance between two samples for one to be considered
    as in the neighborhood of the other. This is not a maximum bound
    on the distances of points within a cluster. This is the most
    important DBSCAN parameter to choose appropriately for your data set
    and distance function.</p>
</li>
<li>
<p><strong>min_samples : int, default=5</strong>
    The number of samples (or total weight) in a neighborhood for a point
    to be considered as a core point. This includes the point itself.</p>
</li>
<li>
<p><strong>metric : string, or callable</strong>
    The metric to use when calculating distance between instances in a
    feature array. If metric is a string or callable, it must be one of
    the options allowed by :func:<code>sklearn.metrics.pairwise_distances</code> for
    its metric parameter.
    If metric is 'precomputed', X is assumed to be a distance matrix and
    must be square during fit.
    X may be a :term:<code>sparse graph &lt;sparse graph&gt;</code>,
    in which case only 'nonzero' elements may be considered neighbors.</p>
</li>
<li>
<p><strong>metric_params : dict, default=None</strong>
    Additional keyword arguments for the metric function.</p>
<p>.. versionadded:: 0.19</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto'</strong>
    The algorithm to be used by the NearestNeighbors module
    to compute pointwise distances and find nearest neighbors.
    See NearestNeighbors module documentation for details.</p>
</li>
<li>
<p><strong>leaf_size : int, default=30</strong>
    Leaf size passed to BallTree or cKDTree. This can affect the speed
    of the construction and query, as well as the memory required
    to store the tree. The optimal value depends
    on the nature of the problem.</p>
</li>
<li>
<p><strong>p : float, default=2</strong>
    The power of the Minkowski metric to be used to calculate distance
    between points.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    Weight of each sample, such that a sample with a weight of at least
    <code>min_samples</code> is by itself a core sample; a sample with negative
    weight may inhibit its eps-neighbor from being core.
    Note that weights are absolute, and default to 1.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of parallel jobs to run for neighbors search. <code>None</code> means
    1 unless in a :obj:<code>joblib.parallel_backend</code> context. <code>-1</code> means
    using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code> for more details.
    If precomputed distance are used, parallel execution is not available
    and thus n_jobs will have no effect.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>core_samples : ndarray of shape (n_core_samples,)</strong>
    Indices of core samples.</p>
</li>
<li>
<p><strong>labels : ndarray of shape (n_samples,)</strong>
    Cluster labels for each point.  Noisy samples are given the label -1.</p>
</li>
</ul>
<h4>See also</h4>
<p>DBSCAN
    An estimator interface for this clustering algorithm.
OPTICS
    A similar estimator interface clustering at multiple values of eps. Our
    implementation is optimized for memory usage.</p>
<h4>Notes</h4>
<p>For an example, see :ref:<code>examples/cluster/plot_dbscan.py
&lt;sphx_glr_auto_examples_cluster_plot_dbscan.py&gt;</code>.</p>
<p>This implementation bulk-computes all neighborhood queries, which increases
the memory complexity to O(n.d) where d is the average number of neighbors,
while original DBSCAN had memory complexity O(n). It may attract a higher
memory complexity when querying these nearest neighborhoods, depending
on the <code>algorithm</code>.</p>
<p>One way to avoid the query complexity is to pre-compute sparse
neighborhoods in chunks using
:func:<code>NearestNeighbors.radius_neighbors_graph
&lt;sklearn.neighbors.NearestNeighbors.radius_neighbors_graph&gt;</code> with
<code>mode='distance'</code>, then using <code>metric='precomputed'</code> here.</p>
<p>Another way to reduce memory and computation time is to remove
(near-)duplicate points and use <code>sample_weight</code> instead.</p>
<p>:func:<code>cluster.optics &lt;sklearn.cluster.optics&gt;</code> provides a similar
clustering with lower memory usage.</p>
<h4>References</h4>
<p>Ester, M., H. P. Kriegel, J. Sander, and X. Xu, 'A Density-Based
Algorithm for Discovering Clusters in Large Spatial Databases with Noise'.</p>
<ul>
<li><strong>In: Proceedings of the 2nd International Conference on Knowledge Discovery</strong>
and Data Mining, Portland, OR, AAAI Press, pp. 226-231. 1996</li>
</ul>
<p>Schubert, E., Sander, J., Ester, M., Kriegel, H. P., &amp; Xu, X. (2017).
DBSCAN revisited, revisited: why and how you should (still) use DBSCAN.
ACM Transactions on Database Systems (TODS), 42(3), 19.</p>
</details>
<h3 id="estimate_bandwidth">estimate_bandwidth<a class="headerlink" href="#estimate_bandwidth" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function estimate_bandwidth</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">estimate_bandwidth</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">quantile</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_samples</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>Estimate the bandwidth to use with the mean-shift algorithm.</p>
<p>That this function takes time at least quadratic in n_samples. For large
datasets, it's wise to set that parameter to a small value.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input points.</p>
</li>
<li>
<p><strong>quantile : float, default=0.3</strong>
    should be between [0, 1]
    0.5 means that the median of all pairwise distances is used.</p>
</li>
<li>
<p><strong>n_samples : int, default=None</strong>
    The number of samples to use. If not given, all samples are used.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    The generator used to randomly select the samples from input points
    for bandwidth estimation. Use an int to make the randomness
    deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of parallel jobs to run for neighbors search.
    <code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
    <code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
    for more details.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>bandwidth : float</strong>
    The bandwidth parameter.</li>
</ul>
</details>
<h3 id="get_bin_seeds">get_bin_seeds<a class="headerlink" href="#get_bin_seeds" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_bin_seeds</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_bin_seeds</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">min_bin_freq</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">bin_size</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finds seeds for mean_shift.</p>
<p>Finds seeds by first binning data onto a grid whose lines are
spaced bin_size apart, and then choosing those bins with at least
min_bin_freq points.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input points, the same points that will be used in mean_shift.</p>
</li>
<li>
<p><strong>bin_size : float</strong>
    Controls the coarseness of the binning. Smaller values lead
    to more seeding (which is computationally more expensive). If you're
    not sure how to set this, set it to the value of the bandwidth used
    in clustering.mean_shift.</p>
</li>
<li>
<p><strong>min_bin_freq : int, default=1</strong>
    Only bins with at least min_bin_freq will be selected as seeds.
    Raising this value decreases the number of seeds found, which
    makes mean_shift computationally cheaper.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>bin_seeds : array-like of shape (n_samples, n_features)</strong>
    Points used as initial kernel positions in clustering.mean_shift.</li>
</ul>
</details>
<h3 id="k_means">k_means<a class="headerlink" href="#k_means" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function k_means</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">k_means</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sample_weight</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Arr</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K_means_</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Random</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">precompute_distances</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">algorithm</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Elkan</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_n_iter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>K-means clustering algorithm.</p>
<p>Read more in the :ref:<code>User Guide &lt;k_means&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : {array-like, sparse} matrix of shape (n_samples, n_features)</strong>
    The observations to cluster. It must be noted that the data
    will be converted to C ordering, which will cause a memory copy
    if the given data is not C-contiguous.</p>
</li>
<li>
<p><strong>n_clusters : int</strong>
    The number of clusters to form as well as the number of
    centroids to generate.</p>
</li>
<li>
<p><strong>sample_weight : array-like of shape (n_samples,), default=None</strong>
    The weights for each observation in X. If None, all observations
    are assigned equal weight</p>
</li>
<li>
<p><strong>init : {'k-means++', 'random', ndarray, callable}, default='k-means++'</strong>
    Method for initialization:</p>
<p>'k-means++' : selects initial cluster centers for k-mean
clustering in a smart way to speed up convergence. See section
Notes in k_init for more details.</p>
<p>'random': choose <code>n_clusters</code> observations (rows) at random from data
for the initial centroids.</p>
<p>If an ndarray is passed, it should be of shape (n_clusters, n_features)
and gives the initial centers.</p>
<p>If a callable is passed, it should take arguments X, n_clusters and a
random state and return an initialization.</p>
</li>
<li>
<p><strong>precompute_distances : {'auto', True, False}</strong>
    Precompute distances (faster but takes more memory).</p>
<p>'auto' : do not precompute distances if n_samples * n_clusters &gt; 12
million. This corresponds to about 100MB overhead per job using
double precision.</p>
</li>
<li>
<p><strong>True : always precompute distances</strong></p>
</li>
<li>
<p><strong>False : never precompute distances</strong></p>
<p>.. deprecated:: 0.23
    'precompute_distances' was deprecated in version 0.23 and will be
    removed in 0.25. It has no effect.</p>
</li>
<li>
<p><strong>n_init : int, default=10</strong>
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.</p>
</li>
<li>
<p><strong>max_iter : int, default=300</strong>
    Maximum number of iterations of the k-means algorithm to run.</p>
</li>
<li>
<p><strong>verbose : bool, default=False</strong>
    Verbosity mode.</p>
</li>
<li>
<p><strong>tol : float, default=1e-4</strong>
    Relative tolerance with regards to Frobenius norm of the difference
    in the cluster centers of two consecutive iterations to declare
    convergence.</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    Determines random number generation for centroid initialization. Use
    an int to make the randomness deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>copy_x : bool, default=True</strong>
    When pre-computing distances it is more numerically accurate to center
    the data first. If copy_x is True (default), then the original data is
    not modified. If False, the original data is modified, and put back
    before the function returns, but small numerical differences may be
    introduced by subtracting and then adding the data mean. Note that if
    the original data is not C-contiguous, a copy will be made even if
    copy_x is False. If the original data is sparse, but not in CSR format,
    a copy will be made even if copy_x is False.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of OpenMP threads to use for the computation. Parallelism is
    sample-wise on the main cython loop which assigns each sample to its
    closest center.</p>
<p><code>None</code> or <code>-1</code> means using all processors.</p>
<p>.. deprecated:: 0.23
    <code>n_jobs</code> was deprecated in version 0.23 and will be removed in
    0.25.</p>
</li>
<li>
<p><strong>algorithm : {'auto', 'full', 'elkan'}, default='auto'</strong>
    K-means algorithm to use. The classical EM-style algorithm is 'full'.
    The 'elkan' variation is more efficient on data with well-defined
    clusters, by using the triangle inequality. However it's more memory
    intensive due to the allocation of an extra array of shape
    (n_samples, n_clusters).</p>
<p>For now 'auto' (kept for backward compatibiliy) chooses 'elkan' but it
might change in the future for a better heuristic.</p>
</li>
<li>
<p><strong>return_n_iter : bool, default=False</strong>
    Whether or not to return the number of iterations.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>centroid : ndarray of shape (n_clusters, n_features)</strong>
    Centroids found at the last iteration of k-means.</p>
</li>
<li>
<p><strong>label : ndarray of shape (n_samples,)</strong>
    label[i] is the code or index of the centroid the
    i'th observation is closest to.</p>
</li>
<li>
<p><strong>inertia : float</strong>
    The final value of the inertia criterion (sum of squared distances to
    the closest centroid for all observations in the training set).</p>
</li>
<li>
<p><strong>best_n_iter : int</strong>
    Number of iterations corresponding to the best results.
    Returned only if <code>return_n_iter</code> is set to True.</p>
</li>
</ul>
</details>
<h3 id="linkage_tree">linkage_tree<a class="headerlink" href="#linkage_tree" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function linkage_tree</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linkage_tree</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">connectivity</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">linkage</span><span class="o">:[`</span><span class="nc">Average</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complete</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Single</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">affinity</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Linkage agglomerative clustering based on a Feature matrix.</p>
<p>The inertia matrix uses a Heapq-based representation.</p>
<p>This is the structured version, that takes into account some topological
structure between samples.</p>
<p>Read more in the :ref:<code>User Guide &lt;hierarchical_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array, shape (n_samples, n_features)</strong>
    feature matrix representing n_samples samples to be clustered</p>
</li>
<li>
<p><strong>connectivity : sparse matrix (optional).</strong>
    connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is None, i.e, the Ward algorithm is unstructured.</p>
</li>
<li>
<p><strong>n_clusters : int (optional)</strong>
    Stop early the construction of the tree at n_clusters. This is
    useful to decrease computation time if the number of clusters is
    not small compared to the number of samples. In this case, the
    complete tree is not computed, thus the 'children' output is of
    limited use, and the 'parents' output should rather be used.
    This option is valid only when specifying a connectivity matrix.</p>
</li>
<li>
<p><strong>linkage : {'average', 'complete', 'single'}, optional, default: 'complete'</strong>
    Which linkage criteria to use. The linkage criterion determines which
    distance to use between sets of observation.
        - average uses the average of the distances of each observation of
          the two sets
        - complete or maximum linkage uses the maximum distances between
          all observations of the two sets.
        - single uses the minimum of the distances between all observations
          of the two sets.</p>
</li>
<li>
<p><strong>affinity : string or callable, optional, default: 'euclidean'.</strong>
    which metric to use. Can be 'euclidean', 'manhattan', or any
    distance know to paired distance (see metric.pairwise)</p>
</li>
<li>
<p><strong>return_distance : bool, default False</strong>
    whether or not to return the distances between the clusters.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>children : 2D array, shape (n_nodes-1, 2)</strong>
    The children of each non-leaf node. Values less than <code>n_samples</code>
    correspond to leaves of the tree which are the original samples.
    A node <code>i</code> greater than or equal to <code>n_samples</code> is a non-leaf
    node and has children <code>children_[i - n_samples]</code>. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node <code>n_samples + i</code></p>
</li>
<li>
<p><strong>n_connected_components : int</strong>
    The number of connected components in the graph.</p>
</li>
<li>
<p><strong>n_leaves : int</strong>
    The number of leaves in the tree.</p>
</li>
<li>
<p><strong>parents : 1D array, shape (n_nodes, ) or None</strong>
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.</p>
</li>
<li>
<p><strong>distances : ndarray, shape (n_nodes-1,)</strong>
    Returned when return_distance is set to True.</p>
<p>distances[i] refers to the distance between children[i][0] and
children[i][1] when they are merged.</p>
</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>ward_tree : hierarchical clustering with ward linkage</strong></li>
</ul>
</details>
<h3 id="mean_shift">mean_shift<a class="headerlink" href="#mean_shift" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function mean_shift</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean_shift</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">bandwidth</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">seeds</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">bin_seeding</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">min_bin_freq</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">cluster_all</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_jobs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Perform mean shift clustering of data using a flat kernel.</p>
<p>Read more in the :ref:<code>User Guide &lt;mean_shift&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array-like of shape (n_samples, n_features)</strong>
    Input data.</p>
</li>
<li>
<p><strong>bandwidth : float, default=None</strong>
    Kernel bandwidth.</p>
<p>If bandwidth is not given, it is determined using a heuristic based on
the median of all pairwise distances. This will take quadratic time in
the number of samples. The sklearn.cluster.estimate_bandwidth function
can be used to do this more efficiently.</p>
</li>
<li>
<p><strong>seeds : array-like of shape (n_seeds, n_features) or None</strong>
    Point used as initial kernel locations. If None and bin_seeding=False,
    each data point is used as a seed. If None and bin_seeding=True,
    see bin_seeding.</p>
</li>
<li>
<p><strong>bin_seeding : boolean, default=False</strong>
    If true, initial kernel locations are not locations of all
    points, but rather the location of the discretized version of
    points, where points are binned onto a grid whose coarseness
    corresponds to the bandwidth. Setting this option to True will speed
    up the algorithm because fewer seeds will be initialized.
    Ignored if seeds argument is not None.</p>
</li>
<li>
<p><strong>min_bin_freq : int, default=1</strong>
   To speed up the algorithm, accept only those bins with at least
   min_bin_freq points as seeds.</p>
</li>
<li>
<p><strong>cluster_all : bool, default=True</strong>
    If true, then all points are clustered, even those orphans that are
    not within any kernel. Orphans are assigned to the nearest kernel.
    If false, then orphans are given cluster label -1.</p>
</li>
<li>
<p><strong>max_iter : int, default=300</strong>
    Maximum number of iterations, per seed point before the clustering
    operation terminates (for that seed point), if has not converged yet.</p>
</li>
<li>
<p><strong>n_jobs : int, default=None</strong>
    The number of jobs to use for the computation. This works by computing
    each of the n_init runs in parallel.</p>
<p><code>None</code> means 1 unless in a :obj:<code>joblib.parallel_backend</code> context.
<code>-1</code> means using all processors. See :term:<code>Glossary &lt;n_jobs&gt;</code>
for more details.</p>
<p>.. versionadded:: 0.17
   Parallel Execution using <em>n_jobs</em>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>cluster_centers : array, shape=[n_clusters, n_features]</strong>
    Coordinates of cluster centers.</p>
</li>
<li>
<p><strong>labels : array, shape=[n_samples]</strong>
    Cluster labels for each point.</p>
</li>
</ul>
<h4>Notes</h4>
<p>For an example, see :ref:<code>examples/cluster/plot_mean_shift.py
&lt;sphx_glr_auto_examples_cluster_plot_mean_shift.py&gt;</code>.</p>
</details>
<h3 id="spectral_clustering">spectral_clustering<a class="headerlink" href="#spectral_clustering" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function spectral_clustering</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spectral_clustering</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_components</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigen_solver</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Arpack</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lobpcg</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">random_state</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_init</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigen_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">assign_labels</span><span class="o">:[`</span><span class="nc">Kmeans</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Discretize</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">affinity</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply clustering to a projection of the normalized Laplacian.</p>
<p>In practice Spectral Clustering is very useful when the structure of
the individual clusters is highly non-convex or more generally when
a measure of the center and spread of the cluster is not a suitable
description of the complete cluster. For instance, when clusters are
nested circles on the 2D plane.</p>
<p>If affinity is the adjacency matrix of a graph, this method can be
used to find normalized graph cuts.</p>
<p>Read more in the :ref:<code>User Guide &lt;spectral_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>affinity : array-like or sparse matrix, shape: (n_samples, n_samples)</strong>
    The affinity matrix describing the relationship of the samples to
    embed. <strong>Must be symmetric</strong>.</p>
<p>Possible examples:
  - adjacency matrix of a graph,
  - heat kernel of the pairwise distance matrix of the samples,
  - symmetric k-nearest neighbours connectivity matrix of the samples.</p>
</li>
<li>
<p><strong>n_clusters : integer, optional</strong>
    Number of clusters to extract.</p>
</li>
<li>
<p><strong>n_components : integer, optional, default is n_clusters</strong>
    Number of eigen vectors to use for the spectral embedding</p>
</li>
<li>
<p><strong>eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'}</strong>
    The eigenvalue decomposition strategy to use. AMG requires pyamg
    to be installed. It can be faster on very large, sparse problems,
    but may also lead to instabilities</p>
</li>
<li>
<p><strong>random_state : int, RandomState instance, default=None</strong>
    A pseudo random number generator used for the initialization of the
    lobpcg eigen vectors decomposition when eigen_solver == 'amg' and by
    the K-Means initialization. Use an int to make the randomness
    deterministic.</p>
</li>
<li>
<p><strong>See :term:<code>Glossary &lt;random_state&gt;</code>.</strong></p>
</li>
<li>
<p><strong>n_init : int, optional, default: 10</strong>
    Number of time the k-means algorithm will be run with different
    centroid seeds. The final results will be the best output of
    n_init consecutive runs in terms of inertia.</p>
</li>
<li>
<p><strong>eigen_tol : float, optional, default: 0.0</strong>
    Stopping criterion for eigendecomposition of the Laplacian matrix
    when using arpack eigen_solver.</p>
</li>
<li>
<p><strong>assign_labels : {'kmeans', 'discretize'}, default: 'kmeans'</strong>
    The strategy to use to assign labels in the embedding
    space.  There are two ways to assign labels after the laplacian
    embedding.  k-means can be applied and is a popular choice. But it can
    also be sensitive to initialization. Discretization is another
    approach which is less sensitive to random initialization. See
    the 'Multiclass spectral clustering' paper referenced below for
    more details on the discretization approach.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>labels : array of integers, shape: n_samples</strong>
    The labels of the clusters.</li>
</ul>
<h4>References</h4>
<ul>
<li>
<p>Normalized cuts and image segmentation, 2000
  Jianbo Shi, Jitendra Malik</p>
</li>
<li>
<p><strong>http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324</strong></p>
</li>
<li>
<p>A Tutorial on Spectral Clustering, 2007
  Ulrike von Luxburg</p>
</li>
<li>
<p><strong>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323</strong></p>
</li>
<li>
<p>Multiclass spectral clustering, 2003
  Stella X. Yu, Jianbo Shi</p>
</li>
<li>
<p><strong>https://www1.icsi.berkeley.edu/~stellayu/publication/doc/2003kwayICCV.pdf</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>The graph should contain only one connect component, elsewhere
the results make little sense.</p>
<p>This algorithm solves the normalized cut for k=2: it is a
normalized spectral clustering.</p>
</details>
<h3 id="ward_tree">ward_tree<a class="headerlink" href="#ward_tree" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function ward_tree</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ward_tree</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">connectivity</span><span class="o">:[&gt;`</span><span class="nc">Spmatrix</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">n_clusters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span> <span class="o">*</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Ward clustering based on a Feature matrix.</p>
<p>Recursively merges the pair of clusters that minimally increases
within-cluster variance.</p>
<p>The inertia matrix uses a Heapq-based representation.</p>
<p>This is the structured version, that takes into account some topological
structure between samples.</p>
<p>Read more in the :ref:<code>User Guide &lt;hierarchical_clustering&gt;</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array, shape (n_samples, n_features)</strong>
    feature matrix representing n_samples samples to be clustered</p>
</li>
<li>
<p><strong>connectivity : sparse matrix (optional).</strong>
    connectivity matrix. Defines for each sample the neighboring samples
    following a given structure of the data. The matrix is assumed to
    be symmetric and only the upper triangular half is used.
    Default is None, i.e, the Ward algorithm is unstructured.</p>
</li>
<li>
<p><strong>n_clusters : int (optional)</strong>
    Stop early the construction of the tree at n_clusters. This is
    useful to decrease computation time if the number of clusters is
    not small compared to the number of samples. In this case, the
    complete tree is not computed, thus the 'children' output is of
    limited use, and the 'parents' output should rather be used.
    This option is valid only when specifying a connectivity matrix.</p>
</li>
<li>
<p><strong>return_distance : bool (optional)</strong>
    If True, return the distance between the clusters.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>children : 2D array, shape (n_nodes-1, 2)</strong>
    The children of each non-leaf node. Values less than <code>n_samples</code>
    correspond to leaves of the tree which are the original samples.
    A node <code>i</code> greater than or equal to <code>n_samples</code> is a non-leaf
    node and has children <code>children_[i - n_samples]</code>. Alternatively
    at the i-th iteration, children[i][0] and children[i][1]
    are merged to form node <code>n_samples + i</code></p>
</li>
<li>
<p><strong>n_connected_components : int</strong>
    The number of connected components in the graph.</p>
</li>
<li>
<p><strong>n_leaves : int</strong>
    The number of leaves in the tree</p>
</li>
<li>
<p><strong>parents : 1D array, shape (n_nodes, ) or None</strong>
    The parent of each node. Only returned when a connectivity matrix
    is specified, elsewhere 'None' is returned.</p>
</li>
<li>
<p><strong>distances : 1D array, shape (n_nodes-1, )</strong>
    Only returned if return_distance is set to True (for compatibility).
    The distances between the centers of the nodes. <code>distances[i]</code>
    corresponds to a weighted euclidean distance between
    the nodes <code>children[i, 1]</code> and <code>children[i, 2]</code>. If the nodes refer to
    leaves of the tree, then <code>distances[i]</code> is their unweighted euclidean
    distance. Distances are updated in the following way
    (from scipy.hierarchy.linkage):</p>
<p>The new entry :math:<code>d(u,v)</code> is computed as follows,</p>
<p>.. math::</p>
<p>d(u,v) = \sqrt{\frac{ |v|+|s| }
                       {T}d(v,s)^2
                + \frac{ |v|+|t| }
                       {T}d(v,t)^2
                - \frac{ |v| }
                       {T}d(s,t)^2}</p>
</li>
<li>
<p><strong>where :math:<code>u</code> is the newly joined cluster consisting of</strong></p>
</li>
<li>
<p><strong>clusters :math:<code>s</code> and :math:<code>t</code>, :math:<code>v</code> is an unused</strong>
    cluster in the forest, :math:<code>T=|v|+|s|+|t|</code>, and
    :math:<code>|*|</code> is the cardinality of its argument. This is also
    known as the incremental algorithm.</p>
</li>
</ul>
</details>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Calibration/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Calibration
              </div>
            </div>
          </a>
        
        
          <a href="../Compose/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Compose
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.0ac82a11.min.js"></script>
      <script src="../../assets/javascripts/bundle.f81dfb4d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ['instant', 'tabs'],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>