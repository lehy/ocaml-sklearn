


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Optimize - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Optimize
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Optimize" class="md-nav__link md-nav__link--active">
      Optimize
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Optimize.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">BFGS</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BFGS</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BFGS</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">exception_strategy</span><span class="o">:[`</span><span class="nc">Skip_update</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Damp_update</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">min_curvature</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">init_scale</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>exception_strategy : {'skip_update', 'damp_update'}, optional
Define how to proceed when the curvature condition is violated.
Set it to 'skip_update' to just skip the update. Or, alternatively,
set it to 'damp_update' to interpolate between the actual BFGS
result and the unmodified matrix. Both exceptions strategies
are explained  in [1]<em>, p.536-537.
min_curvature : float
This number, scaled by a normalization factor, defines the
minimum curvature <code>dot(delta_grad, delta_x)</code> allowed to go
unaffected by the exception strategy. By default is equal to
1e-8 when <code>exception_strategy = 'skip_update'</code> and equal
to 0.2 when <code>exception_strategy = 'damp_update'</code>.
init_scale : {float, 'auto'}
Matrix scale at first iteration. At the first
iteration the Hessian matrix or its inverse will be initialized
with <code>init_scale*np.eye(n)</code>, where <code>n</code> is the problem dimension.
Set it to 'auto' in order to use an automatic heuristic for choosing
the initial scale. The heuristic is described in [1]</em>, p.143.
By default uses 'auto'.</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>The update is based on the description in [1]_, p.140.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] Nocedal, Jorge, and Stephen J. Wright. 'Numerical optimization'
Second Edition (2006).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the product of the internal matrix with the given vector.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>p : array_like
1-d array representing a vector.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>Hp : array
1-d  represents the result of multiplying the approximation matrix
by vector p.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_matrix</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the current internal matrix.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>M : ndarray, shape (n, n)
Dense matrix containing either the Hessian or its inverse
(depending on how <code>approx_type</code> was defined).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">initialize</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">approx_type</span><span class="o">:[`</span><span class="nc">Hess</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Inv_hess</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize internal matrix.</p>
<p>Allocate internal memory for storing and updating
the Hessian or its inverse.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>n : int
Problem dimension.
approx_type : {'hess', 'inv_hess'}
Selects either the Hessian or the inverse Hessian.
When set to 'hess' the Hessian will be stored and updated.
When set to 'inv_hess' its inverse will be used instead.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">delta_x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">delta_grad</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Update internal matrix.</p>
<p>Update Hessian matrix or its inverse (depending on how 'approx_type'
is defined) using information about the last evaluated points.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>delta_x : ndarray
The difference between two points the gradient
function have been evaluated at: <code>delta_x = x2 - x1</code>.
delta_grad : ndarray
The difference between the gradients:
<code>delta_grad = grad(x2) - grad(x1)</code>.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Bounds</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Bounds</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Bounds</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">keep_feasible</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">lb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ub</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Bounds constraint on the variables.</p>
<p>The constraint has the general inequality form::</p>
<p>lb &lt;= x &lt;= ub</p>
<p>It is possible to use equal bounds to represent an equality constraint or
infinite bounds to represent a one-sided constraint.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>lb, ub : array_like, optional
Lower and upper bounds on independent variables. Each array must
have the same size as x or be a scalar, in which case a bound will be
the same for all the variables. Set components of <code>lb</code> and <code>ub</code> equal
to fix a variable. Use <code>np.inf</code> with an appropriate sign to disable
bounds on all or some variables. Note that you can mix constraints of
different types: interval, one-sided or equality, by setting different
components of <code>lb</code> and <code>ub</code> as necessary.
keep_feasible : array_like of bool, optional
Whether to keep the constraint components feasible throughout
iterations. A single value set this property for all components.
Default is False. Has no effect for equality constraints.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">HessianUpdateStrategy</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">HessianUpdateStrategy</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">HessianUpdateStrategy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Interface for implementing Hessian update strategies.</p>
<p>Many optimization methods make use of Hessian (or inverse Hessian)
approximations, such as the quasi-Newton methods BFGS, SR1, L-BFGS.
Some of these  approximations, however, do not actually need to store
the entire matrix or can compute the internal matrix product with a
given vector in a very efficiently manner. This class serves as an
abstract interface between the optimization algorithm and the
quasi-Newton update strategies, giving freedom of implementation
to store and update the internal matrix as efficiently as possible.
Different choices of initialization and update procedure will result
in different quasi-Newton strategies.</p>
<p>Four methods should be implemented in derived classes: <code>initialize</code>,
<code>update</code>, <code>dot</code> and <code>get_matrix</code>.</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>Any instance of a class that implements this interface,
can be accepted by the method <code>minimize</code> and used by
the compatible solvers to approximate the Hessian (or
inverse Hessian) used by the optimization algorithms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the product of the internal matrix with the given vector.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>p : array_like
1-d array representing a vector.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>Hp : array
1-d  represents the result of multiplying the approximation matrix
by vector p.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_matrix</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return current internal matrix.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>H : ndarray, shape (n, n)
Dense matrix containing either the Hessian
or its inverse (depending on how 'approx_type'
is defined).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">initialize</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">approx_type</span><span class="o">:[`</span><span class="nc">Hess</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Inv_hess</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize internal matrix.</p>
<p>Allocate internal memory for storing and updating
the Hessian or its inverse.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>n : int
Problem dimension.
approx_type : {'hess', 'inv_hess'}
Selects either the Hessian or the inverse Hessian.
When set to 'hess' the Hessian will be stored and updated.
When set to 'inv_hess' its inverse will be used instead.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">delta_x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">delta_grad</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Update internal matrix.</p>
<p>Update Hessian matrix or its inverse (depending on how 'approx_type'
is defined) using information about the last evaluated points.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>delta_x : ndarray
The difference between two points the gradient
function have been evaluated at: <code>delta_x = x2 - x1</code>.
delta_grad : ndarray
The difference between the gradients:
<code>delta_grad = grad(x2) - grad(x1)</code>.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LbfgsInvHessProduct</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LbfgsInvHessProduct</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LbfgsInvHessProduct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Linear operator for the L-BFGS approximate inverse Hessian.</p>
<p>This operator computes the product of a vector with the approximate inverse
of the Hessian of the objective function, using the L-BFGS limited
memory approximation to the inverse Hessian, accumulated during the
optimization.</p>
<p>Objects of this class implement the <code>scipy.sparse.linalg.LinearOperator</code>
interface.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>sk : array_like, shape=(n_corr, n)
Array of <code>n_corr</code> most recent updates to the solution vector.
(See [1]).
yk : array_like, shape=(n_corr, n)
Array of <code>n_corr</code> most recent updates to the gradient. (See [1]).</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] Nocedal, Jorge. 'Updating quasi-Newton matrices with limited
storage.' Mathematics of computation 35.151 (1980): 773-782.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a dense array representation of this operator.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>arr : ndarray, shape=(n, n)
An array with the same shape and containing
the same data represented by this <code>LinearOperator</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LinearConstraint</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearConstraint</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearConstraint</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">keep_feasible</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">lb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ub</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Linear constraint on the variables.</p>
<p>The constraint has the general inequality form::</p>
<p>lb &lt;= A.dot(x) &lt;= ub</p>
<p>Here the vector of independent variables x is passed as ndarray of shape
(n,) and the matrix A has shape (m, n).</p>
<p>It is possible to use equal bounds to represent an equality constraint or
infinite bounds to represent a one-sided constraint.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>A : {array_like, sparse matrix}, shape (m, n)
Matrix defining the constraint.
lb, ub : array_like
Lower and upper bounds on the constraint. Each array must have the
shape (m,) or be a scalar, in the latter case a bound will be the same
for all components of the constraint. Use <code>np.inf</code> with an
appropriate sign to specify a one-sided constraint.
Set components of <code>lb</code> and <code>ub</code> equal to represent an equality
constraint. Note that you can mix constraints of different types:
interval, one-sided or equality, by setting different components of
<code>lb</code> and <code>ub</code> as  necessary.
keep_feasible : array_like of bool, optional
Whether to keep the constraint components feasible throughout
iterations. A single value set this property for all components.
Default is False. Has no effect for equality constraints.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">NonlinearConstraint</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">NonlinearConstraint</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">NonlinearConstraint</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">T2_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T3_point</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hess</span><span class="o">:[`</span><span class="nc">T2_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T3_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">HessianUpdateStrategy</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keep_feasible</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">finite_diff_rel_step</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">finite_diff_jac_sparsity</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">lb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ub</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Nonlinear constraint on the variables.</p>
<p>The constraint has the general inequality form::</p>
<p>lb &lt;= fun(x) &lt;= ub</p>
<p>Here the vector of independent variables x is passed as ndarray of shape
(n,) and <code>fun</code> returns a vector with m components.</p>
<p>It is possible to use equal bounds to represent an equality constraint or
infinite bounds to represent a one-sided constraint.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>fun : callable
The function defining the constraint.
The signature is <code>fun(x) -&gt; array_like, shape (m,)</code>.
lb, ub : array_like
Lower and upper bounds on the constraint. Each array must have the
shape (m,) or be a scalar, in the latter case a bound will be the same
for all components of the constraint. Use <code>np.inf</code> with an
appropriate sign to specify a one-sided constraint.
Set components of <code>lb</code> and <code>ub</code> equal to represent an equality
constraint. Note that you can mix constraints of different types:
interval, one-sided or equality, by setting different components of
<code>lb</code> and <code>ub</code> as  necessary.
jac : {callable,  '2-point', '3-point', 'cs'}, optional
Method of computing the Jacobian matrix (an m-by-n matrix,
where element (i, j) is the partial derivative of f[i] with
respect to x[j]).  The keywords {'2-point', '3-point',
'cs'} select a finite difference scheme for the numerical estimation.
A callable must have the following signature:
<code>jac(x) -&gt; {ndarray, sparse matrix}, shape (m, n)</code>.
Default is '2-point'.
hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy, None}, optional
Method for computing the Hessian matrix. The keywords
{'2-point', '3-point', 'cs'} select a finite difference scheme for
numerical  estimation.  Alternatively, objects implementing
<code>HessianUpdateStrategy</code> interface can be used to approximate the
Hessian. Currently available implementations are:</p>
<ul>
<li><code>BFGS</code> (default option)</li>
<li><code>SR1</code></li>
</ul>
<p>A callable must return the Hessian matrix of <code>dot(fun, v)</code> and
must have the following signature:
<code>hess(x, v) -&gt; {LinearOperator, sparse matrix, array_like}, shape (n, n)</code>.
Here <code>v</code> is ndarray with shape (m,) containing Lagrange multipliers.
keep_feasible : array_like of bool, optional
Whether to keep the constraint components feasible throughout
iterations. A single value set this property for all components.
Default is False. Has no effect for equality constraints.
finite_diff_rel_step: None or array_like, optional
Relative step size for the finite difference approximation. Default is
None, which will select a reasonable value automatically depending
on a finite difference scheme.
finite_diff_jac_sparsity: {None, array_like, sparse matrix}, optional
Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations. A zero entry means
that a corresponding element in the Jacobian is identically zero.
If provided, forces the use of 'lsmr' trust-region solver.
If None (default) then dense differencing will be used.</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>Finite difference schemes {'2-point', '3-point', 'cs'} may be used for
approximating either the Jacobian or the Hessian. We, however, do not allow
its use for approximating both simultaneously. Hence whenever the Jacobian
is estimated via finite-differences, we require the Hessian to be estimated
using one of the quasi-Newton strategies.</p>
<p>The scheme 'cs' is potentially the most accurate, but requires the function
to correctly handles complex inputs and be analytically continuable to the
complex plane. The scheme '3-point' is more accurate than '2-point' but
requires twice as many operations.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">OptimizeResult</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">OptimizeResult</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">OptimizeResult</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute x: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute x: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">x_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute success: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">success</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Attribute success: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">success_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">bool</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute status: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">status</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute status: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">status_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute message: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">message</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Attribute message: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">message_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute hess_inv: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hess_inv</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute hess_inv: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hess_inv_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nit: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nit</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute nit: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nit_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute maxcv: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxcv</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute maxcv: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxcv_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">OptimizeWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">OptimizeWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">OptimizeWarning</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">RootResults</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">RootResults</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">RootResults</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">root</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterations</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_calls</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">flag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Represents the root finding result.</p>
<h2 id="attributes">Attributes<a class="headerlink" href="#attributes" title="Permanent link">&para;</a></h2>
<p>root : float
Estimated root location.
iterations : int
Number of iterations needed to find the root.
function_calls : int
Number of times the function was called.
converged : bool
True if the routine converged.
flag : str
Description of the cause of termination.</p>
<p>Attribute root: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">root</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute root: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">root_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute iterations: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterations</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute iterations: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterations_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute function_calls: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">function_calls</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute function_calls: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">function_calls_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute converged: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">converged</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Attribute converged: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">converged_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">bool</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute flag: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flag</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Attribute flag: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flag_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SR1</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SR1</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SR1</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">min_denominator</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">init_scale</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Symmetric-rank-1 Hessian update strategy.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>min_denominator : float
This number, scaled by a normalization factor,
defines the minimum denominator magnitude allowed
in the update. When the condition is violated we skip
the update. By default uses <code>1e-8</code>.
init_scale : {float, 'auto'}, optional
Matrix scale at first iteration. At the first
iteration the Hessian matrix or its inverse will be initialized
with <code>init_scale*np.eye(n)</code>, where <code>n</code> is the problem dimension.
Set it to 'auto' in order to use an automatic heuristic for choosing
the initial scale. The heuristic is described in [1]_, p.143.
By default uses 'auto'.</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>The update is based on the description in [1]_, p.144-146.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] Nocedal, Jorge, and Stephen J. Wright. 'Numerical optimization'
Second Edition (2006).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the product of the internal matrix with the given vector.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>p : array_like
1-d array representing a vector.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>Hp : array
1-d  represents the result of multiplying the approximation matrix
by vector p.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_matrix</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the current internal matrix.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>M : ndarray, shape (n, n)
Dense matrix containing either the Hessian or its inverse
(depending on how <code>approx_type</code> was defined).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">initialize</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">approx_type</span><span class="o">:[`</span><span class="nc">Hess</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Inv_hess</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize internal matrix.</p>
<p>Allocate internal memory for storing and updating
the Hessian or its inverse.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>n : int
Problem dimension.
approx_type : {'hess', 'inv_hess'}
Selects either the Hessian or the inverse Hessian.
When set to 'hess' the Hessian will be stored and updated.
When set to 'inv_hess' its inverse will be used instead.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">delta_x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">delta_grad</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Update internal matrix.</p>
<p>Update Hessian matrix or its inverse (depending on how 'approx_type'
is defined) using information about the last evaluated points.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>delta_x : ndarray
The difference between two points the gradient
function have been evaluated at: <code>delta_x = x2 - x1</code>.
delta_grad : ndarray
The difference between the gradients:
<code>delta_grad = grad(x2) - grad(x1)</code>.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Cobyla</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Izip</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Zip</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zip</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>zip( *iterables) --&gt; zip object</p>
<p>Return a zip object whose .<strong>next</strong>() method returns a tuple where
the i-th element comes from the i-th iterable argument.  The .<strong>next</strong>()
method continues until the shortest iterable in the argument sequence
is exhausted and then it raises StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_cobyla</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">consargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rhobeg</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rhoend</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">catol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimize a function using the Constrained Optimization BY Linear
Approximation (COBYLA) method. This method wraps a FORTRAN
implementation of the algorithm.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>func : callable
Function to minimize. In the form func(x, *args).
x0 : ndarray
Initial guess.
cons : sequence
Constraint functions; must all be <code>&gt;=0</code> (a single function
if only 1 constraint). Each function takes the parameters <code>x</code>
as its first argument, and it can return either a single number or
an array or list of numbers.
args : tuple, optional
Extra arguments to pass to function.
consargs : tuple, optional
Extra arguments to pass to constraint functions (default of None means
use same extra arguments as those passed to func).
Use <code>()</code> for no extra arguments.
rhobeg : float, optional
Reasonable initial changes to the variables.
rhoend : float, optional
Final accuracy in the optimization (not precisely guaranteed). This
is a lower bound on the size of the trust region.
disp : {0, 1, 2, 3}, optional
Controls the frequency of output; 0 implies no output.
maxfun : int, optional
Maximum number of function evaluations.
catol : float, optional
Absolute tolerance for constraint violations.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The argument that minimises <code>f</code>.</p>
<h2 id="see-also">See also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'COBYLA' <code>method</code> in particular.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>This algorithm is based on linear approximations to the objective
function and each constraint. We briefly describe the algorithm.</p>
<p>Suppose the function is being minimized over k variables. At the
jth iteration the algorithm has k+1 points v_1, ..., v_(k+1),
an approximate solution x_j, and a radius RHO_j.
(i.e. linear plus a constant) approximations to the objective
function and constraint functions such that their function values
agree with the linear approximation on the k+1 points v_1,.., v_(k+1).
This gives a linear program to solve (where the linear approximations
of the constraint functions are constrained to be non-negative).</p>
<p>However the linear approximations are likely only good
approximations near the current simplex, so the linear program is
given the further requirement that the solution, which
will become x_(j+1), must be within RHO_j from x_j. RHO_j only
decreases, never increases. The initial RHO_j is rhobeg and the
final RHO_j is rhoend. In this way COBYLA's iterations behave
like a trust region algorithm.</p>
<p>Additionally, the linear program may be inconsistent, or the
approximation may give poor improvement. For details about
how these issues are resolved, as well as how the points v_i are
updated, refer to the source code or the references below.</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>Powell M.J.D. (1994), 'A direct search optimization method that models
the objective and constraint functions by linear interpolation.', in
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J-P Hennart, Kluwer Academic (Dordrecht), pp. 51-67</p>
<p>Powell M.J.D. (1998), 'Direct search algorithms for optimization
calculations', Acta Numerica 7, 287-336</p>
<p>Powell M.J.D. (2007), 'A view of algorithms for optimization without
derivatives', Cambridge University Technical Report DAMTP 2007/NA03</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<p>Minimize the objective function f(x,y) = x<em>y subject
to the constraints x</em><em>2 + y</em>*2 &lt; 1 and y &gt; 0::</p>
<blockquote>
<blockquote>
<blockquote>
<p>def objective(x):
...     return x[0]<em>x[1]
...
def constr1(x):
...     return 1 - (x[0]</em><em>2 + x[1]</em>*2)
...
def constr2(x):
...     return x[1]
...
from scipy.optimize import fmin_cobyla
fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)
array([-0.70710685,  0.70710671])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The exact solution is (-sqrt(2)/2, sqrt(2)/2).</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Lbfgsb</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">LinearOperator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearOperator</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearOperator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for performing matrix vector products</p>
<p>Many iterative methods (e.g. cg, gmres) do not need to know the
individual entries of a matrix to solve a linear system A<em>x=b.
Such solvers only require the computation of matrix vector
products, A</em>v where v is a dense vector.  This class serves as
an abstract interface between iterative solvers and matrix-like
objects.</p>
<p>To construct a concrete LinearOperator, either pass appropriate
callables to the constructor of this class, or subclass it.</p>
<p>A subclass must implement either one of the methods <code>_matvec</code>
and <code>_matmat</code>, and the attributes/properties <code>shape</code> (pair of
integers) and <code>dtype</code> (may be None). It may call the <code>__init__</code>
on this class to have these attributes validated. Implementing
<code>_matvec</code> automatically implements <code>_matmat</code> (using a naive
algorithm) and vice-versa.</p>
<p>Optionally, a subclass may implement <code>_rmatvec</code> or <code>_adjoint</code>
to implement the Hermitian adjoint (conjugate transpose). As with
<code>_matvec</code> and <code>_matmat</code>, implementing either <code>_rmatvec</code> or
<code>_adjoint</code> implements the other automatically. Implementing
<code>_adjoint</code> is preferable; <code>_rmatvec</code> is mostly there for
backwards compatibility.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>shape : tuple
Matrix dimensions (M, N).
matvec : callable f(v)
Returns returns A * v.
rmatvec : callable f(v)
Returns A^H * v, where A^H is the conjugate transpose of A.
matmat : callable f(V)
Returns A * V, where V is a dense matrix with dimensions (N, K).
dtype : dtype
Data type of the matrix.
rmatmat : callable f(V)
Returns A^H * V, where V is a dense matrix with dimensions (M, K).</p>
<h2 id="attributes_1">Attributes<a class="headerlink" href="#attributes_1" title="Permanent link">&para;</a></h2>
<p>args : tuple
For linear operators describing products etc. of other linear
operators, the operands of the binary operation.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>aslinearoperator : Construct LinearOperators</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>The user-defined matvec() function must properly handle the case
where v has shape (N,) as well as the (N,1) case.  The shape of
the return type is handled internally by LinearOperator.</p>
<p>LinearOperator instances can also be multiplied, added with each
other and exponentiated, all lazily: the result of these operations
is always a new, composite LinearOperator, that defers linear
operations to the original operators and combines the results.</p>
<p>More details regarding how to subclass a LinearOperator and several
examples of concrete LinearOperator instances can be found in the
external project <code>PyLops &lt;https://pylops.readthedocs.io&gt;</code>_.</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.sparse.linalg import LinearOperator
def mv(v):
...     return np.array([2<em>v[0], 3</em>v[1]])
...
A = LinearOperator((2,2), matvec=mv)
A
&lt;2x2 _CustomLinearOperator with dtype=float64&gt;
A.matvec(np.ones(2))
array([ 2.,  3.])
A * np.ones(2)
array([ 2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">adjoint</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Hermitian adjoint.</p>
<p>Returns the Hermitian adjoint of self, aka the Hermitian
conjugate or Hermitian transpose. For a complex matrix, the
Hermitian adjoint is equal to the conjugate transpose.</p>
<p>Can be abbreviated self.H instead of self.adjoint().</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>A_H : LinearOperator
Hermitian adjoint of self.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix or matrix-vector multiplication.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-d or 2-d array, representing a vector or matrix.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>Ax : array
1-d or 2-d array (depending on the shape of x) that represents
the result of applying this linear operator on x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-matrix multiplication.</p>
<p>Performs the operation y=A<em>X where A is an MxN linear
operator and X dense N</em>K matrix or ndarray.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
An array with shape (N,K).</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or ndarray with shape (M,K) depending on
the type of the X argument.</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>This matmat wraps any user-specified matmat routine or overridden
_matmat method to ensure that y has the correct type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix-vector multiplication.</p>
<p>Performs the operation y=A*x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (N,) or (N,1).</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (M,) or (M,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>This matvec wraps the user-specified matvec routine or overridden
_matvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatmat</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-matrix multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array, or 2-d array.
The default implementation defers to the adjoint.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>X : {matrix, ndarray}
A matrix or 2D array.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>Y : {matrix, ndarray}
A matrix or 2D array depending on the type of the input.</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>This rmatmat wraps the user-specified rmatmat routine.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Adjoint matrix-vector multiplication.</p>
<p>Performs the operation y = A^H * x where A is an MxN linear
operator and x is a column vector or 1-d array.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>x : {matrix, ndarray}
An array with shape (M,) or (M,1).</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>y : {matrix, ndarray}
A matrix or ndarray with shape (N,) or (N,1) depending
on the type and shape of the x argument.</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>This rmatvec wraps the user-specified rmatvec routine or overridden
_rmatvec method to ensure that y has the correct shape and type.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transpose this linear operator.</p>
<p>Returns a LinearOperator that represents the transpose of this one.
Can be abbreviated self.T instead of self.transpose().</p>
<p>Attribute args: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">args</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute args: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">args_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">MemoizeJac</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MemoizeJac</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MemoizeJac</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Decorator that caches the value gradient of function each time it
is called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">derivative</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Float64</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float64</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float64</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Double-precision floating-point number type, compatible with Python <code>float</code>
and C <code>double</code>.
Character code: <code>'d'</code>.
Canonical name: <code>np.double</code>.
Alias: <code>np.float_</code>.
Alias <em>on this platform</em>: <code>np.float64</code>: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fromhex</span> <span class="o">:</span> <span class="kt">string</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a floating-point number from a hexadecimal string.</p>
<blockquote>
<blockquote>
<blockquote>
<p>float.fromhex('0x1.ffffp10')
2047.984375
float.fromhex('-0x1p-1074')
-5e-324</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hex</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a hexadecimal representation of a floating-point number.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(-0.1).hex()
'-0x1.999999999999ap-4'
3.14159.hex()
'0x1.921f9f01b866ep+1'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_integer</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return True if the float is an integer.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>new_order : str, optional
Byte order to force; a value from the byte order specifications
above.  The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>new_dtype : dtype
New <code>dtype</code> object with the given change to the byte order.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Int32</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Int32</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Int32</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>new_order : str, optional
Byte order to force; a value from the byte order specifications
above.  The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>new_dtype : dtype
New <code>dtype</code> object with the given change to the byte order.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_l_bfgs_b</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">approx_grad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pgtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iprint</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxls</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function func using the L-BFGS-B algorithm.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,<em>args)
Function to minimise.
x0 : ndarray
Initial guess.
fprime : callable fprime(x,</em>args), optional
The gradient of <code>func</code>.  If None, then <code>func</code> returns the function
value and the gradient (<code>f, g = func(x, *args)</code>), unless
<code>approx_grad</code> is True in which case <code>func</code> returns only <code>f</code>.
args : sequence, optional
Arguments to pass to <code>func</code> and <code>fprime</code>.
approx_grad : bool, optional
Whether to approximate the gradient numerically (in which case
<code>func</code> returns only the function value).
bounds : list, optional
<code>(min, max)</code> pairs for each element in <code>x</code>, defining
the bounds on that parameter. Use None or +-inf for one of <code>min</code> or
<code>max</code> when there is no bound in that direction.
m : int, optional
The maximum number of variable metric corrections
used to define the limited memory matrix. (The limited memory BFGS
method does not store the full hessian but uses this many terms in an
approximation to it.)
factr : float, optional
The iteration stops when
<code>(f^k - f^{k+1})/max{ |f^k|,|f^{k+1}|,1} &lt;= factr * eps</code>,
where <code>eps</code> is the machine precision, which is automatically
generated by the code. Typical values for <code>factr</code> are: 1e12 for
low accuracy; 1e7 for moderate accuracy; 10.0 for extremely
high accuracy. See Notes for relationship to <code>ftol</code>, which is exposed
(instead of <code>factr</code>) by the <code>scipy.optimize.minimize</code> interface to
L-BFGS-B.
pgtol : float, optional
The iteration will stop when
<code>max{ |proj g_i | i = 1, ..., n} &lt;= pgtol</code>
where <code>pg_i</code> is the i-th component of the projected gradient.
epsilon : float, optional
Step size used when <code>approx_grad</code> is True, for numerically
calculating the gradient
iprint : int, optional
Controls the frequency of output. <code>iprint &lt; 0</code> means no output;
<code>iprint = 0</code>    print only one line at the last iteration;
<code>0 &lt; iprint &lt; 99</code> print also f and <code>|proj g|</code> every iprint iterations;
<code>iprint = 99</code>   print details of every iteration except n-vectors;
<code>iprint = 100</code>  print also the changes of active set and final x;
<code>iprint &gt; 100</code>  print details of every iteration including x and g.
disp : int, optional
If zero, then no output.  If a positive number, then this over-rides
<code>iprint</code> (i.e., <code>iprint</code> gets the value of <code>disp</code>).
maxfun : int, optional
Maximum number of function evaluations.
maxiter : int, optional
Maximum number of iterations.
callback : callable, optional
Called after each iteration, as <code>callback(xk)</code>, where <code>xk</code> is the
current parameter vector.
maxls : int, optional
Maximum number of line search steps (per iteration). Default is 20.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>x : array_like
Estimated position of the minimum.
f : float
Value of <code>func</code> at the minimum.
d : dict
Information dictionary.</p>
<ul>
<li>
<p>d['warnflag'] is</p>
</li>
<li>
<p>0 if converged,</p>
</li>
<li>1 if too many function evaluations or too many iterations,</li>
<li>
<p>2 if stopped for another reason, given in d['task']</p>
</li>
<li>
<p>d['grad'] is the gradient at the minimum (should be 0 ish)</p>
</li>
<li>d['funcalls'] is the number of function calls made.</li>
<li>d['nit'] is the number of iterations.</li>
</ul>
<h2 id="see-also_4">See also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'L-BFGS-B' <code>method</code> in particular. Note that the
<code>ftol</code> option is made available via that interface, while <code>factr</code> is
provided via this interface, where <code>factr</code> is the factor multiplying
the default machine floating-point precision to arrive at <code>ftol</code>:
<code>ftol = factr * numpy.finfo(float).eps</code>.</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>License of L-BFGS-B (FORTRAN code):</p>
<p>The version included here (in fortran code) is 3.0
(released April 25, 2011).  It was written by Ciyou Zhu, Richard Byrd,
and Jorge Nocedal <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#99;&#101;&#100;&#97;&#108;&#64;&#101;&#99;&#101;&#46;&#110;&#119;&#117;&#46;&#101;&#100;&#117;">&#110;&#111;&#99;&#101;&#100;&#97;&#108;&#64;&#101;&#99;&#101;&#46;&#110;&#119;&#117;&#46;&#101;&#100;&#117;</a>. It carries the following
condition for use:</p>
<p>This software is freely available, but we expect that all publications
describing work using this software, or all commercial products using it,
quote at least one of the references given below. This software is released
under the BSD License.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<ul>
<li>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
Constrained Optimization, (1995), SIAM Journal on Scientific and
Statistical Computing, 16, 5, pp. 1190-1208.</li>
<li>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (1997),
ACM Transactions on Mathematical Software, 23, 4, pp. 550 - 560.</li>
<li>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (2011),
ACM Transactions on Mathematical Software, 38, 1.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wrap_function</span> <span class="o">:</span> <span class="n">function_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Linesearch</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">LineSearchWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LineSearchWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LineSearchWarning</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">line_search</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>As <code>scalar_search_wolfe1</code> but do a line search to direction <code>pk</code></p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>f : callable
Function <code>f(x)</code>
fprime : callable
Gradient of <code>f</code>
xk : array_like
Current point
pk : array_like
Search direction</p>
<p>gfk : array_like, optional
Gradient of <code>f</code> at point <code>xk</code>
old_fval : float, optional
Value of <code>f</code> at point <code>xk</code>
old_old_fval : float, optional
Value of <code>f</code> at point preceding <code>xk</code></p>
<p>The rest of the parameters are the same as for <code>scalar_search_wolfe1</code>.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>stp, f_count, g_count, fval, old_fval
As in <code>line_search_wolfe1</code>
gval : array
Gradient of <code>f</code> at the final point</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_BFGS</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gfk</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">old_fval</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compatibility wrapper for <code>line_search_armijo</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_armijo</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha0</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimize over alpha, the function <code>f(xk+alpha pk)</code>.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>f : callable
Function to be minimized.
xk : array_like
Current point.
pk : array_like
Search direction.
gfk : array_like
Gradient of <code>f</code> at point <code>xk</code>.
old_fval : float
Value of <code>f</code> at point <code>xk</code>.
args : tuple, optional
Optional arguments.
c1 : float, optional
Value to control stopping criterion.
alpha0 : scalar, optional
Value of <code>alpha</code> at start of the optimization.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>alpha
f_count
f_val_at_alpha</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>Uses the interpolation algorithm (Armijo backtracking) as suggested by
Wright and Nocedal in 'Numerical Optimization', 1999, pg. 56-57</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_wolfe1</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>As <code>scalar_search_wolfe1</code> but do a line search to direction <code>pk</code></p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>f : callable
Function <code>f(x)</code>
fprime : callable
Gradient of <code>f</code>
xk : array_like
Current point
pk : array_like
Search direction</p>
<p>gfk : array_like, optional
Gradient of <code>f</code> at point <code>xk</code>
old_fval : float, optional
Value of <code>f</code> at point <code>xk</code>
old_old_fval : float, optional
Value of <code>f</code> at point preceding <code>xk</code></p>
<p>The rest of the parameters are the same as for <code>scalar_search_wolfe1</code>.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>stp, f_count, g_count, fval, old_fval
As in <code>line_search_wolfe1</code>
gval : array
Gradient of <code>f</code> at the final point</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_wolfe2</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">myfprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Find alpha that satisfies strong Wolfe conditions.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function.
myfprime : callable f'(x,</em>args)
Objective function gradient.
xk : ndarray
Starting point.
pk : ndarray
Search direction.
gfk : ndarray, optional
Gradient value for x=xk (xk being the current parameter
estimate). Will be recomputed if omitted.
old_fval : float, optional
Function value for x=xk. Will be recomputed if omitted.
old_old_fval : float, optional
Function value for the point preceding x=xk
args : tuple, optional
Additional arguments passed to objective function.
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax : float, optional
Maximum step size
extra_condition : callable, optional
A callable of the form <code>extra_condition(alpha, x, f, g)</code>
returning a boolean. Arguments are the proposed step <code>alpha</code>
and the corresponding <code>x</code>, <code>f</code> and <code>g</code> values. The line search
accepts the value of <code>alpha</code> only if this
callable returns <code>True</code>. If the callable returns <code>False</code>
for the step length, the algorithm will continue with
new iterates. The callable is only called for iterates
satisfying the strong Wolfe conditions.
maxiter : int, optional
Maximum number of iterations to perform</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>alpha : float or None
Alpha for which <code>x_new = x0 + alpha * pk</code>,
or None if the line search algorithm did not converge.
fc : int
Number of function evaluations made.
gc : int
Number of gradient evaluations made.
new_fval : float or None
New function value <code>f(x_new)=f(x0+alpha*pk)</code>,
or None if the line search algorithm did not converge.
old_fval : float
Old function value <code>f(x0)</code>.
new_slope : float or None
The local slope along the search direction at the
new value <code>&lt;myfprime(x_new), pk&gt;</code>,
or None if the line search algorithm did not converge.</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.</p>
<p>For the zoom phase it uses an algorithm by [...].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">scalar_search_armijo</span> <span class="o">:</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">phi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">phi0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derphi0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimize over alpha, the function <code>phi(alpha)</code>.</p>
<p>Uses the interpolation algorithm (Armijo backtracking) as suggested by
Wright and Nocedal in 'Numerical Optimization', 1999, pg. 56-57</p>
<p>alpha &gt; 0 is assumed to be a descent direction.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>alpha
phi1</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">scalar_search_wolfe1</span> <span class="o">:</span> <span class="o">?</span><span class="n">phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">derphi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">phi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derphi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Scalar function search for alpha that satisfies strong Wolfe conditions</p>
<p>alpha &gt; 0 is assumed to be a descent direction.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>phi : callable phi(alpha)
Function at point <code>alpha</code>
derphi : callable phi'(alpha)
Objective function derivative. Returns a scalar.
phi0 : float, optional
Value of phi at 0
old_phi0 : float, optional
Value of phi at previous point
derphi0 : float, optional
Value derphi at 0
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax, amin : float, optional
Maximum and minimum step size
xtol : float, optional
Relative tolerance for an acceptable step.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>alpha : float
Step size, or None if no suitable step was found
phi : float
Value of <code>phi</code> at the new point <code>alpha</code>
phi0 : float
Value of <code>phi</code> at <code>alpha=0</code></p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>Uses routine DCSRCH from MINPACK.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">scalar_search_wolfe2</span> <span class="o">:</span> <span class="o">?</span><span class="n">phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">derphi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">phi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derphi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Find alpha that satisfies strong Wolfe conditions.</p>
<p>alpha &gt; 0 is assumed to be a descent direction.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>phi : callable phi(alpha)
Objective scalar function.
derphi : callable phi'(alpha)
Objective function derivative. Returns a scalar.
phi0 : float, optional
Value of phi at 0
old_phi0 : float, optional
Value of phi at previous point
derphi0 : float, optional
Value of derphi at 0
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax : float, optional
Maximum step size
extra_condition : callable, optional
A callable of the form <code>extra_condition(alpha, phi_value)</code>
returning a boolean. The line search accepts the value
of <code>alpha</code> only if this callable returns <code>True</code>.
If the callable returns <code>False</code> for the step length,
the algorithm will continue with new iterates.
The callable is only called for iterates satisfying
the strong Wolfe conditions.
maxiter : int, optional
Maximum number of iterations to perform</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>alpha_star : float or None
Best alpha, or None if the line search algorithm did not converge.
phi_star : float
phi at alpha_star
phi0 : float
phi at 0
derphi_star : float or None
derphi at alpha_star, or None if the line search algorithm
did not converge.</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.</p>
<p>For the zoom phase it uses an algorithm by [...].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Minpack</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Error</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Error</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Error</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Finfo</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Finfo</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Finfo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>finfo(dtype)</p>
<p>Machine limits for floating point types.</p>
<h2 id="attributes_2">Attributes<a class="headerlink" href="#attributes_2" title="Permanent link">&para;</a></h2>
<p>bits : int
The number of bits occupied by the type.
eps : float
The smallest representable positive number such that
<code>1.0 + eps != 1.0</code>.  Type of <code>eps</code> is an appropriate floating
point type.
epsneg : floating point number of the appropriate type
The smallest representable positive number such that
<code>1.0 - epsneg != 1.0</code>.
iexp : int
The number of bits in the exponent portion of the floating point
representation.
machar : MachAr
The object which calculated these parameters and holds more
detailed information.
machep : int
The exponent that yields <code>eps</code>.
max : floating point number of the appropriate type
The largest representable number.
maxexp : int
The smallest positive power of the base (2) that causes overflow.
min : floating point number of the appropriate type
The smallest representable number, typically <code>-max</code>.
minexp : int
The most negative power of the base (2) consistent with there
being no leading 0's in the mantissa.
negep : int
The exponent that yields <code>epsneg</code>.
nexp : int
The number of bits in the exponent including its sign and bias.
nmant : int
The number of bits in the mantissa.
precision : int
The approximate number of decimal digits to which this kind of
float is precise.
resolution : floating point number of the appropriate type
The approximate decimal resolution of this type, i.e.,
<code>10**-precision</code>.
tiny : float
The smallest positive usable number.  Type of <code>tiny</code> is an
appropriate floating point type.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>dtype : float, dtype, or instance
Kind of floating point data-type about which to get information.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>MachAr : The implementation of the tests that produce this information.
iinfo : The equivalent for integer data types.</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling <code>finfo()</code>
repeatedly inside your functions is not a problem.</p>
<p>Attribute bits: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute bits: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bits_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute eps: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eps</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute eps: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eps_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute epsneg: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">epsneg</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute epsneg: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">epsneg_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute iexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute iexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute machar: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machar</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute machar: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machar_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute machep: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machep</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute machep: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machep_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute max: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute max: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute maxexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute maxexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute min: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute min: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute minexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute minexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute negep: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">negep</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute negep: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">negep_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute nexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nmant: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nmant</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute nmant: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nmant_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute precision: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">precision</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute precision: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">precision_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute resolution: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resolution</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute resolution: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resolution_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute tiny: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tiny</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute tiny: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tiny_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">abs</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>absolute : ndarray
An ndarray containing the absolute value of
each element in <code>x</code>.  For complex input, <code>a + ib</code>, the
absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([-1.2, 1.2])
np.absolute(x)
array([ 1.2,  1.2])
np.absolute(1.2 + 1j)
1.5620499351813308</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(start=-10, stop=10, num=101)
plt.plot(x, np.absolute(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xx = x + 1j * x[:, np.newaxis]
plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">all</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether all array elements along a given axis evaluate to True.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array or object that can be converted to an array.
axis : None or int or tuple of ints, optional
Axis or axes along which a logical AND reduction is performed.
The default (<code>axis=None</code>) is to perform a logical AND over all
the dimensions of the input array. <code>axis</code> may be negative, in
which case it counts from the last to the first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.
out : ndarray, optional
Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code>dtype(out)</code> is float, the result
will consist of 0.0's and 1.0's). See <code>ufuncs-output-type</code> for more
details.</p>
<p>keepdims : bool, optional
If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>all</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>all : ndarray, bool
A new boolean or array is returned unless <code>out</code> is specified,
in which case a reference to <code>out</code> is returned.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <code>True</code> because these are not equal to zero.</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.all([[True,False],[True,True]])
False</p>
<p>np.all([[True,False],[True,True]], axis=0)
array([ True, False])</p>
<p>np.all([-1, 4, 5])
True</p>
<p>np.all([1.0, np.nan])
True</p>
<p>o=np.array(False)
z=np.all([-1, 4, 5], out=o)
id(z), id(o), z
(28293632, 28293632, array(True)) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_gradient</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">col_deriv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fcn</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dfcn</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform a simple check on the gradient for correctness.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix.</p>
<p>Returns the Cholesky decomposition, :math:<code>A = L L^*</code> or
:math:<code>A = U^* U</code> of a Hermitian positive-definite matrix A.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to be decomposed
lower : bool, optional
Whether to compute the upper or lower triangular Cholesky
factorization.  Default is upper-triangular.
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>c : (M, M) ndarray
Upper- or lower-triangular Cholesky factor of <code>a</code>.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>LinAlgError : if decomposition fails.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky
a = np.array([[1,-2j],[2j,5]])
L = cholesky(a, lower=True)
L
array([[ 1.+0.j,  0.+0.j],
[ 0.+2.j,  1.+0.j]])
L @ L.T.conj()
array([[ 1.+0.j,  0.-2.j],
[ 0.+2.j,  5.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">curve_fit</span> <span class="o">:</span> <span class="o">?</span><span class="n">p0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">absolute_sigma</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Lm</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Trf</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dogbox</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xdata</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">ydata</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Use non-linear least squares to fit a function, f, to data.</p>
<p>Assumes <code>ydata = f(xdata, *params) + eps</code></p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>f : callable
The model function, f(x, ...).  It must take the independent
variable as the first argument and the parameters to fit as
separate remaining arguments.
xdata : array_like or object
The independent variable where the data is measured.
Should usually be an M-length sequence or an (k,M)-shaped array for
functions with k predictors, but can actually be any object.
ydata : array_like
The dependent data, a length M array - nominally <code>f(xdata, ...)</code>.
p0 : array_like, optional
Initial guess for the parameters (length N).  If None, then the
initial values will all be 1 (if the number of parameters for the
function can be determined using introspection, otherwise a
ValueError is raised).
sigma : None or M-length sequence or MxM array, optional
Determines the uncertainty in <code>ydata</code>. If we define residuals as
<code>r = ydata - f(xdata, *popt)</code>, then the interpretation of <code>sigma</code>
depends on its number of dimensions:</p>
<ul>
<li>
<p>A 1-d <code>sigma</code> should contain values of standard deviations of
errors in <code>ydata</code>. In this case, the optimized function is
<code>chisq = sum((r / sigma) ** 2)</code>.</p>
</li>
<li>
<p>A 2-d <code>sigma</code> should contain the covariance matrix of
errors in <code>ydata</code>. In this case, the optimized function is
<code>chisq = r.T @ inv(sigma) @ r</code>.</p>
</li>
</ul>
<p>.. versionadded:: 0.19</p>
<p>None (default) is equivalent of 1-d <code>sigma</code> filled with ones.
absolute_sigma : bool, optional
If True, <code>sigma</code> is used in an absolute sense and the estimated parameter
covariance <code>pcov</code> reflects these absolute values.</p>
<p>If False, only the relative magnitudes of the <code>sigma</code> values matter.
The returned parameter covariance matrix <code>pcov</code> is based on scaling
<code>sigma</code> by a constant factor. This constant is set by demanding that the
reduced <code>chisq</code> for the optimal parameters <code>popt</code> when using the
<em>scaled</em> <code>sigma</code> equals unity. In other words, <code>sigma</code> is scaled to
match the sample variance of the residuals after the fit.
Mathematically,
<code>pcov(absolute_sigma=False) = pcov(absolute_sigma=True) * chisq(popt)/(M-N)</code>
check_finite : bool, optional
If True, check that the input arrays do not contain nans of infs,
and raise a ValueError if they do. Setting this parameter to
False may silently produce nonsensical results if the input arrays
do contain nans. Default is True.
bounds : 2-tuple of array_like, optional
Lower and upper bounds on parameters. Defaults to no bounds.
Each element of the tuple must be either an array with the length equal
to the number of parameters, or a scalar (in which case the bound is
taken to be the same for all parameters.) Use <code>np.inf</code> with an
appropriate sign to disable bounds on all or some parameters.</p>
<p>.. versionadded:: 0.17
method : {'lm', 'trf', 'dogbox'}, optional
Method to use for optimization.  See <code>least_squares</code> for more details.
Default is 'lm' for unconstrained problems and 'trf' if <code>bounds</code> are
provided. The method 'lm' won't work when the number of observations
is less than the number of variables, use 'trf' or 'dogbox' in this
case.</p>
<p>.. versionadded:: 0.17
jac : callable, string or None, optional
Function with signature <code>jac(x, ...)</code> which computes the Jacobian
matrix of the model function with respect to parameters as a dense
array_like structure. It will be scaled according to provided <code>sigma</code>.
If None (default), the Jacobian will be estimated numerically.
String keywords for 'trf' and 'dogbox' methods can be used to select
a finite difference scheme, see <code>least_squares</code>.</p>
<p>.. versionadded:: 0.18
kwargs
Keyword arguments passed to <code>leastsq</code> for <code>method='lm'</code> or
<code>least_squares</code> otherwise.</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>popt : array
Optimal values for the parameters so that the sum of the squared
residuals of <code>f(xdata, *popt) - ydata</code> is minimized
pcov : 2d array
The estimated covariance of popt. The diagonals provide the variance
of the parameter estimate. To compute one standard deviation errors
on the parameters use <code>perr = np.sqrt(np.diag(pcov))</code>.</p>
<p>How the <code>sigma</code> parameter affects the estimated covariance
depends on <code>absolute_sigma</code> argument, as described above.</p>
<p>If the Jacobian matrix at the solution doesn't have a full rank, then
'lm' method returns a matrix filled with <code>np.inf</code>, on the other hand
'trf'  and 'dogbox' methods use Moore-Penrose pseudoinverse to compute
the covariance matrix.</p>
<h2 id="raises_1">Raises<a class="headerlink" href="#raises_1" title="Permanent link">&para;</a></h2>
<p>ValueError
if either <code>ydata</code> or <code>xdata</code> contain NaNs, or if incompatible options
are used.</p>
<p>RuntimeError
if the least-squares minimization fails.</p>
<p>OptimizeWarning
if covariance of the parameters can not be estimated.</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>least_squares : Minimize the sum of squares of nonlinear functions.
scipy.stats.linregress : Calculate a linear least squares regression for
two sets of measurements.</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>With <code>method='lm'</code>, the algorithm uses the Levenberg-Marquardt algorithm
through <code>leastsq</code>. Note that this algorithm can only deal with
unconstrained problems.</p>
<p>Box constraints can be handled by methods 'trf' and 'dogbox'. Refer to
the docstring of <code>least_squares</code> for more information.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy.optimize import curve_fit</p>
<p>def func(x, a, b, c):
...     return a * np.exp(-b * x) + c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the data to be fit with some noise:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xdata = np.linspace(0, 4, 50)
y = func(xdata, 2.5, 1.3, 0.5)
np.random.seed(1729)
y_noise = 0.2 * np.random.normal(size=xdata.size)
ydata = y + y_noise
plt.plot(xdata, ydata, 'b-', label='data')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Fit for the parameters a, b, c of the function <code>func</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>popt, pcov = curve_fit(func, xdata, ydata)
popt
array([ 2.55423706,  1.35190947,  0.47450618])
plt.plot(xdata, func(xdata, *popt), 'r-',
...          label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constrain the optimization to the region of <code>0 &lt;= a &lt;= 3</code>,
<code>0 &lt;= b &lt;= 1</code> and <code>0 &lt;= c &lt;= 0.5</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>popt, pcov = curve_fit(func, xdata, ydata, bounds=(0, [3., 1., 0.5]))
popt
array([ 2.43708906,  1.        ,  0.35015434])
plt.plot(xdata, func(xdata, *popt), 'g--',
...          label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))</p>
<p>plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_2">Raises<a class="headerlink" href="#raises_2" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>N : int
Number of rows in the output.
M : int, optional
Number of columns in the output. If None, defaults to <code>N</code>.
k : int, optional
Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.
dtype : data-type, optional
Data-type of the returned array.
order : {'C', 'F'}, optional
Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<p>.. versionadded:: 1.14.0</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>I : ndarray of shape (N,M)
An array where all elements are equal to zero, except for the <code>k</code>-th
diagonal, whose values are equal to one.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.eye(2, dtype=int)
array([[1, 0],
[0, 1]])
np.eye(3, k=1)
array([[0.,  1.,  0.],
[0.,  0.,  1.],
[0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fixed_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Del2</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iteration</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a fixed point of the function.</p>
<p>Given a function of one or more variables and a starting point, find a
fixed-point of the function: i.e. where <code>func(x0) == x0</code>.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>func : function
Function to evaluate.
x0 : array_like
Fixed point of function.
args : tuple, optional
Extra arguments to <code>func</code>.
xtol : float, optional
Convergence tolerance, defaults to 1e-08.
maxiter : int, optional
Maximum number of iterations, defaults to 500.
method : {'del2', 'iteration'}, optional
Method of finding the fixed-point, defaults to 'del2'
which uses Steffensen's Method with Aitken's <code>Del^2</code>
convergence acceleration [1]_. The 'iteration' method simply iterates
the function until convergence is detected, without attempting to
accelerate the convergence.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] Burden, Faires, 'Numerical Analysis', 5th edition, pg. 80</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def func(x, c1, c2):
...    return np.sqrt(c1/(x+c2))
c1 = np.array([10,12.])
c2 = np.array([3, 5.])
optimize.fixed_point(func, [1.2, 1.3], args=(c1,c2))
array([ 1.4920333 ,  1.37228132])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">col_deriv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsfcn</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="o">)</span>
</code></pre></div>

<p>Find the roots of a function.</p>
<p>Return the roots of the (non-linear) equations defined by
<code>func(x) = 0</code> given a starting estimate.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>func : callable <code>f(x, *args)</code>
A function that takes at least one (possibly vector) argument,
and returns a value of the same length.
x0 : ndarray
The starting estimate for the roots of <code>func(x) = 0</code>.
args : tuple, optional
Any extra arguments to <code>func</code>.
fprime : callable <code>f(x, *args)</code>, optional
A function to compute the Jacobian of <code>func</code> with derivatives
across the rows. By default, the Jacobian will be estimated.
full_output : bool, optional
If True, return optional outputs.
col_deriv : bool, optional
Specify whether the Jacobian function computes derivatives down
the columns (faster, because there is no transpose operation).
xtol : float, optional
The calculation will terminate if the relative error between two
consecutive iterates is at most <code>xtol</code>.
maxfev : int, optional
The maximum number of calls to the function. If zero, then
<code>100*(N+1)</code> is the maximum where N is the number of elements
in <code>x0</code>.
band : tuple, optional
If set to a two-sequence containing the number of sub- and
super-diagonals within the band of the Jacobi matrix, the
Jacobi matrix is considered banded (only for <code>fprime=None</code>).
epsfcn : float, optional
A suitable step length for the forward-difference
approximation of the Jacobian (for <code>fprime=None</code>). If
<code>epsfcn</code> is less than the machine precision, it is assumed
that the relative errors in the functions are of the order of
the machine precision.
factor : float, optional
A parameter determining the initial step bound
(<code>factor * || diag * x||</code>).  Should be in the interval
<code>(0.1, 100)</code>.
diag : sequence, optional
N positive entries that serve as a scale factors for the
variables.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution (or the result of the last iteration for
an unsuccessful call).
infodict : dict
A dictionary of optional outputs with the keys:</p>
<p><code>nfev</code>
number of function calls
<code>njev</code>
number of Jacobian calls
<code>fvec</code>
function evaluated at the output
<code>fjac</code>
the orthogonal matrix, q, produced by the QR
factorization of the final approximate Jacobian
matrix, stored column wise
<code>r</code>
upper triangular matrix produced by QR factorization
of the same matrix
<code>qtf</code>
the vector <code>(transpose(q) * fvec)</code></p>
<p>ier : int
An integer flag.  Set to 1 if a solution was found, otherwise refer
to <code>mesg</code> for more information.
mesg : str
If no solution is found, <code>mesg</code> details the cause of failure.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See the <code>method=='hybr'</code> in particular.</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p><code>fsolve</code> is a wrapper around MINPACK's hybrd and hybrj algorithms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">greater</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &gt; x2) element-wise.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.
Typically of type bool, unless <code>dtype=object</code> is passed.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>greater_equal, less, less_equal, equal, not_equal</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.greater([4,2],[2,2])
array([ True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the inputs are ndarrays, then np.greater is equivalent to '&gt;'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([4,2])
b = np.array([2,2])
a &gt; b
array([ True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isscalar</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Returns True if the type of <code>element</code> is a scalar type.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>element : any
Input argument, can be of any type and shape.</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>val : bool
True if <code>element</code> is a scalar type, False if it is not.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>ndim : Get the number of dimensions of an array</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p>If you need a stricter way to identify a <em>numerical</em> scalar, use
<code>isinstance(x, numbers.Number)</code>, as that returns <code>False</code> for most
non-numerical elements such as strings.</p>
<p>In most cases <code>np.ndim(x) == 0</code> should be used instead of this function,
as that will also return true for 0d arrays. This is how numpy overloads
functions in the style of the <code>dx</code> arguments to <code>gradient</code> and the <code>bins</code>
argument to <code>histogram</code>. Some key differences:</p>
<p>+--------------------------------------+---------------+-------------------+
| x                                    |<code>isscalar(x)</code>|<code>np.ndim(x) == 0</code>|
+======================================+===============+===================+
| PEP 3141 numeric objects (including  | <code>True</code>      | <code>True</code>          |
| builtins)                            |               |                   |
+--------------------------------------+---------------+-------------------+
| builtin string and buffer objects    | <code>True</code>      | <code>True</code>          |
+--------------------------------------+---------------+-------------------+
| other builtin objects, like          | <code>False</code>     | <code>True</code>          |
| <code>pathlib.Path</code>, <code>Exception</code>,         |               |                   |
| the result of <code>re.compile</code>           |               |                   |
+--------------------------------------+---------------+-------------------+
| third-party objects like             | <code>False</code>     | <code>True</code>          |
| <code>matplotlib.figure.Figure</code>           |               |                   |
+--------------------------------------+---------------+-------------------+
| zero-dimensional numpy arrays        | <code>False</code>     | <code>True</code>          |
+--------------------------------------+---------------+-------------------+
| other numpy arrays                   | <code>False</code>     | <code>False</code>         |
+--------------------------------------+---------------+-------------------+
| <code>list</code>, <code>tuple</code>, and other sequence  | <code>False</code>     | <code>False</code>         |
| objects                              |               |                   |
+--------------------------------------+---------------+-------------------+</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.isscalar(3.1)
True
np.isscalar(np.array(3.1))
False
np.isscalar([3.1])
False
np.isscalar(False)
True
np.isscalar('numpy')
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>NumPy supports PEP 3141 numbers:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from fractions import Fraction
np.isscalar(Fraction(5, 17))
True
from numbers import Number
np.isscalar(Number())
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">issubdtype</span> <span class="o">:</span> <span class="n">arg1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arg2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>arg1, arg2 : dtype_like
dtype or string representing a typecode.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>out : bool</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>issubsctype, issubclass_
numpy.core.numerictypes : Overview of numpy type hierarchy.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.issubdtype('S1', np.string_)
True
np.issubdtype(np.float64, np.float32)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">least_squares</span> <span class="o">:</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">T2_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T3_point</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Trf</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dogbox</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_scale</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Jac</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">loss</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diff_step</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tr_solver</span><span class="o">:[`</span><span class="nc">Exact</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lsmr</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tr_options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac_sparsity</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_nfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Solve a nonlinear least-squares problem with bounds on the variables.</p>
<p>Given the residuals f(x) (an m-dimensional real function of n real
variables) and the loss function rho(s) (a scalar function), <code>least_squares</code>
finds a local minimum of the cost function F(x)::</p>
<p>minimize F(x) = 0.5 * sum(rho(f_i(x)**2), i = 0, ..., m - 1)
subject to lb &lt;= x &lt;= ub</p>
<p>The purpose of the loss function rho(s) is to reduce the influence of
outliers on the solution.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>fun : callable
Function which computes the vector of residuals, with the signature
<code>fun(x, *args, **kwargs)</code>, i.e., the minimization proceeds with
respect to its first argument. The argument <code>x</code> passed to this
function is an ndarray of shape (n,) (never a scalar, even for n=1).
It must return a 1-d array_like of shape (m,) or a scalar. If the
argument <code>x</code> is complex or the function <code>fun</code> returns complex
residuals, it must be wrapped in a real function of real arguments,
as shown at the end of the Examples section.
x0 : array_like with shape (n,) or float
Initial guess on independent variables. If float, it will be treated
as a 1-d array with one element.
jac : {'2-point', '3-point', 'cs', callable}, optional
Method of computing the Jacobian matrix (an m-by-n matrix, where
element (i, j) is the partial derivative of f[i] with respect to
x[j]). The keywords select a finite difference scheme for numerical
estimation. The scheme '3-point' is more accurate, but requires
twice as many operations as '2-point' (default). The scheme 'cs'
uses complex steps, and while potentially the most accurate, it is
applicable only when <code>fun</code> correctly handles complex inputs and
can be analytically continued to the complex plane. Method 'lm'
always uses the '2-point' scheme. If callable, it is used as
<code>jac(x, *args, **kwargs)</code> and should return a good approximation
(or the exact value) for the Jacobian as an array_like (np.atleast_2d
is applied), a sparse matrix or a <code>scipy.sparse.linalg.LinearOperator</code>.
bounds : 2-tuple of array_like, optional
Lower and upper bounds on independent variables. Defaults to no bounds.
Each array must match the size of <code>x0</code> or be a scalar, in the latter
case a bound will be the same for all variables. Use <code>np.inf</code> with
an appropriate sign to disable bounds on all or some variables.
method : {'trf', 'dogbox', 'lm'}, optional
Algorithm to perform minimization.</p>
<ul>
<li>'trf' : Trust Region Reflective algorithm, particularly suitable
for large sparse problems with bounds. Generally robust method.</li>
<li>'dogbox' : dogleg algorithm with rectangular trust regions,
typical use case is small problems with bounds. Not recommended
for problems with rank-deficient Jacobian.</li>
<li>'lm' : Levenberg-Marquardt algorithm as implemented in MINPACK.
Doesn't handle bounds and sparse Jacobians. Usually the most
efficient method for small unconstrained problems.</li>
</ul>
<p>Default is 'trf'. See Notes for more information.
ftol : float or None, optional
Tolerance for termination by the change of the cost function. Default
is 1e-8. The optimization process is stopped when  <code>dF &lt; ftol * F</code>,
and there was an adequate agreement between a local quadratic model and
the true model in the last step. If None, the termination by this
condition is disabled.
xtol : float or None, optional
Tolerance for termination by the change of the independent variables.
Default is 1e-8. The exact condition depends on the <code>method</code> used:</p>
<ul>
<li>For 'trf' and 'dogbox' : <code>norm(dx) &lt; xtol * (xtol + norm(x))</code></li>
<li>For 'lm' : <code>Delta &lt; xtol * norm(xs)</code>, where <code>Delta</code> is
a trust-region radius and <code>xs</code> is the value of <code>x</code>
scaled according to <code>x_scale</code> parameter (see below).</li>
</ul>
<p>If None, the termination by this condition is disabled.
gtol : float or None, optional
Tolerance for termination by the norm of the gradient. Default is 1e-8.
The exact condition depends on a <code>method</code> used:</p>
<ul>
<li>For 'trf' : <code>norm(g_scaled, ord=np.inf) &lt; gtol</code>, where
<code>g_scaled</code> is the value of the gradient scaled to account for
the presence of the bounds [STIR]_.</li>
<li>For 'dogbox' : <code>norm(g_free, ord=np.inf) &lt; gtol</code>, where
<code>g_free</code> is the gradient with respect to the variables which
are not in the optimal state on the boundary.</li>
<li>For 'lm' : the maximum absolute value of the cosine of angles
between columns of the Jacobian and the residual vector is less
than <code>gtol</code>, or the residual vector is zero.</li>
</ul>
<p>If None, the termination by this condition is disabled.
x_scale : array_like or 'jac', optional
Characteristic scale of each variable. Setting <code>x_scale</code> is equivalent
to reformulating the problem in scaled variables <code>xs = x / x_scale</code>.
An alternative view is that the size of a trust region along j-th
dimension is proportional to <code>x_scale[j]</code>. Improved convergence may
be achieved by setting <code>x_scale</code> such that a step of a given size
along any of the scaled variables has a similar effect on the cost
function. If set to 'jac', the scale is iteratively updated using the
inverse norms of the columns of the Jacobian matrix (as described in
[JJMore]_).
loss : str or callable, optional
Determines the loss function. The following keyword values are allowed:</p>
<ul>
<li>'linear' (default) : <code>rho(z) = z</code>. Gives a standard
least-squares problem.</li>
<li>'soft_l1' : <code>rho(z) = 2 * ((1 + z)**0.5 - 1)</code>. The smooth
approximation of l1 (absolute value) loss. Usually a good
choice for robust least squares.</li>
<li>'huber' : <code>rho(z) = z if z &lt;= 1 else 2*z**0.5 - 1</code>. Works
similarly to 'soft_l1'.</li>
<li>'cauchy' : <code>rho(z) = ln(1 + z)</code>. Severely weakens outliers
influence, but may cause difficulties in optimization process.</li>
<li>'arctan' : <code>rho(z) = arctan(z)</code>. Limits a maximum loss on
a single residual, has properties similar to 'cauchy'.</li>
</ul>
<p>If callable, it must take a 1-d ndarray <code>z=f**2</code> and return an
array_like with shape (3, m) where row 0 contains function values,
row 1 contains first derivatives and row 2 contains second
derivatives. Method 'lm' supports only 'linear' loss.
f_scale : float, optional
Value of soft margin between inlier and outlier residuals, default
is 1.0. The loss function is evaluated as follows
<code>rho_(f**2) = C**2 * rho(f**2 / C**2)</code>, where <code>C</code> is <code>f_scale</code>,
and <code>rho</code> is determined by <code>loss</code> parameter. This parameter has
no effect with <code>loss='linear'</code>, but for other <code>loss</code> values it is
of crucial importance.
max_nfev : None or int, optional
Maximum number of function evaluations before the termination.
If None (default), the value is chosen automatically:</p>
<ul>
<li>For 'trf' and 'dogbox' : 100 * n.</li>
<li>For 'lm' :  100 * n if <code>jac</code> is callable and 100 * n * (n + 1)
otherwise (because 'lm' counts function calls in Jacobian
estimation).</li>
</ul>
<p>diff_step : None or array_like, optional
Determines the relative step size for the finite difference
approximation of the Jacobian. The actual step is computed as
<code>x * diff_step</code>. If None (default), then <code>diff_step</code> is taken to be
a conventional 'optimal' power of machine epsilon for the finite
difference scheme used [NR]_.
tr_solver : {None, 'exact', 'lsmr'}, optional
Method for solving trust-region subproblems, relevant only for 'trf'
and 'dogbox' methods.</p>
<ul>
<li>'exact' is suitable for not very large problems with dense
Jacobian matrices. The computational complexity per iteration is
comparable to a singular value decomposition of the Jacobian
matrix.</li>
<li>'lsmr' is suitable for problems with sparse and large Jacobian
matrices. It uses the iterative procedure
<code>scipy.sparse.linalg.lsmr</code> for finding a solution of a linear
least-squares problem and only requires matrix-vector product
evaluations.</li>
</ul>
<p>If None (default) the solver is chosen based on the type of Jacobian
returned on the first iteration.
tr_options : dict, optional
Keyword options passed to trust-region solver.</p>
<ul>
<li><code>tr_solver='exact'</code>: <code>tr_options</code> are ignored.</li>
<li><code>tr_solver='lsmr'</code>: options for <code>scipy.sparse.linalg.lsmr</code>.
Additionally  <code>method='trf'</code> supports  'regularize' option
(bool, default is True) which adds a regularization term to the
normal equation, which improves convergence if the Jacobian is
rank-deficient [Byrd]_ (eq. 3.4).</li>
</ul>
<p>jac_sparsity : {None, array_like, sparse matrix}, optional
Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations [Curtis]_. A zero
entry means that a corresponding element in the Jacobian is identically
zero. If provided, forces the use of 'lsmr' trust-region solver.
If None (default) then dense differencing will be used. Has no effect
for 'lm' method.
verbose : {0, 1, 2}, optional
Level of algorithm's verbosity:</p>
<ul>
<li>0 (default) : work silently.</li>
<li>1 : display a termination report.</li>
<li>2 : display progress during iterations (not supported by 'lm'
method).</li>
</ul>
<p>args, kwargs : tuple and dict, optional
Additional arguments passed to <code>fun</code> and <code>jac</code>. Both empty by default.
The calling signature is <code>fun(x, *args, **kwargs)</code> and the same for
<code>jac</code>.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p><code>OptimizeResult</code> with the following fields defined:
x : ndarray, shape (n,)
Solution found.
cost : float
Value of the cost function at the solution.
fun : ndarray, shape (m,)
Vector of residuals at the solution.
jac : ndarray, sparse matrix or LinearOperator, shape (m, n)
Modified Jacobian matrix at the solution, in the sense that J^T J
is a Gauss-Newton approximation of the Hessian of the cost function.
The type is the same as the one used by the algorithm.
grad : ndarray, shape (m,)
Gradient of the cost function at the solution.
optimality : float
First-order optimality measure. In unconstrained problems, it is always
the uniform norm of the gradient. In constrained problems, it is the
quantity which was compared with <code>gtol</code> during iterations.
active_mask : ndarray of int, shape (n,)
Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<ul>
<li>0 : a constraint is not active.</li>
<li>-1 : a lower bound is active.</li>
<li>1 : an upper bound is active.</li>
</ul>
<p>Might be somewhat arbitrary for 'trf' method as it generates a sequence
of strictly feasible iterates and <code>active_mask</code> is determined within a
tolerance threshold.
nfev : int
Number of function evaluations done. Methods 'trf' and 'dogbox' do not
count function calls for numerical Jacobian approximation, as opposed
to 'lm' method.
njev : int or None
Number of Jacobian evaluations done. If numerical Jacobian
approximation is used in 'lm' method, it is set to None.
status : int
The reason for algorithm termination:</p>
<ul>
<li>-1 : improper input parameters status returned from MINPACK.</li>
<li>0 : the maximum number of function evaluations is exceeded.</li>
<li>1 : <code>gtol</code> termination condition is satisfied.</li>
<li>2 : <code>ftol</code> termination condition is satisfied.</li>
<li>3 : <code>xtol</code> termination condition is satisfied.</li>
<li>4 : Both <code>ftol</code> and <code>xtol</code> termination conditions are satisfied.</li>
</ul>
<p>message : str
Verbal description of the termination reason.
success : bool
True if one of the convergence criteria is satisfied (<code>status</code> &gt; 0).</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>leastsq : A legacy wrapper for the MINPACK implementation of the
Levenberg-Marquadt algorithm.
curve_fit : Least-squares minimization applied to a curve fitting problem.</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>Method 'lm' (Levenberg-Marquardt) calls a wrapper over least-squares
algorithms implemented in MINPACK (lmder, lmdif). It runs the
Levenberg-Marquardt algorithm formulated as a trust-region type algorithm.
The implementation is based on paper [JJMore]_, it is very robust and
efficient with a lot of smart tricks. It should be your first choice
for unconstrained problems. Note that it doesn't support bounds. Also
it doesn't work when m &lt; n.</p>
<p>Method 'trf' (Trust Region Reflective) is motivated by the process of
solving a system of equations, which constitute the first-order optimality
condition for a bound-constrained minimization problem as formulated in
[STIR]<em>. The algorithm iteratively solves trust-region subproblems
augmented by a special diagonal quadratic term and with trust-region shape
determined by the distance from the bounds and the direction of the
gradient. This enhancements help to avoid making steps directly into bounds
and efficiently explore the whole space of variables. To further improve
convergence, the algorithm considers search directions reflected from the
bounds. To obey theoretical requirements, the algorithm keeps iterates
strictly feasible. With dense Jacobians trust-region subproblems are
solved by an exact method very similar to the one described in [JJMore]</em>
(and implemented in MINPACK). The difference from the MINPACK
implementation is that a singular value decomposition of a Jacobian
matrix is done once per iteration, instead of a QR decomposition and series
of Givens rotation eliminations. For large sparse Jacobians a 2-d subspace
approach of solving trust-region subproblems is used [STIR]<em>, [Byrd]</em>.
The subspace is spanned by a scaled gradient and an approximate
Gauss-Newton solution delivered by <code>scipy.sparse.linalg.lsmr</code>. When no
constraints are imposed the algorithm is very similar to MINPACK and has
generally comparable performance. The algorithm works quite robust in
unbounded and bounded problems, thus it is chosen as a default algorithm.</p>
<p>Method 'dogbox' operates in a trust-region framework, but considers
rectangular trust regions as opposed to conventional ellipsoids [Voglis]<em>.
The intersection of a current trust region and initial bounds is again
rectangular, so on each iteration a quadratic minimization problem subject
to bound constraints is solved approximately by Powell's dogleg method
[NumOpt]</em>. The required Gauss-Newton step can be computed exactly for
dense Jacobians or approximately by <code>scipy.sparse.linalg.lsmr</code> for large
sparse Jacobians. The algorithm is likely to exhibit slow convergence when
the rank of Jacobian is less than the number of variables. The algorithm
often outperforms 'trf' in bounded problems with a small number of
variables.</p>
<p>Robust loss functions are implemented as described in [BA]_. The idea
is to modify a residual vector and a Jacobian matrix on each iteration
such that computed gradient and Gauss-Newton Hessian approximation match
the true gradient and Hessian approximation of the cost function. Then
the algorithm proceeds in a normal way, i.e. robust loss functions are
implemented as a simple wrapper over standard least-squares algorithms.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [STIR] M. A. Branch, T. F. Coleman, and Y. Li, 'A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems,' SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.
.. [NR] William H. Press et. al., 'Numerical Recipes. The Art of Scientific
Computing. 3rd edition', Sec. 5.7.
.. [Byrd] R. H. Byrd, R. B. Schnabel and G. A. Shultz, 'Approximate
solution of the trust region problem by minimization over
two-dimensional subspaces', Math. Programming, 40, pp. 247-263,
1988.
.. [Curtis] A. Curtis, M. J. D. Powell, and J. Reid, 'On the estimation of
sparse Jacobian matrices', Journal of the Institute of
Mathematics and its Applications, 13, pp. 117-120, 1974.
.. [JJMore] J. J. More, 'The Levenberg-Marquardt Algorithm: Implementation
and Theory,' Numerical Analysis, ed. G. A. Watson, Lecture
Notes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.
.. [Voglis] C. Voglis and I. E. Lagaris, 'A Rectangular Trust Region
Dogleg Approach for Unconstrained and Bound Constrained
Nonlinear Optimization', WSEAS International Conference on
Applied Mathematics, Corfu, Greece, 2004.
.. [NumOpt] J. Nocedal and S. J. Wright, 'Numerical optimization,
2nd edition', Chapter 4.
.. [BA] B. Triggs et. al., 'Bundle Adjustment - A Modern Synthesis',
Proceedings of the International Workshop on Vision Algorithms:
Theory and Practice, pp. 298-372, 1999.</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<p>In this example we find a minimum of the Rosenbrock function without bounds
on independent variables.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun_rosenbrock(x):
...     return np.array([10 * (x[1] - x[0]**2), (1 - x[0])])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that we only provide the vector of the residuals. The algorithm
constructs the cost function as a sum of squares of the residuals, which
gives the Rosenbrock function. The exact minimum is at <code>x = [1.0, 1.0]</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import least_squares
x0_rosenbrock = np.array([2, 2])
res_1 = least_squares(fun_rosenbrock, x0_rosenbrock)
res_1.x
array([ 1.,  1.])
res_1.cost
9.8669242910846867e-30
res_1.optimality
8.8928864934219529e-14</p>
</blockquote>
</blockquote>
</blockquote>
<p>We now constrain the variables, in such a way that the previous solution
becomes infeasible. Specifically, we require that <code>x[1] &gt;= 1.5</code>, and
<code>x[0]</code> left unconstrained. To this end, we specify the <code>bounds</code> parameter
to <code>least_squares</code> in the form <code>bounds=([-np.inf, 1.5], np.inf)</code>.</p>
<p>We also provide the analytic Jacobian:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def jac_rosenbrock(x):
...     return np.array([
...         [-20 * x[0], 10],
...         [-1, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Putting this all together, we see that the new solution lies on the bound:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_2 = least_squares(fun_rosenbrock, x0_rosenbrock, jac_rosenbrock,
...                       bounds=([-np.inf, 1.5], np.inf))
res_2.x
array([ 1.22437075,  1.5       ])
res_2.cost
0.025213093946805685
res_2.optimality
1.5885401433157753e-07</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now we solve a system of equations (i.e., the cost function should be zero
at a minimum) for a Broyden tridiagonal vector-valued function of 100000
variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun_broyden(x):
...     f = (3 - x) * x + 1
...     f[1:] -= x[:-1]
...     f[:-1] -= 2 * x[1:]
...     return f</p>
</blockquote>
</blockquote>
</blockquote>
<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to
estimate it by finite differences and provide the sparsity structure of
Jacobian to significantly speed up this process.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import lil_matrix
def sparsity_broyden(n):
...     sparsity = lil_matrix((n, n), dtype=int)
...     i = np.arange(n)
...     sparsity[i, i] = 1
...     i = np.arange(1, n)
...     sparsity[i, i - 1] = 1
...     i = np.arange(n - 1)
...     sparsity[i, i + 1] = 1
...     return sparsity
...
n = 100000
x0_broyden = -np.ones(n)
...
res_3 = least_squares(fun_broyden, x0_broyden,
...                       jac_sparsity=sparsity_broyden(n))
res_3.cost
4.5687069299604613e-23
res_3.optimality
1.1650454296851518e-11</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let's also solve a curve fitting problem using robust loss function to
take care of outliers in the data. Define the model function as
<code>y = a + b * exp(c * t)</code>, where t is a predictor variable, y is an
observation and a, b, c are parameters to estimate.</p>
<p>First, define the function which generates the data with noise and
outliers, define the model parameters, and generate data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def gen_data(t, a, b, c, noise=0, n_outliers=0, random_state=0):
...     y = a + b * np.exp(t * c)
...
...     rnd = np.random.RandomState(random_state)
...     error = noise * rnd.randn(t.size)
...     outliers = rnd.randint(0, t.size, n_outliers)
...     error[outliers] *= 10
...
...     return y + error
...
a = 0.5
b = 2.0
c = -1
t_min = 0
t_max = 10
n_points = 15
...
t_train = np.linspace(t_min, t_max, n_points)
y_train = gen_data(t_train, a, b, c, noise=0.1, n_outliers=3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define function for computing residuals and initial estimate of
parameters.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun(x, t, y):
...     return x[0] + x[1] * np.exp(x[2] * t) - y
...
x0 = np.array([1.0, 1.0, 0.0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute a standard least-squares solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_lsq = least_squares(fun, x0, args=(t_train, y_train))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute two solutions with two different robust loss functions. The
parameter <code>f_scale</code> is set to 0.1, meaning that inlier residuals should
not significantly exceed 0.1 (the noise level used).</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_soft_l1 = least_squares(fun, x0, loss='soft_l1', f_scale=0.1,
...                             args=(t_train, y_train))
res_log = least_squares(fun, x0, loss='cauchy', f_scale=0.1,
...                         args=(t_train, y_train))</p>
</blockquote>
</blockquote>
</blockquote>
<p>And finally plot all the curves. We see that by selecting an appropriate
<code>loss</code>  we can get estimates close to optimal even in the presence of
strong outliers. But keep in mind that generally it is recommended to try
'soft_l1' or 'huber' losses first (if at all necessary) as the other two
options may cause difficulties in optimization process.</p>
<blockquote>
<blockquote>
<blockquote>
<p>t_test = np.linspace(t_min, t_max, n_points * 10)
y_true = gen_data(t_test, a, b, c)
y_lsq = gen_data(t_test, <em>res_lsq.x)
y_soft_l1 = gen_data(t_test, </em>res_soft_l1.x)
y_log = gen_data(t_test, *res_log.x)
...
import matplotlib.pyplot as plt
plt.plot(t_train, y_train, 'o')
plt.plot(t_test, y_true, 'k', linewidth=2, label='true')
plt.plot(t_test, y_lsq, label='linear loss')
plt.plot(t_test, y_soft_l1, label='soft_l1 loss')
plt.plot(t_test, y_log, label='cauchy loss')
plt.xlabel('t')
plt.ylabel('y')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the next example, we show how complex-valued residual functions of
complex variables can be optimized with <code>least_squares()</code>. Consider the
following function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(z):
...     return z - (0.5 + 0.5j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We wrap it into a function of real variables that returns real residuals
by simply handling the real and imaginary parts as independent variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f_wrap(x):
...     fx = f(x[0] + 1j*x[1])
...     return np.array([fx.real, fx.imag])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thus, instead of the original m-dimensional complex function of n complex
variables we optimize a 2m-dimensional real function of 2n real variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import least_squares
res_wrapped = least_squares(f_wrap, (0.1, 0.1), bounds=([0, 0], [1, 1]))
z = res_wrapped.x[0] + res_wrapped.x[1]*1j
z
(0.49999999999925893+0.49999999999925893j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leastsq</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dfun</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">col_deriv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsfcn</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Minimize the sum of squares of a set of equations.</p>
<p>::</p>
<p>x = arg min(sum(func(y)**2,axis=0))
y</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>func : callable
should take at least one (possibly length N vector) argument and
returns M floating point numbers. It must not return NaNs or
fitting might fail.
x0 : ndarray
The starting estimate for the minimization.
args : tuple, optional
Any extra arguments to func are placed in this tuple.
Dfun : callable, optional
A function or method to compute the Jacobian of func with derivatives
across the rows. If this is None, the Jacobian will be estimated.
full_output : bool, optional
non-zero to return all optional outputs.
col_deriv : bool, optional
non-zero to specify that the Jacobian function computes derivatives
down the columns (faster, because there is no transpose operation).
ftol : float, optional
Relative error desired in the sum of squares.
xtol : float, optional
Relative error desired in the approximate solution.
gtol : float, optional
Orthogonality desired between the function vector and the columns of
the Jacobian.
maxfev : int, optional
The maximum number of calls to the function. If <code>Dfun</code> is provided
then the default <code>maxfev</code> is 100<em>(N+1) where N is the number of elements
in x0, otherwise the default <code>maxfev</code> is 200</em>(N+1).
epsfcn : float, optional
A variable used in determining a suitable step length for the forward-
difference approximation of the Jacobian (for Dfun=None).
Normally the actual step length will be sqrt(epsfcn)*x
If epsfcn is less than the machine precision, it is assumed that the
relative errors are of the order of the machine precision.
factor : float, optional
A parameter determining the initial step bound
(<code>factor * || diag * x||</code>). Should be in interval <code>(0.1, 100)</code>.
diag : sequence, optional
N positive entries that serve as a scale factors for the variables.</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution (or the result of the last iteration for an unsuccessful
call).
cov_x : ndarray
The inverse of the Hessian. <code>fjac</code> and <code>ipvt</code> are used to construct an
estimate of the Hessian. A value of None indicates a singular matrix,
which means the curvature in parameters <code>x</code> is numerically flat. To
obtain the covariance matrix of the parameters <code>x</code>, <code>cov_x</code> must be
multiplied by the variance of the residuals -- see curve_fit.
infodict : dict
a dictionary of optional outputs with the keys:</p>
<p><code>nfev</code>
The number of function calls
<code>fvec</code>
The function evaluated at the output
<code>fjac</code>
A permutation of the R matrix of a QR
factorization of the final approximate
Jacobian matrix, stored column wise.
Together with ipvt, the covariance of the
estimate can be approximated.
<code>ipvt</code>
An integer array of length N which defines
a permutation matrix, p, such that
fjac<em>p = q</em>r, where r is upper triangular
with diagonal elements of nonincreasing
magnitude. Column j of p is column ipvt(j)
of the identity matrix.
<code>qtf</code>
The vector (transpose(q) * fvec).</p>
<p>mesg : str
A string message giving information about the cause of failure.
ier : int
An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
found.  Otherwise, the solution was not found. In either case, the
optional output variable 'mesg' gives more information.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>least_squares : Newer interface to solve nonlinear least-squares problems
with bounds on the variables. See <code>method=='lm'</code> in particular.</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>'leastsq' is a wrapper around MINPACK's lmdif and lmder algorithms.</p>
<p>cov_x is a Jacobian approximation to the Hessian of the least squares
objective function.
This approximation assumes that the objective function is based on the
difference between some observed target data (ydata) and a (non-linear)
function of the parameters <code>f(xdata, params)</code> ::</p>
<p>func(params) = ydata - f(xdata, params)</p>
<p>so that the objective function is ::</p>
<p>min   sum((ydata - f(xdata, params))**2, axis=0)
params</p>
<p>The solution, <code>x</code>, is always a 1D array, regardless of the shape of <code>x0</code>,
or whether <code>x0</code> is a scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">make_strictly_feasible</span> <span class="o">:</span> <span class="o">?</span><span class="n">rstep</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">lb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ub</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift a point to the interior of a feasible region.</p>
<p>Each element of the returned vector is at least at a relative distance
<code>rstep</code> from the closest bound. If <code>rstep=0</code> then <code>np.nextafter</code> is used.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prepare_bounds</span> <span class="o">:</span> <span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of array elements over a given axis.</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.
dtype : dtype, optional
The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <code>a</code> is used by
default unless <code>a</code> has an integer dtype of less precision than the
default platform integer.  In that case, if <code>a</code> is signed then the
platform integer is used while if <code>a</code> is unsigned then an unsigned
integer of the same precision as the platform integer is used.
out : ndarray, optional
Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.
keepdims : bool, optional
If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>prod</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.
initial : scalar, optional
The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
<p>where : array_like of bool, optional
Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>product_along_axis : ndarray, see <code>dtype</code> parameter above.
An array shaped as <code>a</code> but with the specified axis removed.
Returns a reference to <code>out</code> if specified.</p>
<h2 id="see-also_20">See Also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>ndarray.prod : equivalent method
ufuncs-output-type</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([536870910, 536870910, 536870910, 536870910])
np.prod(x)
16 # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>The product of an empty array is the neutral element 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<p>By default, calculate the product of all elements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1.,2.])
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even when the input array is two-dimensional:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]])
24.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>But we can also specify the axis over which to multiply:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Or select specific elements to include:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1., np.nan, 3.], where=[True, False, True])
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the type of <code>x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.uint8)
np.prod(x).dtype == np.uint
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.int8)
np.prod(x).dtype == int
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can also start the product with a value other than one:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1, 2], initial=5)
10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">array</span>
</code></pre></div>

<p>Return the shape of an array.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>shape : tuple of ints
The elements of the shape tuple give the lengths of the
corresponding array dimensions.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>alen
ndarray.shape : Equivalent array method.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.shape(np.eye(3))
(3, 3)
np.shape([[1, 2]])
(1, 2)
np.shape([0])
(1,)
np.shape(0)
()</p>
<p>a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
np.shape(a)
(2,)
a.shape
(2,)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A triangular matrix
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>a x = b</code>
lower : bool, optional
Use only data contained in the lower triangle of <code>a</code>.
Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and
will not be referenced.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</p>
<h2 id="raises_3">Raises<a class="headerlink" href="#raises_3" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.9.0</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<p>Solve the lower triangular system a x = b, where::</p>
<p>[3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
[1  0  1  0]       [4]
[1  1  1  1]       [2]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_triangular
a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
b = np.array([4, 2, 4, 2])
x = solve_triangular(a, b, lower=True)
x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
full_matrices : bool, optional
If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
<code>K = min(M, N)</code>.
compute_uv : bool, optional
Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
Whether to use the more efficient divide-and-conquer approach
(<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Unitary matrix having left singular vectors as columns.
Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.
s : ndarray
The singular values, sorted in non-increasing order.
Of shape (K,), with <code>K = min(M, N)</code>.
Vh : ndarray
Unitary matrix having right singular vectors as rows.
Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h2 id="raises_4">Raises<a class="headerlink" href="#raises_4" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="see-also_22">See also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
m, n = 9, 6
a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
U, s, Vh = linalg.svd(a)
U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Reconstruct the original matrix from the decomposition:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sigma = np.zeros((m, n))
for i in range(min(m, n)):
...     sigma[i, i] = s[i]
a1 = np.dot(U, np.dot(sigma, Vh))
np.allclose(a, a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>U, s, Vh = linalg.svd(a, full_matrices=False)
U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
S = np.diag(s)
np.allclose(a, np.dot(U, np.dot(S, Vh)))
True</p>
<p>s2 = linalg.svd(a, compute_uv=False)
np.allclose(s, s2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">take</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_Ni_Nj_Nk_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Raise</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Clip</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Take elements from an array along an axis.</p>
<p>When axis is not None, this function does the same thing as 'fancy'
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code>np.take(arr, indices, axis=3)</code> is equivalent to
<code>arr[:,:,:,indices,...]</code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <code>ndindex</code>, which sets each of <code>ii</code>, <code>jj</code>, and <code>kk</code> to a tuple of
indices::</p>
<p>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
Nj = indices.shape
for ii in ndindex(Ni):
for jj in ndindex(Nj):
for kk in ndindex(Nk):
out[ii + jj + kk] = a[ii + (indices[jj],) + kk]</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>a : array_like (Ni..., M, Nk...)
The source array.
indices : array_like (Nj...)
The indices of the values to extract.</p>
<p>.. versionadded:: 1.8.0</p>
<p>Also allow scalars for indices.
axis : int, optional
The axis over which to select values. By default, the flattened
input array is used.
out : ndarray, optional (Ni..., Nj..., Nk...)
If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype. Note that <code>out</code> is always
buffered if <code>mode='raise'</code>; use other modes for better performance.
mode : {'raise', 'wrap', 'clip'}, optional
Specifies how out-of-bounds indices will behave.</p>
<ul>
<li>'raise' -- raise an error (default)</li>
<li>'wrap' -- wrap around</li>
<li>'clip' -- clip to the range</li>
</ul>
<p>'clip' mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>out : ndarray (Ni..., Nj..., Nk...)
The returned array has the same type as <code>a</code>.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>By eliminating the inner loop in the description above, and using <code>s_</code> to
build simple slice objects, <code>take</code> can be expressed  in terms of applying
fancy indexing to each 1-d slice::</p>
<p>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
for kk in ndindex(Nj):
out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]</p>
<p>For this reason, it is equivalent to (but faster than) the following use
of <code>apply_along_axis</code>::</p>
<p>out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = [4, 3, 5, 7, 6, 8]
indices = [0, 1, 4]
np.take(a, indices)
array([4, 3, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example if <code>a</code> is an ndarray, 'fancy' indexing can be used.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array(a)
a[indices]
array([4, 3, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>indices</code> is not one dimensional, the output also has these dimensions.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.take(a, [[0, 1], [2, 3]])
array([[4, 3],
[5, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Permute the dimensions of an array.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.
axes : list of ints, optional
By default, reverse the dimensions, otherwise permute the axes
according to the values given.</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>p : ndarray
<code>a</code> with its axes permuted.  A view is returned whenever
possible.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>moveaxis
argsort</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>Use <code>transpose(a, argsort(axes))</code> to invert the transposition of tensors
when using the <code>axes</code> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(4).reshape((2,2))
x
array([[0, 1],
[2, 3]])</p>
<p>np.transpose(x)
array([[0, 2],
[1, 3]])</p>
<p>x = np.ones((1, 2, 3))
np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upper triangle of an array.</p>
<p>Return a copy of a matrix with the elements below the <code>k</code>-th diagonal
zeroed.</p>
<p>Please refer to the documentation for <code>tril</code> for further details.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>tril : lower triangle of an array</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
[ 4,  5,  6],
[ 0,  8,  9],
[ 0,  0, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">where</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">condition</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>where(condition, [x, y])</p>
<p>Return elements chosen from <code>x</code> or <code>y</code> depending on <code>condition</code>.</p>
<p>.. note::
When only <code>condition</code> is provided, this function is a shorthand for
<code>np.asarray(condition).nonzero()</code>. Using <code>nonzero</code> directly should be
preferred, as it behaves correctly for subclasses. The rest of this
documentation covers only the case where all three arguments are
provided.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>condition : array_like, bool
Where True, yield <code>x</code>, otherwise yield <code>y</code>.
x, y : array_like
Values from which to choose. <code>x</code>, <code>y</code> and <code>condition</code> need to be
broadcastable to some shape.</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array with elements from <code>x</code> where <code>condition</code> is True, and elements
from <code>y</code> elsewhere.</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>choose
nonzero : The function that is called when x and y are omitted</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>If all the arrays are 1-D, <code>where</code> is equivalent to::</p>
<p>[xv if c else yv
for c, xv, yv in zip(condition, x, y)]</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(10)
a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.where(a &lt; 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This can be used on multidimensional arrays too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The shapes of x, y, and the condition are broadcast together:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x, y = np.ogrid[:3, :4]
np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
[10, 11,  1,  1],
[10, 11, 12,  2]])</p>
<p>a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
np.where(a &lt; 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
[ 0,  2, -1],
[ 0,  3, -1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Minpack2</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">ModuleTNC</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Nonlin</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Anderson</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Anderson</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Anderson</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using (extended) Anderson mixing.</p>
<p>The Jacobian is formed by for a 'best' solution in the space
spanned by last <code>M</code> vectors. As a result, only a MxM matrix
inversions and MxN multiplications are required. [Ey]_</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
M : float, optional
Number of previous vectors to retain. Defaults to 5.
w0 : float, optional
Regularization parameter for numerical stability.
Compared to unity, good values of the order of 0.01.
%(params_extra)s</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='anderson'</code> in particular.</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [Ey] V. Eyert, J. Comp. Phys., 124, 271 (1996).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">BroydenFirst</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BroydenFirst</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BroydenFirst</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's first Jacobian approximation.</p>
<p>This method is also known as \'Broyden's good method\'.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
%(broyden_params)s
%(params_extra)s</p>
<h2 id="see-also_29">See Also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden1'</code> in particular.</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) dx^\dagger H / ( dx^\dagger H df)</p>
<p>which corresponds to Broyden's first Jacobian update</p>
<p>.. math:: J_+ = J + (df - J dx) dx^\dagger / dx^\dagger dx</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
\'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations\'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">BroydenSecond</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BroydenSecond</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BroydenSecond</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's second Jacobian approximation.</p>
<p>This method is also known as 'Broyden's bad method'.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
%(broyden_params)s
%(params_extra)s</p>
<h2 id="see-also_30">See Also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden2'</code> in particular.</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) df^\dagger / ( df^\dagger df)</p>
<p>corresponding to Broyden's second method.</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">DiagBroyden</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">DiagBroyden</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">DiagBroyden</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using diagonal Broyden Jacobian approximation.</p>
<p>The Jacobian approximation is derived from previous iterations, by
retaining only the diagonal of Broyden matrices.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
%(params_extra)s</p>
<h2 id="see-also_31">See Also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='diagbroyden'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ExcitingMixing</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ExcitingMixing</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ExcitingMixing</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alphamax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a tuned diagonal Jacobian approximation.</p>
<p>The Jacobian matrix is diagonal and is tuned on each iteration.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="see-also_32">See Also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='excitingmixing'</code> in particular.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
alpha : float, optional
Initial Jacobian approximation is (-1/alpha).
alphamax : float, optional
The entries of the diagonal Jacobian are kept in the range
<code>[alpha, alphamax]</code>.
%(params_extra)s</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">GenericBroyden</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">GenericBroyden</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">GenericBroyden</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for Jacobians or Jacobian approximations.</p>
<p>The optional methods come useful when implementing trust region
etc.  algorithms that often require evaluating transposes of the
Jacobian.</p>
<h2 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h2>
<p>solve
Returns J^-1 * v
update
Updates Jacobian to point <code>x</code> (where the function has residual <code>Fx</code>)</p>
<p>matvec : optional
Returns J * v
rmatvec : optional
Returns A^H * v
rsolve : optional
Returns A^-H * v
matmat : optional
Returns A * V, where V is a dense matrix with dimensions (N,K).
todense : optional
Form the dense Jacobian matrix. Necessary for dense trust region
algorithms, and useful for testing.</p>
<h2 id="attributes_3">Attributes<a class="headerlink" href="#attributes_3" title="Permanent link">&para;</a></h2>
<p>shape
Matrix dimensions (M, N)
dtype
Data type of the matrix.
func : callable, optional
Function the Jacobian corresponds to</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">InverseJacobian</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">InverseJacobian</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">InverseJacobian</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Jacobian</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Jacobian</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Jacobian</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Common interface for Jacobians or Jacobian approximations.</p>
<p>The optional methods come useful when implementing trust region
etc.  algorithms that often require evaluating transposes of the
Jacobian.</p>
<h2 id="methods_1">Methods<a class="headerlink" href="#methods_1" title="Permanent link">&para;</a></h2>
<p>solve
Returns J^-1 * v
update
Updates Jacobian to point <code>x</code> (where the function has residual <code>Fx</code>)</p>
<p>matvec : optional
Returns J * v
rmatvec : optional
Returns A^H * v
rsolve : optional
Returns A^-H * v
matmat : optional
Returns A * V, where V is a dense matrix with dimensions (N,K).
todense : optional
Form the dense Jacobian matrix. Necessary for dense trust region
algorithms, and useful for testing.</p>
<h2 id="attributes_4">Attributes<a class="headerlink" href="#attributes_4" title="Permanent link">&para;</a></h2>
<p>shape
Matrix dimensions (M, N)
dtype
Data type of the matrix.
func : callable, optional
Function the Jacobian corresponds to</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Attribute shape: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute shape: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dtype: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dtype: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dtype_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute func: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">func</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute func: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">func_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">KrylovJacobian</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">KrylovJacobian</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">KrylovJacobian</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">rdiff</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Cgs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lgmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bicgstab</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Minres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_M</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Krylov approximation for inverse Jacobian.</p>
<p>This method is suitable for solving large-scale problems.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
rdiff : float, optional
Relative step size to use in numerical differentiation.
method : {'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function
Krylov method to use to approximate the Jacobian.
Can be a string, or a function implementing the same interface as
the iterative solvers in <code>scipy.sparse.linalg</code>.</p>
<p>The default is <code>scipy.sparse.linalg.lgmres</code>.
inner_M : LinearOperator or InverseJacobian
Preconditioner for the inner Krylov iteration.
Note that you can use also inverse Jacobians as (adaptive)
preconditioners. For example,</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
from scipy.optimize.nonlin import InverseJacobian
jac = BroydenFirst()
kjac = KrylovJacobian(inner_M=InverseJacobian(jac))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the preconditioner has a method named 'update', it will be called
as <code>update(x, f)</code> after each nonlinear step, with <code>x</code> giving
the current point, and <code>f</code> the current function value.
inner_tol, inner_maxiter, ...
Parameters to pass on to the \'inner\' Krylov solver.
See <code>scipy.sparse.linalg.gmres</code> for details.
outer_k : int, optional
Size of the subspace kept across LGMRES nonlinear iterations.
See <code>scipy.sparse.linalg.lgmres</code> for details.
%(params_extra)s</p>
<h2 id="see-also_33">See Also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='krylov'</code> in particular.
scipy.sparse.linalg.gmres
scipy.sparse.linalg.lgmres</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>This function implements a Newton-Krylov solver. The basic idea is
to compute the inverse of the Jacobian with an iterative Krylov
method. These methods require only evaluating the Jacobian-vector
products, which are conveniently approximated by a finite difference:</p>
<p>.. math:: J v \approx (f(x + \omega*v/|v|) - f(x)) / \omega</p>
<p>Due to the use of iterative matrix inverses, these methods can
deal with large nonlinear problems.</p>
<p>SciPy's <code>scipy.sparse.linalg</code> module offers a selection of Krylov
solvers to choose from. The default here is <code>lgmres</code>, which is a
variant of restarted GMRES iteration that reuses some of the
information obtained in the previous Newton steps to invert
Jacobians in subsequent steps.</p>
<p>For a review on Newton-Krylov methods, see for example [1]<em>,
and for the LGMRES sparse inverse method, see [2]</em>.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2004).
:doi:<code>10.1016/j.jcp.2003.08.010</code>
.. [2] A.H. Baker and E.R. Jessup and T. Manteuffel,
SIAM J. Matrix Anal. Appl. 26, 962 (2005).
:doi:<code>10.1137/S0895479803422014</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rhs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LinearMixing</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearMixing</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearMixing</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a scalar Jacobian approximation.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>%(params_basic)s
alpha : float, optional
The Jacobian approximation is (-1/alpha).
%(params_extra)s</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='linearmixing'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">aspreconditioner</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">setup</span> <span class="o">:</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">todense</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LowRankMatrix</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LowRankMatrix</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LowRankMatrix</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dtype</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>A matrix represented as</p>
<p>.. math:: \alpha I + \sum_{n=0}^{n=M} c_n d_n^\dagger</p>
<p>However, if the rank of the matrix reaches the dimension of the vectors,
full matrix representation will be used thereon.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">append</span> <span class="o">:</span> <span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">collapse</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Collapse the low-rank matrix to a full-rank one.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matvec</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate w = M v</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">restart_reduce</span> <span class="o">:</span> <span class="n">rank</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reduce the rank of the matrix by dropping all vectors.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rmatvec</span> <span class="o">:</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate w = M^H v</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate w = M^-H v</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">simple_reduce</span> <span class="o">:</span> <span class="n">rank</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reduce the rank of the matrix by dropping oldest vectors.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate w = M^-1 v</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd_reduce</span> <span class="o">:</span> <span class="o">?</span><span class="n">to_retain</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">max_rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reduce the rank of the matrix by retaining some SVD components.</p>
<p>This corresponds to the 'Broyden Rank Reduction Inverse'
algorithm described in [1]_.</p>
<p>Note that the SVD decomposition can be done by solving only a
problem whose size is the effective rank of this matrix, which
is viable even for large problems.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>max_rank : int
Maximum rank of this matrix after reduction.
to_retain : int, optional
Number of SVD components to retain when reduction is done
(ie. rank &gt; max_rank). Default is <code>max_rank - 2</code>.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">NoConvergence</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">NoConvergence</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">NoConvergence</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">TerminationCondition</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">TerminationCondition</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">TerminationCondition</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Termination condition for an iteration. It is terminated if</p>
<ul>
<li>|F| &lt; f_rtol*|F_0|, AND</li>
<li>|F| &lt; f_tol</li>
</ul>
<p>AND</p>
<ul>
<li>|dx| &lt; x_rtol*|x|, AND</li>
<li>|dx| &lt; x_tol</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">anderson</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using (extended) Anderson mixing.</p>
<p>The Jacobian is formed by for a 'best' solution in the space
spanned by last <code>M</code> vectors. As a result, only a MxM matrix
inversions and MxN multiplications are required. [Ey]_</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
M : float, optional
Number of previous vectors to retain. Defaults to 5.
w0 : float, optional
Regularization parameter for numerical stability.
Compared to unity, good values of the order of 0.01.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_5">Raises<a class="headerlink" href="#raises_5" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='anderson'</code> in particular.</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [Ey] V. Eyert, J. Comp. Phys., 124, 271 (1996).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_36">See Also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asjacobian</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert given object to one suitable for use as a Jacobian.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">broyden1</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's first Jacobian approximation.</p>
<p>This method is also known as \'Broyden's good method\'.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is <code>(-1/alpha)</code>.
reduction_method : str or tuple, optional
Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form <code>(method, param1, param2, ...)</code>
that gives the name of the method and values for additional parameters.</p>
<p>Methods available:</p>
<ul>
<li><code>restart</code>: drop all matrix columns. Has no extra parameters.</li>
<li><code>simple</code>: drop oldest matrix column. Has no extra parameters.</li>
<li><code>svd</code>: keep only the most significant SVD components.
Takes an extra parameter, <code>to_retain</code>, which determines the
number of SVD components to retain when rank reduction is done.
Default is <code>max_rank - 2</code>.</li>
</ul>
<p>max_rank : int, optional
Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_6">Raises<a class="headerlink" href="#raises_6" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_37">See Also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden1'</code> in particular.</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) dx^\dagger H / ( dx^\dagger H df)</p>
<p>which corresponds to Broyden's first Jacobian update</p>
<p>.. math:: J_+ = J + (df - J dx) dx^\dagger / dx^\dagger dx</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
\'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations\'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">broyden2</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's second Jacobian approximation.</p>
<p>This method is also known as 'Broyden's bad method'.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is <code>(-1/alpha)</code>.
reduction_method : str or tuple, optional
Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form <code>(method, param1, param2, ...)</code>
that gives the name of the method and values for additional parameters.</p>
<p>Methods available:</p>
<ul>
<li><code>restart</code>: drop all matrix columns. Has no extra parameters.</li>
<li><code>simple</code>: drop oldest matrix column. Has no extra parameters.</li>
<li><code>svd</code>: keep only the most significant SVD components.
Takes an extra parameter, <code>to_retain</code>, which determines the
number of SVD components to retain when rank reduction is done.
Default is <code>max_rank - 2</code>.</li>
</ul>
<p>max_rank : int, optional
Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_7">Raises<a class="headerlink" href="#raises_7" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_38">See Also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden2'</code> in particular.</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) df^\dagger / ( df^\dagger df)</p>
<p>corresponding to Broyden's second method.</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagbroyden</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using diagonal Broyden Jacobian approximation.</p>
<p>The Jacobian approximation is derived from previous iterations, by
retaining only the diagonal of Broyden matrices.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_8">Raises<a class="headerlink" href="#raises_8" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='diagbroyden'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_9">Raises<a class="headerlink" href="#raises_9" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">excitingmixing</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alphamax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a tuned diagonal Jacobian approximation.</p>
<p>The Jacobian matrix is diagonal and is tuned on each iteration.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="see-also_41">See Also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='excitingmixing'</code> in particular.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial Jacobian approximation is (-1/alpha).
alphamax : float, optional
The entries of the diagonal Jacobian are kept in the range
<code>[alpha, alphamax]</code>.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_10">Raises<a class="headerlink" href="#raises_10" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of BLAS functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_gemv = LA.get_blas_funcs('gemv', (a,))
x_gemv.typecode
'd'
x_gemv = LA.get_blas_funcs('gemv',(a*1j,))
x_gemv.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>a : array_like
Square matrix to be inverted.
overwrite_a : bool, optional
Discard data in <code>a</code> (may improve performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>ainv : ndarray
Inverse of the matrix <code>a</code>.</p>
<h2 id="raises_11">Raises<a class="headerlink" href="#raises_11" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular.
ValueError
If <code>a</code> is not square, or not 2-dimensional.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1., 2.], [3., 4.]])
linalg.inv(a)
array([[-2. ,  1. ],
[ 1.5, -0.5]])
np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linearmixing</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a scalar Jacobian approximation.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
The Jacobian approximation is (-1/alpha).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_12">Raises<a class="headerlink" href="#raises_12" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='linearmixing'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxnorm</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newton_krylov</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rdiff</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Cgs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lgmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bicgstab</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Minres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_M</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Krylov approximation for inverse Jacobian.</p>
<p>This method is suitable for solving large-scale problems.</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
rdiff : float, optional
Relative step size to use in numerical differentiation.
method : {'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function
Krylov method to use to approximate the Jacobian.
Can be a string, or a function implementing the same interface as
the iterative solvers in <code>scipy.sparse.linalg</code>.</p>
<p>The default is <code>scipy.sparse.linalg.lgmres</code>.
inner_M : LinearOperator or InverseJacobian
Preconditioner for the inner Krylov iteration.
Note that you can use also inverse Jacobians as (adaptive)
preconditioners. For example,</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
from scipy.optimize.nonlin import InverseJacobian
jac = BroydenFirst()
kjac = KrylovJacobian(inner_M=InverseJacobian(jac))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the preconditioner has a method named 'update', it will be called
as <code>update(x, f)</code> after each nonlinear step, with <code>x</code> giving
the current point, and <code>f</code> the current function value.
inner_tol, inner_maxiter, ...
Parameters to pass on to the \'inner\' Krylov solver.
See <code>scipy.sparse.linalg.gmres</code> for details.
outer_k : int, optional
Size of the subspace kept across LGMRES nonlinear iterations.
See <code>scipy.sparse.linalg.lgmres</code> for details.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_13">Raises<a class="headerlink" href="#raises_13" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_43">See Also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='krylov'</code> in particular.
scipy.sparse.linalg.gmres
scipy.sparse.linalg.lgmres</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>This function implements a Newton-Krylov solver. The basic idea is
to compute the inverse of the Jacobian with an iterative Krylov
method. These methods require only evaluating the Jacobian-vector
products, which are conveniently approximated by a finite difference:</p>
<p>.. math:: J v \approx (f(x + \omega*v/|v|) - f(x)) / \omega</p>
<p>Due to the use of iterative matrix inverses, these methods can
deal with large nonlinear problems.</p>
<p>SciPy's <code>scipy.sparse.linalg</code> module offers a selection of Krylov
solvers to choose from. The default here is <code>lgmres</code>, which is a
variant of restarted GMRES iteration that reuses some of the
information obtained in the previous Newton steps to invert
Jacobians in subsequent steps.</p>
<p>For a review on Newton-Krylov methods, see for example [1]<em>,
and for the LGMRES sparse inverse method, see [2]</em>.</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2004).
:doi:<code>10.1016/j.jcp.2003.08.010</code>
.. [2] A.H. Baker and E.R. Jessup and T. Manteuffel,
SIAM J. Matrix Anal. Appl. 26, 962 (2005).
:doi:<code>10.1137/S0895479803422014</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonlin_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">jacobian</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">raise_exception</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, in a way suitable for large-scale problems.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
jacobian : Jacobian
A Jacobian approximation: <code>Jacobian</code> object or something that
<code>asjacobian</code> can transform to one. Alternatively, a string specifying
which of the builtin Jacobian approximations to use:</p>
<p>krylov, broyden1, broyden2, anderson
diagbroyden, linearmixing, excitingmixing</p>
<p>iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_14">Raises<a class="headerlink" href="#raises_14" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.
full_output : bool
If true, returns a dictionary <code>info</code> containing convergence
information.
raise_exception : bool
If True, a <code>NoConvergence</code> exception is raise if no solution is found.</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>asjacobian, Jacobian</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inexact Newton method, with
backtracking or full line searches. Several Jacobian
approximations are available, including Krylov and Quasi-Newton
methods.</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [KIM] C. T. Kelley, 'Iterative Methods for Linear and Nonlinear
Equations'. Society for Industrial and Applied Mathematics. (1995)
https://archive.siam.org/books/kelley/fr16/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic', 'raw'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes). The final option 'raw'
(added in SciPy 0.11) makes the function return two matrices
(Q, TAU) in the internal format used by LAPACK.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition. If pivoting, compute the decomposition
<code>A P = Q R</code> as above, but where P is chosen such that the diagonal
of R is non-increasing.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>Q : float or complex ndarray
Of shape (M, M), or (M, K) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.
R : float or complex ndarray
Of shape (M, N), or (K, N) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
P : int ndarray
Of shape (N,) for <code>pivoting=True</code>. Not returned if
<code>pivoting=False</code>.</p>
<h2 id="raises_15">Raises<a class="headerlink" href="#raises_15" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)</p>
<p>q, r = linalg.qr(a)
np.allclose(a, np.dot(q, r))
True
q.shape, r.shape
((9, 9), (9, 6))</p>
<p>r2 = linalg.qr(a, mode='r')
np.allclose(r, r2)
True</p>
<p>q3, r3 = linalg.qr(a, mode='economic')
q3.shape, r3.shape
((9, 6), (6, 6))</p>
<p>q4, r4, p4 = linalg.qr(a, pivoting=True)
d = np.abs(np.diag(r4))
np.all(d[1:] &lt;= d[:-1])
True
np.allclose(a[:, p4], np.dot(q4, r4))
True
q4.shape, r4.shape, p4.shape
((9, 9), (9, 6), (6,))</p>
<p>q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)
q5.shape, r5.shape, p5.shape
((9, 6), (6, 6), (6,))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">scalar_search_armijo</span> <span class="o">:</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">phi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">phi0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derphi0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimize over alpha, the function <code>phi(alpha)</code>.</p>
<p>Uses the interpolation algorithm (Armijo backtracking) as suggested by
Wright and Nocedal in 'Numerical Optimization', 1999, pg. 56-57</p>
<p>alpha &gt; 0 is assumed to be a descent direction.</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>alpha
phi1</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">scalar_search_wolfe1</span> <span class="o">:</span> <span class="o">?</span><span class="n">phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_phi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">derphi0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">phi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derphi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Scalar function search for alpha that satisfies strong Wolfe conditions</p>
<p>alpha &gt; 0 is assumed to be a descent direction.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>phi : callable phi(alpha)
Function at point <code>alpha</code>
derphi : callable phi'(alpha)
Objective function derivative. Returns a scalar.
phi0 : float, optional
Value of phi at 0
old_phi0 : float, optional
Value of phi at previous point
derphi0 : float, optional
Value derphi at 0
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax, amin : float, optional
Maximum and minimum step size
xtol : float, optional
Relative tolerance for an acceptable step.</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>alpha : float
Step size, or None if no suitable step was found
phi : float
Value of <code>phi</code> at the new point <code>alpha</code>
phi0 : float
Value of <code>phi</code> at <code>alpha=0</code></p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>Uses routine DCSRCH from MINPACK.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_16">Raises<a class="headerlink" href="#raises_16" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
full_matrices : bool, optional
If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
<code>K = min(M, N)</code>.
compute_uv : bool, optional
Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
Whether to use the more efficient divide-and-conquer approach
(<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Unitary matrix having left singular vectors as columns.
Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.
s : ndarray
The singular values, sorted in non-increasing order.
Of shape (K,), with <code>K = min(M, N)</code>.
Vh : ndarray
Unitary matrix having right singular vectors as rows.
Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h2 id="raises_17">Raises<a class="headerlink" href="#raises_17" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="see-also_45">See also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
m, n = 9, 6
a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
U, s, Vh = linalg.svd(a)
U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Reconstruct the original matrix from the decomposition:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sigma = np.zeros((m, n))
for i in range(min(m, n)):
...     sigma[i, i] = s[i]
a1 = np.dot(U, np.dot(sigma, Vh))
np.allclose(a, a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>U, s, Vh = linalg.svd(a, full_matrices=False)
U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
S = np.diag(s)
np.allclose(a, np.dot(U, np.dot(S, Vh)))
True</p>
<p>s2 = linalg.svd(a, compute_uv=False)
np.allclose(s, s2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vdot</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>vdot(a, b)</p>
<p>Return the dot product of two vectors.</p>
<p>The vdot(<code>a</code>, <code>b</code>) function handles complex numbers differently than
dot(<code>a</code>, <code>b</code>).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.</p>
<p>Note that <code>vdot</code> handles multidimensional arrays differently than <code>dot</code>:
it does <em>not</em> perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>a : array_like
If <code>a</code> is complex the complex conjugate is taken before calculation
of the dot product.
b : array_like
Second argument to the dot product.</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Dot product of <code>a</code> and <code>b</code>.  Can be an int, float, or
complex depending on the types of <code>a</code> and <code>b</code>.</p>
<h2 id="see-also_46">See Also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>dot : Return the dot product without using the complex conjugate of the
first argument.</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1+2j,3+4j])
b = np.array([5+6j,7+8j])
np.vdot(a, b)
(70-8j)
np.vdot(b, a)
(70+8j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that higher-dimensional arrays are flattened!</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 4], [5, 6]])
b = np.array([[4, 1], [2, 2]])
np.vdot(a, b)
30
np.vdot(b, a)
30
1<em>4 + 4</em>1 + 5<em>2 + 6</em>2
30</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Optimize</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Brent</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Brent</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Brent</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_bracket_info</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_result</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">optimize</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_bracket</span> <span class="o">:</span> <span class="o">?</span><span class="n">brack</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LineSearchWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LineSearchWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LineSearchWarning</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">MapWrapper</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MapWrapper</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MapWrapper</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">pool</span><span class="o">:[`</span><span class="nc">Map_like_callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Parallelisation wrapper for working with map-like callables, such as
<code>multiprocessing.Pool.map</code>.</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>pool : int or map-like callable
If <code>pool</code> is an integer, then it specifies the number of threads to
use for parallelization. If <code>int(pool) == 1</code>, then no parallel
processing is used and the map builtin is used.
If <code>pool == -1</code>, then the pool will utilise all available CPUs.
If <code>pool</code> is a map-like callable that follows the same
calling sequence as the built-in map function, then this callable is
used for parallelisation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">join</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">terminate</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">approx_fhess_p</span> <span class="o">:</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">epsilon</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">approx_fprime</span> <span class="o">:</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">epsilon</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finite-difference approximation of the gradient of a scalar function.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>xk : array_like
The coordinate vector at which to determine the gradient of <code>f</code>.
f : callable
The function of which to determine the gradient (partial derivatives).
Should take <code>xk</code> as first argument, other arguments to <code>f</code> can be
supplied in <code>*args</code>.  Should return a scalar, the value of the
function at <code>xk</code>.
epsilon : array_like
Increment to <code>xk</code> to use for determining the function gradient.
If a scalar, uses the same finite difference delta for all partial
derivatives.  If an array, should contain one value per element of
<code>xk</code>.
*args : args, optional
Any other arguments that are to be passed to <code>f</code>.</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>grad : ndarray
The partial derivatives of <code>f</code> to <code>xk</code>.</p>
<h2 id="see-also_47">See Also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>check_grad : Check correctness of gradient function against approx_fprime.</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>The function gradient is determined by the forward finite difference
formula::</p>
<p>f(xk[i] + epsilon[i]) - f(xk[i])
f'[i] = ---------------------------------
epsilon[i]</p>
<p>The main use of <code>approx_fprime</code> is in scalar function optimizers like
<code>fmin_bfgs</code>, to determine numerically the Jacobian of a function.</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def func(x, c0, c1):
...     'Coordinate vector <code>x</code> should be an array of size two.'
...     return c0 * x[0]<strong>2 + c1*x[1]</strong>2</p>
<p>x = np.ones(2)
c0, c1 = (1, 200)
eps = np.sqrt(np.finfo(float).eps)
optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
array([   2.        ,  400.00004198])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the indices of the minimum values along an axis.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.
axis : int, optional
By default, the index is into the flattened array, otherwise
along the specified axis.
out : array, optional
If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>index_array : ndarray of ints
Array of indices into the array. It has the same shape as <code>a.shape</code>
with the dimension along <code>axis</code> removed.</p>
<h2 id="see-also_48">See Also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply <code>np.expand_dims(index_array, axis)</code>
from argmin to an array as if by calling min.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(6).reshape(2,3) + 10
a
array([[10, 11, 12],
[13, 14, 15]])
np.argmin(a)
0
np.argmin(a, axis=0)
array([0, 0, 0])
np.argmin(a, axis=1)
array([0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
ind
(0, 0)
a[ind]
10</p>
<p>b = np.arange(6) + 10
b[4] = 10
b
array([10, 11, 12, 13, 10, 15])
np.argmin(b)  # Only the first occurrence is returned.
0</p>
<p>x = np.array([[4,2,3], [1,0,3]])
index_array = np.argmin(x, axis=-1)</p>
<h1 id="same-as-npminx-axis-1-keepdimstrue">Same as np.min(x, axis=-1, keepdims=True)<a class="headerlink" href="#same-as-npminx-axis-1-keepdimstrue" title="Permanent link">&para;</a></h1>
<p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)
array([[2],
[0]])</p>
<h1 id="same-as-npmaxx-axis-1">Same as np.max(x, axis=-1)<a class="headerlink" href="#same-as-npmaxx-axis-1" title="Permanent link">&para;</a></h1>
<p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
array([2, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_49">See Also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array converted to a float type.</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>a : array_like
The input array.
dtype : str or dtype object, optional
Float type code to coerce input array <code>a</code>.  If <code>dtype</code> is one of the
'int' dtypes, it is replaced with float64.</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The input <code>a</code> as a float ndarray.</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.asfarray([2, 3])
array([2.,  3.])
np.asfarray([2, 3], dtype='float')
array([2.,  3.])
np.asfarray([2, 3], dtype='int8')
array([2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also_50">See Also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bracket</span> <span class="o">:</span> <span class="o">?</span><span class="n">xa</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">grow_limit</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Bracket the minimum of the function.</p>
<p>Given a function and distinct initial points, search in the
downhill direction (as defined by the initital points) and return
new points xa, xb, xc that bracket the minimum of the function
f(xa) &gt; f(xb) &lt; f(xc). It doesn't always mean that obtained
solution will satisfy xa&lt;=x&lt;=xb</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to minimize.
xa, xb : float, optional
Bracketing interval. Defaults <code>xa</code> to 0.0, and <code>xb</code> to 1.0.
args : tuple, optional
Additional arguments (if present), passed to <code>func</code>.
grow_limit : float, optional
Maximum grow limit.  Defaults to 110.0
maxiter : int, optional
Maximum number of iterations to perform. Defaults to 1000.</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>xa, xb, xc : float
Bracket.
fa, fb, fc : float
Objective function values in bracket.
funcalls : int
Number of function evaluations made.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brent</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brack</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Given a function of one-variable and a possible bracket, return
the local minimum of the function isolated to a fractional precision
of tol.</p>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function.
args : tuple, optional
Additional arguments (if present).
brack : tuple, optional
Either a triple (xa,xb,xc) where xa&lt;xb&lt;xc and func(xb) &lt;
func(xa), func(xc) or a pair (xa,xb) which are used as a
starting interval for a downhill bracket search (see
<code>bracket</code>). Providing the pair (xa,xb) does not always mean
the obtained solution will satisfy xa&lt;=x&lt;=xb.
tol : float, optional
Stop if between iteration change is less than <code>tol</code>.
full_output : bool, optional
If True, return all output args (xmin, fval, iter,
funcalls).
maxiter : int, optional
Maximum number of iterations in solution.</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>xmin : ndarray
Optimum point.
fval : float
Optimum value.
iter : int
Number of iterations.
funcalls : int
Number of objective function evaluations made.</p>
<h2 id="see-also_51">See also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Brent' <code>method</code> in particular.</p>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p>Uses inverse parabolic interpolation when possible to speed up
convergence of golden section method.</p>
<p>Does not ensure that the minimum lies in the range specified by
<code>brack</code>. See <code>fminbound</code>.</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<p>We illustrate the behaviour of the function when <code>brack</code> is of
size 2 and 3 respectively. In the case where <code>brack</code> is of the
form (xa,xb), we can see for the given values, the output need
not necessarily lie in the range (xa,xb).</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.brent(f,brack=(1,2))
minimum
0.0
minimum = optimize.brent(f,brack=(-1,0.5,2))
minimum
-2.7755575615628914e-17</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brute</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ns</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">finish</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:[`</span><span class="nc">Map_like_callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ranges</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function over a given range by brute force.</p>
<p>Uses the 'brute force' method, i.e. computes the function's value
at each point of a multidimensional grid of points, to find the global
minimum of the function.</p>
<p>The function is evaluated everywhere in the range with the datatype of the
first call to the function, as enforced by the <code>vectorize</code> NumPy
function.  The value and type of the function evaluation returned when
<code>full_output=True</code> are affected in addition by the <code>finish</code> argument
(see Notes).</p>
<p>The brute force approach is inefficient because the number of grid points
increases exponentially - the number of grid points to evaluate is
<code>Ns ** len(x)</code>. Consequently, even with coarse grid spacing, even
moderately sized problems can take a long time to run, and/or run into
memory limitations.</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>func : callable
The objective function to be minimized. Must be in the
form <code>f(x, *args)</code>, where <code>x</code> is the argument in
the form of a 1-D array and <code>args</code> is a tuple of any
additional fixed parameters needed to completely specify
the function.
ranges : tuple
Each component of the <code>ranges</code> tuple must be either a
'slice object' or a range tuple of the form <code>(low, high)</code>.
The program uses these to create the grid of points on which
the objective function will be computed. See <code>Note 2</code> for
more detail.
args : tuple, optional
Any additional fixed parameters needed to completely specify
the function.
Ns : int, optional
Number of grid points along the axes, if not otherwise
specified. See <code>Note2</code>.
full_output : bool, optional
If True, return the evaluation grid and the objective function's
values on it.
finish : callable, optional
An optimization function that is called with the result of brute force
minimization as initial guess.  <code>finish</code> should take <code>func</code> and
the initial guess as positional arguments, and take <code>args</code> as
keyword arguments.  It may additionally take <code>full_output</code>
and/or <code>disp</code> as keyword arguments.  Use None if no 'polishing'
function is to be used. See Notes for more details.
disp : bool, optional
Set to True to print convergence messages from the <code>finish</code> callable.
workers : int or map-like callable, optional
If <code>workers</code> is an int the grid is subdivided into <code>workers</code>
sections and evaluated in parallel (uses
<code>multiprocessing.Pool &lt;multiprocessing&gt;</code>).
Supply <code>-1</code> to use all cores available to the Process.
Alternatively supply a map-like callable, such as
<code>multiprocessing.Pool.map</code> for evaluating the grid in parallel.
This evaluation is carried out as <code>workers(func, iterable)</code>.
Requires that <code>func</code> be pickleable.</p>
<p>.. versionadded:: 1.3.0</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>x0 : ndarray
A 1-D array containing the coordinates of a point at which the
objective function had its minimum value. (See <code>Note 1</code> for
which point is returned.)
fval : float
Function value at the point <code>x0</code>. (Returned when <code>full_output</code> is
True.)
grid : tuple
Representation of the evaluation grid.  It has the same
length as <code>x0</code>. (Returned when <code>full_output</code> is True.)
Jout : ndarray
Function values at each point of the evaluation
grid, <code>i.e.</code>, <code>Jout = func( *grid)</code>. (Returned
when <code>full_output</code> is True.)</p>
<h2 id="see-also_52">See Also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>basinhopping, differential_evolution</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p><em>Note 1</em>: The program finds the gridpoint at which the lowest value
of the objective function occurs.  If <code>finish</code> is None, that is the
point returned.  When the global minimum occurs within (or not very far
outside) the grid's boundaries, and the grid is fine enough, that
point will be in the neighborhood of the global minimum.</p>
<p>However, users often employ some other optimization program to
'polish' the gridpoint values, <code>i.e.</code>, to seek a more precise
(local) minimum near <code>brute's</code> best gridpoint.
The <code>brute</code> function's <code>finish</code> option provides a convenient way to do
that.  Any polishing program used must take <code>brute's</code> output as its
initial guess as a positional argument, and take <code>brute's</code> input values
for <code>args</code> as keyword arguments, otherwise an error will be raised.
It may additionally take <code>full_output</code> and/or <code>disp</code> as keyword arguments.</p>
<p><code>brute</code> assumes that the <code>finish</code> function returns either an
<code>OptimizeResult</code> object or a tuple in the form:
<code>(xmin, Jmin, ... , statuscode)</code>, where <code>xmin</code> is the minimizing
value of the argument, <code>Jmin</code> is the minimum value of the objective
function, '...' may be some other returned values (which are not used
by <code>brute</code>), and <code>statuscode</code> is the status code of the <code>finish</code> program.</p>
<p>Note that when <code>finish</code> is not None, the values returned are those
of the <code>finish</code> program, <em>not</em> the gridpoint ones.  Consequently,
while <code>brute</code> confines its search to the input grid points,
the <code>finish</code> program's results usually will not coincide with any
gridpoint, and may fall outside the grid's boundary. Thus, if a
minimum only needs to be found over the provided grid points, make
sure to pass in <code>finish=None</code>.</p>
<p><em>Note 2</em>: The grid of points is a <code>numpy.mgrid</code> object.
For <code>brute</code> the <code>ranges</code> and <code>Ns</code> inputs have the following effect.
Each component of the <code>ranges</code> tuple can be either a slice object or a
two-tuple giving a range of values, such as (0, 5).  If the component is a
slice object, <code>brute</code> uses it directly.  If the component is a two-tuple
range, <code>brute</code> internally converts it to a slice object that interpolates
<code>Ns</code> points from its low-value to its high-value, inclusive.</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<p>We illustrate the use of <code>brute</code> to seek the global minimum of a function
of two variables that is given as the sum of a positive-definite
quadratic and two deep 'Gaussian-shaped' craters.  Specifically, define
the objective function <code>f</code> as the sum of three other functions,
<code>f = f1 + f2 + f3</code>.  We suppose each of these has a signature
<code>(z, *params)</code>, where <code>z = (x, y)</code>,  and <code>params</code> and the functions
are as defined below.</p>
<blockquote>
<blockquote>
<blockquote>
<p>params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
def f1(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (a * x</em><em>2 + b * x * y + c * y</em><em>2 + d</em>x + e*y + f)</p>
<p>def f2(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-g</em>np.exp(-((x-h)<strong>2 + (y-i)</strong>2) / scale))</p>
<p>def f3(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-j</em>np.exp(-((x-k)<strong>2 + (y-l)</strong>2) / scale))</p>
<p>def f(z, <em>params):
...     return f1(z, </em>params) + f2(z, <em>params) + f3(z, </em>params)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thus, the objective function may have local minima near the minimum
of each of the three functions of which it is composed.  To
use <code>fmin</code> to polish its gridpoint result, we may then continue as
follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
from scipy import optimize
resbrute = optimize.brute(f, rranges, args=params, full_output=True,
...                           finish=optimize.fmin)
resbrute[0]  # global minimum
array([-1.05665192,  1.80834843])
resbrute[1]  # function value at global minimum
-3.4085818767</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that if <code>finish</code> had been set to None, we would have gotten the
gridpoint [-1.0 1.75] where the rounded function value is -2.892.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_grad</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">grad</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Check the correctness of a gradient function by comparing it against a
(forward) finite-difference approximation of the gradient.</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>func : callable <code>func(x0, *args)</code>
Function whose derivative is to be checked.
grad : callable <code>grad(x0, *args)</code>
Gradient of <code>func</code>.
x0 : ndarray
Points to check <code>grad</code> against forward difference approximation of grad
using <code>func</code>.
args : *args, optional
Extra arguments passed to <code>func</code> and <code>grad</code>.
epsilon : float, optional
Step size used for the finite difference approximation. It defaults to
<code>sqrt(numpy.finfo(float).eps)</code>, which is approximately 1.49e-08.</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>err : float
The square root of the sum of squares (i.e. the 2-norm) of the
difference between <code>grad(x0, *args)</code> and the finite difference
approximation of <code>grad</code> using func at the points <code>x0</code>.</p>
<h2 id="see-also_53">See Also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>approx_fprime</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def func(x):
...     return x[0]<strong>2 - 0.5 * x[1]</strong>3
def grad(x):
...     return [2 * x[0], -1.5 * x[1]**2]
from scipy.optimize import check_grad
check_grad(func, grad, [1.5, -1.5])
2.9802322387695312e-08</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>N : int
Number of rows in the output.
M : int, optional
Number of columns in the output. If None, defaults to <code>N</code>.
k : int, optional
Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.
dtype : data-type, optional
Data-type of the returned array.
order : {'C', 'F'}, optional
Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<p>.. versionadded:: 1.14.0</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>I : ndarray of shape (N,M)
An array where all elements are equal to zero, except for the <code>k</code>-th
diagonal, whose values are equal to one.</p>
<h2 id="see-also_54">See Also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.eye(2, dtype=int)
array([[1, 0],
[0, 1]])
np.eye(3, k=1)
array([[0.,  1.,  0.],
[0.,  0.,  1.],
[0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial_simplex</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using the downhill simplex algorithm.</p>
<p>This algorithm only uses function values, not derivatives or second
derivatives.</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>func : callable func(x,*args)
The objective function to be minimized.
x0 : ndarray
Initial guess.
args : tuple, optional
Extra arguments passed to func, i.e. <code>f(x,*args)</code>.
xtol : float, optional
Absolute error in xopt between iterations that is acceptable for
convergence.
ftol : number, optional
Absolute error in func(xopt) between iterations that is acceptable for
convergence.
maxiter : int, optional
Maximum number of iterations to perform.
maxfun : number, optional
Maximum number of function evaluations to make.
full_output : bool, optional
Set to True if fopt and warnflag outputs are desired.
disp : bool, optional
Set to True to print convergence messages.
retall : bool, optional
Set to True to return list of solutions at each iteration.
callback : callable, optional
Called after each iteration, as callback(xk), where xk is the
current parameter vector.
initial_simplex : array_like of shape (N + 1, N), optional
Initial simplex. If given, overrides <code>x0</code>.
<code>initial_simplex[j,:]</code> should contain the coordinates of
the j-th vertex of the <code>N+1</code> vertices in the simplex, where
<code>N</code> is the dimension.</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameter that minimizes function.
fopt : float
Value of function at minimum: <code>fopt = func(xopt)</code>.
iter : int
Number of iterations performed.
funcalls : int
Number of function calls made.
warnflag : int
1 : Maximum number of function evaluations made.
2 : Maximum number of iterations reached.
allvecs : list
Solution at each iteration.</p>
<h2 id="see-also_55">See also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'Nelder-Mead' <code>method</code> in particular.</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>Uses a Nelder-Mead simplex algorithm to find the minimum of function of
one or more variables.</p>
<p>This algorithm has a long history of successful use in applications.
But it will usually be slower than an algorithm that uses first or
second derivative information. In practice it can have poor
performance in high-dimensional problems and is not robust to
minimizing complicated functions. Additionally, there currently is no
complete theory describing when the algorithm will successfully
converge to the minimum, or how fast it will if it does. Both the ftol and
xtol criteria must be met for convergence.</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fmin(f, 1)
Optimization terminated successfully.
Current function value: 0.000000
Iterations: 17
Function evaluations: 34
minimum[0]
-8.8817841970012523e-16</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] Nelder, J.A. and Mead, R. (1965), 'A simplex method for function
minimization', The Computer Journal, 7, pp. 308-313</p>
<p>.. [2] Wright, M.H. (1996), 'Direct Search Methods: Once Scorned, Now
Respectable', in Numerical Analysis 1995, Proceedings of the
1995 Dundee Biennial Conference in Numerical Analysis, D.F.
Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,
Harlow, UK, pp. 191-208.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_bfgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using the BFGS algorithm.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function to be minimized.
x0 : ndarray
Initial guess.
fprime : callable f'(x,</em>args), optional
Gradient of f.
args : tuple, optional
Extra arguments passed to f and fprime.
gtol : float, optional
Gradient norm must be less than gtol before successful termination.
norm : float, optional
Order of norm (Inf is max, -Inf is min)
epsilon : int or ndarray, optional
If fprime is approximated, use this value for the step size.
callback : callable, optional
An optional user-supplied function to call after each
iteration.  Called as callback(xk), where xk is the
current parameter vector.
maxiter : int, optional
Maximum number of iterations to perform.
full_output : bool, optional
If True,return fopt, func_calls, grad_calls, and warnflag
in addition to xopt.
disp : bool, optional
Print convergence message if True.
retall : bool, optional
Return a list of results at each iteration if True.</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. f(xopt) == fopt.
fopt : float
Minimum value.
gopt : ndarray
Value of gradient at minimum, f'(xopt), which should be near 0.
Bopt : ndarray
Value of 1/f''(xopt), i.e. the inverse hessian matrix.
func_calls : int
Number of function_calls made.
grad_calls : int
Number of gradient calls made.
warnflag : integer
1 : Maximum number of iterations exceeded.
2 : Gradient and/or function calls not changing.
3 : NaN result encountered.
allvecs  :  list
The value of xopt at each iteration.  Only returned if retall is True.</p>
<h2 id="see-also_56">See also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'BFGS' <code>method</code> in particular.</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>Optimize the function, f, whose gradient is given by fprime
using the quasi-Newton method of Broyden, Fletcher, Goldfarb,
and Shanno (BFGS)</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>Wright, and Nocedal 'Numerical Optimization', 1999, pg. 198.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:[`</span><span class="nc">T_fprime_x_args_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_f_x_args_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using a nonlinear conjugate gradient algorithm.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>f : callable, <code>f(x, *args)</code>
Objective function to be minimized.  Here <code>x</code> must be a 1-D array of
the variables that are to be changed in the search for a minimum, and
<code>args</code> are the other (fixed) parameters of <code>f</code>.
x0 : ndarray
A user-supplied initial estimate of <code>xopt</code>, the optimal value of <code>x</code>.
It must be a 1-D array of values.
fprime : callable, <code>fprime(x, *args)</code>, optional
A function that returns the gradient of <code>f</code> at <code>x</code>. Here <code>x</code> and <code>args</code>
are as described above for <code>f</code>. The returned value must be a 1-D array.
Defaults to None, in which case the gradient is approximated
numerically (see <code>epsilon</code>, below).
args : tuple, optional
Parameter values passed to <code>f</code> and <code>fprime</code>. Must be supplied whenever
additional fixed parameters are needed to completely specify the
functions <code>f</code> and <code>fprime</code>.
gtol : float, optional
Stop when the norm of the gradient is less than <code>gtol</code>.
norm : float, optional
Order to use for the norm of the gradient
(<code>-np.Inf</code> is min, <code>np.Inf</code> is max).
epsilon : float or ndarray, optional
Step size(s) to use when <code>fprime</code> is approximated numerically. Can be a
scalar or a 1-D array.  Defaults to <code>sqrt(eps)</code>, with eps the
floating point machine precision.  Usually <code>sqrt(eps)</code> is about
1.5e-8.
maxiter : int, optional
Maximum number of iterations to perform. Default is <code>200 * len(x0)</code>.
full_output : bool, optional
If True, return <code>fopt</code>, <code>func_calls</code>, <code>grad_calls</code>, and <code>warnflag</code> in
addition to <code>xopt</code>.  See the Returns section below for additional
information on optional return values.
disp : bool, optional
If True, return a convergence message, followed by <code>xopt</code>.
retall : bool, optional
If True, add to the returned values the results of each iteration.
callback : callable, optional
An optional user-supplied function, called after each iteration.
Called as <code>callback(xk)</code>, where <code>xk</code> is the current value of <code>x0</code>.</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. <code>f(xopt) == fopt</code>.
fopt : float, optional
Minimum value found, f(xopt).  Only returned if <code>full_output</code> is True.
func_calls : int, optional
The number of function_calls made.  Only returned if <code>full_output</code>
is True.
grad_calls : int, optional
The number of gradient calls made. Only returned if <code>full_output</code> is
True.
warnflag : int, optional
Integer value with warning status, only returned if <code>full_output</code> is
True.</p>
<p>0 : Success.</p>
<p>1 : The maximum number of iterations was exceeded.</p>
<p>2 : Gradient and/or function calls were not changing.  May indicate
that precision was lost, i.e., the routine did not converge.</p>
<p>3 : NaN result encountered.</p>
<p>allvecs : list of ndarray, optional
List of arrays, containing the results at each iteration.
Only returned if <code>retall</code> is True.</p>
<h2 id="see-also_57">See Also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>minimize : common interface to all <code>scipy.optimize</code> algorithms for
unconstrained and constrained minimization of multivariate
functions.  It provides an alternative way to call
<code>fmin_cg</code>, by specifying <code>method='CG'</code>.</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>This conjugate gradient algorithm is based on that of Polak and Ribiere
[1]_.</p>
<p>Conjugate gradient methods tend to work better when:</p>
<ol>
<li><code>f</code> has a unique global minimizing point, and no local minima or
other stationary points,</li>
<li><code>f</code> is, at least locally, reasonably well approximated by a
quadratic function of the variables,</li>
<li><code>f</code> is continuous and has a continuous gradient,</li>
<li><code>fprime</code> is not too large, e.g., has a norm less than 1000,</li>
<li>The initial guess, <code>x0</code>, is reasonably close to <code>f</code> 's global
minimizing point, <code>xopt</code>.</li>
</ol>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] Wright &amp; Nocedal, 'Numerical Optimization', 1999, pp. 120-122.</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<p>Example 1: seek the minimum value of the expression
<code>a*u**2 + b*u*v + c*v**2 + d*u + e*v + f</code> for given values
of the parameters and an initial guess <code>(u, v) = (0, 0)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>args = (2, 3, 7, 8, 9, 10)  # parameter values
def f(x, <em>args):
...     u, v = x
...     a, b, c, d, e, f = args
...     return a</em>u<strong>2 + b<em>u</em>v + c*v</strong>2 + d<em>u + e</em>v + f
def gradf(x, <em>args):
...     u, v = x
...     a, b, c, d, e, f = args
...     gu = 2</em>a<em>u + b</em>v + d     # u-component of the gradient
...     gv = b<em>u + 2</em>c*v + e     # v-component of the gradient
...     return np.asarray((gu, gv))
x0 = np.asarray((0, 0))  # Initial guess.
from scipy import optimize
res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)
Optimization terminated successfully.
Current function value: 1.617021
Iterations: 4
Function evaluations: 8
Gradient evaluations: 8
res1
array([-1.80851064, -0.25531915])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Example 2: solve the same problem using the <code>minimize</code> function.
(This <code>myopts</code> dictionary shows all of the available options,
although in practice only non-default values would be needed.
The returned value will be a dictionary.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>opts = {'maxiter' : None,    # default value.
...         'disp' : True,    # non-default value.
...         'gtol' : 1e-5,    # default value.
...         'norm' : np.inf,  # default value.
...         'eps' : 1.4901161193847656e-08}  # default value.
res2 = optimize.minimize(f, x0, jac=gradf, args=args,
...                          method='CG', options=opts)
Optimization terminated successfully.
Current function value: 1.617021
Iterations: 4
Function evaluations: 8
Gradient evaluations: 8
res2.x  # minimum found
array([-1.80851064, -0.25531915])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_ncg</span> <span class="o">:</span> <span class="o">?</span><span class="n">fhess_p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fhess</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">avextol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Unconstrained minimization of a function using the Newton-CG method.</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>f : callable <code>f(x, *args)</code>
Objective function to be minimized.
x0 : ndarray
Initial guess.
fprime : callable <code>f'(x, *args)</code>
Gradient of f.
fhess_p : callable <code>fhess_p(x, p, *args)</code>, optional
Function which computes the Hessian of f times an
arbitrary vector, p.
fhess : callable <code>fhess(x, *args)</code>, optional
Function to compute the Hessian matrix of f.
args : tuple, optional
Extra arguments passed to f, fprime, fhess_p, and fhess
(the same set of extra arguments is supplied to all of
these functions).
epsilon : float or ndarray, optional
If fhess is approximated, use this value for the step size.
callback : callable, optional
An optional user-supplied function which is called after
each iteration.  Called as callback(xk), where xk is the
current parameter vector.
avextol : float, optional
Convergence is assumed when the average relative error in
the minimizer falls below this amount.
maxiter : int, optional
Maximum number of iterations to perform.
full_output : bool, optional
If True, return the optional outputs.
disp : bool, optional
If True, print convergence message.
retall : bool, optional
If True, return a list of results at each iteration.</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. <code>f(xopt) == fopt</code>.
fopt : float
Value of the function at xopt, i.e. <code>fopt = f(xopt)</code>.
fcalls : int
Number of function calls made.
gcalls : int
Number of gradient calls made.
hcalls : int
Number of hessian calls made.
warnflag : int
Warnings generated by the algorithm.
1 : Maximum number of iterations exceeded.
2 : Line search failure (precision loss).
3 : NaN result encountered.
allvecs : list
The result at each iteration, if retall is True (see below).</p>
<h2 id="see-also_58">See also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'Newton-CG' <code>method</code> in particular.</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>Only one of <code>fhess_p</code> or <code>fhess</code> need to be given.  If <code>fhess</code>
is provided, then <code>fhess_p</code> will be ignored.  If neither <code>fhess</code>
nor <code>fhess_p</code> is provided, then the hessian product will be
approximated using finite differences on <code>fprime</code>. <code>fhess_p</code>
must compute the hessian times an arbitrary vector. If it is not
given, finite-differences on <code>fprime</code> are used to compute
it.</p>
<p>Newton-CG methods are also called truncated Newton methods. This
function differs from scipy.optimize.fmin_tnc because</p>
<ol>
<li>scipy.optimize.fmin_ncg is written purely in python using numpy
and scipy while scipy.optimize.fmin_tnc calls a C function.</li>
<li>scipy.optimize.fmin_ncg is only for unconstrained minimization
while scipy.optimize.fmin_tnc is for unconstrained minimization
or box constrained minimization. (Box constraints give
lower and upper bounds for each variable separately.)</li>
</ol>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>Wright &amp; Nocedal, 'Numerical Optimization', 1999, pg. 140.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_powell</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">direc</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using modified Powell's method.</p>
<p>This method only uses function values, not derivatives.</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to be minimized.
x0 : ndarray
Initial guess.
args : tuple, optional
Extra arguments passed to func.
xtol : float, optional
Line-search error tolerance.
ftol : float, optional
Relative error in <code>func(xopt)</code> acceptable for convergence.
maxiter : int, optional
Maximum number of iterations to perform.
maxfun : int, optional
Maximum number of function evaluations to make.
full_output : bool, optional
If True, <code>fopt</code>, <code>xi</code>, <code>direc</code>, <code>iter</code>, <code>funcalls</code>, and
<code>warnflag</code> are returned.
disp : bool, optional
If True, print convergence messages.
retall : bool, optional
If True, return a list of the solution at each iteration.
callback : callable, optional
An optional user-supplied function, called after each
iteration.  Called as <code>callback(xk)</code>, where <code>xk</code> is the
current parameter vector.
direc : ndarray, optional
Initial fitting step and parameter order set as an (N, N) array, where N
is the number of fitting parameters in <code>x0</code>.  Defaults to step size 1.0
fitting all parameters simultaneously (<code>np.ones((N, N))</code>).  To
prevent initial consideration of values in a step or to change initial
step size, set to 0 or desired step size in the Jth position in the Mth
block, where J is the position in <code>x0</code> and M is the desired evaluation
step, with steps being evaluated in index order.  Step size and ordering
will change freely as minimization proceeds.</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameter which minimizes <code>func</code>.
fopt : number
Value of function at minimum: <code>fopt = func(xopt)</code>.
direc : ndarray
Current direction set.
iter : int
Number of iterations.
funcalls : int
Number of function calls made.
warnflag : int
Integer warning flag:
1 : Maximum number of function evaluations.
2 : Maximum number of iterations.
3 : NaN result encountered.
allvecs : list
List of solutions at each iteration.</p>
<h2 id="see-also_59">See also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to unconstrained minimization algorithms for
multivariate functions. See the 'Powell' method in particular.</p>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>Uses a modification of Powell's method to find the minimum of
a function of N variables. Powell's method is a conjugate
direction method.</p>
<p>The algorithm has two loops.  The outer loop merely iterates over the inner
loop. The inner loop minimizes over each current direction in the direction
set. At the end of the inner loop, if certain conditions are met, the
direction that gave the largest decrease is dropped and replaced with the
difference between the current estimated x and the estimated x from the
beginning of the inner-loop.</p>
<p>The technical conditions for replacing the direction of greatest
increase amount to checking that</p>
<ol>
<li>No further gain can be made along the direction of greatest increase
from that iteration.</li>
<li>The direction of greatest increase accounted for a large sufficient
fraction of the decrease in the function value from that iteration of
the inner loop.</li>
</ol>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>Powell M.J.D. (1964) An efficient method for finding the minimum of a
function of several variables without calculating derivatives,
Computer Journal, 7 (2):155-162.</p>
<p>Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:
Numerical Recipes (any edition), Cambridge University Press</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fmin_powell(f, -1)
Optimization terminated successfully.
Current function value: 0.000000
Iterations: 2
Function evaluations: 18
minimum
array(0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fminbound</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Bounded minimization for scalar functions.</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to be minimized (must accept and return scalars).
x1, x2 : float or array scalar
The optimization bounds.
args : tuple, optional
Extra arguments passed to function.
xtol : float, optional
The convergence tolerance.
maxfun : int, optional
Maximum number of function evaluations allowed.
full_output : bool, optional
If True, return optional outputs.
disp : int, optional
If non-zero, print messages.
0 : no message printing.
1 : non-convergence notification messages only.
2 : print a message on convergence too.
3 : print iteration results.</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters (over given interval) which minimize the
objective function.
fval : number
The function value at the minimum point.
ierr : int
An error flag (0 if converged, 1 if maximum number of
function calls reached).
numfunc : int
The number of function calls made.</p>
<h2 id="see-also_60">See also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Bounded' <code>method</code> in particular.</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>Finds a local minimizer of the scalar function <code>func</code> in the
interval x1 &lt; xopt &lt; x2 using Brent's method.  (See <code>brent</code>
for auto-bracketing).</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<p><code>fminbound</code> finds the minimum of the function in the given range.
The following examples illustrate the same</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fminbound(f, -1, 2)
minimum
0.0
minimum = optimize.fminbound(f, 1, 2)
minimum
1.0000059608609866</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">golden</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brack</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of a function of one variable using golden section
method.</p>
<p>Given a function of one variable and a possible bracketing interval,
return the minimum of the function isolated to a fractional precision of
tol.</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>func : callable func(x,*args)
Objective function to minimize.
args : tuple, optional
Additional arguments (if present), passed to func.
brack : tuple, optional
Triple (a,b,c), where (a&lt;b&lt;c) and func(b) &lt;
func(a),func(c).  If bracket consists of two numbers (a,
c), then they are assumed to be a starting interval for a
downhill bracket search (see <code>bracket</code>); it doesn't always
mean that obtained solution will satisfy a&lt;=x&lt;=c.
tol : float, optional
x tolerance stop criterion
full_output : bool, optional
If True, return optional outputs.
maxiter : int
Maximum number of iterations to perform.</p>
<h2 id="see-also_61">See also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Golden' <code>method</code> in particular.</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<p>Uses analog of bisection method to decrease the bracketed
interval.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<p>We illustrate the behaviour of the function when <code>brack</code> is of
size 2 and 3 respectively. In the case where <code>brack</code> is of the
form (xa,xb), we can see for the given values, the output need
not necessarily lie in the range <code>(xa, xb)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.golden(f, brack=(1, 2))
minimum
1.5717277788484873e-162
minimum = optimize.golden(f, brack=(-1, 0.5, 2))
minimum
-1.5717277788484873e-162</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_array_scalar</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Test whether <code>x</code> is either a scalar or an array scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isinf</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for positive or negative infinity.</p>
<p>Returns a boolean array of the same shape as <code>x</code>, True where <code>x ==
+/-inf</code>, otherwise False.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>y : bool (scalar) or boolean ndarray
True where <code>x</code> is positive or negative infinity, false otherwise.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_62">See Also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>isneginf, isposinf, isnan, isfinite</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.isinf(np.inf)
True
np.isinf(np.nan)
False
np.isinf(np.NINF)
True
np.isinf([np.inf, -np.inf, 1.0, np.nan])
array([ True,  True, False, False])</p>
<p>x = np.array([-np.inf, 0., np.inf])
y = np.array([2, 2, 2])
np.isinf(x, y)
array([1, 0, 1])
y
array([1, 0, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">myfprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Find alpha that satisfies strong Wolfe conditions.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function.
myfprime : callable f'(x,</em>args)
Objective function gradient.
xk : ndarray
Starting point.
pk : ndarray
Search direction.
gfk : ndarray, optional
Gradient value for x=xk (xk being the current parameter
estimate). Will be recomputed if omitted.
old_fval : float, optional
Function value for x=xk. Will be recomputed if omitted.
old_old_fval : float, optional
Function value for the point preceding x=xk
args : tuple, optional
Additional arguments passed to objective function.
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax : float, optional
Maximum step size
extra_condition : callable, optional
A callable of the form <code>extra_condition(alpha, x, f, g)</code>
returning a boolean. Arguments are the proposed step <code>alpha</code>
and the corresponding <code>x</code>, <code>f</code> and <code>g</code> values. The line search
accepts the value of <code>alpha</code> only if this
callable returns <code>True</code>. If the callable returns <code>False</code>
for the step length, the algorithm will continue with
new iterates. The callable is only called for iterates
satisfying the strong Wolfe conditions.
maxiter : int, optional
Maximum number of iterations to perform</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>alpha : float or None
Alpha for which <code>x_new = x0 + alpha * pk</code>,
or None if the line search algorithm did not converge.
fc : int
Number of function evaluations made.
gc : int
Number of gradient evaluations made.
new_fval : float or None
New function value <code>f(x_new)=f(x0+alpha*pk)</code>,
or None if the line search algorithm did not converge.
old_fval : float
Old function value <code>f(x0)</code>.
new_slope : float or None
The local slope along the search direction at the
new value <code>&lt;myfprime(x_new), pk&gt;</code>,
or None if the line search algorithm did not converge.</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p>Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.</p>
<p>For the zoom phase it uses an algorithm by [...].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_wolfe1</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>As <code>scalar_search_wolfe1</code> but do a line search to direction <code>pk</code></p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>f : callable
Function <code>f(x)</code>
fprime : callable
Gradient of <code>f</code>
xk : array_like
Current point
pk : array_like
Search direction</p>
<p>gfk : array_like, optional
Gradient of <code>f</code> at point <code>xk</code>
old_fval : float, optional
Value of <code>f</code> at point <code>xk</code>
old_old_fval : float, optional
Value of <code>f</code> at point preceding <code>xk</code></p>
<p>The rest of the parameters are the same as for <code>scalar_search_wolfe1</code>.</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>stp, f_count, g_count, fval, old_fval
As in <code>line_search_wolfe1</code>
gval : array
Gradient of <code>f</code> at the final point</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search_wolfe2</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">myfprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Find alpha that satisfies strong Wolfe conditions.</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function.
myfprime : callable f'(x,</em>args)
Objective function gradient.
xk : ndarray
Starting point.
pk : ndarray
Search direction.
gfk : ndarray, optional
Gradient value for x=xk (xk being the current parameter
estimate). Will be recomputed if omitted.
old_fval : float, optional
Function value for x=xk. Will be recomputed if omitted.
old_old_fval : float, optional
Function value for the point preceding x=xk
args : tuple, optional
Additional arguments passed to objective function.
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax : float, optional
Maximum step size
extra_condition : callable, optional
A callable of the form <code>extra_condition(alpha, x, f, g)</code>
returning a boolean. Arguments are the proposed step <code>alpha</code>
and the corresponding <code>x</code>, <code>f</code> and <code>g</code> values. The line search
accepts the value of <code>alpha</code> only if this
callable returns <code>True</code>. If the callable returns <code>False</code>
for the step length, the algorithm will continue with
new iterates. The callable is only called for iterates
satisfying the strong Wolfe conditions.
maxiter : int, optional
Maximum number of iterations to perform</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>alpha : float or None
Alpha for which <code>x_new = x0 + alpha * pk</code>,
or None if the line search algorithm did not converge.
fc : int
Number of function evaluations made.
gc : int
Number of gradient evaluations made.
new_fval : float or None
New function value <code>f(x_new)=f(x0+alpha*pk)</code>,
or None if the line search algorithm did not converge.
old_fval : float
Old function value <code>f(x0)</code>.
new_slope : float or None
The local slope along the search direction at the
new value <code>&lt;myfprime(x_new), pk&gt;</code>,
or None if the line search algorithm did not converge.</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p>Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.</p>
<p>For the zoom phase it uses an algorithm by [...].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">main</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>The Rosenbrock function.</p>
<p>The function computed is::</p>
<p>sum(100.0<em>(x[1:] - x[:-1]</em><em>2.0)</em><em>2.0 + (1 - x[:-1])</em>*2.0)</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Rosenbrock function is to be computed.</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>f : float
The value of the Rosenbrock function.</p>
<h2 id="see-also_63">See Also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>rosen_der, rosen_hess, rosen_hess_prod</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen
X = 0.1 * np.arange(10)
rosen(X)
76.56</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_der</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The derivative (i.e. gradient) of the Rosenbrock function.</p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the derivative is to be computed.</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>rosen_der : (N,) ndarray
The gradient of the Rosenbrock function at <code>x</code>.</p>
<h2 id="see-also_64">See Also<a class="headerlink" href="#see-also_64" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_hess, rosen_hess_prod</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_der
X = 0.1 * np.arange(9)
rosen_der(X)
array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_hess</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The Hessian matrix of the Rosenbrock function.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Hessian matrix is to be computed.</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>rosen_hess : ndarray
The Hessian matrix of the Rosenbrock function at <code>x</code>.</p>
<h2 id="see-also_65">See Also<a class="headerlink" href="#see-also_65" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_der, rosen_hess_prod</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_hess
X = 0.1 * np.arange(4)
rosen_hess(X)
array([[-38.,   0.,   0.,   0.],
[  0., 134., -40.,   0.],
[  0., -40., 130., -80.],
[  0.,   0., -80., 200.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_hess_prod</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Product of the Hessian matrix of the Rosenbrock function with a vector.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Hessian matrix is to be computed.
p : array_like
1-D array, the vector to be multiplied by the Hessian matrix.</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>rosen_hess_prod : ndarray
The Hessian matrix of the Rosenbrock function at <code>x</code> multiplied
by the vector <code>p</code>.</p>
<h2 id="see-also_66">See Also<a class="headerlink" href="#see-also_66" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_der, rosen_hess</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_hess_prod
X = 0.1 * np.arange(9)
p = 0.5 * np.arange(9)
rosen_hess_prod(X, p)
array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shape</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="kt">array</span>
</code></pre></div>

<p>Return the shape of an array.</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>shape : tuple of ints
The elements of the shape tuple give the lengths of the
corresponding array dimensions.</p>
<h2 id="see-also_67">See Also<a class="headerlink" href="#see-also_67" title="Permanent link">&para;</a></h2>
<p>alen
ndarray.shape : Equivalent array method.</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.shape(np.eye(3))
(3, 3)
np.shape([[1, 2]])
(1, 2)
np.shape([0])
(1,)
np.shape(0)
()</p>
<p>a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
np.shape(a)
(2,)
a.shape
(2,)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show_options</span> <span class="o">:</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Show documentation for additional options of optimization solvers.</p>
<p>These are method-specific options that can be supplied through the
<code>options</code> dict.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>solver : str
Type of optimization solver. One of 'minimize', 'minimize_scalar',
'root', or 'linprog'.
method : str, optional
If not given, shows all methods of the specified solver. Otherwise,
show only the options for the specified method. Valid values
corresponds to methods' names of respective solver (e.g. 'BFGS' for
'minimize').
disp : bool, optional
Whether to print the result rather than returning it.</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>text
Either None (for disp=True) or the text string (disp=False)</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>The solver-specific methods are:</p>
<p><code>scipy.optimize.minimize</code></p>
<ul>
<li>:ref:<code>Nelder-Mead &lt;optimize.minimize-neldermead&gt;</code></li>
<li>:ref:<code>Powell      &lt;optimize.minimize-powell&gt;</code></li>
<li>:ref:<code>CG          &lt;optimize.minimize-cg&gt;</code></li>
<li>:ref:<code>BFGS        &lt;optimize.minimize-bfgs&gt;</code></li>
<li>:ref:<code>Newton-CG   &lt;optimize.minimize-newtoncg&gt;</code></li>
<li>:ref:<code>L-BFGS-B    &lt;optimize.minimize-lbfgsb&gt;</code></li>
<li>:ref:<code>TNC         &lt;optimize.minimize-tnc&gt;</code></li>
<li>:ref:<code>COBYLA      &lt;optimize.minimize-cobyla&gt;</code></li>
<li>:ref:<code>SLSQP       &lt;optimize.minimize-slsqp&gt;</code></li>
<li>:ref:<code>dogleg      &lt;optimize.minimize-dogleg&gt;</code></li>
<li>:ref:<code>trust-ncg   &lt;optimize.minimize-trustncg&gt;</code></li>
</ul>
<p><code>scipy.optimize.root</code></p>
<ul>
<li>:ref:<code>hybr              &lt;optimize.root-hybr&gt;</code></li>
<li>:ref:<code>lm                &lt;optimize.root-lm&gt;</code></li>
<li>:ref:<code>broyden1          &lt;optimize.root-broyden1&gt;</code></li>
<li>:ref:<code>broyden2          &lt;optimize.root-broyden2&gt;</code></li>
<li>:ref:<code>anderson          &lt;optimize.root-anderson&gt;</code></li>
<li>:ref:<code>linearmixing      &lt;optimize.root-linearmixing&gt;</code></li>
<li>:ref:<code>diagbroyden       &lt;optimize.root-diagbroyden&gt;</code></li>
<li>:ref:<code>excitingmixing    &lt;optimize.root-excitingmixing&gt;</code></li>
<li>:ref:<code>krylov            &lt;optimize.root-krylov&gt;</code></li>
<li>:ref:<code>df-sane           &lt;optimize.root-dfsane&gt;</code></li>
</ul>
<p><code>scipy.optimize.minimize_scalar</code></p>
<ul>
<li>:ref:<code>brent       &lt;optimize.minimize_scalar-brent&gt;</code></li>
<li>:ref:<code>golden      &lt;optimize.minimize_scalar-golden&gt;</code></li>
<li>:ref:<code>bounded     &lt;optimize.minimize_scalar-bounded&gt;</code></li>
</ul>
<p><code>scipy.optimize.linprog</code></p>
<ul>
<li>:ref:<code>simplex         &lt;optimize.linprog-simplex&gt;</code></li>
<li>:ref:<code>interior-point  &lt;optimize.linprog-interior-point&gt;</code></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_68">See Also<a class="headerlink" href="#see-also_68" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">squeeze</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove single-dimensional entries from the shape of an array.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
.. versionadded:: 1.7.0</p>
<p>Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>squeezed : ndarray
The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <code>a</code> itself
or a view into <code>a</code>.</p>
<h2 id="raises_18">Raises<a class="headerlink" href="#raises_18" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>axis</code> is not None, and an axis being squeezed is not of length 1</p>
<h2 id="see-also_69">See Also<a class="headerlink" href="#see-also_69" title="Permanent link">&para;</a></h2>
<p>expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[[0], [1], [2]]])
x.shape
(1, 3, 1)
np.squeeze(x).shape
(3,)
np.squeeze(x, axis=0).shape
(3, 1)
np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
np.squeeze(x, axis=2).shape
(1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vecnorm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wrap_function</span> <span class="o">:</span> <span class="n">function_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_70">See Also<a class="headerlink" href="#see-also_70" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Slsqp</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Finfo</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Finfo</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Finfo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>finfo(dtype)</p>
<p>Machine limits for floating point types.</p>
<h2 id="attributes_5">Attributes<a class="headerlink" href="#attributes_5" title="Permanent link">&para;</a></h2>
<p>bits : int
The number of bits occupied by the type.
eps : float
The smallest representable positive number such that
<code>1.0 + eps != 1.0</code>.  Type of <code>eps</code> is an appropriate floating
point type.
epsneg : floating point number of the appropriate type
The smallest representable positive number such that
<code>1.0 - epsneg != 1.0</code>.
iexp : int
The number of bits in the exponent portion of the floating point
representation.
machar : MachAr
The object which calculated these parameters and holds more
detailed information.
machep : int
The exponent that yields <code>eps</code>.
max : floating point number of the appropriate type
The largest representable number.
maxexp : int
The smallest positive power of the base (2) that causes overflow.
min : floating point number of the appropriate type
The smallest representable number, typically <code>-max</code>.
minexp : int
The most negative power of the base (2) consistent with there
being no leading 0's in the mantissa.
negep : int
The exponent that yields <code>epsneg</code>.
nexp : int
The number of bits in the exponent including its sign and bias.
nmant : int
The number of bits in the mantissa.
precision : int
The approximate number of decimal digits to which this kind of
float is precise.
resolution : floating point number of the appropriate type
The approximate decimal resolution of this type, i.e.,
<code>10**-precision</code>.
tiny : float
The smallest positive usable number.  Type of <code>tiny</code> is an
appropriate floating point type.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>dtype : float, dtype, or instance
Kind of floating point data-type about which to get information.</p>
<h2 id="see-also_71">See Also<a class="headerlink" href="#see-also_71" title="Permanent link">&para;</a></h2>
<p>MachAr : The implementation of the tests that produce this information.
iinfo : The equivalent for integer data types.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling <code>finfo()</code>
repeatedly inside your functions is not a problem.</p>
<p>Attribute bits: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bits</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute bits: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bits_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute eps: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eps</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute eps: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eps_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute epsneg: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">epsneg</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute epsneg: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">epsneg_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute iexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute iexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute machar: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machar</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute machar: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machar_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute machep: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machep</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute machep: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">machep_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute max: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute max: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute maxexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute maxexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute min: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute min: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute minexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute minexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute negep: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">negep</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute negep: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">negep_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nexp: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nexp</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute nexp: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nexp_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute nmant: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nmant</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute nmant: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nmant_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute precision: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">precision</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute precision: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">precision_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute resolution: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resolution</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute resolution: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resolution_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute tiny: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tiny</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute tiny: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tiny_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">append</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">arr</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Append values to the end of an array.</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>arr : array_like
Values are appended to a copy of this array.
values : array_like
These values are appended to a copy of <code>arr</code>.  It must be of the
correct shape (the same shape as <code>arr</code>, excluding <code>axis</code>).  If
<code>axis</code> is not specified, <code>values</code> can be any shape and will be
flattened before use.
axis : int, optional
The axis along which <code>values</code> are appended.  If <code>axis</code> is not
given, both <code>arr</code> and <code>values</code> are flattened before use.</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>append : ndarray
A copy of <code>arr</code> with <code>values</code> appended to <code>axis</code>.  Note that
<code>append</code> does not occur in-place: a new array is allocated and
filled.  If <code>axis</code> is None, <code>out</code> is a flattened array.</p>
<h2 id="see-also_72">See Also<a class="headerlink" href="#see-also_72" title="Permanent link">&para;</a></h2>
<p>insert : Insert elements into an array.
delete : Delete elements from an array.</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>axis</code> is specified, <code>values</code> must have the correct shape.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
...
ValueError: all the input arrays must have same number of dimensions</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">approx_jacobian</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Approximate the Jacobian matrix of a callable function.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>x : array_like
The state vector at which to compute the Jacobian matrix.
func : callable f(x,*args)
The vector-valued function.
epsilon : float
The perturbation used to determine the partial derivatives.
args : sequence
Additional arguments passed to func.</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>An array of dimensions <code>(lenf, lenx)</code> where <code>lenf</code> is the length
of the outputs of <code>func</code>, and <code>lenx</code> is the number of elements in
<code>x</code>.</p>
<h2 id="notes_62">Notes<a class="headerlink" href="#notes_62" title="Permanent link">&para;</a></h2>
<p>The approximation is done using forward differences.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_73">See Also<a class="headerlink" href="#see-also_73" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_63">Notes<a class="headerlink" href="#notes_63" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array converted to a float type.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>a : array_like
The input array.
dtype : str or dtype object, optional
Float type code to coerce input array <code>a</code>.  If <code>dtype</code> is one of the
'int' dtypes, it is replaced with float64.</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The input <code>a</code> as a float ndarray.</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.asfarray([2, 3])
array([2.,  3.])
np.asfarray([2, 3], dtype='float')
array([2.,  3.])
np.asfarray([2, 3], dtype='int8')
array([2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also_74">See Also<a class="headerlink" href="#see-also_74" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">concatenate</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>concatenate((a1, a2, ...), axis=0, out=None)</p>
<p>Join a sequence of arrays along an existing axis.</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>a1, a2, ... : sequence of array_like
The arrays must have the same shape, except in the dimension
corresponding to <code>axis</code> (the first, by default).
axis : int, optional
The axis along which the arrays will be joined.  If axis is None,
arrays are flattened before use.  Default is 0.
out : ndarray, optional
If provided, the destination to place the result. The shape must be
correct, matching that of what concatenate would have returned if no
out argument were specified.</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The concatenated array.</p>
<h2 id="see-also_75">See Also<a class="headerlink" href="#see-also_75" title="Permanent link">&para;</a></h2>
<p>ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)
block : Assemble arrays from blocks.</p>
<h2 id="notes_64">Notes<a class="headerlink" href="#notes_64" title="Permanent link">&para;</a></h2>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])
np.concatenate((a, b), axis=0)
array([[1, 2],
[3, 4],
[5, 6]])
np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
[3, 4, 6]])
np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.ma.arange(3)
a[1] = np.ma.masked
b = np.arange(2, 5)
a
masked_array(data=[0, --, 2],
mask=[False,  True, False],
fill_value=999999)
b
array([2, 3, 4])
np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
mask=False,
fill_value=999999)
np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
mask=[False,  True, False, False, False, False],
fill_value=999999)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise exponential of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_76">See Also<a class="headerlink" href="#see-also_76" title="Permanent link">&para;</a></h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array.
exp2  : Calculate <code>2**x</code> for all elements in the array.</p>
<h2 id="notes_65">Notes<a class="headerlink" href="#notes_65" title="Permanent link">&para;</a></h2>
<p>The irrational number <code>e</code> is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>,
then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write
:math:<code>e^x = e^a e^{ib}</code>.  The first term, :math:<code>e^a</code>, is already
known (it is the real argument, described above).  The second term,
:math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with
magnitude 1 and a periodic phase.</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Exponential function',
https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
http://www.math.sfu.ca/~cbm/aands/page_69.htm</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-2<em>np.pi, 2</em>np.pi, 100)
xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
out = np.exp(xx)</p>
<p>plt.subplot(121)
plt.imshow(np.abs(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='gray')
plt.title('Magnitude of exp(x)')</p>
<p>plt.subplot(122)
plt.imshow(np.angle(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='hsv')
plt.title('Phase (angle) of exp(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_slsqp</span> <span class="o">:</span> <span class="o">?</span><span class="n">eqcons</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_eqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ieqcons</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_ieqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime_eqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime_ieqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">acc</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iprint</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using Sequential Least SQuares Programming</p>
<p>Python interface function for the SLSQP Optimization subroutine
originally implemented by Dieter Kraft.</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,<em>args)
Objective function.  Must return a scalar.
x0 : 1-D ndarray of float
Initial guess for the independent variable(s).
eqcons : list, optional
A list of functions of length n such that
eqcons<a href="x,*args">j</a> == 0.0 in a successfully optimized
problem.
f_eqcons : callable f(x,</em>args), optional
Returns a 1-D array in which each element must equal 0.0 in a
successfully optimized problem.  If f_eqcons is specified,
eqcons is ignored.
ieqcons : list, optional
A list of functions of length n such that
ieqcons<a href="x,*args">j</a> &gt;= 0.0 in a successfully optimized
problem.
f_ieqcons : callable f(x,*args), optional
Returns a 1-D ndarray in which each element must be greater or
equal to 0.0 in a successfully optimized problem.  If
f_ieqcons is specified, ieqcons is ignored.
bounds : list, optional
A list of tuples specifying the lower and upper bound
for each independent variable [(xl0, xu0),(xl1, xu1),...]
Infinite values will be interpreted as large floating values.
fprime : callable <code>f(x,*args)</code>, optional
A function that evaluates the partial derivatives of func.
fprime_eqcons : callable <code>f(x,*args)</code>, optional
A function of the form <code>f(x, *args)</code> that returns the m by n
array of equality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_eqcons should be sized as ( len(eqcons), len(x0) ).
fprime_ieqcons : callable <code>f(x,*args)</code>, optional
A function of the form <code>f(x, *args)</code> that returns the m by n
array of inequality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).
args : sequence, optional
Additional arguments passed to func and fprime.
iter : int, optional
The maximum number of iterations.
acc : float, optional
Requested accuracy.
iprint : int, optional
The verbosity of fmin_slsqp :</p>
<ul>
<li>iprint &lt;= 0 : Silent operation</li>
<li>iprint == 1 : Print summary upon completion (default)</li>
<li>iprint &gt;= 2 : Print status of each iterate and summary
disp : int, optional
Over-rides the iprint interface (preferred).
full_output : bool, optional
If False, return only the minimizer of func (default).
Otherwise, output final objective function and summary
information.
epsilon : float, optional
The step size for finite-difference derivative estimates.
callback : callable, optional
Called after each iteration, as <code>callback(x)</code>, where <code>x</code> is the
current parameter vector.</li>
</ul>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>out : ndarray of float
The final minimizer of func.
fx : ndarray of float, if full_output is true
The final value of the objective function.
its : int, if full_output is true
The number of iterations.
imode : int, if full_output is true
The exit mode from the optimizer (see below).
smode : string, if full_output is true
Message describing the exit mode from the optimizer.</p>
<h2 id="see-also_77">See also<a class="headerlink" href="#see-also_77" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'SLSQP' <code>method</code> in particular.</p>
<h2 id="notes_66">Notes<a class="headerlink" href="#notes_66" title="Permanent link">&para;</a></h2>
<p>Exit modes are defined as follows ::</p>
<p>-1 : Gradient evaluation required (g &amp; a)
0 : Optimization terminated successfully.
1 : Function evaluation required (f &amp; c)
2 : More equality constraints than independent variables
3 : More than 3*n iterations in LSQ subproblem
4 : Inequality constraints incompatible
5 : Singular matrix E in LSQ subproblem
6 : Singular matrix C in LSQ subproblem
7 : Rank-deficient equality constraint subproblem HFTI
8 : Positive directional derivative for linesearch
9 : Iteration limit exceeded</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<p>Examples are given :ref:<code>in the tutorial &lt;tutorial-sqlsp&gt;</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>y : ndarray, bool
True where <code>x</code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_78">See Also<a class="headerlink" href="#see-also_78" title="Permanent link">&para;</a></h2>
<p>isinf, isneginf, isposinf, isnan</p>
<h2 id="notes_67">Notes<a class="headerlink" href="#notes_67" title="Permanent link">&para;</a></h2>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <code>x</code> is a scalar input, or if
first and second arguments have different shapes.</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.isfinite(1)
True
np.isfinite(0)
True
np.isfinite(np.nan)
False
np.isfinite(np.inf)
False
np.isfinite(np.NINF)
False
np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])</p>
<p>x = np.array([-np.inf, 0., np.inf])
y = np.array([2, 2, 2])
np.isfinite(x, y)
array([0, 1, 0])
y
array([0, 1, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_79">See Also<a class="headerlink" href="#see-also_79" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_68">Notes<a class="headerlink" href="#notes_68" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vstack</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <code>(N,)</code> have been reshaped to <code>(1,N)</code>. Rebuilds arrays divided by
<code>vsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and
<code>block</code> provide more general stacking and concatenation operations.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>tup : sequence of ndarrays
The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>stacked : ndarray
The array formed by stacking the given arrays, will be at least 2-D.</p>
<h2 id="see-also_80">See Also<a class="headerlink" href="#see-also_80" title="Permanent link">&para;</a></h2>
<p>stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.
block : Assemble arrays from blocks.</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2, 3])
b = np.array([2, 3, 4])
np.vstack((a,b))
array([[1, 2, 3],
[2, 3, 4]])</p>
<p>a = np.array([[1], [2], [3]])
b = np.array([[2], [3], [4]])
np.vstack((a,b))
array([[1],
[2],
[3],
[2],
[3],
[4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wrap_function</span> <span class="o">:</span> <span class="n">function_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_81">See Also<a class="headerlink" href="#see-also_81" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Tnc</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">MemoizeJac</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MemoizeJac</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MemoizeJac</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Decorator that caches the value gradient of function each time it
is called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">derivative</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">approx_fprime</span> <span class="o">:</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">epsilon</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finite-difference approximation of the gradient of a scalar function.</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>xk : array_like
The coordinate vector at which to determine the gradient of <code>f</code>.
f : callable
The function of which to determine the gradient (partial derivatives).
Should take <code>xk</code> as first argument, other arguments to <code>f</code> can be
supplied in <code>*args</code>.  Should return a scalar, the value of the
function at <code>xk</code>.
epsilon : array_like
Increment to <code>xk</code> to use for determining the function gradient.
If a scalar, uses the same finite difference delta for all partial
derivatives.  If an array, should contain one value per element of
<code>xk</code>.
*args : args, optional
Any other arguments that are to be passed to <code>f</code>.</p>
<h2 id="returns_116">Returns<a class="headerlink" href="#returns_116" title="Permanent link">&para;</a></h2>
<p>grad : ndarray
The partial derivatives of <code>f</code> to <code>xk</code>.</p>
<h2 id="see-also_82">See Also<a class="headerlink" href="#see-also_82" title="Permanent link">&para;</a></h2>
<p>check_grad : Check correctness of gradient function against approx_fprime.</p>
<h2 id="notes_69">Notes<a class="headerlink" href="#notes_69" title="Permanent link">&para;</a></h2>
<p>The function gradient is determined by the forward finite difference
formula::</p>
<p>f(xk[i] + epsilon[i]) - f(xk[i])
f'[i] = ---------------------------------
epsilon[i]</p>
<p>The main use of <code>approx_fprime</code> is in scalar function optimizers like
<code>fmin_bfgs</code>, to determine numerically the Jacobian of a function.</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def func(x, c0, c1):
...     'Coordinate vector <code>x</code> should be an array of size two.'
...     return c0 * x[0]<strong>2 + c1*x[1]</strong>2</p>
<p>x = np.ones(2)
c0, c1 = (1, 200)
eps = np.sqrt(np.finfo(float).eps)
optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
array([   2.        ,  400.00004198])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_117">Returns<a class="headerlink" href="#returns_117" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_83">See Also<a class="headerlink" href="#see-also_83" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_70">Notes<a class="headerlink" href="#notes_70" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asfarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array converted to a float type.</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>a : array_like
The input array.
dtype : str or dtype object, optional
Float type code to coerce input array <code>a</code>.  If <code>dtype</code> is one of the
'int' dtypes, it is replaced with float64.</p>
<h2 id="returns_118">Returns<a class="headerlink" href="#returns_118" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The input <code>a</code> as a float ndarray.</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.asfarray([2, 3])
array([2.,  3.])
np.asfarray([2, 3], dtype='float')
array([2.,  3.])
np.asfarray([2, 3], dtype='int8')
array([2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_tnc</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">approx_grad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">offset</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">messages</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxCGit</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stepmx</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">accuracy</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fmin</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pgtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rescale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function with variables subject to bounds, using
gradient information in a truncated Newton algorithm. This
method wraps a C implementation of the algorithm.</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>func : callable <code>func(x, *args)</code>
Function to minimize.  Must do one of:</p>
<ol>
<li>
<p>Return f and g, where f is the value of the function and g its
gradient (a list of floats).</p>
</li>
<li>
<p>Return the function value but supply gradient function
separately as <code>fprime</code>.</p>
</li>
<li>
<p>Return the function value and set <code>approx_grad=True</code>.</p>
</li>
</ol>
<p>If the function returns None, the minimization
is aborted.
x0 : array_like
Initial estimate of minimum.
fprime : callable <code>fprime(x, *args)</code>, optional
Gradient of <code>func</code>. If None, then either <code>func</code> must return the
function value and the gradient (<code>f,g = func(x, *args)</code>)
or <code>approx_grad</code> must be True.
args : tuple, optional
Arguments to pass to function.
approx_grad : bool, optional
If true, approximate the gradient numerically.
bounds : list, optional
(min, max) pairs for each element in x0, defining the
bounds on that parameter. Use None or +/-inf for one of
min or max when there is no bound in that direction.
epsilon : float, optional
Used if approx_grad is True. The stepsize in a finite
difference approximation for fprime.
scale : array_like, optional
Scaling factors to apply to each variable.  If None, the
factors are up-low for interval bounded variables and
1+|x| for the others.  Defaults to None.
offset : array_like, optional
Value to subtract from each variable.  If None, the
offsets are (up+low)/2 for interval bounded variables
and x for the others.
messages : int, optional
Bit mask used to select messages display during
minimization values defined in the MSGS dict.  Defaults to
MGS_ALL.
disp : int, optional
Integer interface to messages.  0 = no message, 5 = all messages
maxCGit : int, optional
Maximum number of hessian<em>vector evaluations per main
iteration.  If maxCGit == 0, the direction chosen is
-gradient if maxCGit &lt; 0, maxCGit is set to
max(1,min(50,n/2)).  Defaults to -1.
maxfun : int, optional
Maximum number of function evaluation.  if None, maxfun is
set to max(100, 10</em>len(x0)).  Defaults to None.
eta : float, optional
Severity of the line search. if &lt; 0 or &gt; 1, set to 0.25.
Defaults to -1.
stepmx : float, optional
Maximum step for the line search.  May be increased during
call.  If too small, it will be set to 10.0.  Defaults to 0.
accuracy : float, optional
Relative precision for finite difference calculations.  If
&lt;= machine_precision, set to sqrt(machine_precision).
Defaults to 0.
fmin : float, optional
Minimum function value estimate.  Defaults to 0.
ftol : float, optional
Precision goal for the value of f in the stopping criterion.
If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1.
xtol : float, optional
Precision goal for the value of x in the stopping
criterion (after applying x scaling factors).  If xtol &lt;
0.0, xtol is set to sqrt(machine_precision).  Defaults to
-1.
pgtol : float, optional
Precision goal for the value of the projected gradient in
the stopping criterion (after applying x scaling factors).
If pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy).
Setting it to 0.0 is not recommended.  Defaults to -1.
rescale : float, optional
Scaling factor (in log10) used to trigger f value
rescaling.  If 0, rescale at each iteration.  If a large
value, never rescale.  If &lt; 0, rescale is set to 1.3.
callback : callable, optional
Called after each iteration, as callback(xk), where xk is the
current parameter vector.</p>
<h2 id="returns_119">Returns<a class="headerlink" href="#returns_119" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution.
nfeval : int
The number of function evaluations.
rc : int
Return code, see below</p>
<h2 id="see-also_84">See also<a class="headerlink" href="#see-also_84" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'TNC' <code>method</code> in particular.</p>
<h2 id="notes_71">Notes<a class="headerlink" href="#notes_71" title="Permanent link">&para;</a></h2>
<p>The underlying algorithm is truncated Newton, also called
Newton Conjugate-Gradient. This method differs from
scipy.optimize.fmin_ncg in that</p>
<ol>
<li>It wraps a C implementation of the algorithm</li>
<li>It allows each variable to be given an upper and lower bound.</li>
</ol>
<p>The algorithm incorporates the bound constraints by determining
the descent direction as in an unconstrained truncated Newton,
but never taking a step-size large enough to leave the space
of feasible x's. The algorithm keeps track of a set of
currently active constraints, and ignores them when computing
the minimum allowable step size. (The x's associated with the
active constraint are kept fixed.) If the maximum allowable
step size is zero then a new constraint is added. At the end
of each iteration one of the constraints may be deemed no
longer active and removed. A constraint is considered
no longer active is if it is currently active
but the gradient for that variable points inward from the
constraint. The specific constraint removed is the one
associated with the variable of largest index whose
constraint is no longer active.</p>
<p>Return codes are defined as follows::</p>
<p>-1 : Infeasible (lower bound &gt; upper bound)
0 : Local minimum reached (|pg| ~= 0)
1 : Converged (|f_n-f_(n-1)| ~= 0)
2 : Converged (|x_n-x_(n-1)| ~= 0)
3 : Max. number of function evaluations reached
4 : Linear search failed
5 : All lower bounds are equal to the upper bounds
6 : Unable to progress
7 : User requested end of minimization</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>Wright S., Nocedal J. (2006), 'Numerical Optimization'</p>
<p>Nash S.G. (1984), 'Newton-Type Minimization Via the Lanczos Method',
SIAM Journal of Numerical Analysis 21, pp. 770-778</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_120">Returns<a class="headerlink" href="#returns_120" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_85">See Also<a class="headerlink" href="#see-also_85" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Zeros</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">TOMS748Solver</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">TOMS748Solver</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">TOMS748Solver</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Solve f(x, *args) == 0 using Algorithm748 of Alefeld, Potro &amp; Shi.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">configure</span> <span class="o">:</span> <span class="n">xtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">disp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_result</span> <span class="o">:</span> <span class="o">?</span><span class="n">flag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Package the result and statistics into a tuple.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_status</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Determine the current status.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterate</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform one step in the algorithm.</p>
<p>Implements Algorithm 4.1(k=1) or 4.2(k=2) in [APS1995]</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve f(x) = 0 given an interval containing a zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">start</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Prepare for the iterations.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">bisect</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find root of a function within an interval using bisection.</p>
<p>Basic bisection routine to find a zero of the function <code>f</code> between the
arguments <code>a</code> and <code>b</code>. <code>f(a)</code> and <code>f(b)</code> cannot have the same signs.
Slow but sure.</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  <code>f</code> must be continuous, and
f(a) and f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where x is the root, and r is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in a <code>RootResults</code>
return object.</p>
<h2 id="returns_121">Returns<a class="headerlink" href="#returns_121" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.bisect(f, 0, 2)
root
1.0</p>
<p>root = optimize.bisect(f, -2, 0)
root
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_86">See Also<a class="headerlink" href="#see-also_86" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brenth</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in a bracketing interval using Brent's
method with hyperbolic extrapolation.</p>
<p>A variation on the classic Brent routine to find a zero of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. There was a paper back in the 1980's ...
f(a) and f(b) cannot have the same signs. Generally on a par with the
brent routine, but not as heavily tested.  It is a safe version of the
secant method that uses hyperbolic extrapolation. The version here is by
Chuck Harris.</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative. As with <code>brentq</code>, for nice
functions the method will often satisfy the above condition
with <code>xtol/2</code> and <code>rtol/2</code>.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>. As with <code>brentq</code>, for nice functions
the method will often satisfy the above condition with
<code>xtol/2</code> and <code>rtol/2</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_122">Returns<a class="headerlink" href="#returns_122" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.brenth(f, -2, 0)
root
-1.0</p>
<p>root = optimize.brenth(f, 0, 2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_87">See Also<a class="headerlink" href="#see-also_87" title="Permanent link">&para;</a></h2>
<p>fmin, fmin_powell, fmin_cg,
fmin_bfgs, fmin_ncg : multivariate local optimizers</p>
<p>leastsq : nonlinear least squares minimizer</p>
<p>fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers</p>
<p>basinhopping, differential_evolution, brute : global optimizers</p>
<p>fminbound, brent, golden, bracket : local scalar minimizers</p>
<p>fsolve : n-dimensional root-finding</p>
<p>brentq, brenth, ridder, bisect, newton : one-dimensional root-finding</p>
<p>fixed_point : scalar fixed-point finder</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brentq</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in a bracketing interval using Brent's method.</p>
<p>Uses the classic Brent's method to find a zero of the function <code>f</code> on
the sign changing interval [a , b].  Generally considered the best of the
rootfinding routines here.  It is a safe version of the secant method that
uses inverse quadratic extrapolation.  Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation.  It is
sometimes known as the van Wijngaarden-Dekker-Brent method.  Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].</p>
<p>[Brent1973]<em> provides the classic description of the algorithm.  Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]</em>.  A third description is at
http://mathworld.wolfram.com/BrentsMethod.html.  It should be easy to
understand the algorithm just by reading our code.  Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  The function :math:<code>f</code>
must be continuous, and :math:<code>f(a)</code> and :math:<code>f(b)</code> must
have opposite signs.
a : scalar
One end of the bracketing interval :math:<code>[a, b]</code>.
b : scalar
The other end of the bracketing interval :math:<code>[a, b]</code>.
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative. For nice functions, Brent's
method will often satisfy the above condition with <code>xtol/2</code>
and <code>rtol/2</code>. [Brent1973]<em>
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>. For nice functions, Brent's
method will often satisfy the above condition with <code>xtol/2</code>
and <code>rtol/2</code>. [Brent1973]</em>
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_123">Returns<a class="headerlink" href="#returns_123" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="notes_72">Notes<a class="headerlink" href="#notes_72" title="Permanent link">&para;</a></h2>
<p><code>f</code> must be continuous.  f(a) and f(b) must have opposite signs.</p>
<p>Related functions fall into several classes:</p>
<p>multivariate local optimizers
<code>fmin</code>, <code>fmin_powell</code>, <code>fmin_cg</code>, <code>fmin_bfgs</code>, <code>fmin_ncg</code>
nonlinear least squares minimizer
<code>leastsq</code>
constrained multivariate optimizers
<code>fmin_l_bfgs_b</code>, <code>fmin_tnc</code>, <code>fmin_cobyla</code>
global optimizers
<code>basinhopping</code>, <code>brute</code>, <code>differential_evolution</code>
local scalar minimizers
<code>fminbound</code>, <code>brent</code>, <code>golden</code>, <code>bracket</code>
n-dimensional root-finding
<code>fsolve</code>
one-dimensional root-finding
<code>brenth</code>, <code>ridder</code>, <code>bisect</code>, <code>newton</code>
scalar fixed-point finder
<code>fixed_point</code></p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [Brent1973]
Brent, R. P.,
<em>Algorithms for Minimization Without Derivatives</em>.
Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.</p>
<p>.. [PressEtal1992]
Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
<em>Numerical Recipes in FORTRAN: The Art of Scientific Computing</em>, 2nd ed.
Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
Section 9.3:  'Van Wijngaarden-Dekker-Brent Method.'</p>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.brentq(f, -2, 0)
root
-1.0</p>
<p>root = optimize.brentq(f, 0, 2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">namedtuple</span> <span class="o">:</span> <span class="o">?</span><span class="n">rename</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">defaults</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">module_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">typename</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">field_names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a new subclass of tuple with named fields.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Point = namedtuple('Point', ['x', 'y'])
Point.<strong>doc</strong>                   # docstring for the new class
'Point(x, y)'
p = Point(11, y=22)             # instantiate with positional args or keywords
p[0] + p[1]                     # indexable like a plain tuple
33
x, y = p                        # unpack like a regular tuple
x, y
(11, 22)
p.x + p.y                       # fields also accessible by name
33
d = p._asdict()                 # convert to a dictionary
d['x']
11
Point( **d)                      # convert from a dictionary
Point(x=11, y=22)
p._replace(x=100)               # _replace() is like str.replace() but targets named fields
Point(x=100, y=22)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newton</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a zero of a real or complex function using the Newton-Raphson
(or secant or Halley's) method.</p>
<p>Find a zero of the function <code>func</code> given a nearby starting point <code>x0</code>.
The Newton-Raphson method is used if the derivative <code>fprime</code> of <code>func</code>
is provided, otherwise the secant method is used.  If the second order
derivative <code>fprime2</code> of <code>func</code> is also provided, then Halley's method is
used.</p>
<p>If <code>x0</code> is a sequence with more than one item, then <code>newton</code> returns an
array, and <code>func</code> must be vectorized and return a sequence or array of the
same shape as its first argument. If <code>fprime</code> or <code>fprime2</code> is given then
its return must also have the same shape.</p>
<h2 id="parameters_142">Parameters<a class="headerlink" href="#parameters_142" title="Permanent link">&para;</a></h2>
<p>func : callable
The function whose zero is wanted. It must be a function of a
single variable of the form <code>f(x,a,b,c...)</code>, where <code>a,b,c...</code>
are extra arguments that can be passed in the <code>args</code> parameter.
x0 : float, sequence, or ndarray
An initial estimate of the zero that should be somewhere near the
actual zero. If not scalar, then <code>func</code> must be vectorized and return
a sequence or array of the same shape as its first argument.
fprime : callable, optional
The derivative of the function when available and convenient. If it
is None (default), then the secant method is used.
args : tuple, optional
Extra arguments to be used in the function call.
tol : float, optional
The allowable error of the zero value.  If <code>func</code> is complex-valued,
a larger <code>tol</code> is recommended as both the real and imaginary parts
of <code>x</code> contribute to <code>|x - x0|</code>.
maxiter : int, optional
Maximum number of iterations.
fprime2 : callable, optional
The second order derivative of the function when available and
convenient. If it is None (default), then the normal Newton-Raphson
or the secant method is used. If it is not None, then Halley's method
is used.
x1 : float, optional
Another estimate of the zero that should be somewhere near the
actual zero.  Used if <code>fprime</code> is not provided.
rtol : float, optional
Tolerance (relative) for termination.
full_output : bool, optional
If <code>full_output</code> is False (default), the root is returned.
If True and <code>x0</code> is scalar, the return value is <code>(x, r)</code>, where <code>x</code>
is the root and <code>r</code> is a <code>RootResults</code> object.
If True and <code>x0</code> is non-scalar, the return value is <code>(x, converged,
zero_der)</code> (see Returns section for details).
disp : bool, optional
If True, raise a RuntimeError if the algorithm didn't converge, with
the error message containing the number of iterations and current
function value.  Otherwise the convergence status is recorded in a
<code>RootResults</code> return object.
Ignored if <code>x0</code> is not scalar.
<em>Note: this has little to do with displaying, however
the <code>disp</code> keyword cannot be renamed for backwards compatibility.</em></p>
<h2 id="returns_124">Returns<a class="headerlink" href="#returns_124" title="Permanent link">&para;</a></h2>
<p>root : float, sequence, or ndarray
Estimated location where function is zero.
r : <code>RootResults</code>, optional
Present if <code>full_output=True</code> and <code>x0</code> is scalar.
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.
converged : ndarray of bool, optional
Present if <code>full_output=True</code> and <code>x0</code> is non-scalar.
For vector functions, indicates which elements converged successfully.
zero_der : ndarray of bool, optional
Present if <code>full_output=True</code> and <code>x0</code> is non-scalar.
For vector functions, indicates which elements had a zero derivative.</p>
<h2 id="see-also_88">See Also<a class="headerlink" href="#see-also_88" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, ridder, bisect
fsolve : find zeros in n dimensions.</p>
<h2 id="notes_73">Notes<a class="headerlink" href="#notes_73" title="Permanent link">&para;</a></h2>
<p>The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic.  This means that if the function is well behaved
the actual error in the estimated zero after the n-th iteration
is approximately the square (cube for Halley) of the error
after the (n-1)-th step.  However, the stopping criterion used
here is the step size and there is no guarantee that a zero
has been found. Consequently the result should be verified.
Safer algorithms are brentq, brenth, ridder, and bisect,
but they all require that the root first be bracketed in an
interval where the function changes sign. The brentq algorithm
is recommended for general use in one dimensional problems
when such an interval has been found.</p>
<p>When <code>newton</code> is used with arrays, it is best suited for the following
types of problems:</p>
<ul>
<li>The initial guesses, <code>x0</code>, are all relatively the same distance from
the roots.</li>
<li>Some or all of the extra arguments, <code>args</code>, are also arrays so that a
class of similar problems can be solved together.</li>
<li>The size of the initial guesses, <code>x0</code>, is larger than O(100) elements.
Otherwise, a naive loop may perform as well or better than a vector.</li>
</ul>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
import matplotlib.pyplot as plt</p>
<p>def f(x):
...     return (x**3 - 1)  # only one real root at x = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>fprime</code> is not provided, use the secant method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5)
root
1.0000000000000016
root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)
root
1.0000000000000016</p>
</blockquote>
</blockquote>
</blockquote>
<p>Only <code>fprime</code> is provided, use the Newton-Raphson method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Both <code>fprime2</code> and <code>fprime</code> are provided, use Halley's method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,
...                        fprime2=lambda x: 6 * x)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>When we want to find zeros for a set of related starting values and/or
function parameters, we can provide both of those as an array of inputs:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = lambda x, a: x<strong>3 - a
fder = lambda x, a: 3 * x</strong>2
np.random.seed(4321)
x = np.random.randn(100)
a = np.arange(-50, 50)
vec_res = optimize.newton(f, x, fprime=fder, args=(a, ))</p>
</blockquote>
</blockquote>
</blockquote>
<p>The above is the equivalent of solving for each value in <code>(x, a)</code>
separately in a for-loop, just faster:</p>
<blockquote>
<blockquote>
<blockquote>
<p>loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,))
...             for x0, a0 in zip(x, a)]
np.allclose(vec_res, loop_res)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the results found for all values of <code>a</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>analytical_result = np.sign(a) * np.abs(a)**(1/3)
fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(a, analytical_result, 'o')
ax.plot(a, vec_res, '.')
ax.set_xlabel('<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>')
ax.set_ylabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> where <span><span class="MathJax_Preview">f(x, a)=0</span><script type="math/tex">f(x, a)=0</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">results_c</span> <span class="o">:</span> <span class="n">full_output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridder</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in an interval using Ridder's method.</p>
<h2 id="parameters_143">Parameters<a class="headerlink" href="#parameters_143" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_125">Returns<a class="headerlink" href="#returns_125" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.
In particular, <code>r.converged</code> is True if the routine converged.</p>
<h2 id="see-also_89">See Also<a class="headerlink" href="#see-also_89" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, bisect, newton : one-dimensional root-finding
fixed_point : scalar fixed-point finder</p>
<h2 id="notes_74">Notes<a class="headerlink" href="#notes_74" title="Permanent link">&para;</a></h2>
<p>Uses [Ridders1979]<em> method to find a zero of the function <code>f</code> between the
arguments <code>a</code> and <code>b</code>. Ridders' method is faster than bisection, but not
generally as fast as the Brent routines. [Ridders1979]</em> provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.</p>
<p>The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [Ridders1979]
Ridders, C. F. J. 'A New Algorithm for Computing a
Single Root of a Real Continuous Function.'
IEEE Trans. Circuits Systems 26, 979-980, 1979.</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.ridder(f, 0, 2)
root
1.0</p>
<p>root = optimize.ridder(f, -2, 0)
root
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toms748</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a zero using TOMS Algorithm 748 method.</p>
<p>Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a
zero of the function <code>f</code> on the interval <code>[a , b]</code>, where <code>f(a)</code> and
<code>f(b)</code> must have opposite signs.</p>
<p>It uses a mixture of inverse cubic interpolation and
'Newton-quadratic' steps. [APS1995].</p>
<h2 id="parameters_144">Parameters<a class="headerlink" href="#parameters_144" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a scalar.  The function :math:<code>f</code>
must be continuous, and :math:<code>f(a)</code> and :math:<code>f(b)</code>
have opposite signs.
a : scalar,
lower boundary of the search interval
b : scalar,
upper boundary of the search interval
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>f(x, *args)</code>.
k : int, optional
The number of Newton quadratic steps to perform each
iteration. <code>k&gt;=1</code>.
xtol : scalar, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : scalar, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in the <code>RootResults</code>
return object.</p>
<h2 id="returns_126">Returns<a class="headerlink" href="#returns_126" title="Permanent link">&para;</a></h2>
<p>x0 : float
Approximate Zero of <code>f</code>
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="see-also_90">See Also<a class="headerlink" href="#see-also_90" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, ridder, bisect, newton
fsolve : find zeroes in n dimensions.</p>
<h2 id="notes_75">Notes<a class="headerlink" href="#notes_75" title="Permanent link">&para;</a></h2>
<p><code>f</code> must be continuous.
Algorithm 748 with <code>k=2</code> is asymptotically the most efficient
algorithm known for finding roots of a four times continuously
differentiable function.
In contrast with Brent's algorithm, which may only decrease the length of
the enclosing bracket on the last step, Algorithm 748 decreases it each
iteration with the same asymptotic efficiency as it finds the root.</p>
<p>For easy statement of efficiency indices, assume that <code>f</code> has 4
continuouous deriviatives.
For <code>k=1</code>, the convergence order is at least 2.7, and with about
asymptotically 2 function evaluations per iteration, the efficiency
index is approximately 1.65.
For <code>k=2</code>, the order is about 4.6 with asymptotically 3 function
evaluations per iteration, and the efficiency index 1.66.
For higher values of <code>k</code>, the efficiency index approaches
the <code>k</code>-th root of <code>(3k-2)</code>, hence <code>k=1</code> or <code>k=2</code> are
usually appropriate.</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [APS1995]
Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
<em>Algorithm 748: Enclosing Zeros of Continuous Functions</em>,
ACM Trans. Math. Softw. Volume 221(1995)
doi = {10.1145/210089.210111}</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**3 - 1)  # only one real root at x = 1</p>
<p>from scipy import optimize
root, results = optimize.toms748(f, 0, 2, full_output=True)
root
1.0
results
converged: True
flag: 'converged'
function_calls: 11
iterations: 5
root: 1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">anderson</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using (extended) Anderson mixing.</p>
<p>The Jacobian is formed by for a 'best' solution in the space
spanned by last <code>M</code> vectors. As a result, only a MxM matrix
inversions and MxN multiplications are required. [Ey]_</p>
<h2 id="parameters_145">Parameters<a class="headerlink" href="#parameters_145" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
M : float, optional
Number of previous vectors to retain. Defaults to 5.
w0 : float, optional
Regularization parameter for numerical stability.
Compared to unity, good values of the order of 0.01.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_127">Returns<a class="headerlink" href="#returns_127" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_19">Raises<a class="headerlink" href="#raises_19" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_91">See Also<a class="headerlink" href="#see-also_91" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='anderson'</code> in particular.</p>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>.. [Ey] V. Eyert, J. Comp. Phys., 124, 271 (1996).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">approx_fprime</span> <span class="o">:</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">epsilon</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finite-difference approximation of the gradient of a scalar function.</p>
<h2 id="parameters_146">Parameters<a class="headerlink" href="#parameters_146" title="Permanent link">&para;</a></h2>
<p>xk : array_like
The coordinate vector at which to determine the gradient of <code>f</code>.
f : callable
The function of which to determine the gradient (partial derivatives).
Should take <code>xk</code> as first argument, other arguments to <code>f</code> can be
supplied in <code>*args</code>.  Should return a scalar, the value of the
function at <code>xk</code>.
epsilon : array_like
Increment to <code>xk</code> to use for determining the function gradient.
If a scalar, uses the same finite difference delta for all partial
derivatives.  If an array, should contain one value per element of
<code>xk</code>.
*args : args, optional
Any other arguments that are to be passed to <code>f</code>.</p>
<h2 id="returns_128">Returns<a class="headerlink" href="#returns_128" title="Permanent link">&para;</a></h2>
<p>grad : ndarray
The partial derivatives of <code>f</code> to <code>xk</code>.</p>
<h2 id="see-also_92">See Also<a class="headerlink" href="#see-also_92" title="Permanent link">&para;</a></h2>
<p>check_grad : Check correctness of gradient function against approx_fprime.</p>
<h2 id="notes_76">Notes<a class="headerlink" href="#notes_76" title="Permanent link">&para;</a></h2>
<p>The function gradient is determined by the forward finite difference
formula::</p>
<p>f(xk[i] + epsilon[i]) - f(xk[i])
f'[i] = ---------------------------------
epsilon[i]</p>
<p>The main use of <code>approx_fprime</code> is in scalar function optimizers like
<code>fmin_bfgs</code>, to determine numerically the Jacobian of a function.</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def func(x, c0, c1):
...     'Coordinate vector <code>x</code> should be an array of size two.'
...     return c0 * x[0]<strong>2 + c1*x[1]</strong>2</p>
<p>x = np.ones(2)
c0, c1 = (1, 200)
eps = np.sqrt(np.finfo(float).eps)
optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
array([   2.        ,  400.00004198])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">basinhopping</span> <span class="o">:</span> <span class="o">?</span><span class="n">niter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stepsize</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minimizer_kwargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">take_step</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">accept_test</span><span class="o">:[`</span><span class="nc">T_accept_test_f_new_f_new_x_new_x_new_f_old_fold_x_old_x_old_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_callback_x_f_accept_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">interval</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">niter_success</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">seed</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_np_random_RandomState_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the global minimum of a function using the basin-hopping algorithm</p>
<p>Basin-hopping is a two-phase method that combines a global stepping
algorithm with local minimization at each step.  Designed to mimic
the natural process of energy minimization of clusters of atoms, it works
well for similar problems with 'funnel-like, but rugged' energy landscapes
[5]_.</p>
<p>As the step-taking, step acceptance, and minimization methods are all
customizable, this function can also be used to implement other two-phase
methods.</p>
<h2 id="parameters_147">Parameters<a class="headerlink" href="#parameters_147" title="Permanent link">&para;</a></h2>
<p>func : callable <code>f(x, *args)</code>
Function to be optimized.  <code>args</code> can be passed as an optional item
in the dict <code>minimizer_kwargs</code>
x0 : array_like
Initial guess.
niter : integer, optional
The number of basin-hopping iterations
T : float, optional
The 'temperature' parameter for the accept or reject criterion.  Higher
'temperatures' mean that larger jumps in function value will be
accepted.  For best results <code>T</code> should be comparable to the
separation (in function value) between local minima.
stepsize : float, optional
Maximum step size for use in the random displacement.
minimizer_kwargs : dict, optional
Extra keyword arguments to be passed to the local minimizer
<code>scipy.optimize.minimize()</code> Some important options could be:</p>
<p>method : str
The minimization method (e.g. <code>'L-BFGS-B'</code>)
args : tuple
Extra arguments passed to the objective function (<code>func</code>) and
its derivatives (Jacobian, Hessian).</p>
<p>take_step : callable <code>take_step(x)</code>, optional
Replace the default step-taking routine with this routine.  The default
step-taking routine is a random displacement of the coordinates, but
other step-taking algorithms may be better for some systems.
<code>take_step</code> can optionally have the attribute <code>take_step.stepsize</code>.
If this attribute exists, then <code>basinhopping</code> will adjust
<code>take_step.stepsize</code> in order to try to optimize the global minimum
search.
accept_test : callable, <code>accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old)</code>, optional
Define a test which will be used to judge whether or not to accept the
step.  This will be used in addition to the Metropolis test based on
'temperature' <code>T</code>.  The acceptable return values are True,
False, or <code>'force accept'</code>. If any of the tests return False
then the step is rejected. If the latter, then this will override any
other tests in order to accept the step. This can be used, for example,
to forcefully escape from a local minimum that <code>basinhopping</code> is
trapped in.
callback : callable, <code>callback(x, f, accept)</code>, optional
A callback function which will be called for all minima found.  <code>x</code>
and <code>f</code> are the coordinates and function value of the trial minimum,
and <code>accept</code> is whether or not that minimum was accepted.  This can
be used, for example, to save the lowest N minima found.  Also,
<code>callback</code> can be used to specify a user defined stop criterion by
optionally returning True to stop the <code>basinhopping</code> routine.
interval : integer, optional
interval for how often to update the <code>stepsize</code>
disp : bool, optional
Set to True to print status messages
niter_success : integer, optional
Stop the run if the global minimum candidate remains the same for this
number of iterations.
seed : int or <code>np.random.RandomState</code>, optional
If <code>seed</code> is not specified the <code>np.RandomState</code> singleton is used.
If <code>seed</code> is an int, a new <code>np.random.RandomState</code> instance is used,
seeded with seed.
If <code>seed</code> is already a <code>np.random.RandomState instance</code>, then that
<code>np.random.RandomState</code> instance is used.
Specify <code>seed</code> for repeatable minimizations. The random numbers
generated with this seed only affect the default Metropolis
<code>accept_test</code> and the default <code>take_step</code>. If you supply your own
<code>take_step</code> and <code>accept_test</code>, and these functions use random
number generation, then those functions are responsible for the state
of their random number generator.</p>
<h2 id="returns_129">Returns<a class="headerlink" href="#returns_129" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>fun</code> the value
of the function at the solution, and <code>message</code> which describes the
cause of the termination. The <code>OptimizeResult</code> object returned by the
selected minimizer at the lowest minimum is also contained within this
object and can be accessed through the <code>lowest_optimization_result</code>
attribute.  See <code>OptimizeResult</code> for a description of other attributes.</p>
<h2 id="see-also_93">See Also<a class="headerlink" href="#see-also_93" title="Permanent link">&para;</a></h2>
<p>minimize :
The local minimization function called once for each basinhopping step.
<code>minimizer_kwargs</code> is passed to this routine.</p>
<h2 id="notes_77">Notes<a class="headerlink" href="#notes_77" title="Permanent link">&para;</a></h2>
<p>Basin-hopping is a stochastic algorithm which attempts to find the global
minimum of a smooth scalar function of one or more variables [1]<em> [2]</em> [3]<em>
[4]</em>.  The algorithm in its current form was described by David Wales and
Jonathan Doye [2]_ http://www-wales.ch.cam.ac.uk/.</p>
<p>The algorithm is iterative with each cycle composed of the following
features</p>
<p>1) random perturbation of the coordinates</p>
<p>2) local minimization</p>
<p>3) accept or reject the new coordinates based on the minimized function
value</p>
<p>The acceptance test used here is the Metropolis criterion of standard Monte
Carlo algorithms, although there are many other possibilities [3]_.</p>
<p>This global minimization method has been shown to be extremely efficient
for a wide variety of problems in physics and chemistry.  It is
particularly useful when the function has many minima separated by large
barriers. See the Cambridge Cluster Database
http://www-wales.ch.cam.ac.uk/CCD.html for databases of molecular systems
that have been optimized primarily using basin-hopping.  This database
includes minimization problems exceeding 300 degrees of freedom.</p>
<p>See the free software program GMIN (http://www-wales.ch.cam.ac.uk/GMIN) for
a Fortran implementation of basin-hopping.  This implementation has many
different variations of the procedure described above, including more
advanced step taking algorithms and alternate acceptance criterion.</p>
<p>For stochastic global optimization there is no way to determine if the true
global minimum has actually been found. Instead, as a consistency check,
the algorithm can be run from a number of different random starting points
to ensure the lowest minimum found in each example has converged to the
global minimum.  For this reason <code>basinhopping</code> will by default simply
run for the number of iterations <code>niter</code> and return the lowest minimum
found.  It is left to the user to ensure that this is in fact the global
minimum.</p>
<p>Choosing <code>stepsize</code>:  This is a crucial parameter in <code>basinhopping</code> and
depends on the problem being solved.  The step is chosen uniformly in the
region from x0-stepsize to x0+stepsize, in each dimension.  Ideally it
should be comparable to the typical separation (in argument values) between
local minima of the function being optimized.  <code>basinhopping</code> will, by
default, adjust <code>stepsize</code> to find an optimal value, but this may take
many iterations.  You will get quicker results if you set a sensible
initial value for <code>stepsize</code>.</p>
<p>Choosing <code>T</code>: The parameter <code>T</code> is the 'temperature' used in the
Metropolis criterion.  Basinhopping steps are always accepted if
<code>func(xnew) &lt; func(xold)</code>.  Otherwise, they are accepted with
probability::</p>
<p>exp( -(func(xnew) - func(xold)) / T )</p>
<p>So, for best results, <code>T</code> should to be comparable to the typical
difference (in function values) between local minima.  (The height of
'walls' between local minima is irrelevant.)</p>
<p>If <code>T</code> is 0, the algorithm becomes Monotonic Basin-Hopping, in which all
steps that increase energy are rejected.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>.. [1] Wales, David J. 2003, Energy Landscapes, Cambridge University Press,
Cambridge, UK.
.. [2] Wales, D J, and Doye J P K, Global Optimization by Basin-Hopping and
the Lowest Energy Structures of Lennard-Jones Clusters Containing up to
110 Atoms.  Journal of Physical Chemistry A, 1997, 101, 5111.
.. [3] Li, Z. and Scheraga, H. A., Monte Carlo-minimization approach to the
multiple-minima problem in protein folding, Proc. Natl. Acad. Sci. USA,
1987, 84, 6611.
.. [4] Wales, D. J. and Scheraga, H. A., Global optimization of clusters,
crystals, and biomolecules, Science, 1999, 285, 1368.
.. [5] Olson, B., Hashmi, I., Molloy, K., and Shehu1, A., Basin Hopping as
a General and Versatile Optimization Framework for the Characterization
of Biological Macromolecules, Advances in Artificial Intelligence,
Volume 2012 (2012), Article ID 674832, :doi:<code>10.1155/2012/674832</code></p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<p>The following example is a one-dimensional minimization problem,  with many
local minima superimposed on a parabola.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import basinhopping
func = lambda x: np.cos(14.5 * x - 0.3) + (x + 0.2) * x
x0=[1.]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Basinhopping, internally, uses a local minimization algorithm.  We will use
the parameter <code>minimizer_kwargs</code> to tell basinhopping which algorithm to
use and how to set up that minimizer.  This parameter will be passed to
<code>scipy.optimize.minimize()</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>minimizer_kwargs = {'method': 'BFGS'}
ret = basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
print('global minimum: x = %.4f, f(x0) = %.4f' % (ret.x, ret.fun))
global minimum: x = -0.1951, f(x0) = -1.0009</p>
</blockquote>
</blockquote>
</blockquote>
<p>Next consider a two-dimensional minimization problem. Also, this time we
will use gradient information to significantly speed up the search.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def func2d(x):
...     f = np.cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] +
...                                                            0.2) * x[0]
...     df = np.zeros(2)
...     df[0] = -14.5 * np.sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2
...     df[1] = 2. * x[1] + 0.2
...     return f, df</p>
</blockquote>
</blockquote>
</blockquote>
<p>We'll also use a different local minimization algorithm.  Also we must tell
the minimizer that our function returns both energy and gradient (jacobian)</p>
<blockquote>
<blockquote>
<blockquote>
<p>minimizer_kwargs = {'method':'L-BFGS-B', 'jac':True}
x0 = [1.0, 1.0]
ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200)
print('global minimum: x = [%.4f, %.4f], f(x0) = %.4f' % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here is an example using a custom step-taking routine.  Imagine you want
the first coordinate to take larger steps than the rest of the coordinates.
This can be implemented like so:</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MyTakeStep(object):
...    def <strong>init</strong>(self, stepsize=0.5):
...        self.stepsize = stepsize
...    def <strong>call</strong>(self, x):
...        s = self.stepsize
...        x[0] += np.random.uniform(-2.<em>s, 2.</em>s)
...        x[1:] += np.random.uniform(-s, s, x[1:].shape)
...        return x</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since <code>MyTakeStep.stepsize</code> exists basinhopping will adjust the magnitude
of <code>stepsize</code> to optimize the search.  We'll use the same 2-D function as
before</p>
<blockquote>
<blockquote>
<blockquote>
<p>mytakestep = MyTakeStep()
ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=200, take_step=mytakestep)
print('global minimum: x = [%.4f, %.4f], f(x0) = %.4f' % (ret.x[0],
...                                                           ret.x[1],
...                                                           ret.fun))
global minimum: x = [-0.1951, -0.1000], f(x0) = -1.0109</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now let's do an example using a custom callback function which prints the
value of every minimum found</p>
<blockquote>
<blockquote>
<blockquote>
<p>def print_fun(x, f, accepted):
...         print('at minimum %.4f accepted %d' % (f, int(accepted)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>We'll run it for only 10 basinhopping steps this time.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(1)
ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, callback=print_fun)
at minimum 0.4159 accepted 1
at minimum -0.9073 accepted 1
at minimum -0.1021 accepted 1
at minimum -0.1021 accepted 1
at minimum 0.9102 accepted 1
at minimum 0.9102 accepted 1
at minimum 2.2945 accepted 0
at minimum -0.1021 accepted 1
at minimum -1.0109 accepted 1
at minimum -1.0109 accepted 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>The minimum at -1.0109 is actually the global minimum, found already on the
8th iteration.</p>
<p>Now let's implement bounds on the problem using a custom <code>accept_test</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MyBounds(object):
...     def <strong>init</strong>(self, xmax=[1.1,1.1], xmin=[-1.1,-1.1] ):
...         self.xmax = np.array(xmax)
...         self.xmin = np.array(xmin)
...     def <strong>call</strong>(self, **kwargs):
...         x = kwargs['x_new']
...         tmax = bool(np.all(x &lt;= self.xmax))
...         tmin = bool(np.all(x &gt;= self.xmin))
...         return tmax and tmin</p>
<p>mybounds = MyBounds()
ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs,
...                    niter=10, accept_test=mybounds)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bisect</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find root of a function within an interval using bisection.</p>
<p>Basic bisection routine to find a zero of the function <code>f</code> between the
arguments <code>a</code> and <code>b</code>. <code>f(a)</code> and <code>f(b)</code> cannot have the same signs.
Slow but sure.</p>
<h2 id="parameters_148">Parameters<a class="headerlink" href="#parameters_148" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  <code>f</code> must be continuous, and
f(a) and f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where x is the root, and r is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in a <code>RootResults</code>
return object.</p>
<h2 id="returns_130">Returns<a class="headerlink" href="#returns_130" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.bisect(f, 0, 2)
root
1.0</p>
<p>root = optimize.bisect(f, -2, 0)
root
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_94">See Also<a class="headerlink" href="#see-also_94" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, bisect, newton
fixed_point : scalar fixed-point finder
fsolve : n-dimensional root-finding</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bracket</span> <span class="o">:</span> <span class="o">?</span><span class="n">xa</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">grow_limit</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Bracket the minimum of the function.</p>
<p>Given a function and distinct initial points, search in the
downhill direction (as defined by the initital points) and return
new points xa, xb, xc that bracket the minimum of the function
f(xa) &gt; f(xb) &lt; f(xc). It doesn't always mean that obtained
solution will satisfy xa&lt;=x&lt;=xb</p>
<h2 id="parameters_149">Parameters<a class="headerlink" href="#parameters_149" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to minimize.
xa, xb : float, optional
Bracketing interval. Defaults <code>xa</code> to 0.0, and <code>xb</code> to 1.0.
args : tuple, optional
Additional arguments (if present), passed to <code>func</code>.
grow_limit : float, optional
Maximum grow limit.  Defaults to 110.0
maxiter : int, optional
Maximum number of iterations to perform. Defaults to 1000.</p>
<h2 id="returns_131">Returns<a class="headerlink" href="#returns_131" title="Permanent link">&para;</a></h2>
<p>xa, xb, xc : float
Bracket.
fa, fb, fc : float
Objective function values in bracket.
funcalls : int
Number of function evaluations made.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brent</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brack</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Given a function of one-variable and a possible bracket, return
the local minimum of the function isolated to a fractional precision
of tol.</p>
<h2 id="parameters_150">Parameters<a class="headerlink" href="#parameters_150" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function.
args : tuple, optional
Additional arguments (if present).
brack : tuple, optional
Either a triple (xa,xb,xc) where xa&lt;xb&lt;xc and func(xb) &lt;
func(xa), func(xc) or a pair (xa,xb) which are used as a
starting interval for a downhill bracket search (see
<code>bracket</code>). Providing the pair (xa,xb) does not always mean
the obtained solution will satisfy xa&lt;=x&lt;=xb.
tol : float, optional
Stop if between iteration change is less than <code>tol</code>.
full_output : bool, optional
If True, return all output args (xmin, fval, iter,
funcalls).
maxiter : int, optional
Maximum number of iterations in solution.</p>
<h2 id="returns_132">Returns<a class="headerlink" href="#returns_132" title="Permanent link">&para;</a></h2>
<p>xmin : ndarray
Optimum point.
fval : float
Optimum value.
iter : int
Number of iterations.
funcalls : int
Number of objective function evaluations made.</p>
<h2 id="see-also_95">See also<a class="headerlink" href="#see-also_95" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Brent' <code>method</code> in particular.</p>
<h2 id="notes_78">Notes<a class="headerlink" href="#notes_78" title="Permanent link">&para;</a></h2>
<p>Uses inverse parabolic interpolation when possible to speed up
convergence of golden section method.</p>
<p>Does not ensure that the minimum lies in the range specified by
<code>brack</code>. See <code>fminbound</code>.</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<p>We illustrate the behaviour of the function when <code>brack</code> is of
size 2 and 3 respectively. In the case where <code>brack</code> is of the
form (xa,xb), we can see for the given values, the output need
not necessarily lie in the range (xa,xb).</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.brent(f,brack=(1,2))
minimum
0.0
minimum = optimize.brent(f,brack=(-1,0.5,2))
minimum
-2.7755575615628914e-17</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brenth</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in a bracketing interval using Brent's
method with hyperbolic extrapolation.</p>
<p>A variation on the classic Brent routine to find a zero of the function f
between the arguments a and b that uses hyperbolic extrapolation instead of
inverse quadratic extrapolation. There was a paper back in the 1980's ...
f(a) and f(b) cannot have the same signs. Generally on a par with the
brent routine, but not as heavily tested.  It is a safe version of the
secant method that uses hyperbolic extrapolation. The version here is by
Chuck Harris.</p>
<h2 id="parameters_151">Parameters<a class="headerlink" href="#parameters_151" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative. As with <code>brentq</code>, for nice
functions the method will often satisfy the above condition
with <code>xtol/2</code> and <code>rtol/2</code>.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>. As with <code>brentq</code>, for nice functions
the method will often satisfy the above condition with
<code>xtol/2</code> and <code>rtol/2</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_133">Returns<a class="headerlink" href="#returns_133" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.brenth(f, -2, 0)
root
-1.0</p>
<p>root = optimize.brenth(f, 0, 2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_96">See Also<a class="headerlink" href="#see-also_96" title="Permanent link">&para;</a></h2>
<p>fmin, fmin_powell, fmin_cg,
fmin_bfgs, fmin_ncg : multivariate local optimizers</p>
<p>leastsq : nonlinear least squares minimizer</p>
<p>fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers</p>
<p>basinhopping, differential_evolution, brute : global optimizers</p>
<p>fminbound, brent, golden, bracket : local scalar minimizers</p>
<p>fsolve : n-dimensional root-finding</p>
<p>brentq, brenth, ridder, bisect, newton : one-dimensional root-finding</p>
<p>fixed_point : scalar fixed-point finder</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brentq</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in a bracketing interval using Brent's method.</p>
<p>Uses the classic Brent's method to find a zero of the function <code>f</code> on
the sign changing interval [a , b].  Generally considered the best of the
rootfinding routines here.  It is a safe version of the secant method that
uses inverse quadratic extrapolation.  Brent's method combines root
bracketing, interval bisection, and inverse quadratic interpolation.  It is
sometimes known as the van Wijngaarden-Dekker-Brent method.  Brent (1973)
claims convergence is guaranteed for functions computable within [a,b].</p>
<p>[Brent1973]<em> provides the classic description of the algorithm.  Another
description can be found in a recent edition of Numerical Recipes, including
[PressEtal1992]</em>.  A third description is at
http://mathworld.wolfram.com/BrentsMethod.html.  It should be easy to
understand the algorithm just by reading our code.  Our code diverges a bit
from standard presentations: we choose a different formula for the
extrapolation step.</p>
<h2 id="parameters_152">Parameters<a class="headerlink" href="#parameters_152" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  The function :math:<code>f</code>
must be continuous, and :math:<code>f(a)</code> and :math:<code>f(b)</code> must
have opposite signs.
a : scalar
One end of the bracketing interval :math:<code>[a, b]</code>.
b : scalar
The other end of the bracketing interval :math:<code>[a, b]</code>.
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative. For nice functions, Brent's
method will often satisfy the above condition with <code>xtol/2</code>
and <code>rtol/2</code>. [Brent1973]<em>
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>. For nice functions, Brent's
method will often satisfy the above condition with <code>xtol/2</code>
and <code>rtol/2</code>. [Brent1973]</em>
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_134">Returns<a class="headerlink" href="#returns_134" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="notes_79">Notes<a class="headerlink" href="#notes_79" title="Permanent link">&para;</a></h2>
<p><code>f</code> must be continuous.  f(a) and f(b) must have opposite signs.</p>
<p>Related functions fall into several classes:</p>
<p>multivariate local optimizers
<code>fmin</code>, <code>fmin_powell</code>, <code>fmin_cg</code>, <code>fmin_bfgs</code>, <code>fmin_ncg</code>
nonlinear least squares minimizer
<code>leastsq</code>
constrained multivariate optimizers
<code>fmin_l_bfgs_b</code>, <code>fmin_tnc</code>, <code>fmin_cobyla</code>
global optimizers
<code>basinhopping</code>, <code>brute</code>, <code>differential_evolution</code>
local scalar minimizers
<code>fminbound</code>, <code>brent</code>, <code>golden</code>, <code>bracket</code>
n-dimensional root-finding
<code>fsolve</code>
one-dimensional root-finding
<code>brenth</code>, <code>ridder</code>, <code>bisect</code>, <code>newton</code>
scalar fixed-point finder
<code>fixed_point</code></p>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [Brent1973]
Brent, R. P.,
<em>Algorithms for Minimization Without Derivatives</em>.
Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.</p>
<p>.. [PressEtal1992]
Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.
<em>Numerical Recipes in FORTRAN: The Art of Scientific Computing</em>, 2nd ed.
Cambridge, England: Cambridge University Press, pp. 352-355, 1992.
Section 9.3:  'Van Wijngaarden-Dekker-Brent Method.'</p>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.brentq(f, -2, 0)
root
-1.0</p>
<p>root = optimize.brentq(f, 0, 2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">broyden1</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's first Jacobian approximation.</p>
<p>This method is also known as \'Broyden's good method\'.</p>
<h2 id="parameters_153">Parameters<a class="headerlink" href="#parameters_153" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is <code>(-1/alpha)</code>.
reduction_method : str or tuple, optional
Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form <code>(method, param1, param2, ...)</code>
that gives the name of the method and values for additional parameters.</p>
<p>Methods available:</p>
<ul>
<li><code>restart</code>: drop all matrix columns. Has no extra parameters.</li>
<li><code>simple</code>: drop oldest matrix column. Has no extra parameters.</li>
<li><code>svd</code>: keep only the most significant SVD components.
Takes an extra parameter, <code>to_retain</code>, which determines the
number of SVD components to retain when rank reduction is done.
Default is <code>max_rank - 2</code>.</li>
</ul>
<p>max_rank : int, optional
Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_135">Returns<a class="headerlink" href="#returns_135" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_20">Raises<a class="headerlink" href="#raises_20" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_97">See Also<a class="headerlink" href="#see-also_97" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden1'</code> in particular.</p>
<h2 id="notes_80">Notes<a class="headerlink" href="#notes_80" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) dx^\dagger H / ( dx^\dagger H df)</p>
<p>which corresponds to Broyden's first Jacobian update</p>
<p>.. math:: J_+ = J + (df - J dx) dx^\dagger / dx^\dagger dx</p>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
\'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations\'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">broyden2</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reduction_method</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Broyden's second Jacobian approximation.</p>
<p>This method is also known as 'Broyden's bad method'.</p>
<h2 id="parameters_154">Parameters<a class="headerlink" href="#parameters_154" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is <code>(-1/alpha)</code>.
reduction_method : str or tuple, optional
Method used in ensuring that the rank of the Broyden matrix
stays low. Can either be a string giving the name of the method,
or a tuple of the form <code>(method, param1, param2, ...)</code>
that gives the name of the method and values for additional parameters.</p>
<p>Methods available:</p>
<ul>
<li><code>restart</code>: drop all matrix columns. Has no extra parameters.</li>
<li><code>simple</code>: drop oldest matrix column. Has no extra parameters.</li>
<li><code>svd</code>: keep only the most significant SVD components.
Takes an extra parameter, <code>to_retain</code>, which determines the
number of SVD components to retain when rank reduction is done.
Default is <code>max_rank - 2</code>.</li>
</ul>
<p>max_rank : int, optional
Maximum rank for the Broyden matrix.
Default is infinity (ie., no rank reduction).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_136">Returns<a class="headerlink" href="#returns_136" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_21">Raises<a class="headerlink" href="#raises_21" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_98">See Also<a class="headerlink" href="#see-also_98" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='broyden2'</code> in particular.</p>
<h2 id="notes_81">Notes<a class="headerlink" href="#notes_81" title="Permanent link">&para;</a></h2>
<p>This algorithm implements the inverse Jacobian Quasi-Newton update</p>
<p>.. math:: H_+ = H + (dx - H df) df^\dagger / ( df^\dagger df)</p>
<p>corresponding to Broyden's second method.</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [1] B.A. van der Rotten, PhD thesis,
'A limited memory Broyden method to solve high-dimensional
systems of nonlinear equations'. Mathematisch Instituut,
Universiteit Leiden, The Netherlands (2003).</p>
<p>https://web.archive.org/web/20161022015821/http://www.math.leidenuniv.nl/scripties/Rotten.pdf</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">brute</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ns</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">finish</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:[`</span><span class="nc">Map_like_callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ranges</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function over a given range by brute force.</p>
<p>Uses the 'brute force' method, i.e. computes the function's value
at each point of a multidimensional grid of points, to find the global
minimum of the function.</p>
<p>The function is evaluated everywhere in the range with the datatype of the
first call to the function, as enforced by the <code>vectorize</code> NumPy
function.  The value and type of the function evaluation returned when
<code>full_output=True</code> are affected in addition by the <code>finish</code> argument
(see Notes).</p>
<p>The brute force approach is inefficient because the number of grid points
increases exponentially - the number of grid points to evaluate is
<code>Ns ** len(x)</code>. Consequently, even with coarse grid spacing, even
moderately sized problems can take a long time to run, and/or run into
memory limitations.</p>
<h2 id="parameters_155">Parameters<a class="headerlink" href="#parameters_155" title="Permanent link">&para;</a></h2>
<p>func : callable
The objective function to be minimized. Must be in the
form <code>f(x, *args)</code>, where <code>x</code> is the argument in
the form of a 1-D array and <code>args</code> is a tuple of any
additional fixed parameters needed to completely specify
the function.
ranges : tuple
Each component of the <code>ranges</code> tuple must be either a
'slice object' or a range tuple of the form <code>(low, high)</code>.
The program uses these to create the grid of points on which
the objective function will be computed. See <code>Note 2</code> for
more detail.
args : tuple, optional
Any additional fixed parameters needed to completely specify
the function.
Ns : int, optional
Number of grid points along the axes, if not otherwise
specified. See <code>Note2</code>.
full_output : bool, optional
If True, return the evaluation grid and the objective function's
values on it.
finish : callable, optional
An optimization function that is called with the result of brute force
minimization as initial guess.  <code>finish</code> should take <code>func</code> and
the initial guess as positional arguments, and take <code>args</code> as
keyword arguments.  It may additionally take <code>full_output</code>
and/or <code>disp</code> as keyword arguments.  Use None if no 'polishing'
function is to be used. See Notes for more details.
disp : bool, optional
Set to True to print convergence messages from the <code>finish</code> callable.
workers : int or map-like callable, optional
If <code>workers</code> is an int the grid is subdivided into <code>workers</code>
sections and evaluated in parallel (uses
<code>multiprocessing.Pool &lt;multiprocessing&gt;</code>).
Supply <code>-1</code> to use all cores available to the Process.
Alternatively supply a map-like callable, such as
<code>multiprocessing.Pool.map</code> for evaluating the grid in parallel.
This evaluation is carried out as <code>workers(func, iterable)</code>.
Requires that <code>func</code> be pickleable.</p>
<p>.. versionadded:: 1.3.0</p>
<h2 id="returns_137">Returns<a class="headerlink" href="#returns_137" title="Permanent link">&para;</a></h2>
<p>x0 : ndarray
A 1-D array containing the coordinates of a point at which the
objective function had its minimum value. (See <code>Note 1</code> for
which point is returned.)
fval : float
Function value at the point <code>x0</code>. (Returned when <code>full_output</code> is
True.)
grid : tuple
Representation of the evaluation grid.  It has the same
length as <code>x0</code>. (Returned when <code>full_output</code> is True.)
Jout : ndarray
Function values at each point of the evaluation
grid, <code>i.e.</code>, <code>Jout = func( *grid)</code>. (Returned
when <code>full_output</code> is True.)</p>
<h2 id="see-also_99">See Also<a class="headerlink" href="#see-also_99" title="Permanent link">&para;</a></h2>
<p>basinhopping, differential_evolution</p>
<h2 id="notes_82">Notes<a class="headerlink" href="#notes_82" title="Permanent link">&para;</a></h2>
<p><em>Note 1</em>: The program finds the gridpoint at which the lowest value
of the objective function occurs.  If <code>finish</code> is None, that is the
point returned.  When the global minimum occurs within (or not very far
outside) the grid's boundaries, and the grid is fine enough, that
point will be in the neighborhood of the global minimum.</p>
<p>However, users often employ some other optimization program to
'polish' the gridpoint values, <code>i.e.</code>, to seek a more precise
(local) minimum near <code>brute's</code> best gridpoint.
The <code>brute</code> function's <code>finish</code> option provides a convenient way to do
that.  Any polishing program used must take <code>brute's</code> output as its
initial guess as a positional argument, and take <code>brute's</code> input values
for <code>args</code> as keyword arguments, otherwise an error will be raised.
It may additionally take <code>full_output</code> and/or <code>disp</code> as keyword arguments.</p>
<p><code>brute</code> assumes that the <code>finish</code> function returns either an
<code>OptimizeResult</code> object or a tuple in the form:
<code>(xmin, Jmin, ... , statuscode)</code>, where <code>xmin</code> is the minimizing
value of the argument, <code>Jmin</code> is the minimum value of the objective
function, '...' may be some other returned values (which are not used
by <code>brute</code>), and <code>statuscode</code> is the status code of the <code>finish</code> program.</p>
<p>Note that when <code>finish</code> is not None, the values returned are those
of the <code>finish</code> program, <em>not</em> the gridpoint ones.  Consequently,
while <code>brute</code> confines its search to the input grid points,
the <code>finish</code> program's results usually will not coincide with any
gridpoint, and may fall outside the grid's boundary. Thus, if a
minimum only needs to be found over the provided grid points, make
sure to pass in <code>finish=None</code>.</p>
<p><em>Note 2</em>: The grid of points is a <code>numpy.mgrid</code> object.
For <code>brute</code> the <code>ranges</code> and <code>Ns</code> inputs have the following effect.
Each component of the <code>ranges</code> tuple can be either a slice object or a
two-tuple giving a range of values, such as (0, 5).  If the component is a
slice object, <code>brute</code> uses it directly.  If the component is a two-tuple
range, <code>brute</code> internally converts it to a slice object that interpolates
<code>Ns</code> points from its low-value to its high-value, inclusive.</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<p>We illustrate the use of <code>brute</code> to seek the global minimum of a function
of two variables that is given as the sum of a positive-definite
quadratic and two deep 'Gaussian-shaped' craters.  Specifically, define
the objective function <code>f</code> as the sum of three other functions,
<code>f = f1 + f2 + f3</code>.  We suppose each of these has a signature
<code>(z, *params)</code>, where <code>z = (x, y)</code>,  and <code>params</code> and the functions
are as defined below.</p>
<blockquote>
<blockquote>
<blockquote>
<p>params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
def f1(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (a * x</em><em>2 + b * x * y + c * y</em><em>2 + d</em>x + e*y + f)</p>
<p>def f2(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-g</em>np.exp(-((x-h)<strong>2 + (y-i)</strong>2) / scale))</p>
<p>def f3(z, <em>params):
...     x, y = z
...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
...     return (-j</em>np.exp(-((x-k)<strong>2 + (y-l)</strong>2) / scale))</p>
<p>def f(z, <em>params):
...     return f1(z, </em>params) + f2(z, <em>params) + f3(z, </em>params)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thus, the objective function may have local minima near the minimum
of each of the three functions of which it is composed.  To
use <code>fmin</code> to polish its gridpoint result, we may then continue as
follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
from scipy import optimize
resbrute = optimize.brute(f, rranges, args=params, full_output=True,
...                           finish=optimize.fmin)
resbrute[0]  # global minimum
array([-1.05665192,  1.80834843])
resbrute[1]  # function value at global minimum
-3.4085818767</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that if <code>finish</code> had been set to None, we would have gotten the
gridpoint [-1.0 1.75] where the rounded function value is -2.892.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_grad</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">grad</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Check the correctness of a gradient function by comparing it against a
(forward) finite-difference approximation of the gradient.</p>
<h2 id="parameters_156">Parameters<a class="headerlink" href="#parameters_156" title="Permanent link">&para;</a></h2>
<p>func : callable <code>func(x0, *args)</code>
Function whose derivative is to be checked.
grad : callable <code>grad(x0, *args)</code>
Gradient of <code>func</code>.
x0 : ndarray
Points to check <code>grad</code> against forward difference approximation of grad
using <code>func</code>.
args : *args, optional
Extra arguments passed to <code>func</code> and <code>grad</code>.
epsilon : float, optional
Step size used for the finite difference approximation. It defaults to
<code>sqrt(numpy.finfo(float).eps)</code>, which is approximately 1.49e-08.</p>
<h2 id="returns_138">Returns<a class="headerlink" href="#returns_138" title="Permanent link">&para;</a></h2>
<p>err : float
The square root of the sum of squares (i.e. the 2-norm) of the
difference between <code>grad(x0, *args)</code> and the finite difference
approximation of <code>grad</code> using func at the points <code>x0</code>.</p>
<h2 id="see-also_100">See Also<a class="headerlink" href="#see-also_100" title="Permanent link">&para;</a></h2>
<p>approx_fprime</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def func(x):
...     return x[0]<strong>2 - 0.5 * x[1]</strong>3
def grad(x):
...     return [2 * x[0], -1.5 * x[1]**2]
from scipy.optimize import check_grad
check_grad(func, grad, [1.5, -1.5])
2.9802322387695312e-08</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">curve_fit</span> <span class="o">:</span> <span class="o">?</span><span class="n">p0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sigma</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">absolute_sigma</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Lm</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Trf</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dogbox</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xdata</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">ydata</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Use non-linear least squares to fit a function, f, to data.</p>
<p>Assumes <code>ydata = f(xdata, *params) + eps</code></p>
<h2 id="parameters_157">Parameters<a class="headerlink" href="#parameters_157" title="Permanent link">&para;</a></h2>
<p>f : callable
The model function, f(x, ...).  It must take the independent
variable as the first argument and the parameters to fit as
separate remaining arguments.
xdata : array_like or object
The independent variable where the data is measured.
Should usually be an M-length sequence or an (k,M)-shaped array for
functions with k predictors, but can actually be any object.
ydata : array_like
The dependent data, a length M array - nominally <code>f(xdata, ...)</code>.
p0 : array_like, optional
Initial guess for the parameters (length N).  If None, then the
initial values will all be 1 (if the number of parameters for the
function can be determined using introspection, otherwise a
ValueError is raised).
sigma : None or M-length sequence or MxM array, optional
Determines the uncertainty in <code>ydata</code>. If we define residuals as
<code>r = ydata - f(xdata, *popt)</code>, then the interpretation of <code>sigma</code>
depends on its number of dimensions:</p>
<ul>
<li>
<p>A 1-d <code>sigma</code> should contain values of standard deviations of
errors in <code>ydata</code>. In this case, the optimized function is
<code>chisq = sum((r / sigma) ** 2)</code>.</p>
</li>
<li>
<p>A 2-d <code>sigma</code> should contain the covariance matrix of
errors in <code>ydata</code>. In this case, the optimized function is
<code>chisq = r.T @ inv(sigma) @ r</code>.</p>
</li>
</ul>
<p>.. versionadded:: 0.19</p>
<p>None (default) is equivalent of 1-d <code>sigma</code> filled with ones.
absolute_sigma : bool, optional
If True, <code>sigma</code> is used in an absolute sense and the estimated parameter
covariance <code>pcov</code> reflects these absolute values.</p>
<p>If False, only the relative magnitudes of the <code>sigma</code> values matter.
The returned parameter covariance matrix <code>pcov</code> is based on scaling
<code>sigma</code> by a constant factor. This constant is set by demanding that the
reduced <code>chisq</code> for the optimal parameters <code>popt</code> when using the
<em>scaled</em> <code>sigma</code> equals unity. In other words, <code>sigma</code> is scaled to
match the sample variance of the residuals after the fit.
Mathematically,
<code>pcov(absolute_sigma=False) = pcov(absolute_sigma=True) * chisq(popt)/(M-N)</code>
check_finite : bool, optional
If True, check that the input arrays do not contain nans of infs,
and raise a ValueError if they do. Setting this parameter to
False may silently produce nonsensical results if the input arrays
do contain nans. Default is True.
bounds : 2-tuple of array_like, optional
Lower and upper bounds on parameters. Defaults to no bounds.
Each element of the tuple must be either an array with the length equal
to the number of parameters, or a scalar (in which case the bound is
taken to be the same for all parameters.) Use <code>np.inf</code> with an
appropriate sign to disable bounds on all or some parameters.</p>
<p>.. versionadded:: 0.17
method : {'lm', 'trf', 'dogbox'}, optional
Method to use for optimization.  See <code>least_squares</code> for more details.
Default is 'lm' for unconstrained problems and 'trf' if <code>bounds</code> are
provided. The method 'lm' won't work when the number of observations
is less than the number of variables, use 'trf' or 'dogbox' in this
case.</p>
<p>.. versionadded:: 0.17
jac : callable, string or None, optional
Function with signature <code>jac(x, ...)</code> which computes the Jacobian
matrix of the model function with respect to parameters as a dense
array_like structure. It will be scaled according to provided <code>sigma</code>.
If None (default), the Jacobian will be estimated numerically.
String keywords for 'trf' and 'dogbox' methods can be used to select
a finite difference scheme, see <code>least_squares</code>.</p>
<p>.. versionadded:: 0.18
kwargs
Keyword arguments passed to <code>leastsq</code> for <code>method='lm'</code> or
<code>least_squares</code> otherwise.</p>
<h2 id="returns_139">Returns<a class="headerlink" href="#returns_139" title="Permanent link">&para;</a></h2>
<p>popt : array
Optimal values for the parameters so that the sum of the squared
residuals of <code>f(xdata, *popt) - ydata</code> is minimized
pcov : 2d array
The estimated covariance of popt. The diagonals provide the variance
of the parameter estimate. To compute one standard deviation errors
on the parameters use <code>perr = np.sqrt(np.diag(pcov))</code>.</p>
<p>How the <code>sigma</code> parameter affects the estimated covariance
depends on <code>absolute_sigma</code> argument, as described above.</p>
<p>If the Jacobian matrix at the solution doesn't have a full rank, then
'lm' method returns a matrix filled with <code>np.inf</code>, on the other hand
'trf'  and 'dogbox' methods use Moore-Penrose pseudoinverse to compute
the covariance matrix.</p>
<h2 id="raises_22">Raises<a class="headerlink" href="#raises_22" title="Permanent link">&para;</a></h2>
<p>ValueError
if either <code>ydata</code> or <code>xdata</code> contain NaNs, or if incompatible options
are used.</p>
<p>RuntimeError
if the least-squares minimization fails.</p>
<p>OptimizeWarning
if covariance of the parameters can not be estimated.</p>
<h2 id="see-also_101">See Also<a class="headerlink" href="#see-also_101" title="Permanent link">&para;</a></h2>
<p>least_squares : Minimize the sum of squares of nonlinear functions.
scipy.stats.linregress : Calculate a linear least squares regression for
two sets of measurements.</p>
<h2 id="notes_83">Notes<a class="headerlink" href="#notes_83" title="Permanent link">&para;</a></h2>
<p>With <code>method='lm'</code>, the algorithm uses the Levenberg-Marquardt algorithm
through <code>leastsq</code>. Note that this algorithm can only deal with
unconstrained problems.</p>
<p>Box constraints can be handled by methods 'trf' and 'dogbox'. Refer to
the docstring of <code>least_squares</code> for more information.</p>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy.optimize import curve_fit</p>
<p>def func(x, a, b, c):
...     return a * np.exp(-b * x) + c</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the data to be fit with some noise:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xdata = np.linspace(0, 4, 50)
y = func(xdata, 2.5, 1.3, 0.5)
np.random.seed(1729)
y_noise = 0.2 * np.random.normal(size=xdata.size)
ydata = y + y_noise
plt.plot(xdata, ydata, 'b-', label='data')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Fit for the parameters a, b, c of the function <code>func</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>popt, pcov = curve_fit(func, xdata, ydata)
popt
array([ 2.55423706,  1.35190947,  0.47450618])
plt.plot(xdata, func(xdata, *popt), 'r-',
...          label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constrain the optimization to the region of <code>0 &lt;= a &lt;= 3</code>,
<code>0 &lt;= b &lt;= 1</code> and <code>0 &lt;= c &lt;= 0.5</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>popt, pcov = curve_fit(func, xdata, ydata, bounds=(0, [3., 1., 0.5]))
popt
array([ 2.43708906,  1.        ,  0.35015434])
plt.plot(xdata, func(xdata, *popt), 'g--',
...          label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))</p>
<p>plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagbroyden</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using diagonal Broyden Jacobian approximation.</p>
<p>The Jacobian approximation is derived from previous iterations, by
retaining only the diagonal of Broyden matrices.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_158">Parameters<a class="headerlink" href="#parameters_158" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial guess for the Jacobian is (-1/alpha).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_140">Returns<a class="headerlink" href="#returns_140" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_23">Raises<a class="headerlink" href="#raises_23" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_102">See Also<a class="headerlink" href="#see-also_102" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='diagbroyden'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">differential_evolution</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">strategy</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">popsize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mutation</span><span class="o">:[`</span><span class="nc">Tuple_float_float_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">recombination</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">seed</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_np_random_RandomState_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_callback_xk_convergence_val_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">polish</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">init</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">atol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">updating</span><span class="o">:[`</span><span class="nc">Immediate</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Deferred</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:[`</span><span class="nc">Map_like_callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">constraints</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finds the global minimum of a multivariate function.</p>
<p>Differential Evolution is stochastic in nature (does not use gradient
methods) to find the minimum, and can search large areas of candidate
space, but often requires larger numbers of function evaluations than
conventional gradient based techniques.</p>
<p>The algorithm is due to Storn and Price [1]_.</p>
<h2 id="parameters_159">Parameters<a class="headerlink" href="#parameters_159" title="Permanent link">&para;</a></h2>
<p>func : callable
The objective function to be minimized.  Must be in the form
<code>f(x, *args)</code>, where <code>x</code> is the argument in the form of a 1-D array
and <code>args</code> is a  tuple of any additional fixed parameters needed to
completely specify the function.
bounds : sequence or <code>Bounds</code>, optional
Bounds for variables.  There are two ways to specify the bounds:
1. Instance of <code>Bounds</code> class.
2. <code>(min, max)</code> pairs for each element in <code>x</code>, defining the finite
lower and upper bounds for the optimizing argument of <code>func</code>. It is
required to have <code>len(bounds) == len(x)</code>. <code>len(bounds)</code> is used
to determine the number of parameters in <code>x</code>.
args : tuple, optional
Any additional fixed parameters needed to
completely specify the objective function.
strategy : str, optional
The differential evolution strategy to use. Should be one of:</p>
<ul>
<li>'best1bin'</li>
<li>'best1exp'</li>
<li>'rand1exp'</li>
<li>'randtobest1exp'</li>
<li>'currenttobest1exp'</li>
<li>'best2exp'</li>
<li>'rand2exp'</li>
<li>'randtobest1bin'</li>
<li>'currenttobest1bin'</li>
<li>'best2bin'</li>
<li>'rand2bin'</li>
<li>'rand1bin'</li>
</ul>
<p>The default is 'best1bin'.
maxiter : int, optional
The maximum number of generations over which the entire population is
evolved. The maximum number of function evaluations (with no polishing)
is: <code>(maxiter + 1) * popsize * len(x)</code>
popsize : int, optional
A multiplier for setting the total population size.  The population has
<code>popsize * len(x)</code> individuals (unless the initial population is
supplied via the <code>init</code> keyword).
tol : float, optional
Relative tolerance for convergence, the solving stops when
<code>np.std(pop) &lt;= atol + tol * np.abs(np.mean(population_energies))</code>,
where and <code>atol</code> and <code>tol</code> are the absolute and relative tolerance
respectively.
mutation : float or tuple(float, float), optional
The mutation constant. In the literature this is also known as
differential weight, being denoted by F.
If specified as a float it should be in the range [0, 2].
If specified as a tuple <code>(min, max)</code> dithering is employed. Dithering
randomly changes the mutation constant on a generation by generation
basis. The mutation constant for that generation is taken from
<code>U[min, max)</code>. Dithering can help speed convergence significantly.
Increasing the mutation constant increases the search radius, but will
slow down convergence.
recombination : float, optional
The recombination constant, should be in the range [0, 1]. In the
literature this is also known as the crossover probability, being
denoted by CR. Increasing this value allows a larger number of mutants
to progress into the next generation, but at the risk of population
stability.
seed : int or <code>np.random.RandomState</code>, optional
If <code>seed</code> is not specified the <code>np.RandomState</code> singleton is used.
If <code>seed</code> is an int, a new <code>np.random.RandomState</code> instance is used,
seeded with seed.
If <code>seed</code> is already a <code>np.random.RandomState instance</code>, then that
<code>np.random.RandomState</code> instance is used.
Specify <code>seed</code> for repeatable minimizations.
disp : bool, optional
Prints the evaluated <code>func</code> at every iteration.
callback : callable, <code>callback(xk, convergence=val)</code>, optional
A function to follow the progress of the minimization. <code>xk</code> is
the current value of <code>x0</code>. <code>val</code> represents the fractional
value of the population convergence.  When <code>val</code> is greater than one
the function halts. If callback returns <code>True</code>, then the minimization
is halted (any polishing is still carried out).
polish : bool, optional
If True (default), then <code>scipy.optimize.minimize</code> with the <code>L-BFGS-B</code>
method is used to polish the best population member at the end, which
can improve the minimization slightly. If a constrained problem is
being studied then the <code>trust-constr</code> method is used instead.
init : str or array-like, optional
Specify which type of population initialization is performed. Should be
one of:</p>
<ul>
<li>'latinhypercube'</li>
<li>'random'</li>
<li>array specifying the initial population. The array should have
shape <code>(M, len(x))</code>, where len(x) is the number of parameters.
<code>init</code> is clipped to <code>bounds</code> before use.</li>
</ul>
<p>The default is 'latinhypercube'. Latin Hypercube sampling tries to
maximize coverage of the available parameter space. 'random'
initializes the population randomly - this has the drawback that
clustering can occur, preventing the whole of parameter space being
covered. Use of an array to specify a population subset could be used,
for example, to create a tight bunch of initial guesses in an location
where the solution is known to exist, thereby reducing time for
convergence.
atol : float, optional
Absolute tolerance for convergence, the solving stops when
<code>np.std(pop) &lt;= atol + tol * np.abs(np.mean(population_energies))</code>,
where and <code>atol</code> and <code>tol</code> are the absolute and relative tolerance
respectively.
updating : {'immediate', 'deferred'}, optional
If <code>'immediate'</code>, the best solution vector is continuously updated
within a single generation [4]_. This can lead to faster convergence as
trial vectors can take advantage of continuous improvements in the best
solution.
With <code>'deferred'</code>, the best solution vector is updated once per
generation. Only <code>'deferred'</code> is compatible with parallelization, and
the <code>workers</code> keyword can over-ride this option.</p>
<p>.. versionadded:: 1.2.0</p>
<p>workers : int or map-like callable, optional
If <code>workers</code> is an int the population is subdivided into <code>workers</code>
sections and evaluated in parallel
(uses <code>multiprocessing.Pool &lt;multiprocessing&gt;</code>).
Supply -1 to use all available CPU cores.
Alternatively supply a map-like callable, such as
<code>multiprocessing.Pool.map</code> for evaluating the population in parallel.
This evaluation is carried out as <code>workers(func, iterable)</code>.
This option will override the <code>updating</code> keyword to
<code>updating='deferred'</code> if <code>workers != 1</code>.
Requires that <code>func</code> be pickleable.</p>
<p>.. versionadded:: 1.2.0</p>
<p>constraints : {NonLinearConstraint, LinearConstraint, Bounds}
Constraints on the solver, over and above those applied by the <code>bounds</code>
kwd. Uses the approach by Lampinen [5]_.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_141">Returns<a class="headerlink" href="#returns_141" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>success</code> a
Boolean flag indicating if the optimizer exited successfully and
<code>message</code> which describes the cause of the termination. See
<code>OptimizeResult</code> for a description of other attributes.  If <code>polish</code>
was employed, and a lower minimum was obtained by the polishing, then
OptimizeResult also contains the <code>jac</code> attribute.
If the eventual solution does not satisfy the applied constraints
<code>success</code> will be <code>False</code>.</p>
<h2 id="notes_84">Notes<a class="headerlink" href="#notes_84" title="Permanent link">&para;</a></h2>
<p>Differential evolution is a stochastic population based method that is
useful for global optimization problems. At each pass through the population
the algorithm mutates each candidate solution by mixing with other candidate
solutions to create a trial candidate. There are several strategies [2]_ for
creating trial candidates, which suit some problems more than others. The
'best1bin' strategy is a good starting point for many systems. In this
strategy two members of the population are randomly chosen. Their difference
is used to mutate the best member (the <code>best</code> in <code>best1bin</code>), :math:<code>b_0</code>,
so far:</p>
<p>.. math::</p>
<p>b' = b_0 + mutation * (population[rand0] - population[rand1])</p>
<p>A trial vector is then constructed. Starting with a randomly chosen 'i'th
parameter the trial is sequentially filled (in modulo) with parameters from
<code>b'</code> or the original candidate. The choice of whether to use <code>b'</code> or the
original candidate is made with a binomial distribution (the 'bin' in
'best1bin') - a random number in [0, 1) is generated.  If this number is
less than the <code>recombination</code> constant then the parameter is loaded from
<code>b'</code>, otherwise it is loaded from the original candidate.  The final
parameter is always loaded from <code>b'</code>.  Once the trial candidate is built
its fitness is assessed. If the trial is better than the original candidate
then it takes its place. If it is also better than the best overall
candidate it also replaces that.
To improve your chances of finding a global minimum use higher <code>popsize</code>
values, with higher <code>mutation</code> and (dithering), but lower <code>recombination</code>
values. This has the effect of widening the search radius, but slowing
convergence.
By default the best solution vector is updated continuously within a single
iteration (<code>updating='immediate'</code>). This is a modification [4]_ of the
original differential evolution algorithm which can lead to faster
convergence as trial vectors can immediately benefit from improved
solutions. To use the original Storn and Price behaviour, updating the best
solution once per iteration, set <code>updating='deferred'</code>.</p>
<p>.. versionadded:: 0.15.0</p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<p>Let us consider the problem of minimizing the Rosenbrock function. This
function is implemented in <code>rosen</code> in <code>scipy.optimize</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen, differential_evolution
bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
result = differential_evolution(rosen, bounds)
result.x, result.fun
(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now repeat, but with parallelization.</p>
<blockquote>
<blockquote>
<blockquote>
<p>bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
result = differential_evolution(rosen, bounds, updating='deferred',
...                                 workers=2)
result.x, result.fun
(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let's try and do a constrained minimization</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import NonlinearConstraint, Bounds
def constr_f(x):
...     return np.array(x[0] + x[1])</p>
<h1 id="the-sum-of-x0-and-x1-must-be-less-than-19">the sum of x[0] and x[1] must be less than 1.9<a class="headerlink" href="#the-sum-of-x0-and-x1-must-be-less-than-19" title="Permanent link">&para;</a></h1>
<p>nlc = NonlinearConstraint(constr_f, -np.inf, 1.9)</p>
<h1 id="specify-limits-using-a-bounds-object">specify limits using a <code>Bounds</code> object.<a class="headerlink" href="#specify-limits-using-a-bounds-object" title="Permanent link">&para;</a></h1>
<p>bounds = Bounds([0., 0.], [2., 2.])
result = differential_evolution(rosen, bounds, constraints=(nlc),
...                                 seed=1)
result.x, result.fun
(array([0.96633867, 0.93363577]), 0.0011361355854792312)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Next find the minimum of the Ackley function
(https://en.wikipedia.org/wiki/Test_functions_for_optimization).</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import differential_evolution
import numpy as np
def ackley(x):
...     arg1 = -0.2 * np.sqrt(0.5 * (x[0] <strong> 2 + x[1] </strong> 2))
...     arg2 = 0.5 * (np.cos(2. * np.pi * x[0]) + np.cos(2. * np.pi * x[1]))
...     return -20. * np.exp(arg1) - np.exp(arg2) + 20. + np.e
bounds = [(-5, 5), (-5, 5)]
result = differential_evolution(ackley, bounds)
result.x, result.fun
(array([ 0.,  0.]), 4.4408920985006262e-16)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [1] Storn, R and Price, K, Differential Evolution - a Simple and
Efficient Heuristic for Global Optimization over Continuous Spaces,
Journal of Global Optimization, 1997, 11, 341 - 359.
.. [2] http://www1.icsi.berkeley.edu/~storn/code.html
.. [3] http://en.wikipedia.org/wiki/Differential_evolution
.. [4] Wormington, M., Panaccione, C., Matney, K. M., Bowen, D. K., -
Characterization of structures from X-ray scattering data using
genetic algorithms, Phil. Trans. R. Soc. Lond. A, 1999, 357,
2827-2848
.. [5] Lampinen, J., A constraint handling approach for the differential
evolution algorithm. Proceedings of the 2002 Congress on
Evolutionary Computation. CEC'02 (Cat. No. 02TH8600). Vol. 2. IEEE,
2002.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_annealing</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">local_search_options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial_temp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">restart_temp_ratio</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">visit</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">accept</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">seed</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">no_local_search</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the global minimum of a function using Dual Annealing.</p>
<h2 id="parameters_160">Parameters<a class="headerlink" href="#parameters_160" title="Permanent link">&para;</a></h2>
<p>func : callable
The objective function to be minimized.  Must be in the form
<code>f(x, *args)</code>, where <code>x</code> is the argument in the form of a 1-D array
and <code>args</code> is a  tuple of any additional fixed parameters needed to
completely specify the function.
bounds : sequence, shape (n, 2)
Bounds for variables.  <code>(min, max)</code> pairs for each element in <code>x</code>,
defining bounds for the objective function parameter.
args : tuple, optional
Any additional fixed parameters needed to completely specify the
objective function.
maxiter : int, optional
The maximum number of global search iterations. Default value is 1000.
local_search_options : dict, optional
Extra keyword arguments to be passed to the local minimizer
(<code>minimize</code>). Some important options could be:
<code>method</code> for the minimizer method to use and <code>args</code> for
objective function additional arguments.
initial_temp : float, optional
The initial temperature, use higher values to facilitates a wider
search of the energy landscape, allowing dual_annealing to escape
local minima that it is trapped in. Default value is 5230. Range is
(0.01, 5.e4].
restart_temp_ratio : float, optional
During the annealing process, temperature is decreasing, when it
reaches <code>initial_temp * restart_temp_ratio</code>, the reannealing process
is triggered. Default value of the ratio is 2e-5. Range is (0, 1).
visit : float, optional
Parameter for visiting distribution. Default value is 2.62. Higher
values give the visiting distribution a heavier tail, this makes
the algorithm jump to a more distant region. The value range is (0, 3].
accept : float, optional
Parameter for acceptance distribution. It is used to control the
probability of acceptance. The lower the acceptance parameter, the
smaller the probability of acceptance. Default value is -5.0 with
a range (-1e4, -5].
maxfun : int, optional
Soft limit for the number of objective function calls. If the
algorithm is in the middle of a local search, this number will be
exceeded, the algorithm will stop just after the local search is
done. Default value is 1e7.
seed : {int or <code>~numpy.random.mtrand.RandomState</code> instance}, optional
If <code>seed</code> is not specified the <code>~numpy.random.mtrand.RandomState</code>
singleton is used.
If <code>seed</code> is an int, a new <code>RandomState</code> instance is used,
seeded with <code>seed</code>.
If <code>seed</code> is already a <code>RandomState</code> instance, then that
instance is used.
Specify <code>seed</code> for repeatable minimizations. The random numbers
generated with this seed only affect the visiting distribution
function and new coordinates generation.
no_local_search : bool, optional
If <code>no_local_search</code> is set to True, a traditional Generalized
Simulated Annealing will be performed with no local search
strategy applied.
callback : callable, optional
A callback function with signature <code>callback(x, f, context)</code>,
which will be called for all minima found.
<code>x</code> and <code>f</code> are the coordinates and function value of the
latest minimum found, and <code>context</code> has value in [0, 1, 2], with the
following meaning:</p>
<ul>
<li>0: minimum detected in the annealing process.</li>
<li>1: detection occurred in the local search process.</li>
<li>2: detection done in the dual annealing process.</li>
</ul>
<p>If the callback implementation returns True, the algorithm will stop.
x0 : ndarray, shape(n,), optional
Coordinates of a single n-dimensional starting point.</p>
<h2 id="returns_142">Returns<a class="headerlink" href="#returns_142" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>fun</code> the value
of the function at the solution, and <code>message</code> which describes the
cause of the termination.
See <code>OptimizeResult</code> for a description of other attributes.</p>
<h2 id="notes_85">Notes<a class="headerlink" href="#notes_85" title="Permanent link">&para;</a></h2>
<p>This function implements the Dual Annealing optimization. This stochastic
approach derived from [3]<em> combines the generalization of CSA (Classical
Simulated Annealing) and FSA (Fast Simulated Annealing) [1]</em> [2]<em> coupled
to a strategy for applying a local search on accepted locations [4]</em>.
An alternative implementation of this same algorithm is described in [5]<em>
and benchmarks are presented in [6]</em>. This approach introduces an advanced
method to refine the solution found by the generalized annealing
process. This algorithm uses a distorted Cauchy-Lorentz visiting
distribution, with its shape controlled by the parameter :math:<code>q_{v}</code></p>
<p>.. math::</p>
<p>g_{q_{v}}(\Delta x(t)) \propto \frac{ \
\left[T_{q_{v}}(t) \right]^{-\frac{D}{3-q_{v}}}}{ \
\left[{1+(q_{v}-1)\frac{(\Delta x(t))^{2}} { \
\left[T_{q_{v}}(t)\right]^{\frac{2}{3-q_{v}}}}}\right]^{ \
\frac{1}{q_{v}-1}+\frac{D-1}{2}}}</p>
<p>Where :math:<code>t</code> is the artificial time. This visiting distribution is used
to generate a trial jump distance :math:<code>\Delta x(t)</code> of variable
:math:<code>x(t)</code> under artificial temperature :math:<code>T_{q_{v}}(t)</code>.</p>
<p>From the starting point, after calling the visiting distribution
function, the acceptance probability is computed as follows:</p>
<p>.. math::</p>
<p>p_{q_{a}} = \min{{1,\left[1-(1-q_{a}) \beta \Delta E \right]^{ \
\frac{1}{1-q_{a}}}}}</p>
<p>Where :math:<code>q_{a}</code> is a acceptance parameter. For :math:<code>q_{a}&lt;1</code>, zero
acceptance probability is assigned to the cases where</p>
<p>.. math::</p>
<p>[1-(1-q_{a}) \beta \Delta E] &lt; 0</p>
<p>The artificial temperature :math:<code>T_{q_{v}}(t)</code> is decreased according to</p>
<p>.. math::</p>
<p>T_{q_{v}}(t) = T_{q_{v}}(1) \frac{2^{q_{v}-1}-1}{\left( \
1 + t\right)^{q_{v}-1}-1}</p>
<p>Where :math:<code>q_{v}</code> is the visiting parameter.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="references_34">References<a class="headerlink" href="#references_34" title="Permanent link">&para;</a></h2>
<p>.. [1] Tsallis C. Possible generalization of Boltzmann-Gibbs
statistics. Journal of Statistical Physics, 52, 479-487 (1998).
.. [2] Tsallis C, Stariolo DA. Generalized Simulated Annealing.
Physica A, 233, 395-406 (1996).
.. [3] Xiang Y, Sun DY, Fan W, Gong XG. Generalized Simulated
Annealing Algorithm and Its Application to the Thomson Model.
Physics Letters A, 233, 216-220 (1997).
.. [4] Xiang Y, Gong XG. Efficiency of Generalized Simulated
Annealing. Physical Review E, 62, 4473 (2000).
.. [5] Xiang Y, Gubian S, Suomela B, Hoeng J. Generalized
Simulated Annealing for Efficient Global Optimization: the GenSA
Package for R. The R Journal, Volume 5/1 (2013).
.. [6] Mullen, K. Continuous Global Optimization in R. Journal of
Statistical Software, 60(6), 1 - 45, (2014). DOI:10.18637/jss.v060.i06</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<p>The following example is a 10-dimensional problem, with many local minima.
The function involved is called Rastrigin
(https://en.wikipedia.org/wiki/Rastrigin_function)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import dual_annealing
func = lambda x: np.sum(x<em>x - 10</em>np.cos(2<em>np.pi</em>x)) + 10*np.size(x)
lw = [-5.12] * 10
up = [5.12] * 10
ret = dual_annealing(func, bounds=list(zip(lw, up)), seed=1234)
print('global minimum: xmin = {0}, f(xmin) = {1:.6f}'.format(
...       ret.x, ret.fun))
global minimum: xmin = [-4.26437714e-09 -3.91699361e-09 -1.86149218e-09 -3.97165720e-09
-6.29151648e-09 -6.53145322e-09 -3.93616815e-09 -6.55623025e-09
-6.05775280e-09 -5.00668935e-09], f(xmin) = 0.000000</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">excitingmixing</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alphamax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a tuned diagonal Jacobian approximation.</p>
<p>The Jacobian matrix is diagonal and is tuned on each iteration.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="see-also_103">See Also<a class="headerlink" href="#see-also_103" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='excitingmixing'</code> in particular.</p>
<h2 id="parameters_161">Parameters<a class="headerlink" href="#parameters_161" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
Initial Jacobian approximation is (-1/alpha).
alphamax : float, optional
The entries of the diagonal Jacobian are kept in the range
<code>[alpha, alphamax]</code>.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_143">Returns<a class="headerlink" href="#returns_143" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_24">Raises<a class="headerlink" href="#raises_24" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fixed_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Del2</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iteration</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a fixed point of the function.</p>
<p>Given a function of one or more variables and a starting point, find a
fixed-point of the function: i.e. where <code>func(x0) == x0</code>.</p>
<h2 id="parameters_162">Parameters<a class="headerlink" href="#parameters_162" title="Permanent link">&para;</a></h2>
<p>func : function
Function to evaluate.
x0 : array_like
Fixed point of function.
args : tuple, optional
Extra arguments to <code>func</code>.
xtol : float, optional
Convergence tolerance, defaults to 1e-08.
maxiter : int, optional
Maximum number of iterations, defaults to 500.
method : {'del2', 'iteration'}, optional
Method of finding the fixed-point, defaults to 'del2'
which uses Steffensen's Method with Aitken's <code>Del^2</code>
convergence acceleration [1]_. The 'iteration' method simply iterates
the function until convergence is detected, without attempting to
accelerate the convergence.</p>
<h2 id="references_35">References<a class="headerlink" href="#references_35" title="Permanent link">&para;</a></h2>
<p>.. [1] Burden, Faires, 'Numerical Analysis', 5th edition, pg. 80</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def func(x, c1, c2):
...    return np.sqrt(c1/(x+c2))
c1 = np.array([10,12.])
c2 = np.array([3, 5.])
optimize.fixed_point(func, [1.2, 1.3], args=(c1,c2))
array([ 1.4920333 ,  1.37228132])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial_simplex</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using the downhill simplex algorithm.</p>
<p>This algorithm only uses function values, not derivatives or second
derivatives.</p>
<h2 id="parameters_163">Parameters<a class="headerlink" href="#parameters_163" title="Permanent link">&para;</a></h2>
<p>func : callable func(x,*args)
The objective function to be minimized.
x0 : ndarray
Initial guess.
args : tuple, optional
Extra arguments passed to func, i.e. <code>f(x,*args)</code>.
xtol : float, optional
Absolute error in xopt between iterations that is acceptable for
convergence.
ftol : number, optional
Absolute error in func(xopt) between iterations that is acceptable for
convergence.
maxiter : int, optional
Maximum number of iterations to perform.
maxfun : number, optional
Maximum number of function evaluations to make.
full_output : bool, optional
Set to True if fopt and warnflag outputs are desired.
disp : bool, optional
Set to True to print convergence messages.
retall : bool, optional
Set to True to return list of solutions at each iteration.
callback : callable, optional
Called after each iteration, as callback(xk), where xk is the
current parameter vector.
initial_simplex : array_like of shape (N + 1, N), optional
Initial simplex. If given, overrides <code>x0</code>.
<code>initial_simplex[j,:]</code> should contain the coordinates of
the j-th vertex of the <code>N+1</code> vertices in the simplex, where
<code>N</code> is the dimension.</p>
<h2 id="returns_144">Returns<a class="headerlink" href="#returns_144" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameter that minimizes function.
fopt : float
Value of function at minimum: <code>fopt = func(xopt)</code>.
iter : int
Number of iterations performed.
funcalls : int
Number of function calls made.
warnflag : int
1 : Maximum number of function evaluations made.
2 : Maximum number of iterations reached.
allvecs : list
Solution at each iteration.</p>
<h2 id="see-also_104">See also<a class="headerlink" href="#see-also_104" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'Nelder-Mead' <code>method</code> in particular.</p>
<h2 id="notes_86">Notes<a class="headerlink" href="#notes_86" title="Permanent link">&para;</a></h2>
<p>Uses a Nelder-Mead simplex algorithm to find the minimum of function of
one or more variables.</p>
<p>This algorithm has a long history of successful use in applications.
But it will usually be slower than an algorithm that uses first or
second derivative information. In practice it can have poor
performance in high-dimensional problems and is not robust to
minimizing complicated functions. Additionally, there currently is no
complete theory describing when the algorithm will successfully
converge to the minimum, or how fast it will if it does. Both the ftol and
xtol criteria must be met for convergence.</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fmin(f, 1)
Optimization terminated successfully.
Current function value: 0.000000
Iterations: 17
Function evaluations: 34
minimum[0]
-8.8817841970012523e-16</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_36">References<a class="headerlink" href="#references_36" title="Permanent link">&para;</a></h2>
<p>.. [1] Nelder, J.A. and Mead, R. (1965), 'A simplex method for function
minimization', The Computer Journal, 7, pp. 308-313</p>
<p>.. [2] Wright, M.H. (1996), 'Direct Search Methods: Once Scorned, Now
Respectable', in Numerical Analysis 1995, Proceedings of the
1995 Dundee Biennial Conference in Numerical Analysis, D.F.
Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,
Harlow, UK, pp. 191-208.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_bfgs</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using the BFGS algorithm.</p>
<h2 id="parameters_164">Parameters<a class="headerlink" href="#parameters_164" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function to be minimized.
x0 : ndarray
Initial guess.
fprime : callable f'(x,</em>args), optional
Gradient of f.
args : tuple, optional
Extra arguments passed to f and fprime.
gtol : float, optional
Gradient norm must be less than gtol before successful termination.
norm : float, optional
Order of norm (Inf is max, -Inf is min)
epsilon : int or ndarray, optional
If fprime is approximated, use this value for the step size.
callback : callable, optional
An optional user-supplied function to call after each
iteration.  Called as callback(xk), where xk is the
current parameter vector.
maxiter : int, optional
Maximum number of iterations to perform.
full_output : bool, optional
If True,return fopt, func_calls, grad_calls, and warnflag
in addition to xopt.
disp : bool, optional
Print convergence message if True.
retall : bool, optional
Return a list of results at each iteration if True.</p>
<h2 id="returns_145">Returns<a class="headerlink" href="#returns_145" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. f(xopt) == fopt.
fopt : float
Minimum value.
gopt : ndarray
Value of gradient at minimum, f'(xopt), which should be near 0.
Bopt : ndarray
Value of 1/f''(xopt), i.e. the inverse hessian matrix.
func_calls : int
Number of function_calls made.
grad_calls : int
Number of gradient calls made.
warnflag : integer
1 : Maximum number of iterations exceeded.
2 : Gradient and/or function calls not changing.
3 : NaN result encountered.
allvecs  :  list
The value of xopt at each iteration.  Only returned if retall is True.</p>
<h2 id="see-also_105">See also<a class="headerlink" href="#see-also_105" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'BFGS' <code>method</code> in particular.</p>
<h2 id="notes_87">Notes<a class="headerlink" href="#notes_87" title="Permanent link">&para;</a></h2>
<p>Optimize the function, f, whose gradient is given by fprime
using the quasi-Newton method of Broyden, Fletcher, Goldfarb,
and Shanno (BFGS)</p>
<h2 id="references_37">References<a class="headerlink" href="#references_37" title="Permanent link">&para;</a></h2>
<p>Wright, and Nocedal 'Numerical Optimization', 1999, pg. 198.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_cg</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:[`</span><span class="nc">T_fprime_x_args_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_f_x_args_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using a nonlinear conjugate gradient algorithm.</p>
<h2 id="parameters_165">Parameters<a class="headerlink" href="#parameters_165" title="Permanent link">&para;</a></h2>
<p>f : callable, <code>f(x, *args)</code>
Objective function to be minimized.  Here <code>x</code> must be a 1-D array of
the variables that are to be changed in the search for a minimum, and
<code>args</code> are the other (fixed) parameters of <code>f</code>.
x0 : ndarray
A user-supplied initial estimate of <code>xopt</code>, the optimal value of <code>x</code>.
It must be a 1-D array of values.
fprime : callable, <code>fprime(x, *args)</code>, optional
A function that returns the gradient of <code>f</code> at <code>x</code>. Here <code>x</code> and <code>args</code>
are as described above for <code>f</code>. The returned value must be a 1-D array.
Defaults to None, in which case the gradient is approximated
numerically (see <code>epsilon</code>, below).
args : tuple, optional
Parameter values passed to <code>f</code> and <code>fprime</code>. Must be supplied whenever
additional fixed parameters are needed to completely specify the
functions <code>f</code> and <code>fprime</code>.
gtol : float, optional
Stop when the norm of the gradient is less than <code>gtol</code>.
norm : float, optional
Order to use for the norm of the gradient
(<code>-np.Inf</code> is min, <code>np.Inf</code> is max).
epsilon : float or ndarray, optional
Step size(s) to use when <code>fprime</code> is approximated numerically. Can be a
scalar or a 1-D array.  Defaults to <code>sqrt(eps)</code>, with eps the
floating point machine precision.  Usually <code>sqrt(eps)</code> is about
1.5e-8.
maxiter : int, optional
Maximum number of iterations to perform. Default is <code>200 * len(x0)</code>.
full_output : bool, optional
If True, return <code>fopt</code>, <code>func_calls</code>, <code>grad_calls</code>, and <code>warnflag</code> in
addition to <code>xopt</code>.  See the Returns section below for additional
information on optional return values.
disp : bool, optional
If True, return a convergence message, followed by <code>xopt</code>.
retall : bool, optional
If True, add to the returned values the results of each iteration.
callback : callable, optional
An optional user-supplied function, called after each iteration.
Called as <code>callback(xk)</code>, where <code>xk</code> is the current value of <code>x0</code>.</p>
<h2 id="returns_146">Returns<a class="headerlink" href="#returns_146" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. <code>f(xopt) == fopt</code>.
fopt : float, optional
Minimum value found, f(xopt).  Only returned if <code>full_output</code> is True.
func_calls : int, optional
The number of function_calls made.  Only returned if <code>full_output</code>
is True.
grad_calls : int, optional
The number of gradient calls made. Only returned if <code>full_output</code> is
True.
warnflag : int, optional
Integer value with warning status, only returned if <code>full_output</code> is
True.</p>
<p>0 : Success.</p>
<p>1 : The maximum number of iterations was exceeded.</p>
<p>2 : Gradient and/or function calls were not changing.  May indicate
that precision was lost, i.e., the routine did not converge.</p>
<p>3 : NaN result encountered.</p>
<p>allvecs : list of ndarray, optional
List of arrays, containing the results at each iteration.
Only returned if <code>retall</code> is True.</p>
<h2 id="see-also_106">See Also<a class="headerlink" href="#see-also_106" title="Permanent link">&para;</a></h2>
<p>minimize : common interface to all <code>scipy.optimize</code> algorithms for
unconstrained and constrained minimization of multivariate
functions.  It provides an alternative way to call
<code>fmin_cg</code>, by specifying <code>method='CG'</code>.</p>
<h2 id="notes_88">Notes<a class="headerlink" href="#notes_88" title="Permanent link">&para;</a></h2>
<p>This conjugate gradient algorithm is based on that of Polak and Ribiere
[1]_.</p>
<p>Conjugate gradient methods tend to work better when:</p>
<ol>
<li><code>f</code> has a unique global minimizing point, and no local minima or
other stationary points,</li>
<li><code>f</code> is, at least locally, reasonably well approximated by a
quadratic function of the variables,</li>
<li><code>f</code> is continuous and has a continuous gradient,</li>
<li><code>fprime</code> is not too large, e.g., has a norm less than 1000,</li>
<li>The initial guess, <code>x0</code>, is reasonably close to <code>f</code> 's global
minimizing point, <code>xopt</code>.</li>
</ol>
<h2 id="references_38">References<a class="headerlink" href="#references_38" title="Permanent link">&para;</a></h2>
<p>.. [1] Wright &amp; Nocedal, 'Numerical Optimization', 1999, pp. 120-122.</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<p>Example 1: seek the minimum value of the expression
<code>a*u**2 + b*u*v + c*v**2 + d*u + e*v + f</code> for given values
of the parameters and an initial guess <code>(u, v) = (0, 0)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>args = (2, 3, 7, 8, 9, 10)  # parameter values
def f(x, <em>args):
...     u, v = x
...     a, b, c, d, e, f = args
...     return a</em>u<strong>2 + b<em>u</em>v + c*v</strong>2 + d<em>u + e</em>v + f
def gradf(x, <em>args):
...     u, v = x
...     a, b, c, d, e, f = args
...     gu = 2</em>a<em>u + b</em>v + d     # u-component of the gradient
...     gv = b<em>u + 2</em>c*v + e     # v-component of the gradient
...     return np.asarray((gu, gv))
x0 = np.asarray((0, 0))  # Initial guess.
from scipy import optimize
res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)
Optimization terminated successfully.
Current function value: 1.617021
Iterations: 4
Function evaluations: 8
Gradient evaluations: 8
res1
array([-1.80851064, -0.25531915])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Example 2: solve the same problem using the <code>minimize</code> function.
(This <code>myopts</code> dictionary shows all of the available options,
although in practice only non-default values would be needed.
The returned value will be a dictionary.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>opts = {'maxiter' : None,    # default value.
...         'disp' : True,    # non-default value.
...         'gtol' : 1e-5,    # default value.
...         'norm' : np.inf,  # default value.
...         'eps' : 1.4901161193847656e-08}  # default value.
res2 = optimize.minimize(f, x0, jac=gradf, args=args,
...                          method='CG', options=opts)
Optimization terminated successfully.
Current function value: 1.617021
Iterations: 4
Function evaluations: 8
Gradient evaluations: 8
res2.x  # minimum found
array([-1.80851064, -0.25531915])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_cobyla</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">consargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rhobeg</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rhoend</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">catol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimize a function using the Constrained Optimization BY Linear
Approximation (COBYLA) method. This method wraps a FORTRAN
implementation of the algorithm.</p>
<h2 id="parameters_166">Parameters<a class="headerlink" href="#parameters_166" title="Permanent link">&para;</a></h2>
<p>func : callable
Function to minimize. In the form func(x, *args).
x0 : ndarray
Initial guess.
cons : sequence
Constraint functions; must all be <code>&gt;=0</code> (a single function
if only 1 constraint). Each function takes the parameters <code>x</code>
as its first argument, and it can return either a single number or
an array or list of numbers.
args : tuple, optional
Extra arguments to pass to function.
consargs : tuple, optional
Extra arguments to pass to constraint functions (default of None means
use same extra arguments as those passed to func).
Use <code>()</code> for no extra arguments.
rhobeg : float, optional
Reasonable initial changes to the variables.
rhoend : float, optional
Final accuracy in the optimization (not precisely guaranteed). This
is a lower bound on the size of the trust region.
disp : {0, 1, 2, 3}, optional
Controls the frequency of output; 0 implies no output.
maxfun : int, optional
Maximum number of function evaluations.
catol : float, optional
Absolute tolerance for constraint violations.</p>
<h2 id="returns_147">Returns<a class="headerlink" href="#returns_147" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The argument that minimises <code>f</code>.</p>
<h2 id="see-also_107">See also<a class="headerlink" href="#see-also_107" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'COBYLA' <code>method</code> in particular.</p>
<h2 id="notes_89">Notes<a class="headerlink" href="#notes_89" title="Permanent link">&para;</a></h2>
<p>This algorithm is based on linear approximations to the objective
function and each constraint. We briefly describe the algorithm.</p>
<p>Suppose the function is being minimized over k variables. At the
jth iteration the algorithm has k+1 points v_1, ..., v_(k+1),
an approximate solution x_j, and a radius RHO_j.
(i.e. linear plus a constant) approximations to the objective
function and constraint functions such that their function values
agree with the linear approximation on the k+1 points v_1,.., v_(k+1).
This gives a linear program to solve (where the linear approximations
of the constraint functions are constrained to be non-negative).</p>
<p>However the linear approximations are likely only good
approximations near the current simplex, so the linear program is
given the further requirement that the solution, which
will become x_(j+1), must be within RHO_j from x_j. RHO_j only
decreases, never increases. The initial RHO_j is rhobeg and the
final RHO_j is rhoend. In this way COBYLA's iterations behave
like a trust region algorithm.</p>
<p>Additionally, the linear program may be inconsistent, or the
approximation may give poor improvement. For details about
how these issues are resolved, as well as how the points v_i are
updated, refer to the source code or the references below.</p>
<h2 id="references_39">References<a class="headerlink" href="#references_39" title="Permanent link">&para;</a></h2>
<p>Powell M.J.D. (1994), 'A direct search optimization method that models
the objective and constraint functions by linear interpolation.', in
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J-P Hennart, Kluwer Academic (Dordrecht), pp. 51-67</p>
<p>Powell M.J.D. (1998), 'Direct search algorithms for optimization
calculations', Acta Numerica 7, 287-336</p>
<p>Powell M.J.D. (2007), 'A view of algorithms for optimization without
derivatives', Cambridge University Technical Report DAMTP 2007/NA03</p>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<p>Minimize the objective function f(x,y) = x<em>y subject
to the constraints x</em><em>2 + y</em>*2 &lt; 1 and y &gt; 0::</p>
<blockquote>
<blockquote>
<blockquote>
<p>def objective(x):
...     return x[0]<em>x[1]
...
def constr1(x):
...     return 1 - (x[0]</em><em>2 + x[1]</em>*2)
...
def constr2(x):
...     return x[1]
...
from scipy.optimize import fmin_cobyla
fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)
array([-0.70710685,  0.70710671])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The exact solution is (-sqrt(2)/2, sqrt(2)/2).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_l_bfgs_b</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">approx_grad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pgtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iprint</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxls</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function func using the L-BFGS-B algorithm.</p>
<h2 id="parameters_167">Parameters<a class="headerlink" href="#parameters_167" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,<em>args)
Function to minimise.
x0 : ndarray
Initial guess.
fprime : callable fprime(x,</em>args), optional
The gradient of <code>func</code>.  If None, then <code>func</code> returns the function
value and the gradient (<code>f, g = func(x, *args)</code>), unless
<code>approx_grad</code> is True in which case <code>func</code> returns only <code>f</code>.
args : sequence, optional
Arguments to pass to <code>func</code> and <code>fprime</code>.
approx_grad : bool, optional
Whether to approximate the gradient numerically (in which case
<code>func</code> returns only the function value).
bounds : list, optional
<code>(min, max)</code> pairs for each element in <code>x</code>, defining
the bounds on that parameter. Use None or +-inf for one of <code>min</code> or
<code>max</code> when there is no bound in that direction.
m : int, optional
The maximum number of variable metric corrections
used to define the limited memory matrix. (The limited memory BFGS
method does not store the full hessian but uses this many terms in an
approximation to it.)
factr : float, optional
The iteration stops when
<code>(f^k - f^{k+1})/max{ |f^k|,|f^{k+1}|,1} &lt;= factr * eps</code>,
where <code>eps</code> is the machine precision, which is automatically
generated by the code. Typical values for <code>factr</code> are: 1e12 for
low accuracy; 1e7 for moderate accuracy; 10.0 for extremely
high accuracy. See Notes for relationship to <code>ftol</code>, which is exposed
(instead of <code>factr</code>) by the <code>scipy.optimize.minimize</code> interface to
L-BFGS-B.
pgtol : float, optional
The iteration will stop when
<code>max{ |proj g_i | i = 1, ..., n} &lt;= pgtol</code>
where <code>pg_i</code> is the i-th component of the projected gradient.
epsilon : float, optional
Step size used when <code>approx_grad</code> is True, for numerically
calculating the gradient
iprint : int, optional
Controls the frequency of output. <code>iprint &lt; 0</code> means no output;
<code>iprint = 0</code>    print only one line at the last iteration;
<code>0 &lt; iprint &lt; 99</code> print also f and <code>|proj g|</code> every iprint iterations;
<code>iprint = 99</code>   print details of every iteration except n-vectors;
<code>iprint = 100</code>  print also the changes of active set and final x;
<code>iprint &gt; 100</code>  print details of every iteration including x and g.
disp : int, optional
If zero, then no output.  If a positive number, then this over-rides
<code>iprint</code> (i.e., <code>iprint</code> gets the value of <code>disp</code>).
maxfun : int, optional
Maximum number of function evaluations.
maxiter : int, optional
Maximum number of iterations.
callback : callable, optional
Called after each iteration, as <code>callback(xk)</code>, where <code>xk</code> is the
current parameter vector.
maxls : int, optional
Maximum number of line search steps (per iteration). Default is 20.</p>
<h2 id="returns_148">Returns<a class="headerlink" href="#returns_148" title="Permanent link">&para;</a></h2>
<p>x : array_like
Estimated position of the minimum.
f : float
Value of <code>func</code> at the minimum.
d : dict
Information dictionary.</p>
<ul>
<li>
<p>d['warnflag'] is</p>
</li>
<li>
<p>0 if converged,</p>
</li>
<li>1 if too many function evaluations or too many iterations,</li>
<li>
<p>2 if stopped for another reason, given in d['task']</p>
</li>
<li>
<p>d['grad'] is the gradient at the minimum (should be 0 ish)</p>
</li>
<li>d['funcalls'] is the number of function calls made.</li>
<li>d['nit'] is the number of iterations.</li>
</ul>
<h2 id="see-also_108">See also<a class="headerlink" href="#see-also_108" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'L-BFGS-B' <code>method</code> in particular. Note that the
<code>ftol</code> option is made available via that interface, while <code>factr</code> is
provided via this interface, where <code>factr</code> is the factor multiplying
the default machine floating-point precision to arrive at <code>ftol</code>:
<code>ftol = factr * numpy.finfo(float).eps</code>.</p>
<h2 id="notes_90">Notes<a class="headerlink" href="#notes_90" title="Permanent link">&para;</a></h2>
<p>License of L-BFGS-B (FORTRAN code):</p>
<p>The version included here (in fortran code) is 3.0
(released April 25, 2011).  It was written by Ciyou Zhu, Richard Byrd,
and Jorge Nocedal <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#99;&#101;&#100;&#97;&#108;&#64;&#101;&#99;&#101;&#46;&#110;&#119;&#117;&#46;&#101;&#100;&#117;">&#110;&#111;&#99;&#101;&#100;&#97;&#108;&#64;&#101;&#99;&#101;&#46;&#110;&#119;&#117;&#46;&#101;&#100;&#117;</a>. It carries the following
condition for use:</p>
<p>This software is freely available, but we expect that all publications
describing work using this software, or all commercial products using it,
quote at least one of the references given below. This software is released
under the BSD License.</p>
<h2 id="references_40">References<a class="headerlink" href="#references_40" title="Permanent link">&para;</a></h2>
<ul>
<li>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound
Constrained Optimization, (1995), SIAM Journal on Scientific and
Statistical Computing, 16, 5, pp. 1190-1208.</li>
<li>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (1997),
ACM Transactions on Mathematical Software, 23, 4, pp. 550 - 560.</li>
<li>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B,
FORTRAN routines for large scale bound constrained optimization (2011),
ACM Transactions on Mathematical Software, 38, 1.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_ncg</span> <span class="o">:</span> <span class="o">?</span><span class="n">fhess_p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fhess</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">avextol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Unconstrained minimization of a function using the Newton-CG method.</p>
<h2 id="parameters_168">Parameters<a class="headerlink" href="#parameters_168" title="Permanent link">&para;</a></h2>
<p>f : callable <code>f(x, *args)</code>
Objective function to be minimized.
x0 : ndarray
Initial guess.
fprime : callable <code>f'(x, *args)</code>
Gradient of f.
fhess_p : callable <code>fhess_p(x, p, *args)</code>, optional
Function which computes the Hessian of f times an
arbitrary vector, p.
fhess : callable <code>fhess(x, *args)</code>, optional
Function to compute the Hessian matrix of f.
args : tuple, optional
Extra arguments passed to f, fprime, fhess_p, and fhess
(the same set of extra arguments is supplied to all of
these functions).
epsilon : float or ndarray, optional
If fhess is approximated, use this value for the step size.
callback : callable, optional
An optional user-supplied function which is called after
each iteration.  Called as callback(xk), where xk is the
current parameter vector.
avextol : float, optional
Convergence is assumed when the average relative error in
the minimizer falls below this amount.
maxiter : int, optional
Maximum number of iterations to perform.
full_output : bool, optional
If True, return the optional outputs.
disp : bool, optional
If True, print convergence message.
retall : bool, optional
If True, return a list of results at each iteration.</p>
<h2 id="returns_149">Returns<a class="headerlink" href="#returns_149" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters which minimize f, i.e. <code>f(xopt) == fopt</code>.
fopt : float
Value of the function at xopt, i.e. <code>fopt = f(xopt)</code>.
fcalls : int
Number of function calls made.
gcalls : int
Number of gradient calls made.
hcalls : int
Number of hessian calls made.
warnflag : int
Warnings generated by the algorithm.
1 : Maximum number of iterations exceeded.
2 : Line search failure (precision loss).
3 : NaN result encountered.
allvecs : list
The result at each iteration, if retall is True (see below).</p>
<h2 id="see-also_109">See also<a class="headerlink" href="#see-also_109" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'Newton-CG' <code>method</code> in particular.</p>
<h2 id="notes_91">Notes<a class="headerlink" href="#notes_91" title="Permanent link">&para;</a></h2>
<p>Only one of <code>fhess_p</code> or <code>fhess</code> need to be given.  If <code>fhess</code>
is provided, then <code>fhess_p</code> will be ignored.  If neither <code>fhess</code>
nor <code>fhess_p</code> is provided, then the hessian product will be
approximated using finite differences on <code>fprime</code>. <code>fhess_p</code>
must compute the hessian times an arbitrary vector. If it is not
given, finite-differences on <code>fprime</code> are used to compute
it.</p>
<p>Newton-CG methods are also called truncated Newton methods. This
function differs from scipy.optimize.fmin_tnc because</p>
<ol>
<li>scipy.optimize.fmin_ncg is written purely in python using numpy
and scipy while scipy.optimize.fmin_tnc calls a C function.</li>
<li>scipy.optimize.fmin_ncg is only for unconstrained minimization
while scipy.optimize.fmin_tnc is for unconstrained minimization
or box constrained minimization. (Box constraints give
lower and upper bounds for each variable separately.)</li>
</ol>
<h2 id="references_41">References<a class="headerlink" href="#references_41" title="Permanent link">&para;</a></h2>
<p>Wright &amp; Nocedal, 'Numerical Optimization', 1999, pg. 140.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_powell</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retall</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">direc</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using modified Powell's method.</p>
<p>This method only uses function values, not derivatives.</p>
<h2 id="parameters_169">Parameters<a class="headerlink" href="#parameters_169" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to be minimized.
x0 : ndarray
Initial guess.
args : tuple, optional
Extra arguments passed to func.
xtol : float, optional
Line-search error tolerance.
ftol : float, optional
Relative error in <code>func(xopt)</code> acceptable for convergence.
maxiter : int, optional
Maximum number of iterations to perform.
maxfun : int, optional
Maximum number of function evaluations to make.
full_output : bool, optional
If True, <code>fopt</code>, <code>xi</code>, <code>direc</code>, <code>iter</code>, <code>funcalls</code>, and
<code>warnflag</code> are returned.
disp : bool, optional
If True, print convergence messages.
retall : bool, optional
If True, return a list of the solution at each iteration.
callback : callable, optional
An optional user-supplied function, called after each
iteration.  Called as <code>callback(xk)</code>, where <code>xk</code> is the
current parameter vector.
direc : ndarray, optional
Initial fitting step and parameter order set as an (N, N) array, where N
is the number of fitting parameters in <code>x0</code>.  Defaults to step size 1.0
fitting all parameters simultaneously (<code>np.ones((N, N))</code>).  To
prevent initial consideration of values in a step or to change initial
step size, set to 0 or desired step size in the Jth position in the Mth
block, where J is the position in <code>x0</code> and M is the desired evaluation
step, with steps being evaluated in index order.  Step size and ordering
will change freely as minimization proceeds.</p>
<h2 id="returns_150">Returns<a class="headerlink" href="#returns_150" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameter which minimizes <code>func</code>.
fopt : number
Value of function at minimum: <code>fopt = func(xopt)</code>.
direc : ndarray
Current direction set.
iter : int
Number of iterations.
funcalls : int
Number of function calls made.
warnflag : int
Integer warning flag:
1 : Maximum number of function evaluations.
2 : Maximum number of iterations.
3 : NaN result encountered.
allvecs : list
List of solutions at each iteration.</p>
<h2 id="see-also_110">See also<a class="headerlink" href="#see-also_110" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to unconstrained minimization algorithms for
multivariate functions. See the 'Powell' method in particular.</p>
<h2 id="notes_92">Notes<a class="headerlink" href="#notes_92" title="Permanent link">&para;</a></h2>
<p>Uses a modification of Powell's method to find the minimum of
a function of N variables. Powell's method is a conjugate
direction method.</p>
<p>The algorithm has two loops.  The outer loop merely iterates over the inner
loop. The inner loop minimizes over each current direction in the direction
set. At the end of the inner loop, if certain conditions are met, the
direction that gave the largest decrease is dropped and replaced with the
difference between the current estimated x and the estimated x from the
beginning of the inner-loop.</p>
<p>The technical conditions for replacing the direction of greatest
increase amount to checking that</p>
<ol>
<li>No further gain can be made along the direction of greatest increase
from that iteration.</li>
<li>The direction of greatest increase accounted for a large sufficient
fraction of the decrease in the function value from that iteration of
the inner loop.</li>
</ol>
<h2 id="references_42">References<a class="headerlink" href="#references_42" title="Permanent link">&para;</a></h2>
<p>Powell M.J.D. (1964) An efficient method for finding the minimum of a
function of several variables without calculating derivatives,
Computer Journal, 7 (2):155-162.</p>
<p>Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:
Numerical Recipes (any edition), Cambridge University Press</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fmin_powell(f, -1)
Optimization terminated successfully.
Current function value: 0.000000
Iterations: 2
Function evaluations: 18
minimum
array(0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_slsqp</span> <span class="o">:</span> <span class="o">?</span><span class="n">eqcons</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_eqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ieqcons</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_ieqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime_eqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime_ieqcons</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">acc</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iprint</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function using Sequential Least SQuares Programming</p>
<p>Python interface function for the SLSQP Optimization subroutine
originally implemented by Dieter Kraft.</p>
<h2 id="parameters_170">Parameters<a class="headerlink" href="#parameters_170" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,<em>args)
Objective function.  Must return a scalar.
x0 : 1-D ndarray of float
Initial guess for the independent variable(s).
eqcons : list, optional
A list of functions of length n such that
eqcons<a href="x,*args">j</a> == 0.0 in a successfully optimized
problem.
f_eqcons : callable f(x,</em>args), optional
Returns a 1-D array in which each element must equal 0.0 in a
successfully optimized problem.  If f_eqcons is specified,
eqcons is ignored.
ieqcons : list, optional
A list of functions of length n such that
ieqcons<a href="x,*args">j</a> &gt;= 0.0 in a successfully optimized
problem.
f_ieqcons : callable f(x,*args), optional
Returns a 1-D ndarray in which each element must be greater or
equal to 0.0 in a successfully optimized problem.  If
f_ieqcons is specified, ieqcons is ignored.
bounds : list, optional
A list of tuples specifying the lower and upper bound
for each independent variable [(xl0, xu0),(xl1, xu1),...]
Infinite values will be interpreted as large floating values.
fprime : callable <code>f(x,*args)</code>, optional
A function that evaluates the partial derivatives of func.
fprime_eqcons : callable <code>f(x,*args)</code>, optional
A function of the form <code>f(x, *args)</code> that returns the m by n
array of equality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_eqcons should be sized as ( len(eqcons), len(x0) ).
fprime_ieqcons : callable <code>f(x,*args)</code>, optional
A function of the form <code>f(x, *args)</code> that returns the m by n
array of inequality constraint normals.  If not provided,
the normals will be approximated. The array returned by
fprime_ieqcons should be sized as ( len(ieqcons), len(x0) ).
args : sequence, optional
Additional arguments passed to func and fprime.
iter : int, optional
The maximum number of iterations.
acc : float, optional
Requested accuracy.
iprint : int, optional
The verbosity of fmin_slsqp :</p>
<ul>
<li>iprint &lt;= 0 : Silent operation</li>
<li>iprint == 1 : Print summary upon completion (default)</li>
<li>iprint &gt;= 2 : Print status of each iterate and summary
disp : int, optional
Over-rides the iprint interface (preferred).
full_output : bool, optional
If False, return only the minimizer of func (default).
Otherwise, output final objective function and summary
information.
epsilon : float, optional
The step size for finite-difference derivative estimates.
callback : callable, optional
Called after each iteration, as <code>callback(x)</code>, where <code>x</code> is the
current parameter vector.</li>
</ul>
<h2 id="returns_151">Returns<a class="headerlink" href="#returns_151" title="Permanent link">&para;</a></h2>
<p>out : ndarray of float
The final minimizer of func.
fx : ndarray of float, if full_output is true
The final value of the objective function.
its : int, if full_output is true
The number of iterations.
imode : int, if full_output is true
The exit mode from the optimizer (see below).
smode : string, if full_output is true
Message describing the exit mode from the optimizer.</p>
<h2 id="see-also_111">See also<a class="headerlink" href="#see-also_111" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'SLSQP' <code>method</code> in particular.</p>
<h2 id="notes_93">Notes<a class="headerlink" href="#notes_93" title="Permanent link">&para;</a></h2>
<p>Exit modes are defined as follows ::</p>
<p>-1 : Gradient evaluation required (g &amp; a)
0 : Optimization terminated successfully.
1 : Function evaluation required (f &amp; c)
2 : More equality constraints than independent variables
3 : More than 3*n iterations in LSQ subproblem
4 : Inequality constraints incompatible
5 : Singular matrix E in LSQ subproblem
6 : Singular matrix C in LSQ subproblem
7 : Rank-deficient equality constraint subproblem HFTI
8 : Positive directional derivative for linesearch
9 : Iteration limit exceeded</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<p>Examples are given :ref:<code>in the tutorial &lt;tutorial-sqlsp&gt;</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fmin_tnc</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">approx_grad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsilon</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">offset</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">messages</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxCGit</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stepmx</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">accuracy</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fmin</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pgtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rescale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Minimize a function with variables subject to bounds, using
gradient information in a truncated Newton algorithm. This
method wraps a C implementation of the algorithm.</p>
<h2 id="parameters_171">Parameters<a class="headerlink" href="#parameters_171" title="Permanent link">&para;</a></h2>
<p>func : callable <code>func(x, *args)</code>
Function to minimize.  Must do one of:</p>
<ol>
<li>
<p>Return f and g, where f is the value of the function and g its
gradient (a list of floats).</p>
</li>
<li>
<p>Return the function value but supply gradient function
separately as <code>fprime</code>.</p>
</li>
<li>
<p>Return the function value and set <code>approx_grad=True</code>.</p>
</li>
</ol>
<p>If the function returns None, the minimization
is aborted.
x0 : array_like
Initial estimate of minimum.
fprime : callable <code>fprime(x, *args)</code>, optional
Gradient of <code>func</code>. If None, then either <code>func</code> must return the
function value and the gradient (<code>f,g = func(x, *args)</code>)
or <code>approx_grad</code> must be True.
args : tuple, optional
Arguments to pass to function.
approx_grad : bool, optional
If true, approximate the gradient numerically.
bounds : list, optional
(min, max) pairs for each element in x0, defining the
bounds on that parameter. Use None or +/-inf for one of
min or max when there is no bound in that direction.
epsilon : float, optional
Used if approx_grad is True. The stepsize in a finite
difference approximation for fprime.
scale : array_like, optional
Scaling factors to apply to each variable.  If None, the
factors are up-low for interval bounded variables and
1+|x| for the others.  Defaults to None.
offset : array_like, optional
Value to subtract from each variable.  If None, the
offsets are (up+low)/2 for interval bounded variables
and x for the others.
messages : int, optional
Bit mask used to select messages display during
minimization values defined in the MSGS dict.  Defaults to
MGS_ALL.
disp : int, optional
Integer interface to messages.  0 = no message, 5 = all messages
maxCGit : int, optional
Maximum number of hessian<em>vector evaluations per main
iteration.  If maxCGit == 0, the direction chosen is
-gradient if maxCGit &lt; 0, maxCGit is set to
max(1,min(50,n/2)).  Defaults to -1.
maxfun : int, optional
Maximum number of function evaluation.  if None, maxfun is
set to max(100, 10</em>len(x0)).  Defaults to None.
eta : float, optional
Severity of the line search. if &lt; 0 or &gt; 1, set to 0.25.
Defaults to -1.
stepmx : float, optional
Maximum step for the line search.  May be increased during
call.  If too small, it will be set to 10.0.  Defaults to 0.
accuracy : float, optional
Relative precision for finite difference calculations.  If
&lt;= machine_precision, set to sqrt(machine_precision).
Defaults to 0.
fmin : float, optional
Minimum function value estimate.  Defaults to 0.
ftol : float, optional
Precision goal for the value of f in the stopping criterion.
If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1.
xtol : float, optional
Precision goal for the value of x in the stopping
criterion (after applying x scaling factors).  If xtol &lt;
0.0, xtol is set to sqrt(machine_precision).  Defaults to
-1.
pgtol : float, optional
Precision goal for the value of the projected gradient in
the stopping criterion (after applying x scaling factors).
If pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy).
Setting it to 0.0 is not recommended.  Defaults to -1.
rescale : float, optional
Scaling factor (in log10) used to trigger f value
rescaling.  If 0, rescale at each iteration.  If a large
value, never rescale.  If &lt; 0, rescale is set to 1.3.
callback : callable, optional
Called after each iteration, as callback(xk), where xk is the
current parameter vector.</p>
<h2 id="returns_152">Returns<a class="headerlink" href="#returns_152" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution.
nfeval : int
The number of function evaluations.
rc : int
Return code, see below</p>
<h2 id="see-also_112">See also<a class="headerlink" href="#see-also_112" title="Permanent link">&para;</a></h2>
<p>minimize: Interface to minimization algorithms for multivariate
functions. See the 'TNC' <code>method</code> in particular.</p>
<h2 id="notes_94">Notes<a class="headerlink" href="#notes_94" title="Permanent link">&para;</a></h2>
<p>The underlying algorithm is truncated Newton, also called
Newton Conjugate-Gradient. This method differs from
scipy.optimize.fmin_ncg in that</p>
<ol>
<li>It wraps a C implementation of the algorithm</li>
<li>It allows each variable to be given an upper and lower bound.</li>
</ol>
<p>The algorithm incorporates the bound constraints by determining
the descent direction as in an unconstrained truncated Newton,
but never taking a step-size large enough to leave the space
of feasible x's. The algorithm keeps track of a set of
currently active constraints, and ignores them when computing
the minimum allowable step size. (The x's associated with the
active constraint are kept fixed.) If the maximum allowable
step size is zero then a new constraint is added. At the end
of each iteration one of the constraints may be deemed no
longer active and removed. A constraint is considered
no longer active is if it is currently active
but the gradient for that variable points inward from the
constraint. The specific constraint removed is the one
associated with the variable of largest index whose
constraint is no longer active.</p>
<p>Return codes are defined as follows::</p>
<p>-1 : Infeasible (lower bound &gt; upper bound)
0 : Local minimum reached (|pg| ~= 0)
1 : Converged (|f_n-f_(n-1)| ~= 0)
2 : Converged (|x_n-x_(n-1)| ~= 0)
3 : Max. number of function evaluations reached
4 : Linear search failed
5 : All lower bounds are equal to the upper bounds
6 : Unable to progress
7 : User requested end of minimization</p>
<h2 id="references_43">References<a class="headerlink" href="#references_43" title="Permanent link">&para;</a></h2>
<p>Wright S., Nocedal J. (2006), 'Numerical Optimization'</p>
<p>Nash S.G. (1984), 'Newton-Type Minimization Via the Lanczos Method',
SIAM Journal of Numerical Analysis 21, pp. 770-778</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fminbound</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfun</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x1</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Bounded minimization for scalar functions.</p>
<h2 id="parameters_172">Parameters<a class="headerlink" href="#parameters_172" title="Permanent link">&para;</a></h2>
<p>func : callable f(x,*args)
Objective function to be minimized (must accept and return scalars).
x1, x2 : float or array scalar
The optimization bounds.
args : tuple, optional
Extra arguments passed to function.
xtol : float, optional
The convergence tolerance.
maxfun : int, optional
Maximum number of function evaluations allowed.
full_output : bool, optional
If True, return optional outputs.
disp : int, optional
If non-zero, print messages.
0 : no message printing.
1 : non-convergence notification messages only.
2 : print a message on convergence too.
3 : print iteration results.</p>
<h2 id="returns_153">Returns<a class="headerlink" href="#returns_153" title="Permanent link">&para;</a></h2>
<p>xopt : ndarray
Parameters (over given interval) which minimize the
objective function.
fval : number
The function value at the minimum point.
ierr : int
An error flag (0 if converged, 1 if maximum number of
function calls reached).
numfunc : int
The number of function calls made.</p>
<h2 id="see-also_113">See also<a class="headerlink" href="#see-also_113" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Bounded' <code>method</code> in particular.</p>
<h2 id="notes_95">Notes<a class="headerlink" href="#notes_95" title="Permanent link">&para;</a></h2>
<p>Finds a local minimizer of the scalar function <code>func</code> in the
interval x1 &lt; xopt &lt; x2 using Brent's method.  (See <code>brent</code>
for auto-bracketing).</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<p><code>fminbound</code> finds the minimum of the function in the given range.
The following examples illustrate the same</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.fminbound(f, -1, 2)
minimum
0.0
minimum = optimize.fminbound(f, 1, 2)
minimum
1.0000059608609866</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fsolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">col_deriv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsfcn</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="o">)</span>
</code></pre></div>

<p>Find the roots of a function.</p>
<p>Return the roots of the (non-linear) equations defined by
<code>func(x) = 0</code> given a starting estimate.</p>
<h2 id="parameters_173">Parameters<a class="headerlink" href="#parameters_173" title="Permanent link">&para;</a></h2>
<p>func : callable <code>f(x, *args)</code>
A function that takes at least one (possibly vector) argument,
and returns a value of the same length.
x0 : ndarray
The starting estimate for the roots of <code>func(x) = 0</code>.
args : tuple, optional
Any extra arguments to <code>func</code>.
fprime : callable <code>f(x, *args)</code>, optional
A function to compute the Jacobian of <code>func</code> with derivatives
across the rows. By default, the Jacobian will be estimated.
full_output : bool, optional
If True, return optional outputs.
col_deriv : bool, optional
Specify whether the Jacobian function computes derivatives down
the columns (faster, because there is no transpose operation).
xtol : float, optional
The calculation will terminate if the relative error between two
consecutive iterates is at most <code>xtol</code>.
maxfev : int, optional
The maximum number of calls to the function. If zero, then
<code>100*(N+1)</code> is the maximum where N is the number of elements
in <code>x0</code>.
band : tuple, optional
If set to a two-sequence containing the number of sub- and
super-diagonals within the band of the Jacobi matrix, the
Jacobi matrix is considered banded (only for <code>fprime=None</code>).
epsfcn : float, optional
A suitable step length for the forward-difference
approximation of the Jacobian (for <code>fprime=None</code>). If
<code>epsfcn</code> is less than the machine precision, it is assumed
that the relative errors in the functions are of the order of
the machine precision.
factor : float, optional
A parameter determining the initial step bound
(<code>factor * || diag * x||</code>).  Should be in the interval
<code>(0.1, 100)</code>.
diag : sequence, optional
N positive entries that serve as a scale factors for the
variables.</p>
<h2 id="returns_154">Returns<a class="headerlink" href="#returns_154" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution (or the result of the last iteration for
an unsuccessful call).
infodict : dict
A dictionary of optional outputs with the keys:</p>
<p><code>nfev</code>
number of function calls
<code>njev</code>
number of Jacobian calls
<code>fvec</code>
function evaluated at the output
<code>fjac</code>
the orthogonal matrix, q, produced by the QR
factorization of the final approximate Jacobian
matrix, stored column wise
<code>r</code>
upper triangular matrix produced by QR factorization
of the same matrix
<code>qtf</code>
the vector <code>(transpose(q) * fvec)</code></p>
<p>ier : int
An integer flag.  Set to 1 if a solution was found, otherwise refer
to <code>mesg</code> for more information.
mesg : str
If no solution is found, <code>mesg</code> details the cause of failure.</p>
<h2 id="see-also_114">See Also<a class="headerlink" href="#see-also_114" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See the <code>method=='hybr'</code> in particular.</p>
<h2 id="notes_96">Notes<a class="headerlink" href="#notes_96" title="Permanent link">&para;</a></h2>
<p><code>fsolve</code> is a wrapper around MINPACK's hybrd and hybrj algorithms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">golden</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brack</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum of a function of one variable using golden section
method.</p>
<p>Given a function of one variable and a possible bracketing interval,
return the minimum of the function isolated to a fractional precision of
tol.</p>
<h2 id="parameters_174">Parameters<a class="headerlink" href="#parameters_174" title="Permanent link">&para;</a></h2>
<p>func : callable func(x,*args)
Objective function to minimize.
args : tuple, optional
Additional arguments (if present), passed to func.
brack : tuple, optional
Triple (a,b,c), where (a&lt;b&lt;c) and func(b) &lt;
func(a),func(c).  If bracket consists of two numbers (a,
c), then they are assumed to be a starting interval for a
downhill bracket search (see <code>bracket</code>); it doesn't always
mean that obtained solution will satisfy a&lt;=x&lt;=c.
tol : float, optional
x tolerance stop criterion
full_output : bool, optional
If True, return optional outputs.
maxiter : int
Maximum number of iterations to perform.</p>
<h2 id="see-also_115">See also<a class="headerlink" href="#see-also_115" title="Permanent link">&para;</a></h2>
<p>minimize_scalar: Interface to minimization algorithms for scalar
univariate functions. See the 'Golden' <code>method</code> in particular.</p>
<h2 id="notes_97">Notes<a class="headerlink" href="#notes_97" title="Permanent link">&para;</a></h2>
<p>Uses analog of bisection method to decrease the bracketed
interval.</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<p>We illustrate the behaviour of the function when <code>brack</code> is of
size 2 and 3 respectively. In the case where <code>brack</code> is of the
form (xa,xb), we can see for the given values, the output need
not necessarily lie in the range <code>(xa, xb)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return x**2</p>
<p>from scipy import optimize</p>
<p>minimum = optimize.golden(f, brack=(1, 2))
minimum
1.5717277788484873e-162
minimum = optimize.golden(f, brack=(-1, 0.5, 2))
minimum
-1.5717277788484873e-162</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">least_squares</span> <span class="o">:</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">T2_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T3_point</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Trf</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dogbox</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_scale</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Jac</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">loss</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diff_step</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tr_solver</span><span class="o">:[`</span><span class="nc">Exact</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lsmr</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tr_options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac_sparsity</span><span class="o">:[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_nfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Solve a nonlinear least-squares problem with bounds on the variables.</p>
<p>Given the residuals f(x) (an m-dimensional real function of n real
variables) and the loss function rho(s) (a scalar function), <code>least_squares</code>
finds a local minimum of the cost function F(x)::</p>
<p>minimize F(x) = 0.5 * sum(rho(f_i(x)**2), i = 0, ..., m - 1)
subject to lb &lt;= x &lt;= ub</p>
<p>The purpose of the loss function rho(s) is to reduce the influence of
outliers on the solution.</p>
<h2 id="parameters_175">Parameters<a class="headerlink" href="#parameters_175" title="Permanent link">&para;</a></h2>
<p>fun : callable
Function which computes the vector of residuals, with the signature
<code>fun(x, *args, **kwargs)</code>, i.e., the minimization proceeds with
respect to its first argument. The argument <code>x</code> passed to this
function is an ndarray of shape (n,) (never a scalar, even for n=1).
It must return a 1-d array_like of shape (m,) or a scalar. If the
argument <code>x</code> is complex or the function <code>fun</code> returns complex
residuals, it must be wrapped in a real function of real arguments,
as shown at the end of the Examples section.
x0 : array_like with shape (n,) or float
Initial guess on independent variables. If float, it will be treated
as a 1-d array with one element.
jac : {'2-point', '3-point', 'cs', callable}, optional
Method of computing the Jacobian matrix (an m-by-n matrix, where
element (i, j) is the partial derivative of f[i] with respect to
x[j]). The keywords select a finite difference scheme for numerical
estimation. The scheme '3-point' is more accurate, but requires
twice as many operations as '2-point' (default). The scheme 'cs'
uses complex steps, and while potentially the most accurate, it is
applicable only when <code>fun</code> correctly handles complex inputs and
can be analytically continued to the complex plane. Method 'lm'
always uses the '2-point' scheme. If callable, it is used as
<code>jac(x, *args, **kwargs)</code> and should return a good approximation
(or the exact value) for the Jacobian as an array_like (np.atleast_2d
is applied), a sparse matrix or a <code>scipy.sparse.linalg.LinearOperator</code>.
bounds : 2-tuple of array_like, optional
Lower and upper bounds on independent variables. Defaults to no bounds.
Each array must match the size of <code>x0</code> or be a scalar, in the latter
case a bound will be the same for all variables. Use <code>np.inf</code> with
an appropriate sign to disable bounds on all or some variables.
method : {'trf', 'dogbox', 'lm'}, optional
Algorithm to perform minimization.</p>
<ul>
<li>'trf' : Trust Region Reflective algorithm, particularly suitable
for large sparse problems with bounds. Generally robust method.</li>
<li>'dogbox' : dogleg algorithm with rectangular trust regions,
typical use case is small problems with bounds. Not recommended
for problems with rank-deficient Jacobian.</li>
<li>'lm' : Levenberg-Marquardt algorithm as implemented in MINPACK.
Doesn't handle bounds and sparse Jacobians. Usually the most
efficient method for small unconstrained problems.</li>
</ul>
<p>Default is 'trf'. See Notes for more information.
ftol : float or None, optional
Tolerance for termination by the change of the cost function. Default
is 1e-8. The optimization process is stopped when  <code>dF &lt; ftol * F</code>,
and there was an adequate agreement between a local quadratic model and
the true model in the last step. If None, the termination by this
condition is disabled.
xtol : float or None, optional
Tolerance for termination by the change of the independent variables.
Default is 1e-8. The exact condition depends on the <code>method</code> used:</p>
<ul>
<li>For 'trf' and 'dogbox' : <code>norm(dx) &lt; xtol * (xtol + norm(x))</code></li>
<li>For 'lm' : <code>Delta &lt; xtol * norm(xs)</code>, where <code>Delta</code> is
a trust-region radius and <code>xs</code> is the value of <code>x</code>
scaled according to <code>x_scale</code> parameter (see below).</li>
</ul>
<p>If None, the termination by this condition is disabled.
gtol : float or None, optional
Tolerance for termination by the norm of the gradient. Default is 1e-8.
The exact condition depends on a <code>method</code> used:</p>
<ul>
<li>For 'trf' : <code>norm(g_scaled, ord=np.inf) &lt; gtol</code>, where
<code>g_scaled</code> is the value of the gradient scaled to account for
the presence of the bounds [STIR]_.</li>
<li>For 'dogbox' : <code>norm(g_free, ord=np.inf) &lt; gtol</code>, where
<code>g_free</code> is the gradient with respect to the variables which
are not in the optimal state on the boundary.</li>
<li>For 'lm' : the maximum absolute value of the cosine of angles
between columns of the Jacobian and the residual vector is less
than <code>gtol</code>, or the residual vector is zero.</li>
</ul>
<p>If None, the termination by this condition is disabled.
x_scale : array_like or 'jac', optional
Characteristic scale of each variable. Setting <code>x_scale</code> is equivalent
to reformulating the problem in scaled variables <code>xs = x / x_scale</code>.
An alternative view is that the size of a trust region along j-th
dimension is proportional to <code>x_scale[j]</code>. Improved convergence may
be achieved by setting <code>x_scale</code> such that a step of a given size
along any of the scaled variables has a similar effect on the cost
function. If set to 'jac', the scale is iteratively updated using the
inverse norms of the columns of the Jacobian matrix (as described in
[JJMore]_).
loss : str or callable, optional
Determines the loss function. The following keyword values are allowed:</p>
<ul>
<li>'linear' (default) : <code>rho(z) = z</code>. Gives a standard
least-squares problem.</li>
<li>'soft_l1' : <code>rho(z) = 2 * ((1 + z)**0.5 - 1)</code>. The smooth
approximation of l1 (absolute value) loss. Usually a good
choice for robust least squares.</li>
<li>'huber' : <code>rho(z) = z if z &lt;= 1 else 2*z**0.5 - 1</code>. Works
similarly to 'soft_l1'.</li>
<li>'cauchy' : <code>rho(z) = ln(1 + z)</code>. Severely weakens outliers
influence, but may cause difficulties in optimization process.</li>
<li>'arctan' : <code>rho(z) = arctan(z)</code>. Limits a maximum loss on
a single residual, has properties similar to 'cauchy'.</li>
</ul>
<p>If callable, it must take a 1-d ndarray <code>z=f**2</code> and return an
array_like with shape (3, m) where row 0 contains function values,
row 1 contains first derivatives and row 2 contains second
derivatives. Method 'lm' supports only 'linear' loss.
f_scale : float, optional
Value of soft margin between inlier and outlier residuals, default
is 1.0. The loss function is evaluated as follows
<code>rho_(f**2) = C**2 * rho(f**2 / C**2)</code>, where <code>C</code> is <code>f_scale</code>,
and <code>rho</code> is determined by <code>loss</code> parameter. This parameter has
no effect with <code>loss='linear'</code>, but for other <code>loss</code> values it is
of crucial importance.
max_nfev : None or int, optional
Maximum number of function evaluations before the termination.
If None (default), the value is chosen automatically:</p>
<ul>
<li>For 'trf' and 'dogbox' : 100 * n.</li>
<li>For 'lm' :  100 * n if <code>jac</code> is callable and 100 * n * (n + 1)
otherwise (because 'lm' counts function calls in Jacobian
estimation).</li>
</ul>
<p>diff_step : None or array_like, optional
Determines the relative step size for the finite difference
approximation of the Jacobian. The actual step is computed as
<code>x * diff_step</code>. If None (default), then <code>diff_step</code> is taken to be
a conventional 'optimal' power of machine epsilon for the finite
difference scheme used [NR]_.
tr_solver : {None, 'exact', 'lsmr'}, optional
Method for solving trust-region subproblems, relevant only for 'trf'
and 'dogbox' methods.</p>
<ul>
<li>'exact' is suitable for not very large problems with dense
Jacobian matrices. The computational complexity per iteration is
comparable to a singular value decomposition of the Jacobian
matrix.</li>
<li>'lsmr' is suitable for problems with sparse and large Jacobian
matrices. It uses the iterative procedure
<code>scipy.sparse.linalg.lsmr</code> for finding a solution of a linear
least-squares problem and only requires matrix-vector product
evaluations.</li>
</ul>
<p>If None (default) the solver is chosen based on the type of Jacobian
returned on the first iteration.
tr_options : dict, optional
Keyword options passed to trust-region solver.</p>
<ul>
<li><code>tr_solver='exact'</code>: <code>tr_options</code> are ignored.</li>
<li><code>tr_solver='lsmr'</code>: options for <code>scipy.sparse.linalg.lsmr</code>.
Additionally  <code>method='trf'</code> supports  'regularize' option
(bool, default is True) which adds a regularization term to the
normal equation, which improves convergence if the Jacobian is
rank-deficient [Byrd]_ (eq. 3.4).</li>
</ul>
<p>jac_sparsity : {None, array_like, sparse matrix}, optional
Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations [Curtis]_. A zero
entry means that a corresponding element in the Jacobian is identically
zero. If provided, forces the use of 'lsmr' trust-region solver.
If None (default) then dense differencing will be used. Has no effect
for 'lm' method.
verbose : {0, 1, 2}, optional
Level of algorithm's verbosity:</p>
<ul>
<li>0 (default) : work silently.</li>
<li>1 : display a termination report.</li>
<li>2 : display progress during iterations (not supported by 'lm'
method).</li>
</ul>
<p>args, kwargs : tuple and dict, optional
Additional arguments passed to <code>fun</code> and <code>jac</code>. Both empty by default.
The calling signature is <code>fun(x, *args, **kwargs)</code> and the same for
<code>jac</code>.</p>
<h2 id="returns_155">Returns<a class="headerlink" href="#returns_155" title="Permanent link">&para;</a></h2>
<p><code>OptimizeResult</code> with the following fields defined:
x : ndarray, shape (n,)
Solution found.
cost : float
Value of the cost function at the solution.
fun : ndarray, shape (m,)
Vector of residuals at the solution.
jac : ndarray, sparse matrix or LinearOperator, shape (m, n)
Modified Jacobian matrix at the solution, in the sense that J^T J
is a Gauss-Newton approximation of the Hessian of the cost function.
The type is the same as the one used by the algorithm.
grad : ndarray, shape (m,)
Gradient of the cost function at the solution.
optimality : float
First-order optimality measure. In unconstrained problems, it is always
the uniform norm of the gradient. In constrained problems, it is the
quantity which was compared with <code>gtol</code> during iterations.
active_mask : ndarray of int, shape (n,)
Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<ul>
<li>0 : a constraint is not active.</li>
<li>-1 : a lower bound is active.</li>
<li>1 : an upper bound is active.</li>
</ul>
<p>Might be somewhat arbitrary for 'trf' method as it generates a sequence
of strictly feasible iterates and <code>active_mask</code> is determined within a
tolerance threshold.
nfev : int
Number of function evaluations done. Methods 'trf' and 'dogbox' do not
count function calls for numerical Jacobian approximation, as opposed
to 'lm' method.
njev : int or None
Number of Jacobian evaluations done. If numerical Jacobian
approximation is used in 'lm' method, it is set to None.
status : int
The reason for algorithm termination:</p>
<ul>
<li>-1 : improper input parameters status returned from MINPACK.</li>
<li>0 : the maximum number of function evaluations is exceeded.</li>
<li>1 : <code>gtol</code> termination condition is satisfied.</li>
<li>2 : <code>ftol</code> termination condition is satisfied.</li>
<li>3 : <code>xtol</code> termination condition is satisfied.</li>
<li>4 : Both <code>ftol</code> and <code>xtol</code> termination conditions are satisfied.</li>
</ul>
<p>message : str
Verbal description of the termination reason.
success : bool
True if one of the convergence criteria is satisfied (<code>status</code> &gt; 0).</p>
<h2 id="see-also_116">See Also<a class="headerlink" href="#see-also_116" title="Permanent link">&para;</a></h2>
<p>leastsq : A legacy wrapper for the MINPACK implementation of the
Levenberg-Marquadt algorithm.
curve_fit : Least-squares minimization applied to a curve fitting problem.</p>
<h2 id="notes_98">Notes<a class="headerlink" href="#notes_98" title="Permanent link">&para;</a></h2>
<p>Method 'lm' (Levenberg-Marquardt) calls a wrapper over least-squares
algorithms implemented in MINPACK (lmder, lmdif). It runs the
Levenberg-Marquardt algorithm formulated as a trust-region type algorithm.
The implementation is based on paper [JJMore]_, it is very robust and
efficient with a lot of smart tricks. It should be your first choice
for unconstrained problems. Note that it doesn't support bounds. Also
it doesn't work when m &lt; n.</p>
<p>Method 'trf' (Trust Region Reflective) is motivated by the process of
solving a system of equations, which constitute the first-order optimality
condition for a bound-constrained minimization problem as formulated in
[STIR]<em>. The algorithm iteratively solves trust-region subproblems
augmented by a special diagonal quadratic term and with trust-region shape
determined by the distance from the bounds and the direction of the
gradient. This enhancements help to avoid making steps directly into bounds
and efficiently explore the whole space of variables. To further improve
convergence, the algorithm considers search directions reflected from the
bounds. To obey theoretical requirements, the algorithm keeps iterates
strictly feasible. With dense Jacobians trust-region subproblems are
solved by an exact method very similar to the one described in [JJMore]</em>
(and implemented in MINPACK). The difference from the MINPACK
implementation is that a singular value decomposition of a Jacobian
matrix is done once per iteration, instead of a QR decomposition and series
of Givens rotation eliminations. For large sparse Jacobians a 2-d subspace
approach of solving trust-region subproblems is used [STIR]<em>, [Byrd]</em>.
The subspace is spanned by a scaled gradient and an approximate
Gauss-Newton solution delivered by <code>scipy.sparse.linalg.lsmr</code>. When no
constraints are imposed the algorithm is very similar to MINPACK and has
generally comparable performance. The algorithm works quite robust in
unbounded and bounded problems, thus it is chosen as a default algorithm.</p>
<p>Method 'dogbox' operates in a trust-region framework, but considers
rectangular trust regions as opposed to conventional ellipsoids [Voglis]<em>.
The intersection of a current trust region and initial bounds is again
rectangular, so on each iteration a quadratic minimization problem subject
to bound constraints is solved approximately by Powell's dogleg method
[NumOpt]</em>. The required Gauss-Newton step can be computed exactly for
dense Jacobians or approximately by <code>scipy.sparse.linalg.lsmr</code> for large
sparse Jacobians. The algorithm is likely to exhibit slow convergence when
the rank of Jacobian is less than the number of variables. The algorithm
often outperforms 'trf' in bounded problems with a small number of
variables.</p>
<p>Robust loss functions are implemented as described in [BA]_. The idea
is to modify a residual vector and a Jacobian matrix on each iteration
such that computed gradient and Gauss-Newton Hessian approximation match
the true gradient and Hessian approximation of the cost function. Then
the algorithm proceeds in a normal way, i.e. robust loss functions are
implemented as a simple wrapper over standard least-squares algorithms.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="references_44">References<a class="headerlink" href="#references_44" title="Permanent link">&para;</a></h2>
<p>.. [STIR] M. A. Branch, T. F. Coleman, and Y. Li, 'A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems,' SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.
.. [NR] William H. Press et. al., 'Numerical Recipes. The Art of Scientific
Computing. 3rd edition', Sec. 5.7.
.. [Byrd] R. H. Byrd, R. B. Schnabel and G. A. Shultz, 'Approximate
solution of the trust region problem by minimization over
two-dimensional subspaces', Math. Programming, 40, pp. 247-263,
1988.
.. [Curtis] A. Curtis, M. J. D. Powell, and J. Reid, 'On the estimation of
sparse Jacobian matrices', Journal of the Institute of
Mathematics and its Applications, 13, pp. 117-120, 1974.
.. [JJMore] J. J. More, 'The Levenberg-Marquardt Algorithm: Implementation
and Theory,' Numerical Analysis, ed. G. A. Watson, Lecture
Notes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.
.. [Voglis] C. Voglis and I. E. Lagaris, 'A Rectangular Trust Region
Dogleg Approach for Unconstrained and Bound Constrained
Nonlinear Optimization', WSEAS International Conference on
Applied Mathematics, Corfu, Greece, 2004.
.. [NumOpt] J. Nocedal and S. J. Wright, 'Numerical optimization,
2nd edition', Chapter 4.
.. [BA] B. Triggs et. al., 'Bundle Adjustment - A Modern Synthesis',
Proceedings of the International Workshop on Vision Algorithms:
Theory and Practice, pp. 298-372, 1999.</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<p>In this example we find a minimum of the Rosenbrock function without bounds
on independent variables.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun_rosenbrock(x):
...     return np.array([10 * (x[1] - x[0]**2), (1 - x[0])])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that we only provide the vector of the residuals. The algorithm
constructs the cost function as a sum of squares of the residuals, which
gives the Rosenbrock function. The exact minimum is at <code>x = [1.0, 1.0]</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import least_squares
x0_rosenbrock = np.array([2, 2])
res_1 = least_squares(fun_rosenbrock, x0_rosenbrock)
res_1.x
array([ 1.,  1.])
res_1.cost
9.8669242910846867e-30
res_1.optimality
8.8928864934219529e-14</p>
</blockquote>
</blockquote>
</blockquote>
<p>We now constrain the variables, in such a way that the previous solution
becomes infeasible. Specifically, we require that <code>x[1] &gt;= 1.5</code>, and
<code>x[0]</code> left unconstrained. To this end, we specify the <code>bounds</code> parameter
to <code>least_squares</code> in the form <code>bounds=([-np.inf, 1.5], np.inf)</code>.</p>
<p>We also provide the analytic Jacobian:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def jac_rosenbrock(x):
...     return np.array([
...         [-20 * x[0], 10],
...         [-1, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Putting this all together, we see that the new solution lies on the bound:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_2 = least_squares(fun_rosenbrock, x0_rosenbrock, jac_rosenbrock,
...                       bounds=([-np.inf, 1.5], np.inf))
res_2.x
array([ 1.22437075,  1.5       ])
res_2.cost
0.025213093946805685
res_2.optimality
1.5885401433157753e-07</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now we solve a system of equations (i.e., the cost function should be zero
at a minimum) for a Broyden tridiagonal vector-valued function of 100000
variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun_broyden(x):
...     f = (3 - x) * x + 1
...     f[1:] -= x[:-1]
...     f[:-1] -= 2 * x[1:]
...     return f</p>
</blockquote>
</blockquote>
</blockquote>
<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to
estimate it by finite differences and provide the sparsity structure of
Jacobian to significantly speed up this process.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import lil_matrix
def sparsity_broyden(n):
...     sparsity = lil_matrix((n, n), dtype=int)
...     i = np.arange(n)
...     sparsity[i, i] = 1
...     i = np.arange(1, n)
...     sparsity[i, i - 1] = 1
...     i = np.arange(n - 1)
...     sparsity[i, i + 1] = 1
...     return sparsity
...
n = 100000
x0_broyden = -np.ones(n)
...
res_3 = least_squares(fun_broyden, x0_broyden,
...                       jac_sparsity=sparsity_broyden(n))
res_3.cost
4.5687069299604613e-23
res_3.optimality
1.1650454296851518e-11</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let's also solve a curve fitting problem using robust loss function to
take care of outliers in the data. Define the model function as
<code>y = a + b * exp(c * t)</code>, where t is a predictor variable, y is an
observation and a, b, c are parameters to estimate.</p>
<p>First, define the function which generates the data with noise and
outliers, define the model parameters, and generate data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def gen_data(t, a, b, c, noise=0, n_outliers=0, random_state=0):
...     y = a + b * np.exp(t * c)
...
...     rnd = np.random.RandomState(random_state)
...     error = noise * rnd.randn(t.size)
...     outliers = rnd.randint(0, t.size, n_outliers)
...     error[outliers] *= 10
...
...     return y + error
...
a = 0.5
b = 2.0
c = -1
t_min = 0
t_max = 10
n_points = 15
...
t_train = np.linspace(t_min, t_max, n_points)
y_train = gen_data(t_train, a, b, c, noise=0.1, n_outliers=3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define function for computing residuals and initial estimate of
parameters.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun(x, t, y):
...     return x[0] + x[1] * np.exp(x[2] * t) - y
...
x0 = np.array([1.0, 1.0, 0.0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute a standard least-squares solution:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_lsq = least_squares(fun, x0, args=(t_train, y_train))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute two solutions with two different robust loss functions. The
parameter <code>f_scale</code> is set to 0.1, meaning that inlier residuals should
not significantly exceed 0.1 (the noise level used).</p>
<blockquote>
<blockquote>
<blockquote>
<p>res_soft_l1 = least_squares(fun, x0, loss='soft_l1', f_scale=0.1,
...                             args=(t_train, y_train))
res_log = least_squares(fun, x0, loss='cauchy', f_scale=0.1,
...                         args=(t_train, y_train))</p>
</blockquote>
</blockquote>
</blockquote>
<p>And finally plot all the curves. We see that by selecting an appropriate
<code>loss</code>  we can get estimates close to optimal even in the presence of
strong outliers. But keep in mind that generally it is recommended to try
'soft_l1' or 'huber' losses first (if at all necessary) as the other two
options may cause difficulties in optimization process.</p>
<blockquote>
<blockquote>
<blockquote>
<p>t_test = np.linspace(t_min, t_max, n_points * 10)
y_true = gen_data(t_test, a, b, c)
y_lsq = gen_data(t_test, <em>res_lsq.x)
y_soft_l1 = gen_data(t_test, </em>res_soft_l1.x)
y_log = gen_data(t_test, *res_log.x)
...
import matplotlib.pyplot as plt
plt.plot(t_train, y_train, 'o')
plt.plot(t_test, y_true, 'k', linewidth=2, label='true')
plt.plot(t_test, y_lsq, label='linear loss')
plt.plot(t_test, y_soft_l1, label='soft_l1 loss')
plt.plot(t_test, y_log, label='cauchy loss')
plt.xlabel('t')
plt.ylabel('y')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the next example, we show how complex-valued residual functions of
complex variables can be optimized with <code>least_squares()</code>. Consider the
following function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(z):
...     return z - (0.5 + 0.5j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We wrap it into a function of real variables that returns real residuals
by simply handling the real and imaginary parts as independent variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f_wrap(x):
...     fx = f(x[0] + 1j*x[1])
...     return np.array([fx.real, fx.imag])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thus, instead of the original m-dimensional complex function of n complex
variables we optimize a 2m-dimensional real function of 2n real variables:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import least_squares
res_wrapped = least_squares(f_wrap, (0.1, 0.1), bounds=([0, 0], [1, 1]))
z = res_wrapped.x[0] + res_wrapped.x[1]*1j
z
(0.49999999999925893+0.49999999999925893j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leastsq</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dfun</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">col_deriv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxfev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">epsfcn</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">factor</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">diag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Minimize the sum of squares of a set of equations.</p>
<p>::</p>
<p>x = arg min(sum(func(y)**2,axis=0))
y</p>
<h2 id="parameters_176">Parameters<a class="headerlink" href="#parameters_176" title="Permanent link">&para;</a></h2>
<p>func : callable
should take at least one (possibly length N vector) argument and
returns M floating point numbers. It must not return NaNs or
fitting might fail.
x0 : ndarray
The starting estimate for the minimization.
args : tuple, optional
Any extra arguments to func are placed in this tuple.
Dfun : callable, optional
A function or method to compute the Jacobian of func with derivatives
across the rows. If this is None, the Jacobian will be estimated.
full_output : bool, optional
non-zero to return all optional outputs.
col_deriv : bool, optional
non-zero to specify that the Jacobian function computes derivatives
down the columns (faster, because there is no transpose operation).
ftol : float, optional
Relative error desired in the sum of squares.
xtol : float, optional
Relative error desired in the approximate solution.
gtol : float, optional
Orthogonality desired between the function vector and the columns of
the Jacobian.
maxfev : int, optional
The maximum number of calls to the function. If <code>Dfun</code> is provided
then the default <code>maxfev</code> is 100<em>(N+1) where N is the number of elements
in x0, otherwise the default <code>maxfev</code> is 200</em>(N+1).
epsfcn : float, optional
A variable used in determining a suitable step length for the forward-
difference approximation of the Jacobian (for Dfun=None).
Normally the actual step length will be sqrt(epsfcn)*x
If epsfcn is less than the machine precision, it is assumed that the
relative errors are of the order of the machine precision.
factor : float, optional
A parameter determining the initial step bound
(<code>factor * || diag * x||</code>). Should be in interval <code>(0.1, 100)</code>.
diag : sequence, optional
N positive entries that serve as a scale factors for the variables.</p>
<h2 id="returns_156">Returns<a class="headerlink" href="#returns_156" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The solution (or the result of the last iteration for an unsuccessful
call).
cov_x : ndarray
The inverse of the Hessian. <code>fjac</code> and <code>ipvt</code> are used to construct an
estimate of the Hessian. A value of None indicates a singular matrix,
which means the curvature in parameters <code>x</code> is numerically flat. To
obtain the covariance matrix of the parameters <code>x</code>, <code>cov_x</code> must be
multiplied by the variance of the residuals -- see curve_fit.
infodict : dict
a dictionary of optional outputs with the keys:</p>
<p><code>nfev</code>
The number of function calls
<code>fvec</code>
The function evaluated at the output
<code>fjac</code>
A permutation of the R matrix of a QR
factorization of the final approximate
Jacobian matrix, stored column wise.
Together with ipvt, the covariance of the
estimate can be approximated.
<code>ipvt</code>
An integer array of length N which defines
a permutation matrix, p, such that
fjac<em>p = q</em>r, where r is upper triangular
with diagonal elements of nonincreasing
magnitude. Column j of p is column ipvt(j)
of the identity matrix.
<code>qtf</code>
The vector (transpose(q) * fvec).</p>
<p>mesg : str
A string message giving information about the cause of failure.
ier : int
An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was
found.  Otherwise, the solution was not found. In either case, the
optional output variable 'mesg' gives more information.</p>
<h2 id="see-also_117">See Also<a class="headerlink" href="#see-also_117" title="Permanent link">&para;</a></h2>
<p>least_squares : Newer interface to solve nonlinear least-squares problems
with bounds on the variables. See <code>method=='lm'</code> in particular.</p>
<h2 id="notes_99">Notes<a class="headerlink" href="#notes_99" title="Permanent link">&para;</a></h2>
<p>'leastsq' is a wrapper around MINPACK's lmdif and lmder algorithms.</p>
<p>cov_x is a Jacobian approximation to the Hessian of the least squares
objective function.
This approximation assumes that the objective function is based on the
difference between some observed target data (ydata) and a (non-linear)
function of the parameters <code>f(xdata, params)</code> ::</p>
<p>func(params) = ydata - f(xdata, params)</p>
<p>so that the objective function is ::</p>
<p>min   sum((ydata - f(xdata, params))**2, axis=0)
params</p>
<p>The solution, <code>x</code>, is always a 1D array, regardless of the shape of <code>x0</code>,
or whether <code>x0</code> is a scalar.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">line_search</span> <span class="o">:</span> <span class="o">?</span><span class="n">gfk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">old_old_fval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c2</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">amax</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_condition</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">myfprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Find alpha that satisfies strong Wolfe conditions.</p>
<h2 id="parameters_177">Parameters<a class="headerlink" href="#parameters_177" title="Permanent link">&para;</a></h2>
<p>f : callable f(x,<em>args)
Objective function.
myfprime : callable f'(x,</em>args)
Objective function gradient.
xk : ndarray
Starting point.
pk : ndarray
Search direction.
gfk : ndarray, optional
Gradient value for x=xk (xk being the current parameter
estimate). Will be recomputed if omitted.
old_fval : float, optional
Function value for x=xk. Will be recomputed if omitted.
old_old_fval : float, optional
Function value for the point preceding x=xk
args : tuple, optional
Additional arguments passed to objective function.
c1 : float, optional
Parameter for Armijo condition rule.
c2 : float, optional
Parameter for curvature condition rule.
amax : float, optional
Maximum step size
extra_condition : callable, optional
A callable of the form <code>extra_condition(alpha, x, f, g)</code>
returning a boolean. Arguments are the proposed step <code>alpha</code>
and the corresponding <code>x</code>, <code>f</code> and <code>g</code> values. The line search
accepts the value of <code>alpha</code> only if this
callable returns <code>True</code>. If the callable returns <code>False</code>
for the step length, the algorithm will continue with
new iterates. The callable is only called for iterates
satisfying the strong Wolfe conditions.
maxiter : int, optional
Maximum number of iterations to perform</p>
<h2 id="returns_157">Returns<a class="headerlink" href="#returns_157" title="Permanent link">&para;</a></h2>
<p>alpha : float or None
Alpha for which <code>x_new = x0 + alpha * pk</code>,
or None if the line search algorithm did not converge.
fc : int
Number of function evaluations made.
gc : int
Number of gradient evaluations made.
new_fval : float or None
New function value <code>f(x_new)=f(x0+alpha*pk)</code>,
or None if the line search algorithm did not converge.
old_fval : float
Old function value <code>f(x0)</code>.
new_slope : float or None
The local slope along the search direction at the
new value <code>&lt;myfprime(x_new), pk&gt;</code>,
or None if the line search algorithm did not converge.</p>
<h2 id="notes_100">Notes<a class="headerlink" href="#notes_100" title="Permanent link">&para;</a></h2>
<p>Uses the line search algorithm to enforce strong Wolfe
conditions.  See Wright and Nocedal, 'Numerical Optimization',
1999, pg. 59-60.</p>
<p>For the zoom phase it uses an algorithm by [...].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linear_sum_assignment</span> <span class="o">:</span> <span class="o">?</span><span class="n">maximize</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">cost_matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear sum assignment problem.</p>
<p>The linear sum assignment problem is also known as minimum weight matching
in bipartite graphs. A problem instance is described by a matrix C, where
each C[i,j] is the cost of matching vertex i of the first partite set
(a 'worker') and vertex j of the second set (a 'job'). The goal is to find
a complete assignment of workers to jobs of minimal cost.</p>
<p>Formally, let X be a boolean matrix where :math:<code>X[i,j] = 1</code> iff row i is
assigned to column j. Then the optimal assignment has cost</p>
<p>.. math::
\min \sum_i \sum_j C_{i,j} X_{i,j}</p>
<p>where, in the case where the matrix X is square, each row is assigned to
exactly one column, and each column to exactly one row.</p>
<p>This function can also solve a generalization of the classic assignment
problem where the cost matrix is rectangular. If it has more rows than
columns, then not every row needs to be assigned to a column, and vice
versa.</p>
<h2 id="parameters_178">Parameters<a class="headerlink" href="#parameters_178" title="Permanent link">&para;</a></h2>
<p>cost_matrix : array
The cost matrix of the bipartite graph.</p>
<p>maximize : bool (default: False)
Calculates a maximum weight matching if true.</p>
<h2 id="returns_158">Returns<a class="headerlink" href="#returns_158" title="Permanent link">&para;</a></h2>
<p>row_ind, col_ind : array
An array of row indices and one of corresponding column indices giving
the optimal assignment. The cost of the assignment can be computed
as <code>cost_matrix[row_ind, col_ind].sum()</code>. The row indices will be
sorted; in the case of a square cost matrix they will be equal to
<code>numpy.arange(cost_matrix.shape[0])</code>.</p>
<h2 id="notes_101">Notes<a class="headerlink" href="#notes_101" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.17.0</p>
<h2 id="references_45">References<a class="headerlink" href="#references_45" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p>https://en.wikipedia.org/wiki/Assignment_problem</p>
</li>
<li>
<p>DF Crouse. On implementing 2D rectangular assignment algorithms.
<em>IEEE Transactions on Aerospace and Electronic Systems</em>,
52(4):1679-1696, August 2016, https://doi.org/10.1109/TAES.2016.140952</p>
</li>
</ol>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>cost = np.array([[4, 1, 3], [2, 0, 5], [3, 2, 2]])
from scipy.optimize import linear_sum_assignment
row_ind, col_ind = linear_sum_assignment(cost)
col_ind
array([1, 0, 2])
cost[row_ind, col_ind].sum()
5</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linearmixing</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using a scalar Jacobian approximation.</p>
<p>.. warning::</p>
<p>This algorithm may be useful for specific problems, but whether
it will work may depend strongly on the problem.</p>
<h2 id="parameters_179">Parameters<a class="headerlink" href="#parameters_179" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
alpha : float, optional
The Jacobian approximation is (-1/alpha).
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_159">Returns<a class="headerlink" href="#returns_159" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_25">Raises<a class="headerlink" href="#raises_25" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_118">See Also<a class="headerlink" href="#see-also_118" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='linearmixing'</code> in particular.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linprog</span> <span class="o">:</span> <span class="o">?</span><span class="n">a_ub</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b_ub</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">a_eq</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b_eq</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Interior_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Revised_simplex</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Simplex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="o">)</span>
</code></pre></div>

<p>Linear programming: minimize a linear objective function subject to linear
equality and inequality constraints.</p>
<p>Linear programming solves problems of the following form:</p>
<p>.. math::</p>
<p>\min_x \ &amp; c^T x \
\mbox{such that} \ &amp; A_{ub} x \leq b_{ub},\
&amp; A_{eq} x = b_{eq},\
&amp; l \leq x \leq u ,</p>
<p>where :math:<code>x</code> is a vector of decision variables; :math:<code>c</code>,
:math:<code>b_{ub}</code>, :math:<code>b_{eq}</code>, :math:<code>l</code>, and :math:<code>u</code> are vectors; and
:math:<code>A_{ub}</code> and :math:<code>A_{eq}</code> are matrices.</p>
<p>Informally, that's:</p>
<p>minimize::</p>
<p>c @ x</p>
<p>such that::</p>
<p>A_ub @ x &lt;= b_ub
A_eq @ x == b_eq
lb &lt;= x &lt;= ub</p>
<p>Note that by default <code>lb = 0</code> and <code>ub = None</code> unless specified with
<code>bounds</code>.</p>
<h2 id="parameters_180">Parameters<a class="headerlink" href="#parameters_180" title="Permanent link">&para;</a></h2>
<p>c : 1D array
The coefficients of the linear objective function to be minimized.
A_ub : 2D array, optional
The inequality constraint matrix. Each row of <code>A_ub</code> specifies the
coefficients of a linear inequality constraint on <code>x</code>.
b_ub : 1D array, optional
The inequality constraint vector. Each element represents an
upper bound on the corresponding value of <code>A_ub @ x</code>.
A_eq : 2D array, optional
The equality constraint matrix. Each row of <code>A_eq</code> specifies the
coefficients of a linear equality constraint on <code>x</code>.
b_eq : 1D array, optional
The equality constraint vector. Each element of <code>A_eq @ x</code> must equal
the corresponding element of <code>b_eq</code>.
bounds : sequence, optional
A sequence of <code>(min, max)</code> pairs for each element in <code>x</code>, defining
the minimum and maximum values of that decision variable. Use <code>None</code> to
indicate that there is no bound. By default, bounds are <code>(0, None)</code>
(all decision variables are non-negative).
If a single tuple <code>(min, max)</code> is provided, then <code>min</code> and
<code>max</code> will serve as bounds for all decision variables.
method : {'interior-point', 'revised simplex', 'simplex'}, optional
The algorithm used to solve the standard form problem.
:ref:<code>'interior-point' &lt;optimize.linprog-interior-point&gt;</code> (default),
:ref:<code>'revised simplex' &lt;optimize.linprog-revised_simplex&gt;</code>, and
:ref:<code>'simplex' &lt;optimize.linprog-simplex&gt;</code> (legacy)
are supported.
callback : callable, optional
If a callback function is provided, it will be called at least once per
iteration of the algorithm. The callback function must accept a single
<code>scipy.optimize.OptimizeResult</code> consisting of the following fields:</p>
<p>x : 1D array
The current solution vector.
fun : float
The current value of the objective function <code>c @ x</code>.
success : bool
<code>True</code> when the algorithm has completed successfully.
slack : 1D array
The (nominally positive) values of the slack,
<code>b_ub - A_ub @ x</code>.
con : 1D array
The (nominally zero) residuals of the equality constraints,
<code>b_eq - A_eq @ x</code>.
phase : int
The phase of the algorithm being executed.
status : int
An integer representing the status of the algorithm.</p>
<p><code>0</code> : Optimization proceeding nominally.</p>
<p><code>1</code> : Iteration limit reached.</p>
<p><code>2</code> : Problem appears to be infeasible.</p>
<p><code>3</code> : Problem appears to be unbounded.</p>
<p><code>4</code> : Numerical difficulties encountered.</p>
<p>nit : int
The current iteration number.
message : str
A string descriptor of the algorithm status.</p>
<p>options : dict, optional
A dictionary of solver options. All methods accept the following
options:</p>
<p>maxiter : int
Maximum number of iterations to perform.
Default: see method-specific documentation.
disp : bool
Set to <code>True</code> to print convergence messages.
Default: <code>False</code>.
autoscale : bool
Set to <code>True</code> to automatically perform equilibration.
Consider using this option if the numerical values in the
constraints are separated by several orders of magnitude.
Default: <code>False</code>.
presolve : bool
Set to <code>False</code> to disable automatic presolve.
Default: <code>True</code>.
rr : bool
Set to <code>False</code> to disable automatic redundancy removal.
Default: <code>True</code>.</p>
<p>For method-specific options, see
:func:<code>show_options('linprog') &lt;show_options&gt;</code>.</p>
<p>x0 : 1D array, optional
Guess values of the decision variables, which will be refined by
the optimization algorithm. This argument is currently used only by the
'revised simplex' method, and can only be used if <code>x0</code> represents a
basic feasible solution.</p>
<h2 id="returns_160">Returns<a class="headerlink" href="#returns_160" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
A :class:<code>scipy.optimize.OptimizeResult</code> consisting of the fields:</p>
<p>x : 1D array
The values of the decision variables that minimizes the
objective function while satisfying the constraints.
fun : float
The optimal value of the objective function <code>c @ x</code>.
slack : 1D array
The (nominally positive) values of the slack variables,
<code>b_ub - A_ub @ x</code>.
con : 1D array
The (nominally zero) residuals of the equality constraints,
<code>b_eq - A_eq @ x</code>.
success : bool
<code>True</code> when the algorithm succeeds in finding an optimal
solution.
status : int
An integer representing the exit status of the algorithm.</p>
<p><code>0</code> : Optimization terminated successfully.</p>
<p><code>1</code> : Iteration limit reached.</p>
<p><code>2</code> : Problem appears to be infeasible.</p>
<p><code>3</code> : Problem appears to be unbounded.</p>
<p><code>4</code> : Numerical difficulties encountered.</p>
<p>nit : int
The total number of iterations performed in all phases.
message : str
A string descriptor of the exit status of the algorithm.</p>
<h2 id="see-also_119">See Also<a class="headerlink" href="#see-also_119" title="Permanent link">&para;</a></h2>
<p>show_options : Additional options accepted by the solvers.</p>
<h2 id="notes_102">Notes<a class="headerlink" href="#notes_102" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter.</p>
<p>:ref:<code>'interior-point' &lt;optimize.linprog-interior-point&gt;</code> is the default
as it is typically the fastest and most robust method.
:ref:<code>'revised simplex' &lt;optimize.linprog-revised_simplex&gt;</code> is more
accurate for the problems it solves.
:ref:<code>'simplex' &lt;optimize.linprog-simplex&gt;</code> is the legacy method and is
included for backwards compatibility and educational purposes.</p>
<p>Method <em>interior-point</em> uses the primal-dual path following algorithm
as outlined in [4]_. This algorithm supports sparse constraint matrices and
is typically faster than the simplex methods, especially for large, sparse
problems. Note, however, that the solution returned may be slightly less
accurate than those of the simplex methods and will not, in general,
correspond with a vertex of the polytope defined by the constraints.</p>
<p>.. versionadded:: 1.0.0</p>
<p>Method <em>revised simplex</em> uses the revised simplex method as described in
[9]<em>, except that a factorization [11]</em> of the basis matrix, rather than
its inverse, is efficiently maintained and used to solve the linear systems
at each iteration of the algorithm.</p>
<p>.. versionadded:: 1.3.0</p>
<p>Method <em>simplex</em> uses a traditional, full-tableau implementation of
Dantzig's simplex algorithm [1]<em>, [2]</em> ( <em>not</em> the
Nelder-Mead simplex). This algorithm is included for backwards
compatibility and educational purposes.</p>
<p>.. versionadded:: 0.15.0</p>
<p>Before applying any method, a presolve procedure based on [8]_ attempts
to identify trivial infeasibilities, trivial unboundedness, and potential
problem simplifications. Specifically, it checks for:</p>
<ul>
<li>rows of zeros in <code>A_eq</code> or <code>A_ub</code>, representing trivial constraints;</li>
<li>columns of zeros in <code>A_eq</code> <code>and</code> <code>A_ub</code>, representing unconstrained
variables;</li>
<li>column singletons in <code>A_eq</code>, representing fixed variables; and</li>
<li>column singletons in <code>A_ub</code>, representing simple bounds.</li>
</ul>
<p>If presolve reveals that the problem is unbounded (e.g. an unconstrained
and unbounded variable has negative cost) or infeasible (e.g. a row of
zeros in <code>A_eq</code> corresponds with a nonzero in <code>b_eq</code>), the solver
terminates with the appropriate status code. Note that presolve terminates
as soon as any sign of unboundedness is detected; consequently, a problem
may be reported as unbounded when in reality the problem is infeasible
(but infeasibility has not been detected yet). Therefore, if it is
important to know whether the problem is actually infeasible, solve the
problem again with option <code>presolve=False</code>.</p>
<p>If neither infeasibility nor unboundedness are detected in a single pass
of the presolve, bounds are tightened where possible and fixed
variables are removed from the problem. Then, linearly dependent rows
of the <code>A_eq</code> matrix are removed, (unless they represent an
infeasibility) to avoid numerical difficulties in the primary solve
routine. Note that rows that are nearly linearly dependent (within a
prescribed tolerance) may also be removed, which can change the optimal
solution in rare cases. If this is a concern, eliminate redundancy from
your problem formulation and run with option <code>rr=False</code> or
<code>presolve=False</code>.</p>
<p>Several potential improvements can be made here: additional presolve
checks outlined in [8]<em> should be implemented, the presolve routine should
be run multiple times (until no further simplifications can be made), and
more of the efficiency improvements from [5]</em> should be implemented in the
redundancy removal routines.</p>
<p>After presolve, the problem is transformed to standard form by converting
the (tightened) simple bounds to upper bound constraints, introducing
non-negative slack variables for inequality constraints, and expressing
unbounded variables as the difference between two non-negative variables.
Optionally, the problem is automatically scaled via equilibration [12]_.
The selected algorithm solves the standard form problem, and a
postprocessing routine converts the result to a solution to the original
problem.</p>
<h2 id="references_46">References<a class="headerlink" href="#references_46" title="Permanent link">&para;</a></h2>
<p>.. [1] Dantzig, George B., Linear programming and extensions. Rand
Corporation Research Study Princeton Univ. Press, Princeton, NJ,
1963
.. [2] Hillier, S.H. and Lieberman, G.J. (1995), 'Introduction to
Mathematical Programming', McGraw-Hill, Chapter 4.
.. [3] Bland, Robert G. New finite pivoting rules for the simplex method.
Mathematics of Operations Research (2), 1977: pp. 103-107.
.. [4] Andersen, Erling D., and Knud D. Andersen. 'The MOSEK interior point
optimizer for linear programming: an implementation of the
homogeneous algorithm.' High performance optimization. Springer US,
2000. 197-232.
.. [5] Andersen, Erling D. 'Finding all linearly dependent rows in
large-scale linear programming.' Optimization Methods and Software
6.3 (1995): 219-227.
.. [6] Freund, Robert M. 'Primal-Dual Interior-Point Methods for Linear
Programming based on Newton's Method.' Unpublished Course Notes,
March 2004. Available 2/25/2017 at
https://ocw.mit.edu/courses/sloan-school-of-management/15-084j-nonlinear-programming-spring-2004/lecture-notes/lec14_int_pt_mthd.pdf
.. [7] Fourer, Robert. 'Solving Linear Programs by Interior-Point Methods.'
Unpublished Course Notes, August 26, 2005. Available 2/25/2017 at
http://www.4er.org/CourseNotes/Book%20B/B-III.pdf
.. [8] Andersen, Erling D., and Knud D. Andersen. 'Presolving in linear
programming.' Mathematical Programming 71.2 (1995): 221-245.
.. [9] Bertsimas, Dimitris, and J. Tsitsiklis. 'Introduction to linear
programming.' Athena Scientific 1 (1997): 997.
.. [10] Andersen, Erling D., et al. Implementation of interior point
methods for large scale linear programming. HEC/Universite de
Geneve, 1996.
.. [11] Bartels, Richard H. 'A stabilization of the simplex method.'
Journal in  Numerische Mathematik 16.5 (1971): 414-434.
.. [12] Tomlin, J. A. 'On scaling linear programming problems.'
Mathematical Programming Study 4 (1975): 146-166.</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<p>Consider the following problem:</p>
<p>.. math::</p>
<p>\min_{x_0, x_1} \ -x_0 + 4x_1 &amp; \
\mbox{such that} \ -3x_0 + x_1 &amp; \leq 6,\
-x_0 - 2x_1 &amp; \geq -4,\
x_1 &amp; \geq -3.</p>
<p>The problem is not presented in the form accepted by <code>linprog</code>. This is
easily remedied by converting the 'greater than' inequality
constraint to a 'less than' inequality constraint by
multiplying both sides by a factor of :math:<code>-1</code>. Note also that the last
constraint is really the simple bound :math:<code>-3 \leq x_1 \leq \infty</code>.
Finally, since there are no bounds on :math:<code>x_0</code>, we must explicitly
specify the bounds :math:<code>-\infty \leq x_0 \leq \infty</code>, as the
default is for variables to be non-negative. After collecting coeffecients
into arrays and tuples, the input for this problem is:</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = [-1, 4]
A = [[-3, 1], [1, 2]]
b = [6, 4]
x0_bounds = (None, None)
x1_bounds = (-3, None)
from scipy.optimize import linprog
res = linprog(c, A_ub=A, b_ub=b, bounds=[x0_bounds, x1_bounds])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the default method for <code>linprog</code> is 'interior-point', which is
approximate by nature.</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(res)
con: array([], dtype=float64)
fun: -21.99999984082494 # may vary
message: 'Optimization terminated successfully.'
nit: 6 # may vary
slack: array([3.89999997e+01, 8.46872439e-08] # may vary
status: 0
success: True
x: array([ 9.99999989, -2.99999999]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you need greater accuracy, try 'revised simplex'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>res = linprog(c, A_ub=A, b_ub=b, bounds=[x0_bounds, x1_bounds], method='revised simplex')
print(res)
con: array([], dtype=float64)
fun: -22.0 # may vary
message: 'Optimization terminated successfully.'
nit: 1 # may vary
slack: array([39.,  0.]) # may vary
status: 0
success: True
x: array([10., -3.]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linprog_verbose_callback</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A sample callback function demonstrating the linprog callback interface.
This callback produces detailed output to sys.stdout before each iteration
and after the final iteration of the simplex algorithm.</p>
<h2 id="parameters_181">Parameters<a class="headerlink" href="#parameters_181" title="Permanent link">&para;</a></h2>
<p>res : A <code>scipy.optimize.OptimizeResult</code> consisting of the following fields:</p>
<p>x : 1D array
The independent variable vector which optimizes the linear
programming problem.
fun : float
Value of the objective function.
success : bool
True if the algorithm succeeded in finding an optimal solution.
slack : 1D array
The values of the slack variables. Each slack variable corresponds
to an inequality constraint. If the slack is zero, then the
corresponding constraint is active.
con : 1D array
The (nominally zero) residuals of the equality constraints, that is,
<code>b - A_eq @ x</code>
phase : int
The phase of the optimization being executed. In phase 1 a basic
feasible solution is sought and the T has an additional row
representing an alternate objective function.
status : int
An integer representing the exit status of the optimization::</p>
<p>0 : Optimization terminated successfully
1 : Iteration limit reached
2 : Problem appears to be infeasible
3 : Problem appears to be unbounded
4 : Serious numerical difficulties encountered</p>
<p>nit : int
The number of iterations performed.
message : str
A string descriptor of the exit status of the optimization.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsq_linear</span> <span class="o">:</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Trf</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bvls</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lsq_solver</span><span class="o">:[`</span><span class="nc">Exact</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lsmr</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lsmr_tol</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sparse_matrix_of_LinearOperator</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Solve a linear least-squares problem with bounds on the variables.</p>
<p>Given a m-by-n design matrix A and a target vector b with m elements,
<code>lsq_linear</code> solves the following optimization problem::</p>
<p>minimize 0.5 * ||A x - b||**2
subject to lb &lt;= x &lt;= ub</p>
<p>This optimization problem is convex, hence a found minimum (if iterations
have converged) is guaranteed to be global.</p>
<h2 id="parameters_182">Parameters<a class="headerlink" href="#parameters_182" title="Permanent link">&para;</a></h2>
<p>A : array_like, sparse matrix of LinearOperator, shape (m, n)
Design matrix. Can be <code>scipy.sparse.linalg.LinearOperator</code>.
b : array_like, shape (m,)
Target vector.
bounds : 2-tuple of array_like, optional
Lower and upper bounds on independent variables. Defaults to no bounds.
Each array must have shape (n,) or be a scalar, in the latter
case a bound will be the same for all variables. Use <code>np.inf</code> with
an appropriate sign to disable bounds on all or some variables.
method : 'trf' or 'bvls', optional
Method to perform minimization.</p>
<ul>
<li>'trf' : Trust Region Reflective algorithm adapted for a linear
least-squares problem. This is an interior-point-like method
and the required number of iterations is weakly correlated with
the number of variables.</li>
<li>'bvls' : Bounded-Variable Least-Squares algorithm. This is
an active set method, which requires the number of iterations
comparable to the number of variables. Can't be used when <code>A</code> is
sparse or LinearOperator.</li>
</ul>
<p>Default is 'trf'.
tol : float, optional
Tolerance parameter. The algorithm terminates if a relative change
of the cost function is less than <code>tol</code> on the last iteration.
Additionally the first-order optimality measure is considered:</p>
<ul>
<li><code>method='trf'</code> terminates if the uniform norm of the gradient,
scaled to account for the presence of the bounds, is less than
<code>tol</code>.</li>
<li><code>method='bvls'</code> terminates if Karush-Kuhn-Tucker conditions
are satisfied within <code>tol</code> tolerance.</li>
</ul>
<p>lsq_solver : {None, 'exact', 'lsmr'}, optional
Method of solving unbounded least-squares problems throughout
iterations:</p>
<ul>
<li>'exact' : Use dense QR or SVD decomposition approach. Can't be
used when <code>A</code> is sparse or LinearOperator.</li>
<li>'lsmr' : Use <code>scipy.sparse.linalg.lsmr</code> iterative procedure
which requires only matrix-vector product evaluations. Can't
be used with <code>method='bvls'</code>.</li>
</ul>
<p>If None (default) the solver is chosen based on type of <code>A</code>.
lsmr_tol : None, float or 'auto', optional
Tolerance parameters 'atol' and 'btol' for <code>scipy.sparse.linalg.lsmr</code>
If None (default), it is set to <code>1e-2 * tol</code>. If 'auto', the
tolerance will be adjusted based on the optimality of the current
iterate, which can speed up the optimization process, but is not always
reliable.
max_iter : None or int, optional
Maximum number of iterations before termination. If None (default), it
is set to 100 for <code>method='trf'</code> or to the number of variables for
<code>method='bvls'</code> (not counting iterations for 'bvls' initialization).
verbose : {0, 1, 2}, optional
Level of algorithm's verbosity:</p>
<ul>
<li>0 : work silently (default).</li>
<li>1 : display a termination report.</li>
<li>2 : display progress during iterations.</li>
</ul>
<h2 id="returns_161">Returns<a class="headerlink" href="#returns_161" title="Permanent link">&para;</a></h2>
<p>OptimizeResult with the following fields defined:
x : ndarray, shape (n,)
Solution found.
cost : float
Value of the cost function at the solution.
fun : ndarray, shape (m,)
Vector of residuals at the solution.
optimality : float
First-order optimality measure. The exact meaning depends on <code>method</code>,
refer to the description of <code>tol</code> parameter.
active_mask : ndarray of int, shape (n,)
Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<ul>
<li>0 : a constraint is not active.</li>
<li>-1 : a lower bound is active.</li>
<li>1 : an upper bound is active.</li>
</ul>
<p>Might be somewhat arbitrary for the <code>trf</code> method as it generates a
sequence of strictly feasible iterates and active_mask is determined
within a tolerance threshold.
nit : int
Number of iterations. Zero if the unconstrained solution is optimal.
status : int
Reason for algorithm termination:</p>
<ul>
<li>-1 : the algorithm was not able to make progress on the last
iteration.</li>
<li>0 : the maximum number of iterations is exceeded.</li>
<li>1 : the first-order optimality measure is less than <code>tol</code>.</li>
<li>2 : the relative change of the cost function is less than <code>tol</code>.</li>
<li>3 : the unconstrained solution is optimal.</li>
</ul>
<p>message : str
Verbal description of the termination reason.
success : bool
True if one of the convergence criteria is satisfied (<code>status</code> &gt; 0).</p>
<h2 id="see-also_120">See Also<a class="headerlink" href="#see-also_120" title="Permanent link">&para;</a></h2>
<p>nnls : Linear least squares with non-negativity constraint.
least_squares : Nonlinear least squares with bounds on the variables.</p>
<h2 id="notes_103">Notes<a class="headerlink" href="#notes_103" title="Permanent link">&para;</a></h2>
<p>The algorithm first computes the unconstrained least-squares solution by
<code>numpy.linalg.lstsq</code> or <code>scipy.sparse.linalg.lsmr</code> depending on
<code>lsq_solver</code>. This solution is returned as optimal if it lies within the
bounds.</p>
<p>Method 'trf' runs the adaptation of the algorithm described in [STIR]_ for
a linear least-squares problem. The iterations are essentially the same as
in the nonlinear least-squares algorithm, but as the quadratic function
model is always accurate, we don't need to track or modify the radius of
a trust region. The line search (backtracking) is used as a safety net
when a selected step does not decrease the cost function. Read more
detailed description of the algorithm in <code>scipy.optimize.least_squares</code>.</p>
<p>Method 'bvls' runs a Python implementation of the algorithm described in
[BVLS]_. The algorithm maintains active and free sets of variables, on
each iteration chooses a new variable to move from the active set to the
free set and then solves the unconstrained least-squares problem on free
variables. This algorithm is guaranteed to give an accurate solution
eventually, but may require up to n iterations for a problem with n
variables. Additionally, an ad-hoc initialization procedure is
implemented, that determines which variables to set free or active
initially. It takes some number of iterations before actual BVLS starts,
but can significantly reduce the number of further iterations.</p>
<h2 id="references_47">References<a class="headerlink" href="#references_47" title="Permanent link">&para;</a></h2>
<p>.. [STIR] M. A. Branch, T. F. Coleman, and Y. Li, 'A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems,' SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.
.. [BVLS] P. B. Start and R. L. Parker, 'Bounded-Variable Least-Squares:
an Algorithm and Applications', Computational Statistics, 10,
129-141, 1995.</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<p>In this example a problem with a large sparse matrix and bounds on the
variables is solved.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.sparse import rand
from scipy.optimize import lsq_linear
...
np.random.seed(0)
...
m = 20000
n = 10000
...
A = rand(m, n, density=1e-4)
b = np.random.randn(m)
...
lb = np.random.randn(n)
ub = lb + 1
...
res = lsq_linear(A, b, bounds=(lb, ub), lsmr_tol='auto', verbose=1)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="may-vary">may vary<a class="headerlink" href="#may-vary" title="Permanent link">&para;</a></h1>
<p>The relative change of the cost function is less than <code>tol</code>.
Number of iterations 16, initial cost 1.5039e+04, final cost 1.1112e+04,
first-order optimality 4.66e-08.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimize</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hess</span><span class="o">:[`</span><span class="nc">T2_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T3_point</span> <span class="o">|</span> <span class="o">`</span><span class="nc">HessianUpdateStrategy</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hessp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">constraints</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimization of scalar function of one or more variables.</p>
<h2 id="parameters_183">Parameters<a class="headerlink" href="#parameters_183" title="Permanent link">&para;</a></h2>
<p>fun : callable
The objective function to be minimized.</p>
<p><code>fun(x, *args) -&gt; float</code></p>
<p>where x is an 1-D array with shape (n,) and <code>args</code>
is a tuple of the fixed parameters needed to completely
specify the function.
x0 : ndarray, shape (n,)
Initial guess. Array of real elements of size (n,),
where 'n' is the number of independent variables.
args : tuple, optional
Extra arguments passed to the objective function and its
derivatives (<code>fun</code>, <code>jac</code> and <code>hess</code> functions).
method : str or callable, optional
Type of solver.  Should be one of</p>
<ul>
<li>'Nelder-Mead' :ref:<code>(see here) &lt;optimize.minimize-neldermead&gt;</code></li>
<li>'Powell'      :ref:<code>(see here) &lt;optimize.minimize-powell&gt;</code></li>
<li>'CG'          :ref:<code>(see here) &lt;optimize.minimize-cg&gt;</code></li>
<li>'BFGS'        :ref:<code>(see here) &lt;optimize.minimize-bfgs&gt;</code></li>
<li>'Newton-CG'   :ref:<code>(see here) &lt;optimize.minimize-newtoncg&gt;</code></li>
<li>'L-BFGS-B'    :ref:<code>(see here) &lt;optimize.minimize-lbfgsb&gt;</code></li>
<li>'TNC'         :ref:<code>(see here) &lt;optimize.minimize-tnc&gt;</code></li>
<li>'COBYLA'      :ref:<code>(see here) &lt;optimize.minimize-cobyla&gt;</code></li>
<li>'SLSQP'       :ref:<code>(see here) &lt;optimize.minimize-slsqp&gt;</code></li>
<li>'trust-constr':ref:<code>(see here) &lt;optimize.minimize-trustconstr&gt;</code></li>
<li>'dogleg'      :ref:<code>(see here) &lt;optimize.minimize-dogleg&gt;</code></li>
<li>'trust-ncg'   :ref:<code>(see here) &lt;optimize.minimize-trustncg&gt;</code></li>
<li>'trust-exact' :ref:<code>(see here) &lt;optimize.minimize-trustexact&gt;</code></li>
<li>'trust-krylov' :ref:<code>(see here) &lt;optimize.minimize-trustkrylov&gt;</code></li>
<li>custom - a callable object (added in version 0.14.0),
see below for description.</li>
</ul>
<p>If not given, chosen to be one of <code>BFGS</code>, <code>L-BFGS-B</code>, <code>SLSQP</code>,
depending if the problem has constraints or bounds.
jac : {callable,  '2-point', '3-point', 'cs', bool}, optional
Method for computing the gradient vector. Only for CG, BFGS,
Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg, trust-krylov,
trust-exact and trust-constr. If it is a callable, it should be a
function that returns the gradient vector:</p>
<p><code>jac(x, *args) -&gt; array_like, shape (n,)</code></p>
<p>where x is an array with shape (n,) and <code>args</code> is a tuple with
the fixed parameters. Alternatively, the keywords
{'2-point', '3-point', 'cs'} select a finite
difference scheme for numerical estimation of the gradient. Options
'3-point' and 'cs' are available only to 'trust-constr'.
If <code>jac</code> is a Boolean and is True, <code>fun</code> is assumed to return the
gradient along with the objective function. If False, the gradient
will be estimated using '2-point' finite difference estimation.
hess : {callable, '2-point', '3-point', 'cs', HessianUpdateStrategy},  optional
Method for computing the Hessian matrix. Only for Newton-CG, dogleg,
trust-ncg,  trust-krylov, trust-exact and trust-constr. If it is
callable, it should return the  Hessian matrix:</p>
<p><code>hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)</code></p>
<p>where x is a (n,) ndarray and <code>args</code> is a tuple with the fixed
parameters. LinearOperator and sparse matrix returns are
allowed only for 'trust-constr' method. Alternatively, the keywords
{'2-point', '3-point', 'cs'} select a finite difference scheme
for numerical estimation. Or, objects implementing
<code>HessianUpdateStrategy</code> interface can be used to approximate
the Hessian. Available quasi-Newton methods implementing
this interface are:</p>
<ul>
<li><code>BFGS</code>;</li>
<li><code>SR1</code>.</li>
</ul>
<p>Whenever the gradient is estimated via finite-differences,
the Hessian cannot be estimated with options
{'2-point', '3-point', 'cs'} and needs to be
estimated using one of the quasi-Newton strategies.
Finite-difference options {'2-point', '3-point', 'cs'} and
<code>HessianUpdateStrategy</code> are available only for 'trust-constr' method.
hessp : callable, optional
Hessian of objective function times an arbitrary vector p. Only for
Newton-CG, trust-ncg, trust-krylov, trust-constr.
Only one of <code>hessp</code> or <code>hess</code> needs to be given.  If <code>hess</code> is
provided, then <code>hessp</code> will be ignored.  <code>hessp</code> must compute the
Hessian times an arbitrary vector:</p>
<p><code>hessp(x, p, *args) -&gt;  ndarray shape (n,)</code></p>
<p>where x is a (n,) ndarray, p is an arbitrary vector with
dimension (n,) and <code>args</code> is a tuple with the fixed
parameters.
bounds : sequence or <code>Bounds</code>, optional
Bounds on variables for L-BFGS-B, TNC, SLSQP and
trust-constr methods. There are two ways to specify the bounds:</p>
<ol>
<li>Instance of <code>Bounds</code> class.</li>
<li>Sequence of <code>(min, max)</code> pairs for each element in <code>x</code>. None
is used to specify no bound.</li>
</ol>
<p>constraints : {Constraint, dict} or List of {Constraint, dict}, optional
Constraints definition (only for COBYLA, SLSQP and trust-constr).
Constraints for 'trust-constr' are defined as a single object or a
list of objects specifying constraints to the optimization problem.
Available constraints are:</p>
<ul>
<li><code>LinearConstraint</code></li>
<li><code>NonlinearConstraint</code></li>
</ul>
<p>Constraints for COBYLA, SLSQP are defined as a list of dictionaries.
Each dictionary with fields:</p>
<p>type : str
Constraint type: 'eq' for equality, 'ineq' for inequality.
fun : callable
The function defining the constraint.
jac : callable, optional
The Jacobian of <code>fun</code> (only for SLSQP).
args : sequence, optional
Extra arguments to be passed to the function and Jacobian.</p>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.
tol : float, optional
Tolerance for termination. For detailed control, use solver-specific
options.
options : dict, optional
A dictionary of solver options. All methods accept the following
generic options:</p>
<p>maxiter : int
Maximum number of iterations to perform. Depending on the
method each iteration may use several function evaluations.
disp : bool
Set to True to print convergence messages.</p>
<p>For method-specific options, see :func:<code>show_options()</code>.
callback : callable, optional
Called after each iteration. For 'trust-constr' it is a callable with
the signature:</p>
<p><code>callback(xk, OptimizeResult state) -&gt; bool</code></p>
<p>where <code>xk</code> is the current parameter vector. and <code>state</code>
is an <code>OptimizeResult</code> object, with the same fields
as the ones from the return.  If callback returns True
the algorithm execution is terminated.
For all the other methods, the signature is:</p>
<p><code>callback(xk)</code></p>
<p>where <code>xk</code> is the current parameter vector.</p>
<h2 id="returns_162">Returns<a class="headerlink" href="#returns_162" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>success</code> a
Boolean flag indicating if the optimizer exited successfully and
<code>message</code> which describes the cause of the termination. See
<code>OptimizeResult</code> for a description of other attributes.</p>
<h2 id="see-also_121">See also<a class="headerlink" href="#see-also_121" title="Permanent link">&para;</a></h2>
<p>minimize_scalar : Interface to minimization algorithms for scalar
univariate functions
show_options : Additional options accepted by the solvers</p>
<h2 id="notes_104">Notes<a class="headerlink" href="#notes_104" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter. The default method is <em>BFGS</em>.</p>
<p><strong>Unconstrained minimization</strong></p>
<p>Method :ref:<code>Nelder-Mead &lt;optimize.minimize-neldermead&gt;</code> uses the
Simplex algorithm [1]<em>, [2]</em>. This algorithm is robust in many
applications. However, if numerical computation of derivative can be
trusted, other algorithms using the first and/or second derivatives
information might be preferred for their better performance in
general.</p>
<p>Method :ref:<code>Powell &lt;optimize.minimize-powell&gt;</code> is a modification
of Powell's method [3]<em>, [4]</em> which is a conjugate direction
method. It performs sequential one-dimensional minimizations along
each vector of the directions set (<code>direc</code> field in <code>options</code> and
<code>info</code>), which is updated at each iteration of the main
minimization loop. The function need not be differentiable, and no
derivatives are taken.</p>
<p>Method :ref:<code>CG &lt;optimize.minimize-cg&gt;</code> uses a nonlinear conjugate
gradient algorithm by Polak and Ribiere, a variant of the
Fletcher-Reeves method described in [5]_ pp.  120-122. Only the
first derivatives are used.</p>
<p>Method :ref:<code>BFGS &lt;optimize.minimize-bfgs&gt;</code> uses the quasi-Newton
method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [5]_
pp. 136. It uses the first derivatives only. BFGS has proven good
performance even for non-smooth optimizations. This method also
returns an approximation of the Hessian inverse, stored as
<code>hess_inv</code> in the OptimizeResult object.</p>
<p>Method :ref:<code>Newton-CG &lt;optimize.minimize-newtoncg&gt;</code> uses a
Newton-CG algorithm [5]_ pp. 168 (also known as the truncated
Newton method). It uses a CG method to the compute the search
direction. See also <em>TNC</em> method for a box-constrained
minimization with a similar algorithm. Suitable for large-scale
problems.</p>
<p>Method :ref:<code>dogleg &lt;optimize.minimize-dogleg&gt;</code> uses the dog-leg
trust-region algorithm [5]_ for unconstrained minimization. This
algorithm requires the gradient and Hessian; furthermore the
Hessian is required to be positive definite.</p>
<p>Method :ref:<code>trust-ncg &lt;optimize.minimize-trustncg&gt;</code> uses the
Newton conjugate gradient trust-region algorithm [5]_ for
unconstrained minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.</p>
<p>Method :ref:<code>trust-krylov &lt;optimize.minimize-trustkrylov&gt;</code> uses
the Newton GLTR trust-region algorithm [14]<em>, [15]</em> for unconstrained
minimization. This algorithm requires the gradient
and either the Hessian or a function that computes the product of
the Hessian with a given vector. Suitable for large-scale problems.
On indefinite problems it requires usually less iterations than the
<code>trust-ncg</code> method and is recommended for medium and large-scale problems.</p>
<p>Method :ref:<code>trust-exact &lt;optimize.minimize-trustexact&gt;</code>
is a trust-region method for unconstrained minimization in which
quadratic subproblems are solved almost exactly [13]_. This
algorithm requires the gradient and the Hessian (which is
<em>not</em> required to be positive definite). It is, in many
situations, the Newton method to converge in fewer iteraction
and the most recommended for small and medium-size problems.</p>
<p><strong>Bound-Constrained minimization</strong></p>
<p>Method :ref:<code>L-BFGS-B &lt;optimize.minimize-lbfgsb&gt;</code> uses the L-BFGS-B
algorithm [6]<em>, [7]</em> for bound constrained minimization.</p>
<p>Method :ref:<code>TNC &lt;optimize.minimize-tnc&gt;</code> uses a truncated Newton
algorithm [5]<em>, [8]</em> to minimize a function with variables subject
to bounds. This algorithm uses gradient information; it is also
called Newton Conjugate-Gradient. It differs from the <em>Newton-CG</em>
method described above as it wraps a C implementation and allows
each variable to be given upper and lower bounds.</p>
<p><strong>Constrained Minimization</strong></p>
<p>Method :ref:<code>COBYLA &lt;optimize.minimize-cobyla&gt;</code> uses the
Constrained Optimization BY Linear Approximation (COBYLA) method
[9]<em>, [10]</em>, [11]_. The algorithm is based on linear
approximations to the objective function and each constraint. The
method wraps a FORTRAN implementation of the algorithm. The
constraints functions 'fun' may return either a single number
or an array or list of numbers.</p>
<p>Method :ref:<code>SLSQP &lt;optimize.minimize-slsqp&gt;</code> uses Sequential
Least SQuares Programming to minimize a function of several
variables with any combination of bounds, equality and inequality
constraints. The method wraps the SLSQP Optimization subroutine
originally implemented by Dieter Kraft [12]_. Note that the
wrapper handles infinite values in bounds by converting them into
large floating values.</p>
<p>Method :ref:<code>trust-constr &lt;optimize.minimize-trustconstr&gt;</code> is a
trust-region algorithm for constrained optimization. It swiches
between two implementations depending on the problem definition.
It is the most versatile constrained minimization algorithm
implemented in SciPy and the most appropriate for large-scale problems.
For equality constrained problems it is an implementation of Byrd-Omojokun
Trust-Region SQP method described in [17]<em> and in [5]</em>, p. 549. When
inequality constraints  are imposed as well, it swiches to the trust-region
interior point  method described in [16]_. This interior point algorithm,
in turn, solves inequality constraints by introducing slack variables
and solving a sequence of equality-constrained barrier problems
for progressively smaller values of the barrier parameter.
The previously described equality constrained SQP method is
used to solve the subproblems with increasing levels of accuracy
as the iterate gets closer to a solution.</p>
<p><strong>Finite-Difference Options</strong></p>
<p>For Method :ref:<code>trust-constr &lt;optimize.minimize-trustconstr&gt;</code>
the gradient and the Hessian may be approximated using
three finite-difference schemes: {'2-point', '3-point', 'cs'}.
The scheme 'cs' is, potentially, the most accurate but it
requires the function to correctly handles complex inputs and to
be differentiable in the complex plane. The scheme '3-point' is more
accurate than '2-point' but requires twice as much operations.</p>
<p><strong>Custom minimizers</strong></p>
<p>It may be useful to pass a custom minimization method, for example
when using a frontend to this method such as <code>scipy.optimize.basinhopping</code>
or a different library.  You can simply pass a callable as the <code>method</code>
parameter.</p>
<p>The callable is called as <code>method(fun, x0, args, **kwargs, **options)</code>
where <code>kwargs</code> corresponds to any other parameters passed to <code>minimize</code>
(such as <code>callback</code>, <code>hess</code>, etc.), except the <code>options</code> dict, which has
its contents also passed as <code>method</code> parameters pair by pair.  Also, if
<code>jac</code> has been passed as a bool type, <code>jac</code> and <code>fun</code> are mangled so that
<code>fun</code> returns just the function values and <code>jac</code> is converted to a function
returning the Jacobian.  The method shall return an <code>OptimizeResult</code>
object.</p>
<p>The provided <code>method</code> callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by <code>minimize</code> may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_48">References<a class="headerlink" href="#references_48" title="Permanent link">&para;</a></h2>
<p>.. [1] Nelder, J A, and R Mead. 1965. A Simplex Method for Function
Minimization. The Computer Journal 7: 308-13.
.. [2] Wright M H. 1996. Direct search methods: Once scorned, now
respectable, in Numerical Analysis 1995: Proceedings of the 1995
Dundee Biennial Conference in Numerical Analysis (Eds. D F
Griffiths and G A Watson). Addison Wesley Longman, Harlow, UK.
191-208.
.. [3] Powell, M J D. 1964. An efficient method for finding the minimum of
a function of several variables without calculating derivatives. The
Computer Journal 7: 155-162.
.. [4] Press W, S A Teukolsky, W T Vetterling and B P Flannery.
Numerical Recipes (any edition), Cambridge University Press.
.. [5] Nocedal, J, and S J Wright. 2006. Numerical Optimization.
Springer New York.
.. [6] Byrd, R H and P Lu and J. Nocedal. 1995. A Limited Memory
Algorithm for Bound Constrained Optimization. SIAM Journal on
Scientific and Statistical Computing 16 (5): 1190-1208.
.. [7] Zhu, C and R H Byrd and J Nocedal. 1997. L-BFGS-B: Algorithm
778: L-BFGS-B, FORTRAN routines for large scale bound constrained
optimization. ACM Transactions on Mathematical Software 23 (4):
550-560.
.. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Method.
1984. SIAM Journal of Numerical Analysis 21: 770-778.
.. [9] Powell, M J D. A direct search optimization method that models
the objective and constraint functions by linear interpolation.
1994. Advances in Optimization and Numerical Analysis, eds. S. Gomez
and J-P Hennart, Kluwer Academic (Dordrecht), 51-67.
.. [10] Powell M J D. Direct search algorithms for optimization
calculations. 1998. Acta Numerica 7: 287-336.
.. [11] Powell M J D. A view of algorithms for optimization without
derivatives. 2007.Cambridge University Technical Report DAMTP
2007/NA03
.. [12] Kraft, D. A software package for sequential quadratic
programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace
Center -- Institute for Flight Mechanics, Koln, Germany.
.. [13] Conn, A. R., Gould, N. I., and Toint, P. L.
Trust region methods. 2000. Siam. pp. 169-200.
.. [14] F. Lenders, C. Kirches, A. Potschka: 'trlib: A vector-free
implementation of the GLTR method for iterative solution of
the trust region problem', https://arxiv.org/abs/1611.04718
.. [15] N. Gould, S. Lucidi, M. Roma, P. Toint: 'Solving the
Trust-Region Subproblem using the Lanczos Method',
SIAM J. Optim., 9(2), 504--525, (1999).
.. [16] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999.
An interior point algorithm for large-scale nonlinear  programming.
SIAM Journal on Optimization 9.4: 877-900.
.. [17] Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the
implementation of an algorithm for large-scale equality constrained
optimization. SIAM Journal on Optimization 8.3: 682-706.</p>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<p>Let us consider the problem of minimizing the Rosenbrock function. This
function (and its respective derivatives) is implemented in <code>rosen</code>
(resp. <code>rosen_der</code>, <code>rosen_hess</code>) in the <code>scipy.optimize</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import minimize, rosen, rosen_der</p>
</blockquote>
</blockquote>
</blockquote>
<p>A simple application of the <em>Nelder-Mead</em> method is:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x0 = [1.3, 0.7, 0.8, 1.9, 1.2]
res = minimize(rosen, x0, method='Nelder-Mead', tol=1e-6)
res.x
array([ 1.,  1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now using the <em>BFGS</em> algorithm, using the first derivative and a few
options:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res = minimize(rosen, x0, method='BFGS', jac=rosen_der,
...                options={'gtol': 1e-6, 'disp': True})
Optimization terminated successfully.
Current function value: 0.000000
Iterations: 26
Function evaluations: 31
Gradient evaluations: 31
res.x
array([ 1.,  1.,  1.,  1.,  1.])
print(res.message)
Optimization terminated successfully.
res.hess_inv
array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary
[ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269],
[ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151],
[ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ],
[ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Next, consider a minimization problem with several constraints (namely
Example 16.4 from [5]_). The objective function is:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fun = lambda x: (x[0] - 1)<strong>2 + (x[1] - 2.5)</strong>2</p>
</blockquote>
</blockquote>
</blockquote>
<p>There are three constraints defined as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>cons = ({'type': 'ineq', 'fun': lambda x:  x[0] - 2 * x[1] + 2},
...         {'type': 'ineq', 'fun': lambda x: -x[0] - 2 * x[1] + 6},
...         {'type': 'ineq', 'fun': lambda x: -x[0] + 2 * x[1] + 2})</p>
</blockquote>
</blockquote>
</blockquote>
<p>And variables must be positive, hence the following bounds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>bnds = ((0, None), (0, None))</p>
</blockquote>
</blockquote>
</blockquote>
<p>The optimization problem is solved using the SLSQP method as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res = minimize(fun, (2, 0), method='SLSQP', bounds=bnds,
...                constraints=cons)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It should converge to the theoretical solution (1.4 ,1.7).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimize_scalar</span> <span class="o">:</span> <span class="o">?</span><span class="n">bracket</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Minimization of scalar function of one variable.</p>
<h2 id="parameters_184">Parameters<a class="headerlink" href="#parameters_184" title="Permanent link">&para;</a></h2>
<p>fun : callable
Objective function.
Scalar function, must return a scalar.
bracket : sequence, optional
For methods 'brent' and 'golden', <code>bracket</code> defines the bracketing
interval and can either have three items <code>(a, b, c)</code> so that
<code>a &lt; b &lt; c</code> and <code>fun(b) &lt; fun(a), fun(c)</code> or two items <code>a</code> and
<code>c</code> which are assumed to be a starting interval for a downhill
bracket search (see <code>bracket</code>); it doesn't always mean that the
obtained solution will satisfy <code>a &lt;= x &lt;= c</code>.
bounds : sequence, optional
For method 'bounded', <code>bounds</code> is mandatory and must have two items
corresponding to the optimization bounds.
args : tuple, optional
Extra arguments passed to the objective function.
method : str or callable, optional
Type of solver.  Should be one of:</p>
<ul>
<li>'Brent'     :ref:<code>(see here) &lt;optimize.minimize_scalar-brent&gt;</code></li>
<li>'Bounded'   :ref:<code>(see here) &lt;optimize.minimize_scalar-bounded&gt;</code></li>
<li>'Golden'    :ref:<code>(see here) &lt;optimize.minimize_scalar-golden&gt;</code></li>
<li>custom - a callable object (added in version 0.14.0), see below</li>
</ul>
<p>tol : float, optional
Tolerance for termination. For detailed control, use solver-specific
options.
options : dict, optional
A dictionary of solver options.</p>
<p>maxiter : int
Maximum number of iterations to perform.
disp : bool
Set to True to print convergence messages.</p>
<p>See :func:<code>show_options()</code> for solver-specific options.</p>
<h2 id="returns_163">Returns<a class="headerlink" href="#returns_163" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>success</code> a
Boolean flag indicating if the optimizer exited successfully and
<code>message</code> which describes the cause of the termination. See
<code>OptimizeResult</code> for a description of other attributes.</p>
<h2 id="see-also_122">See also<a class="headerlink" href="#see-also_122" title="Permanent link">&para;</a></h2>
<p>minimize : Interface to minimization algorithms for scalar multivariate
functions
show_options : Additional options accepted by the solvers</p>
<h2 id="notes_105">Notes<a class="headerlink" href="#notes_105" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter. The default method is <em>Brent</em>.</p>
<p>Method :ref:<code>Brent &lt;optimize.minimize_scalar-brent&gt;</code> uses Brent's
algorithm to find a local minimum.  The algorithm uses inverse
parabolic interpolation when possible to speed up convergence of
the golden section method.</p>
<p>Method :ref:<code>Golden &lt;optimize.minimize_scalar-golden&gt;</code> uses the
golden section search technique. It uses analog of the bisection
method to decrease the bracketed interval. It is usually
preferable to use the <em>Brent</em> method.</p>
<p>Method :ref:<code>Bounded &lt;optimize.minimize_scalar-bounded&gt;</code> can
perform bounded minimization. It uses the Brent method to find a
local minimum in the interval x1 &lt; xopt &lt; x2.</p>
<p><strong>Custom minimizers</strong></p>
<p>It may be useful to pass a custom minimization method, for example
when using some library frontend to minimize_scalar.  You can simply
pass a callable as the <code>method</code> parameter.</p>
<p>The callable is called as <code>method(fun, args, **kwargs, **options)</code>
where <code>kwargs</code> corresponds to any other parameters passed to <code>minimize</code>
(such as <code>bracket</code>, <code>tol</code>, etc.), except the <code>options</code> dict, which has
its contents also passed as <code>method</code> parameters pair by pair.  The method
shall return an <code>OptimizeResult</code> object.</p>
<p>The provided <code>method</code> callable must be able to accept (and possibly ignore)
arbitrary parameters; the set of parameters accepted by <code>minimize</code> may
expand in future versions and then these parameters will be passed to
the method.  You can find an example in the scipy.optimize tutorial.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<p>Consider the problem of minimizing the following function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x - 2) * x * (x + 2)**2</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the <em>Brent</em> method, we find the local minimum as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import minimize_scalar
res = minimize_scalar(f)
res.x
1.28077640403</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the <em>Bounded</em> method, we find a local minimum with specified
bounds as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>res = minimize_scalar(f, bounds=(-3, -1), method='bounded')
res.x
-2.0000002026</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newton</span> <span class="o">:</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a zero of a real or complex function using the Newton-Raphson
(or secant or Halley's) method.</p>
<p>Find a zero of the function <code>func</code> given a nearby starting point <code>x0</code>.
The Newton-Raphson method is used if the derivative <code>fprime</code> of <code>func</code>
is provided, otherwise the secant method is used.  If the second order
derivative <code>fprime2</code> of <code>func</code> is also provided, then Halley's method is
used.</p>
<p>If <code>x0</code> is a sequence with more than one item, then <code>newton</code> returns an
array, and <code>func</code> must be vectorized and return a sequence or array of the
same shape as its first argument. If <code>fprime</code> or <code>fprime2</code> is given then
its return must also have the same shape.</p>
<h2 id="parameters_185">Parameters<a class="headerlink" href="#parameters_185" title="Permanent link">&para;</a></h2>
<p>func : callable
The function whose zero is wanted. It must be a function of a
single variable of the form <code>f(x,a,b,c...)</code>, where <code>a,b,c...</code>
are extra arguments that can be passed in the <code>args</code> parameter.
x0 : float, sequence, or ndarray
An initial estimate of the zero that should be somewhere near the
actual zero. If not scalar, then <code>func</code> must be vectorized and return
a sequence or array of the same shape as its first argument.
fprime : callable, optional
The derivative of the function when available and convenient. If it
is None (default), then the secant method is used.
args : tuple, optional
Extra arguments to be used in the function call.
tol : float, optional
The allowable error of the zero value.  If <code>func</code> is complex-valued,
a larger <code>tol</code> is recommended as both the real and imaginary parts
of <code>x</code> contribute to <code>|x - x0|</code>.
maxiter : int, optional
Maximum number of iterations.
fprime2 : callable, optional
The second order derivative of the function when available and
convenient. If it is None (default), then the normal Newton-Raphson
or the secant method is used. If it is not None, then Halley's method
is used.
x1 : float, optional
Another estimate of the zero that should be somewhere near the
actual zero.  Used if <code>fprime</code> is not provided.
rtol : float, optional
Tolerance (relative) for termination.
full_output : bool, optional
If <code>full_output</code> is False (default), the root is returned.
If True and <code>x0</code> is scalar, the return value is <code>(x, r)</code>, where <code>x</code>
is the root and <code>r</code> is a <code>RootResults</code> object.
If True and <code>x0</code> is non-scalar, the return value is <code>(x, converged,
zero_der)</code> (see Returns section for details).
disp : bool, optional
If True, raise a RuntimeError if the algorithm didn't converge, with
the error message containing the number of iterations and current
function value.  Otherwise the convergence status is recorded in a
<code>RootResults</code> return object.
Ignored if <code>x0</code> is not scalar.
<em>Note: this has little to do with displaying, however
the <code>disp</code> keyword cannot be renamed for backwards compatibility.</em></p>
<h2 id="returns_164">Returns<a class="headerlink" href="#returns_164" title="Permanent link">&para;</a></h2>
<p>root : float, sequence, or ndarray
Estimated location where function is zero.
r : <code>RootResults</code>, optional
Present if <code>full_output=True</code> and <code>x0</code> is scalar.
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.
converged : ndarray of bool, optional
Present if <code>full_output=True</code> and <code>x0</code> is non-scalar.
For vector functions, indicates which elements converged successfully.
zero_der : ndarray of bool, optional
Present if <code>full_output=True</code> and <code>x0</code> is non-scalar.
For vector functions, indicates which elements had a zero derivative.</p>
<h2 id="see-also_123">See Also<a class="headerlink" href="#see-also_123" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, ridder, bisect
fsolve : find zeros in n dimensions.</p>
<h2 id="notes_106">Notes<a class="headerlink" href="#notes_106" title="Permanent link">&para;</a></h2>
<p>The convergence rate of the Newton-Raphson method is quadratic,
the Halley method is cubic, and the secant method is
sub-quadratic.  This means that if the function is well behaved
the actual error in the estimated zero after the n-th iteration
is approximately the square (cube for Halley) of the error
after the (n-1)-th step.  However, the stopping criterion used
here is the step size and there is no guarantee that a zero
has been found. Consequently the result should be verified.
Safer algorithms are brentq, brenth, ridder, and bisect,
but they all require that the root first be bracketed in an
interval where the function changes sign. The brentq algorithm
is recommended for general use in one dimensional problems
when such an interval has been found.</p>
<p>When <code>newton</code> is used with arrays, it is best suited for the following
types of problems:</p>
<ul>
<li>The initial guesses, <code>x0</code>, are all relatively the same distance from
the roots.</li>
<li>Some or all of the extra arguments, <code>args</code>, are also arrays so that a
class of similar problems can be solved together.</li>
<li>The size of the initial guesses, <code>x0</code>, is larger than O(100) elements.
Otherwise, a naive loop may perform as well or better than a vector.</li>
</ul>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
import matplotlib.pyplot as plt</p>
<p>def f(x):
...     return (x**3 - 1)  # only one real root at x = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>fprime</code> is not provided, use the secant method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5)
root
1.0000000000000016
root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)
root
1.0000000000000016</p>
</blockquote>
</blockquote>
</blockquote>
<p>Only <code>fprime</code> is provided, use the Newton-Raphson method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Both <code>fprime2</code> and <code>fprime</code> are provided, use Halley's method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,
...                        fprime2=lambda x: 6 * x)
root
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>When we want to find zeros for a set of related starting values and/or
function parameters, we can provide both of those as an array of inputs:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = lambda x, a: x<strong>3 - a
fder = lambda x, a: 3 * x</strong>2
np.random.seed(4321)
x = np.random.randn(100)
a = np.arange(-50, 50)
vec_res = optimize.newton(f, x, fprime=fder, args=(a, ))</p>
</blockquote>
</blockquote>
</blockquote>
<p>The above is the equivalent of solving for each value in <code>(x, a)</code>
separately in a for-loop, just faster:</p>
<blockquote>
<blockquote>
<blockquote>
<p>loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,))
...             for x0, a0 in zip(x, a)]
np.allclose(vec_res, loop_res)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the results found for all values of <code>a</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>analytical_result = np.sign(a) * np.abs(a)**(1/3)
fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(a, analytical_result, 'o')
ax.plot(a, vec_res, '.')
ax.set_xlabel('<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>')
ax.set_ylabel('<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> where <span><span class="MathJax_Preview">f(x, a)=0</span><script type="math/tex">f(x, a)=0</script></span>')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newton_krylov</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rdiff</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Cgs</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lgmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gmres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bicgstab</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Minres</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_maxiter</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">inner_M</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outer_k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">verbose</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">f_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x_rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol_norm</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">line_search</span><span class="o">:[`</span><span class="nc">Armijo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wolfe</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xin</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a function, using Krylov approximation for inverse Jacobian.</p>
<p>This method is suitable for solving large-scale problems.</p>
<h2 id="parameters_186">Parameters<a class="headerlink" href="#parameters_186" title="Permanent link">&para;</a></h2>
<p>F : function(x) -&gt; f
Function whose root to find; should take and return an array-like
object.
xin : array_like
Initial guess for the solution
rdiff : float, optional
Relative step size to use in numerical differentiation.
method : {'lgmres', 'gmres', 'bicgstab', 'cgs', 'minres'} or function
Krylov method to use to approximate the Jacobian.
Can be a string, or a function implementing the same interface as
the iterative solvers in <code>scipy.sparse.linalg</code>.</p>
<p>The default is <code>scipy.sparse.linalg.lgmres</code>.
inner_M : LinearOperator or InverseJacobian
Preconditioner for the inner Krylov iteration.
Note that you can use also inverse Jacobians as (adaptive)
preconditioners. For example,</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize.nonlin import BroydenFirst, KrylovJacobian
from scipy.optimize.nonlin import InverseJacobian
jac = BroydenFirst()
kjac = KrylovJacobian(inner_M=InverseJacobian(jac))</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the preconditioner has a method named 'update', it will be called
as <code>update(x, f)</code> after each nonlinear step, with <code>x</code> giving
the current point, and <code>f</code> the current function value.
inner_tol, inner_maxiter, ...
Parameters to pass on to the \'inner\' Krylov solver.
See <code>scipy.sparse.linalg.gmres</code> for details.
outer_k : int, optional
Size of the subspace kept across LGMRES nonlinear iterations.
See <code>scipy.sparse.linalg.lgmres</code> for details.
iter : int, optional
Number of iterations to make. If omitted (default), make as many
as required to meet tolerances.
verbose : bool, optional
Print status to stdout on every iteration.
maxiter : int, optional
Maximum number of iterations to make. If more are needed to
meet convergence, <code>NoConvergence</code> is raised.
f_tol : float, optional
Absolute tolerance (in max-norm) for the residual.
If omitted, default is 6e-6.
f_rtol : float, optional
Relative tolerance for the residual. If omitted, not used.
x_tol : float, optional
Absolute minimum step size, as determined from the Jacobian
approximation. If the step size is smaller than this, optimization
is terminated as successful. If omitted, not used.
x_rtol : float, optional
Relative minimum step size. If omitted, not used.
tol_norm : function(vector) -&gt; scalar, optional
Norm to use in convergence check. Default is the maximum norm.
line_search : {None, 'armijo' (default), 'wolfe'}, optional
Which type of a line search to use to determine the step size in the
direction given by the Jacobian approximation. Defaults to 'armijo'.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual.</p>
<h2 id="returns_165">Returns<a class="headerlink" href="#returns_165" title="Permanent link">&para;</a></h2>
<p>sol : ndarray
An array (of similar array type as <code>x0</code>) containing the final solution.</p>
<h2 id="raises_26">Raises<a class="headerlink" href="#raises_26" title="Permanent link">&para;</a></h2>
<p>NoConvergence
When a solution was not found.</p>
<h2 id="see-also_124">See Also<a class="headerlink" href="#see-also_124" title="Permanent link">&para;</a></h2>
<p>root : Interface to root finding algorithms for multivariate
functions. See <code>method=='krylov'</code> in particular.
scipy.sparse.linalg.gmres
scipy.sparse.linalg.lgmres</p>
<h2 id="notes_107">Notes<a class="headerlink" href="#notes_107" title="Permanent link">&para;</a></h2>
<p>This function implements a Newton-Krylov solver. The basic idea is
to compute the inverse of the Jacobian with an iterative Krylov
method. These methods require only evaluating the Jacobian-vector
products, which are conveniently approximated by a finite difference:</p>
<p>.. math:: J v \approx (f(x + \omega*v/|v|) - f(x)) / \omega</p>
<p>Due to the use of iterative matrix inverses, these methods can
deal with large nonlinear problems.</p>
<p>SciPy's <code>scipy.sparse.linalg</code> module offers a selection of Krylov
solvers to choose from. The default here is <code>lgmres</code>, which is a
variant of restarted GMRES iteration that reuses some of the
information obtained in the previous Newton steps to invert
Jacobians in subsequent steps.</p>
<p>For a review on Newton-Krylov methods, see for example [1]<em>,
and for the LGMRES sparse inverse method, see [2]</em>.</p>
<h2 id="references_49">References<a class="headerlink" href="#references_49" title="Permanent link">&para;</a></h2>
<p>.. [1] D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2004).
:doi:<code>10.1016/j.jcp.2003.08.010</code>
.. [2] A.H. Baker and E.R. Jessup and T. Manteuffel,
SIAM J. Matrix Anal. Appl. 26, 962 (2005).
:doi:<code>10.1137/S0895479803422014</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nnls</span> <span class="o">:</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Solve <code>argmin_x || Ax - b ||_2</code> for <code>x&gt;=0</code>. This is a wrapper
for a FORTRAN non-negative least squares solver.</p>
<h2 id="parameters_187">Parameters<a class="headerlink" href="#parameters_187" title="Permanent link">&para;</a></h2>
<p>A : ndarray
Matrix <code>A</code> as shown above.
b : ndarray
Right-hand side vector.
maxiter: int, optional
Maximum number of iterations, optional.
Default is <code>3 * A.shape[1]</code>.</p>
<h2 id="returns_166">Returns<a class="headerlink" href="#returns_166" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution vector.
rnorm : float
The residual, <code>|| Ax-b ||_2</code>.</p>
<h2 id="see-also_125">See Also<a class="headerlink" href="#see-also_125" title="Permanent link">&para;</a></h2>
<p>lsq_linear : Linear least squares with bounds on the variables</p>
<h2 id="notes_108">Notes<a class="headerlink" href="#notes_108" title="Permanent link">&para;</a></h2>
<p>The FORTRAN code was published in the book below. The algorithm
is an active set method. It solves the KKT (Karush-Kuhn-Tucker)
conditions for the non-negative least squares problem.</p>
<h2 id="references_50">References<a class="headerlink" href="#references_50" title="Permanent link">&para;</a></h2>
<p>Lawson C., Hanson R.J., (1987) Solving Least Squares Problems, SIAM</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import nnls
...
A = np.array([[1, 0], [1, 0], [0, 1]])
b = np.array([2, 1, 1])
nnls(A, b)
(array([1.5, 1. ]), 0.7071067811865475)</p>
<p>b = np.array([-1, -1, -1])
nnls(A, b)
(array([0., 0.]), 1.7320508075688772)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridder</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a root of a function in an interval using Ridder's method.</p>
<h2 id="parameters_188">Parameters<a class="headerlink" href="#parameters_188" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a number.  f must be continuous, and f(a) and
f(b) must have opposite signs.
a : scalar
One end of the bracketing interval [a,b].
b : scalar
The other end of the bracketing interval [a,b].
xtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : number, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter cannot be smaller than its default value of
<code>4*np.finfo(float).eps</code>.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>apply(f, (x)+args)</code>.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in any <code>RootResults</code>
return object.</p>
<h2 id="returns_167">Returns<a class="headerlink" href="#returns_167" title="Permanent link">&para;</a></h2>
<p>x0 : float
Zero of <code>f</code> between <code>a</code> and <code>b</code>.
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.
In particular, <code>r.converged</code> is True if the routine converged.</p>
<h2 id="see-also_126">See Also<a class="headerlink" href="#see-also_126" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, bisect, newton : one-dimensional root-finding
fixed_point : scalar fixed-point finder</p>
<h2 id="notes_109">Notes<a class="headerlink" href="#notes_109" title="Permanent link">&para;</a></h2>
<p>Uses [Ridders1979]<em> method to find a zero of the function <code>f</code> between the
arguments <code>a</code> and <code>b</code>. Ridders' method is faster than bisection, but not
generally as fast as the Brent routines. [Ridders1979]</em> provides the
classic description and source of the algorithm. A description can also be
found in any recent edition of Numerical Recipes.</p>
<p>The routine used here diverges slightly from standard presentations in
order to be a bit more careful of tolerance.</p>
<h2 id="references_51">References<a class="headerlink" href="#references_51" title="Permanent link">&para;</a></h2>
<p>.. [Ridders1979]
Ridders, C. F. J. 'A New Algorithm for Computing a
Single Root of a Real Continuous Function.'
IEEE Trans. Circuits Systems 26, 979-980, 1979.</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**2 - 1)</p>
<p>from scipy import optimize</p>
<p>root = optimize.ridder(f, 0, 2)
root
1.0</p>
<p>root = optimize.ridder(f, -2, 0)
root
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">root</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">jac</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fun_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a vector function.</p>
<h2 id="parameters_189">Parameters<a class="headerlink" href="#parameters_189" title="Permanent link">&para;</a></h2>
<p>fun : callable
A vector function to find a root of.
x0 : ndarray
Initial guess.
args : tuple, optional
Extra arguments passed to the objective function and its Jacobian.
method : str, optional
Type of solver.  Should be one of</p>
<ul>
<li>'hybr'             :ref:<code>(see here) &lt;optimize.root-hybr&gt;</code></li>
<li>'lm'               :ref:<code>(see here) &lt;optimize.root-lm&gt;</code></li>
<li>'broyden1'         :ref:<code>(see here) &lt;optimize.root-broyden1&gt;</code></li>
<li>'broyden2'         :ref:<code>(see here) &lt;optimize.root-broyden2&gt;</code></li>
<li>'anderson'         :ref:<code>(see here) &lt;optimize.root-anderson&gt;</code></li>
<li>'linearmixing'     :ref:<code>(see here) &lt;optimize.root-linearmixing&gt;</code></li>
<li>'diagbroyden'      :ref:<code>(see here) &lt;optimize.root-diagbroyden&gt;</code></li>
<li>'excitingmixing'   :ref:<code>(see here) &lt;optimize.root-excitingmixing&gt;</code></li>
<li>'krylov'           :ref:<code>(see here) &lt;optimize.root-krylov&gt;</code></li>
<li>'df-sane'          :ref:<code>(see here) &lt;optimize.root-dfsane&gt;</code></li>
</ul>
<p>jac : bool or callable, optional
If <code>jac</code> is a Boolean and is True, <code>fun</code> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<code>jac</code> can also be a callable returning the Jacobian of <code>fun</code>. In
this case, it must accept the same arguments as <code>fun</code>.
tol : float, optional
Tolerance for termination. For detailed control, use solver-specific
options.
callback : function, optional
Optional callback function. It is called on every iteration as
<code>callback(x, f)</code> where <code>x</code> is the current solution and <code>f</code>
the corresponding residual. For all methods but 'hybr' and 'lm'.
options : dict, optional
A dictionary of solver options. E.g. <code>xtol</code> or <code>maxiter</code>, see
:obj:<code>show_options()</code> for details.</p>
<h2 id="returns_168">Returns<a class="headerlink" href="#returns_168" title="Permanent link">&para;</a></h2>
<p>sol : OptimizeResult
The solution represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>success</code> a
Boolean flag indicating if the algorithm exited successfully and
<code>message</code> which describes the cause of the termination. See
<code>OptimizeResult</code> for a description of other attributes.</p>
<h2 id="see-also_127">See also<a class="headerlink" href="#see-also_127" title="Permanent link">&para;</a></h2>
<p>show_options : Additional options accepted by the solvers</p>
<h2 id="notes_110">Notes<a class="headerlink" href="#notes_110" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter. The default method is <em>hybr</em>.</p>
<p>Method <em>hybr</em> uses a modification of the Powell hybrid method as
implemented in MINPACK [1]_.</p>
<p>Method <em>lm</em> solves the system of nonlinear equations in a least squares
sense using a modification of the Levenberg-Marquardt algorithm as
implemented in MINPACK [1]_.</p>
<p>Method <em>df-sane</em> is a derivative-free spectral method. [3]_</p>
<p>Methods <em>broyden1</em>, <em>broyden2</em>, <em>anderson</em>, <em>linearmixing</em>,
<em>diagbroyden</em>, <em>excitingmixing</em>, <em>krylov</em> are inexact Newton methods,
with backtracking or full line searches [2]_. Each method corresponds
to a particular Jacobian approximations. See <code>nonlin</code> for details.</p>
<ul>
<li>Method <em>broyden1</em> uses Broyden's first Jacobian approximation, it is
known as Broyden's good method.</li>
<li>Method <em>broyden2</em> uses Broyden's second Jacobian approximation, it
is known as Broyden's bad method.</li>
<li>Method <em>anderson</em> uses (extended) Anderson mixing.</li>
<li>Method <em>Krylov</em> uses Krylov approximation for inverse Jacobian. It
is suitable for large-scale problem.</li>
<li>Method <em>diagbroyden</em> uses diagonal Broyden Jacobian approximation.</li>
<li>Method <em>linearmixing</em> uses a scalar Jacobian approximation.</li>
<li>Method <em>excitingmixing</em> uses a tuned diagonal Jacobian
approximation.</li>
</ul>
<p>.. warning::</p>
<p>The algorithms implemented for methods <em>diagbroyden</em>,
<em>linearmixing</em> and <em>excitingmixing</em> may be useful for specific
problems, but whether they will work may depend strongly on the
problem.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_52">References<a class="headerlink" href="#references_52" title="Permanent link">&para;</a></h2>
<p>.. [1] More, Jorge J., Burton S. Garbow, and Kenneth E. Hillstrom.
1980. User Guide for MINPACK-1.
.. [2] C. T. Kelley. 1995. Iterative Methods for Linear and Nonlinear
Equations. Society for Industrial and Applied Mathematics.
<a href="https://archive.siam.org/books/kelley/fr16/">https://archive.siam.org/books/kelley/fr16/</a>
.. [3] W. La Cruz, J.M. Martinez, M. Raydan. Math. Comp. 75, 1429 (2006).</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<p>The following functions define a system of nonlinear equations and its
jacobian.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fun(x):
...     return [x[0]  + 0.5 * (x[0] - x[1])<strong>3 - 1.0,
...             0.5 * (x[1] - x[0])</strong>3 + x[1]]</p>
<p>def jac(x):
...     return np.array([[1 + 1.5 * (x[0] - x[1])<strong>2,
...                       -1.5 * (x[0] - x[1])</strong>2],
...                      [-1.5 * (x[1] - x[0])<strong>2,
...                       1 + 1.5 * (x[1] - x[0])</strong>2]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A solution can be obtained as follows.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
sol = optimize.root(fun, [0, 0], jac=jac, method='hybr')
sol.x
array([ 0.8411639,  0.1588361])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">root_scalar</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bracket</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fprime2</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find a root of a scalar function.</p>
<h2 id="parameters_190">Parameters<a class="headerlink" href="#parameters_190" title="Permanent link">&para;</a></h2>
<p>f : callable
A function to find a root of.
args : tuple, optional
Extra arguments passed to the objective function and its derivative(s).
method : str, optional
Type of solver.  Should be one of</p>
<ul>
<li>'bisect'    :ref:<code>(see here) &lt;optimize.root_scalar-bisect&gt;</code></li>
<li>'brentq'    :ref:<code>(see here) &lt;optimize.root_scalar-brentq&gt;</code></li>
<li>'brenth'    :ref:<code>(see here) &lt;optimize.root_scalar-brenth&gt;</code></li>
<li>'ridder'    :ref:<code>(see here) &lt;optimize.root_scalar-ridder&gt;</code></li>
<li>'toms748'    :ref:<code>(see here) &lt;optimize.root_scalar-toms748&gt;</code></li>
<li>'newton'    :ref:<code>(see here) &lt;optimize.root_scalar-newton&gt;</code></li>
<li>'secant'    :ref:<code>(see here) &lt;optimize.root_scalar-secant&gt;</code></li>
<li>'halley'    :ref:<code>(see here) &lt;optimize.root_scalar-halley&gt;</code></li>
</ul>
<p>bracket: A sequence of 2 floats, optional
An interval bracketing a root.  <code>f(x, *args)</code> must have different
signs at the two endpoints.
x0 : float, optional
Initial guess.
x1 : float, optional
A second guess.
fprime : bool or callable, optional
If <code>fprime</code> is a boolean and is True, <code>f</code> is assumed to return the
value of the objective function and of the derivative.
<code>fprime</code> can also be a callable returning the derivative of <code>f</code>. In
this case, it must accept the same arguments as <code>f</code>.
fprime2 : bool or callable, optional
If <code>fprime2</code> is a boolean and is True, <code>f</code> is assumed to return the
value of the objective function and of the
first and second derivatives.
<code>fprime2</code> can also be a callable returning the second derivative of <code>f</code>.
In this case, it must accept the same arguments as <code>f</code>.
xtol : float, optional
Tolerance (absolute) for termination.
rtol : float, optional
Tolerance (relative) for termination.
maxiter : int, optional
Maximum number of iterations.
options : dict, optional
A dictionary of solver options. E.g. <code>k</code>, see
:obj:<code>show_options()</code> for details.</p>
<h2 id="returns_169">Returns<a class="headerlink" href="#returns_169" title="Permanent link">&para;</a></h2>
<p>sol : RootResults
The solution represented as a <code>RootResults</code> object.
Important attributes are: <code>root</code> the solution , <code>converged</code> a
boolean flag indicating if the algorithm exited successfully and
<code>flag</code> which describes the cause of the termination. See
<code>RootResults</code> for a description of other attributes.</p>
<h2 id="see-also_128">See also<a class="headerlink" href="#see-also_128" title="Permanent link">&para;</a></h2>
<p>show_options : Additional options accepted by the solvers
root : Find a root of a vector function.</p>
<h2 id="notes_111">Notes<a class="headerlink" href="#notes_111" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter.</p>
<p>The default is to use the best method available for the situation
presented.
If a bracket is provided, it may use one of the bracketing methods.
If a derivative and an initial value are specified, it may
select one of the derivative-based methods.
If no method is judged applicable, it will raise an Exception.</p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<p>Find the root of a simple cubic</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import optimize
def f(x):
...     return (x**3 - 1)  # only one real root at x = 1</p>
<p>def fprime(x):
...     return 3<em>x</em>*2</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>brentq</code> method takes as input a bracket</p>
<blockquote>
<blockquote>
<blockquote>
<p>sol = optimize.root_scalar(f, bracket=[0, 3], method='brentq')
sol.root, sol.iterations, sol.function_calls
(1.0, 10, 11)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>newton</code> method takes as input a single point and uses the derivative(s)</p>
<blockquote>
<blockquote>
<blockquote>
<p>sol = optimize.root_scalar(f, x0=0.2, fprime=fprime, method='newton')
sol.root, sol.iterations, sol.function_calls
(1.0, 11, 22)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The function can provide the value and derivative(s) in a single call.</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f_p_pp(x):
...     return (x<strong>3 - 1), 3*x</strong>2, 6*x</p>
<p>sol = optimize.root_scalar(f_p_pp, x0=0.2, fprime=True, method='newton')
sol.root, sol.iterations, sol.function_calls
(1.0, 11, 11)</p>
<p>sol = optimize.root_scalar(f_p_pp, x0=0.2, fprime=True, fprime2=True, method='halley')
sol.root, sol.iterations, sol.function_calls
(1.0, 7, 8)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>The Rosenbrock function.</p>
<p>The function computed is::</p>
<p>sum(100.0<em>(x[1:] - x[:-1]</em><em>2.0)</em><em>2.0 + (1 - x[:-1])</em>*2.0)</p>
<h2 id="parameters_191">Parameters<a class="headerlink" href="#parameters_191" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Rosenbrock function is to be computed.</p>
<h2 id="returns_170">Returns<a class="headerlink" href="#returns_170" title="Permanent link">&para;</a></h2>
<p>f : float
The value of the Rosenbrock function.</p>
<h2 id="see-also_129">See Also<a class="headerlink" href="#see-also_129" title="Permanent link">&para;</a></h2>
<p>rosen_der, rosen_hess, rosen_hess_prod</p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen
X = 0.1 * np.arange(10)
rosen(X)
76.56</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_der</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The derivative (i.e. gradient) of the Rosenbrock function.</p>
<h2 id="parameters_192">Parameters<a class="headerlink" href="#parameters_192" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the derivative is to be computed.</p>
<h2 id="returns_171">Returns<a class="headerlink" href="#returns_171" title="Permanent link">&para;</a></h2>
<p>rosen_der : (N,) ndarray
The gradient of the Rosenbrock function at <code>x</code>.</p>
<h2 id="see-also_130">See Also<a class="headerlink" href="#see-also_130" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_hess, rosen_hess_prod</p>
<h2 id="examples_112">Examples<a class="headerlink" href="#examples_112" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_der
X = 0.1 * np.arange(9)
rosen_der(X)
array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_hess</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The Hessian matrix of the Rosenbrock function.</p>
<h2 id="parameters_193">Parameters<a class="headerlink" href="#parameters_193" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Hessian matrix is to be computed.</p>
<h2 id="returns_172">Returns<a class="headerlink" href="#returns_172" title="Permanent link">&para;</a></h2>
<p>rosen_hess : ndarray
The Hessian matrix of the Rosenbrock function at <code>x</code>.</p>
<h2 id="see-also_131">See Also<a class="headerlink" href="#see-also_131" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_der, rosen_hess_prod</p>
<h2 id="examples_113">Examples<a class="headerlink" href="#examples_113" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_hess
X = 0.1 * np.arange(4)
rosen_hess(X)
array([[-38.,   0.,   0.,   0.],
[  0., 134., -40.,   0.],
[  0., -40., 130., -80.],
[  0.,   0., -80., 200.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rosen_hess_prod</span> <span class="o">:</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Product of the Hessian matrix of the Rosenbrock function with a vector.</p>
<h2 id="parameters_194">Parameters<a class="headerlink" href="#parameters_194" title="Permanent link">&para;</a></h2>
<p>x : array_like
1-D array of points at which the Hessian matrix is to be computed.
p : array_like
1-D array, the vector to be multiplied by the Hessian matrix.</p>
<h2 id="returns_173">Returns<a class="headerlink" href="#returns_173" title="Permanent link">&para;</a></h2>
<p>rosen_hess_prod : ndarray
The Hessian matrix of the Rosenbrock function at <code>x</code> multiplied
by the vector <code>p</code>.</p>
<h2 id="see-also_132">See Also<a class="headerlink" href="#see-also_132" title="Permanent link">&para;</a></h2>
<p>rosen, rosen_der, rosen_hess</p>
<h2 id="examples_114">Examples<a class="headerlink" href="#examples_114" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen_hess_prod
X = 0.1 * np.arange(9)
p = 0.5 * np.arange(9)
rosen_hess_prod(X, p)
array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shgo</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">constraints</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iters</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">callback</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minimizer_kwargs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">options</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sampling_method</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bounds</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Finds the global minimum of a function using SHG optimization.</p>
<p>SHGO stands for 'simplicial homology global optimization'.</p>
<h2 id="parameters_195">Parameters<a class="headerlink" href="#parameters_195" title="Permanent link">&para;</a></h2>
<p>func : callable
The objective function to be minimized.  Must be in the form
<code>f(x, *args)</code>, where <code>x</code> is the argument in the form of a 1-D array
and <code>args</code> is a tuple of any additional fixed parameters needed to
completely specify the function.
bounds : sequence
Bounds for variables.  <code>(min, max)</code> pairs for each element in <code>x</code>,
defining the lower and upper bounds for the optimizing argument of
<code>func</code>. It is required to have <code>len(bounds) == len(x)</code>.
<code>len(bounds)</code> is used to determine the number of parameters in <code>x</code>.
Use <code>None</code> for one of min or max when there is no bound in that
direction. By default bounds are <code>(None, None)</code>.
args : tuple, optional
Any additional fixed parameters needed to completely specify the
objective function.
constraints : dict or sequence of dict, optional
Constraints definition.
Function(s) <code>R**n</code> in the form::</p>
<p>g(x) &lt;= 0 applied as g : R^n -&gt; R^m
h(x) == 0 applied as h : R^n -&gt; R^p</p>
<p>Each constraint is defined in a dictionary with fields:</p>
<p>type : str
Constraint type: 'eq' for equality, 'ineq' for inequality.
fun : callable
The function defining the constraint.
jac : callable, optional
The Jacobian of <code>fun</code> (only for SLSQP).
args : sequence, optional
Extra arguments to be passed to the function and Jacobian.</p>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
<p>.. note::</p>
<p>Only the COBYLA and SLSQP local minimize methods currently
support constraint arguments. If the <code>constraints</code> sequence
used in the local optimization problem is not defined in
<code>minimizer_kwargs</code> and a constrained method is used then the
global <code>constraints</code> will be used.
(Defining a <code>constraints</code> sequence in <code>minimizer_kwargs</code>
means that <code>constraints</code> will not be added so if equality
constraints and so forth need to be added then the inequality
functions in <code>constraints</code> need to be added to
<code>minimizer_kwargs</code> too).</p>
<p>n : int, optional
Number of sampling points used in the construction of the simplicial
complex. Note that this argument is only used for <code>sobol</code> and other
arbitrary <code>sampling_methods</code>.
iters : int, optional
Number of iterations used in the construction of the simplicial complex.
callback : callable, optional
Called after each iteration, as <code>callback(xk)</code>, where <code>xk</code> is the
current parameter vector.
minimizer_kwargs : dict, optional
Extra keyword arguments to be passed to the minimizer
<code>scipy.optimize.minimize</code> Some important options could be:</p>
<ul>
<li>method : str
The minimization method (e.g. <code>SLSQP</code>).</li>
<li>args : tuple
Extra arguments passed to the objective function (<code>func</code>) and
its derivatives (Jacobian, Hessian).</li>
<li>options : dict, optional
Note that by default the tolerance is specified as
<code>{ftol: 1e-12}</code></li>
</ul>
<p>options : dict, optional
A dictionary of solver options. Many of the options specified for the
global routine are also passed to the scipy.optimize.minimize routine.
The options that are also passed to the local routine are marked with
'(L)'.</p>
<p>Stopping criteria, the algorithm will terminate if any of the specified
criteria are met. However, the default algorithm does not require any to
be specified:</p>
<ul>
<li>maxfev : int (L)
Maximum number of function evaluations in the feasible domain.
(Note only methods that support this option will terminate
the routine at precisely exact specified value. Otherwise the
criterion will only terminate during a global iteration)</li>
<li>f_min
Specify the minimum objective function value, if it is known.</li>
<li>f_tol : float
Precision goal for the value of f in the stopping
criterion. Note that the global routine will also
terminate if a sampling point in the global routine is
within this tolerance.</li>
<li>maxiter : int
Maximum number of iterations to perform.</li>
<li>maxev : int
Maximum number of sampling evaluations to perform (includes
searching in infeasible points).</li>
<li>maxtime : float
Maximum processing runtime allowed</li>
<li>minhgrd : int
Minimum homology group rank differential. The homology group of the
objective function is calculated (approximately) during every
iteration. The rank of this group has a one-to-one correspondence
with the number of locally convex subdomains in the objective
function (after adequate sampling points each of these subdomains
contain a unique global minimum). If the difference in the hgr is 0
between iterations for <code>maxhgrd</code> specified iterations the
algorithm will terminate.</li>
</ul>
<p>Objective function knowledge:</p>
<ul>
<li>
<p>symmetry : bool
Specify True if the objective function contains symmetric variables.
The search space (and therefore performance) is decreased by O(n!).</p>
</li>
<li>
<p>jac : bool or callable, optional
Jacobian (gradient) of objective function. Only for CG, BFGS,
Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If <code>jac</code> is a
boolean and is True, <code>fun</code> is assumed to return the gradient along
with the objective function. If False, the gradient will be
estimated numerically. <code>jac</code> can also be a callable returning the
gradient of the objective. In this case, it must accept the same
arguments as <code>fun</code>. (Passed to <code>scipy.optimize.minmize</code> automatically)</p>
</li>
<li>
<p>hess, hessp : callable, optional
Hessian (matrix of second-order derivatives) of objective function
or Hessian of objective function times an arbitrary vector p.
Only for Newton-CG, dogleg, trust-ncg. Only one of <code>hessp</code> or
<code>hess</code> needs to be given. If <code>hess</code> is provided, then
<code>hessp</code> will be ignored. If neither <code>hess</code> nor <code>hessp</code> is
provided, then the Hessian product will be approximated using
finite differences on <code>jac</code>. <code>hessp</code> must compute the Hessian
times an arbitrary vector. (Passed to <code>scipy.optimize.minmize</code>
automatically)</p>
</li>
</ul>
<p>Algorithm settings:</p>
<ul>
<li>minimize_every_iter : bool
If True then promising global sampling points will be passed to a
local minimisation routine every iteration. If False then only the
final minimiser pool will be run. Defaults to False.</li>
<li>local_iter : int
Only evaluate a few of the best minimiser pool candidates every
iteration. If False all potential points are passed to the local
minimisation routine.</li>
<li>infty_constraints: bool
If True then any sampling points generated which are outside will
the feasible domain will be saved and given an objective function
value of <code>inf</code>. If False then these points will be discarded.
Using this functionality could lead to higher performance with
respect to function evaluations before the global minimum is found,
specifying False will use less memory at the cost of a slight
decrease in performance. Defaults to True.</li>
</ul>
<p>Feedback:</p>
<ul>
<li>disp : bool (L)
Set to True to print convergence messages.</li>
</ul>
<p>sampling_method : str or function, optional
Current built in sampling method options are <code>sobol</code> and
<code>simplicial</code>. The default <code>simplicial</code> uses less memory and provides
the theoretical guarantee of convergence to the global minimum in finite
time. The <code>sobol</code> method is faster in terms of sampling point
generation at the cost of higher memory resources and the loss of
guaranteed convergence. It is more appropriate for most 'easier'
problems where the convergence is relatively fast.
User defined sampling functions must accept two arguments of <code>n</code>
sampling points of dimension <code>dim</code> per call and output an array of
sampling points with shape <code>n x dim</code>.</p>
<h2 id="returns_174">Returns<a class="headerlink" href="#returns_174" title="Permanent link">&para;</a></h2>
<p>res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are:
<code>x</code> the solution array corresponding to the global minimum,
<code>fun</code> the function output at the global solution,
<code>xl</code> an ordered list of local minima solutions,
<code>funl</code> the function output at the corresponding local solutions,
<code>success</code> a Boolean flag indicating if the optimizer exited
successfully,
<code>message</code> which describes the cause of the termination,
<code>nfev</code> the total number of objective function evaluations including
the sampling calls,
<code>nlfev</code> the total number of objective function evaluations
culminating from all local search optimisations,
<code>nit</code> number of iterations performed by the global routine.</p>
<h2 id="notes_112">Notes<a class="headerlink" href="#notes_112" title="Permanent link">&para;</a></h2>
<p>Global optimization using simplicial homology global optimisation [1]_.
Appropriate for solving general purpose NLP and blackbox optimisation
problems to global optimality (low dimensional problems).</p>
<p>In general, the optimization problems are of the form::</p>
<p>minimize f(x) subject to</p>
<p>g_i(x) &gt;= 0,  i = 1,...,m
h_j(x)  = 0,  j = 1,...,p</p>
<p>where x is a vector of one or more variables. <code>f(x)</code> is the objective
function <code>R^n -&gt; R</code>, <code>g_i(x)</code> are the inequality constraints, and
<code>h_j(x)</code> are the equality constraints.</p>
<p>Optionally, the lower and upper bounds for each element in x can also be
specified using the <code>bounds</code> argument.</p>
<p>While most of the theoretical advantages of SHGO are only proven for when
<code>f(x)</code> is a Lipschitz smooth function. The algorithm is also proven to
converge to the global optimum for the more general case where <code>f(x)</code> is
non-continuous, non-convex and non-smooth, if the default sampling method
is used [1]_.</p>
<p>The local search method may be specified using the <code>minimizer_kwargs</code>
parameter which is passed on to <code>scipy.optimize.minimize</code>. By default
the <code>SLSQP</code> method is used. In general it is recommended to use the
<code>SLSQP</code> or <code>COBYLA</code> local minimization if inequality constraints
are defined for the problem since the other methods do not use constraints.</p>
<p>The <code>sobol</code> method points are generated using the Sobol (1967) [2]<em>
sequence. The primitive polynomials and various sets of initial direction
numbers for generating Sobol sequences is provided by [3]</em> by Frances Kuo
and Stephen Joe. The original program sobol.cc (MIT) is available and
described at https://web.maths.unsw.edu.au/~fkuo/sobol/ translated to
Python 3 by Carl Sandrock 2016-03-31.</p>
<h2 id="references_53">References<a class="headerlink" href="#references_53" title="Permanent link">&para;</a></h2>
<p>.. [1] Endres, SC, Sandrock, C, Focke, WW (2018) 'A simplicial homology
algorithm for lipschitz optimisation', Journal of Global Optimization.
.. [2] Sobol, IM (1967) 'The distribution of points in a cube and the
approximate evaluation of integrals', USSR Comput. Math. Math. Phys.
7, 86-112.
.. [3] Joe, SW and Kuo, FY (2008) 'Constructing Sobol sequences with
better  two-dimensional projections', SIAM J. Sci. Comput. 30,
2635-2654.
.. [4] Hoch, W and Schittkowski, K (1981) 'Test examples for nonlinear
programming codes', Lecture Notes in Economics and mathematical
Systems, 187. Springer-Verlag, New York.
http://www.ai7.uni-bayreuth.de/test_problem_coll.pdf
.. [5] Wales, DJ (2015) 'Perspective: Insight into reaction coordinates and
dynamics from the potential energy landscape',
Journal of Chemical Physics, 142(13), 2015.</p>
<h2 id="examples_115">Examples<a class="headerlink" href="#examples_115" title="Permanent link">&para;</a></h2>
<p>First consider the problem of minimizing the Rosenbrock function, <code>rosen</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import rosen, shgo
bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
result = shgo(rosen, bounds)
result.x, result.fun
(array([ 1.,  1.,  1.,  1.,  1.]), 2.9203923741900809e-18)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that bounds determine the dimensionality of the objective
function and is therefore a required input, however you can specify
empty bounds using <code>None</code> or objects like <code>np.inf</code> which will be
converted to large float numbers.</p>
<blockquote>
<blockquote>
<blockquote>
<p>bounds = [(None, None), ]*4
result = shgo(rosen, bounds)
result.x
array([ 0.99999851,  0.99999704,  0.99999411,  0.9999882 ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Next we consider the Eggholder function, a problem with several local
minima and one global minimum. We will demonstrate the use of arguments and
the capabilities of <code>shgo</code>.
(https://en.wikipedia.org/wiki/Test_functions_for_optimization)</p>
<blockquote>
<blockquote>
<blockquote>
<p>def eggholder(x):
...     return (-(x[1] + 47.0)
...             * np.sin(np.sqrt(abs(x[0]/2.0 + (x[1] + 47.0))))
...             - x[0] * np.sin(np.sqrt(abs(x[0] - (x[1] + 47.0))))
...             )
...
bounds = [(-512, 512), (-512, 512)]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>shgo</code> has two built-in low discrepancy sampling sequences.  First we will
input 30 initial sampling points of the Sobol sequence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>result = shgo(eggholder, bounds, n=30, sampling_method='sobol')
result.x, result.fun
(array([ 512.        ,  404.23180542]), -959.64066272085051)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>shgo</code> also has a return for any other local minima that was found, these
can be called using:</p>
<blockquote>
<blockquote>
<blockquote>
<p>result.xl
array([[ 512.        ,  404.23180542],
[ 283.07593402, -487.12566542],
[-294.66820039, -462.01964031],
[-105.87688985,  423.15324143],
[-242.97923629,  274.38032063],
[-506.25823477,    6.3131022 ],
[-408.71981195, -156.10117154],
[ 150.23210485,  301.31378508],
[  91.00922754, -391.28375925],
[ 202.8966344 , -269.38042147],
[ 361.66625957, -106.96490692],
[-219.40615102, -244.06022436],
[ 151.59603137, -100.61082677]])</p>
<p>result.funl
array([-959.64066272, -718.16745962, -704.80659592, -565.99778097,
-559.78685655, -557.36868733, -507.87385942, -493.9605115 ,
-426.48799655, -421.15571437, -419.31194957, -410.98477763,
-202.53912972])</p>
</blockquote>
</blockquote>
</blockquote>
<p>These results are useful in applications where there are many global minima
and the values of other global minima are desired or where the local minima
can provide insight into the system (for example morphologies
in physical chemistry [5]_).</p>
<p>If we want to find a larger number of local minima, we can increase the
number of sampling points or the number of iterations. We'll increase the
number of sampling points to 60 and the number of iterations from the
default of 1 to 5. This gives us 60 x 5 = 300 initial sampling points.</p>
<blockquote>
<blockquote>
<blockquote>
<p>result_2 = shgo(eggholder, bounds, n=60, iters=5, sampling_method='sobol')
len(result.xl), len(result_2.xl)
(13, 39)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note the difference between, e.g., <code>n=180, iters=1</code> and <code>n=60, iters=3</code>.
In the first case the promising points contained in the minimiser pool
is processed only once. In the latter case it is processed every 60 sampling
points for a total of 3 times.</p>
<p>To demonstrate solving problems with non-linear constraints consider the
following example from Hock and Schittkowski problem 73 (cattle-feed) [4]_::</p>
<p>minimize: f = 24.55 * x_1 + 26.75 * x_2 + 39 * x_3 + 40.50 * x_4</p>
<p>subject to: 2.3 * x_1 + 5.6 * x_2 + 11.1 * x_3 + 1.3 * x_4 - 5     &gt;= 0,</p>
<p>12 * x_1 + 11.9 * x_2 + 41.8 * x_3 + 52.1 * x_4 - 21
-1.645 * sqrt(0.28 * x_1<strong>2 + 0.19 * x_2</strong>2 +
20.5 * x_3<strong>2 + 0.62 * x_4</strong>2)       &gt;= 0,</p>
<p>x_1 + x_2 + x_3 + x_4 - 1                              == 0,</p>
<p>1 &gt;= x_i &gt;= 0 for all i</p>
<p>The approximate answer given in [4]_ is::</p>
<p>f([0.6355216, -0.12e-11, 0.3127019, 0.05177655]) = 29.894378</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):  # (cattle-feed)
...     return 24.55<em>x[0] + 26.75</em>x[1] + 39<em>x[2] + 40.50</em>x[3]
...
def g1(x):
...     return 2.3<em>x[0] + 5.6</em>x[1] + 11.1<em>x[2] + 1.3</em>x[3] - 5  # &gt;=0
...
def g2(x):
...     return (12<em>x[0] + 11.9</em>x[1] +41.8<em>x[2] + 52.1</em>x[3] - 21
...             - 1.645 * np.sqrt(0.28<em>x[0]</em><em>2 + 0.19</em>x[1]<strong>2
...                             + 20.5*x[2]</strong>2 + 0.62<em>x[3]</em><em>2)
...             ) # &gt;=0
...
def h1(x):
...     return x[0] + x[1] + x[2] + x[3] - 1  # == 0
...
cons = ({'type': 'ineq', 'fun': g1},
...         {'type': 'ineq', 'fun': g2},
...         {'type': 'eq', 'fun': h1})
bounds = [(0, 1.0),]</em>4
res = shgo(f, bounds, iters=3, constraints=cons)
res
fun: 29.894378159142136
funl: array([29.89437816])
message: 'Optimization terminated successfully.'
nfev: 119
nit: 3
nlfev: 40
nlhev: 0
nljev: 5
success: True
x: array([6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02])
xl: array([[6.35521569e-01, 1.13700270e-13, 3.12701881e-01, 5.17765506e-02]])</p>
<p>g1(res.x), g2(res.x), h1(res.x)
(-5.0626169922907138e-14, -2.9594104944408173e-12, 0.0)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show_options</span> <span class="o">:</span> <span class="o">?</span><span class="n">solver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Show documentation for additional options of optimization solvers.</p>
<p>These are method-specific options that can be supplied through the
<code>options</code> dict.</p>
<h2 id="parameters_196">Parameters<a class="headerlink" href="#parameters_196" title="Permanent link">&para;</a></h2>
<p>solver : str
Type of optimization solver. One of 'minimize', 'minimize_scalar',
'root', or 'linprog'.
method : str, optional
If not given, shows all methods of the specified solver. Otherwise,
show only the options for the specified method. Valid values
corresponds to methods' names of respective solver (e.g. 'BFGS' for
'minimize').
disp : bool, optional
Whether to print the result rather than returning it.</p>
<h2 id="returns_175">Returns<a class="headerlink" href="#returns_175" title="Permanent link">&para;</a></h2>
<p>text
Either None (for disp=True) or the text string (disp=False)</p>
<h2 id="notes_113">Notes<a class="headerlink" href="#notes_113" title="Permanent link">&para;</a></h2>
<p>The solver-specific methods are:</p>
<p><code>scipy.optimize.minimize</code></p>
<ul>
<li>:ref:<code>Nelder-Mead &lt;optimize.minimize-neldermead&gt;</code></li>
<li>:ref:<code>Powell      &lt;optimize.minimize-powell&gt;</code></li>
<li>:ref:<code>CG          &lt;optimize.minimize-cg&gt;</code></li>
<li>:ref:<code>BFGS        &lt;optimize.minimize-bfgs&gt;</code></li>
<li>:ref:<code>Newton-CG   &lt;optimize.minimize-newtoncg&gt;</code></li>
<li>:ref:<code>L-BFGS-B    &lt;optimize.minimize-lbfgsb&gt;</code></li>
<li>:ref:<code>TNC         &lt;optimize.minimize-tnc&gt;</code></li>
<li>:ref:<code>COBYLA      &lt;optimize.minimize-cobyla&gt;</code></li>
<li>:ref:<code>SLSQP       &lt;optimize.minimize-slsqp&gt;</code></li>
<li>:ref:<code>dogleg      &lt;optimize.minimize-dogleg&gt;</code></li>
<li>:ref:<code>trust-ncg   &lt;optimize.minimize-trustncg&gt;</code></li>
</ul>
<p><code>scipy.optimize.root</code></p>
<ul>
<li>:ref:<code>hybr              &lt;optimize.root-hybr&gt;</code></li>
<li>:ref:<code>lm                &lt;optimize.root-lm&gt;</code></li>
<li>:ref:<code>broyden1          &lt;optimize.root-broyden1&gt;</code></li>
<li>:ref:<code>broyden2          &lt;optimize.root-broyden2&gt;</code></li>
<li>:ref:<code>anderson          &lt;optimize.root-anderson&gt;</code></li>
<li>:ref:<code>linearmixing      &lt;optimize.root-linearmixing&gt;</code></li>
<li>:ref:<code>diagbroyden       &lt;optimize.root-diagbroyden&gt;</code></li>
<li>:ref:<code>excitingmixing    &lt;optimize.root-excitingmixing&gt;</code></li>
<li>:ref:<code>krylov            &lt;optimize.root-krylov&gt;</code></li>
<li>:ref:<code>df-sane           &lt;optimize.root-dfsane&gt;</code></li>
</ul>
<p><code>scipy.optimize.minimize_scalar</code></p>
<ul>
<li>:ref:<code>brent       &lt;optimize.minimize_scalar-brent&gt;</code></li>
<li>:ref:<code>golden      &lt;optimize.minimize_scalar-golden&gt;</code></li>
<li>:ref:<code>bounded     &lt;optimize.minimize_scalar-bounded&gt;</code></li>
</ul>
<p><code>scipy.optimize.linprog</code></p>
<ul>
<li>:ref:<code>simplex         &lt;optimize.linprog-simplex&gt;</code></li>
<li>:ref:<code>interior-point  &lt;optimize.linprog-interior-point&gt;</code></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toms748</span> <span class="o">:</span> <span class="o">?</span><span class="n">args</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">xtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">full_output</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find a zero using TOMS Algorithm 748 method.</p>
<p>Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a
zero of the function <code>f</code> on the interval <code>[a , b]</code>, where <code>f(a)</code> and
<code>f(b)</code> must have opposite signs.</p>
<p>It uses a mixture of inverse cubic interpolation and
'Newton-quadratic' steps. [APS1995].</p>
<h2 id="parameters_197">Parameters<a class="headerlink" href="#parameters_197" title="Permanent link">&para;</a></h2>
<p>f : function
Python function returning a scalar.  The function :math:<code>f</code>
must be continuous, and :math:<code>f(a)</code> and :math:<code>f(b)</code>
have opposite signs.
a : scalar,
lower boundary of the search interval
b : scalar,
upper boundary of the search interval
args : tuple, optional
containing extra arguments for the function <code>f</code>.
<code>f</code> is called by <code>f(x, *args)</code>.
k : int, optional
The number of Newton quadratic steps to perform each
iteration. <code>k&gt;=1</code>.
xtol : scalar, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root. The
parameter must be nonnegative.
rtol : scalar, optional
The computed root <code>x0</code> will satisfy <code>np.allclose(x, x0,
atol=xtol, rtol=rtol)</code>, where <code>x</code> is the exact root.
maxiter : int, optional
if convergence is not achieved in <code>maxiter</code> iterations, an error is
raised.  Must be &gt;= 0.
full_output : bool, optional
If <code>full_output</code> is False, the root is returned.  If <code>full_output</code> is
True, the return value is <code>(x, r)</code>, where <code>x</code> is the root, and <code>r</code> is
a <code>RootResults</code> object.
disp : bool, optional
If True, raise RuntimeError if the algorithm didn't converge.
Otherwise the convergence status is recorded in the <code>RootResults</code>
return object.</p>
<h2 id="returns_176">Returns<a class="headerlink" href="#returns_176" title="Permanent link">&para;</a></h2>
<p>x0 : float
Approximate Zero of <code>f</code>
r : <code>RootResults</code> (present if <code>full_output = True</code>)
Object containing information about the convergence.  In particular,
<code>r.converged</code> is True if the routine converged.</p>
<h2 id="see-also_133">See Also<a class="headerlink" href="#see-also_133" title="Permanent link">&para;</a></h2>
<p>brentq, brenth, ridder, bisect, newton
fsolve : find zeroes in n dimensions.</p>
<h2 id="notes_114">Notes<a class="headerlink" href="#notes_114" title="Permanent link">&para;</a></h2>
<p><code>f</code> must be continuous.
Algorithm 748 with <code>k=2</code> is asymptotically the most efficient
algorithm known for finding roots of a four times continuously
differentiable function.
In contrast with Brent's algorithm, which may only decrease the length of
the enclosing bracket on the last step, Algorithm 748 decreases it each
iteration with the same asymptotic efficiency as it finds the root.</p>
<p>For easy statement of efficiency indices, assume that <code>f</code> has 4
continuouous deriviatives.
For <code>k=1</code>, the convergence order is at least 2.7, and with about
asymptotically 2 function evaluations per iteration, the efficiency
index is approximately 1.65.
For <code>k=2</code>, the order is about 4.6 with asymptotically 3 function
evaluations per iteration, and the efficiency index 1.66.
For higher values of <code>k</code>, the efficiency index approaches
the <code>k</code>-th root of <code>(3k-2)</code>, hence <code>k=1</code> or <code>k=2</code> are
usually appropriate.</p>
<h2 id="references_54">References<a class="headerlink" href="#references_54" title="Permanent link">&para;</a></h2>
<p>.. [APS1995]
Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
<em>Algorithm 748: Enclosing Zeros of Continuous Functions</em>,
ACM Trans. Math. Softw. Volume 221(1995)
doi = {10.1145/210089.210111}</p>
<h2 id="examples_116">Examples<a class="headerlink" href="#examples_116" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):
...     return (x**3 - 1)  # only one real root at x = 1</p>
<p>from scipy import optimize
root, results = optimize.toms748(f, 0, 2, full_output=True)
root
1.0
results
converged: True
flag: 'converged'
function_calls: 11
iterations: 5
root: 1.0</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Odr/" title="Odr" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Odr
              </div>
            </div>
          </a>
        
        
          <a href="../Setup/" title="Setup" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Setup
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>