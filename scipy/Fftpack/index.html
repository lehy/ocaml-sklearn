


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Fftpack - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Fftpack
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Fftpack" class="md-nav__link md-nav__link--active">
      Fftpack
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Fftpack.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Basic</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return discrete Fourier transform of real or complex sequence.</p>
<p>The returned complex array contains <code>y(0), y(1),..., y(n-1)</code> where</p>
<p><code>y(j) = (x * exp(-2*pi*sqrt(-1)*j*np.arange(n)/n)).sum()</code>.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>x : array_like
Array to Fourier transform.
n : int, optional
Length of the Fourier transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the fft's are computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>z : complex ndarray
with the elements::</p>
<p>[y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even
[y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd</p>
<p>where::</p>
<p>y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)<em>j</em>k<em> 2</em>pi/n), j = 0..n-1</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>ifft : Inverse FFT
rfft : FFT of a real sequence</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>The packing of the result is 'standard': If <code>A = fft(a, n)</code>, then
<code>A[0]</code> contains the zero-frequency term, <code>A[1:n/2]</code> contains the
positive-frequency terms, and <code>A[n/2:]</code> contains the negative-frequency
terms, in order of decreasingly negative frequency. So for an 8-point
transform, the frequencies of the result are [0, 1, 2, 3, -4, -3, -2, -1].
To rearrange the fft output so that the zero-frequency component is
centered, like [-4, -3, -2, -1,  0,  1,  2,  3], use <code>fftshift</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>This function is most efficient when <code>n</code> is a power of two, and least
efficient when <code>n</code> is prime.</p>
<p>Note that if <code>x</code> is real-valued then <code>A[j] == A[n-j].conjugate()</code>.
If <code>x</code> is real-valued and <code>n</code> is even then <code>A[n/2]</code> is real.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, ifft
x = np.arange(5)
np.allclose(fft(ifft(x)), x, atol=1e-15)  # within numerical accuracy.
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>2-D discrete Fourier transform.</p>
<p>Return the two-dimensional discrete Fourier transform of the 2-D argument
<code>x</code>.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>fftn : for detailed information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional discrete Fourier transform.</p>
<p>The returned array contains::</p>
<p>y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)<em>2</em>pi/n_i * j_i * k_i)</p>
<p>where d = len(x.shape) and n = x.shape.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>x : array_like
The (n-dimensional) array to transform.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
The axes of <code>x</code> (<code>y</code> if <code>shape</code> is not None) along which the
transform is applied.
The default is over all axes.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed.  Default is False.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>y : complex-valued n-dimensional numpy array
The (n-dimensional) DFT of the input array.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>ifftn</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>If <code>x</code> is real-valued, then
<code>y[..., j_i, ...] == y[..., n_i-j_i, ...].conjugate()</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fftn, ifftn
y = (-np.arange(16), 8 - np.arange(16), np.arange(16))
np.allclose(y, fftn(ifftn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return discrete inverse Fourier transform of real or complex sequence.</p>
<p>The returned complex array contains <code>y(0), y(1),..., y(n-1)</code> where</p>
<p><code>y(j) = (x * exp(2*pi*sqrt(-1)*j*np.arange(n)/n)).mean()</code>.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>x : array_like
Transformed data to invert.
n : int, optional
Length of the inverse Fourier transform.  If <code>n &lt; x.shape[axis]</code>,
<code>x</code> is truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded.
The default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the ifft's are computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>ifft : ndarray of floats
The inverse discrete Fourier transform.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>fft : Forward FFT</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>This function is most efficient when <code>n</code> is a power of two, and least
efficient when <code>n</code> is prime.</p>
<p>If the data type of <code>x</code> is real, a 'real IFFT' algorithm is automatically
used, which roughly halves the computation time.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, ifft
import numpy as np
x = np.arange(5)
np.allclose(ifft(fft(x)), x, atol=1e-15)  # within numerical accuracy.
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>2-D discrete inverse Fourier transform of real or complex sequence.</p>
<p>Return inverse two-dimensional discrete Fourier transform of
arbitrary type sequence x.</p>
<p>See <code>ifft</code> for more information.</p>
<h2 id="see-also_4">See also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>fft2, ifft</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse multi-dimensional discrete Fourier transform.</p>
<p>The sequence can be of an arbitrary type.</p>
<p>The returned array contains::</p>
<p>y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)<em>2</em>pi/n_i * j_i * k_i)</p>
<p>where <code>d = len(x.shape)</code>, <code>n = x.shape</code>, and <code>p = prod[i=1..d] n_i</code>.</p>
<p>For description of parameters see <code>fftn</code>.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>fftn : for detailed information.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fftn, ifftn
import numpy as np
y = (-np.arange(16), 8 - np.arange(16), np.arange(16))
np.allclose(y, ifftn(fftn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse discrete Fourier transform of real sequence x.</p>
<p>The contents of <code>x</code> are interpreted as the output of the <code>rfft</code>
function.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>x : array_like
Transformed data to invert.
n : int, optional
Length of the inverse Fourier transform.
If n &lt; x.shape[axis], x is truncated.
If n &gt; x.shape[axis], x is zero-padded.
The default results in n = x.shape[axis].
axis : int, optional
Axis along which the ifft's are computed; the default is over
the last axis (i.e., axis=-1).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>irfft : ndarray of floats
The inverse discrete Fourier transform.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>rfft, ifft, scipy.fft.irfft</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>The returned real array contains::</p>
<p>[y(0),y(1),...,y(n-1)]</p>
<p>where for n is even::</p>
<p>y(j) = 1/n (sum[k=1..n/2-1] (x[2<em>k-1]+sqrt(-1)</em>x[2<em>k])
* exp(sqrt(-1)</em>j<em>k</em> 2<em>pi/n)
+ c.c. + x[0] + (-1)</em>*(j) x[n-1])</p>
<p>and for n is odd::</p>
<p>y(j) = 1/n (sum[k=1..(n-1)/2] (x[2<em>k-1]+sqrt(-1)</em>x[2<em>k])
* exp(sqrt(-1)</em>j<em>k</em> 2*pi/n)
+ c.c. + x[0])</p>
<p>c.c. denotes complex conjugate of preceding expression.</p>
<p>For details on input parameters, see <code>rfft</code>.</p>
<p>To process (conjugate-symmetric) frequency-domain data with a complex
datatype, consider using the newer function <code>scipy.fft.irfft</code>.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import rfft, irfft
a = [1.0, 2.0, 3.0, 4.0, 5.0]
irfft(a)
array([ 2.6       , -3.16405192,  1.24398433, -1.14955713,  1.46962473])
irfft(rfft(a))
array([1., 2., 3., 4., 5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Real_valued</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Discrete Fourier transform of a real sequence.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>x : array_like, real-valued
The data to transform.
n : int, optional
Defines the length of the Fourier transform.  If <code>n</code> is not specified
(the default) then <code>n = x.shape[axis]</code>.  If <code>n &lt; x.shape[axis]</code>,
<code>x</code> is truncated, if <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded.
axis : int, optional
The axis along which the transform is applied.  The default is the
last axis.
overwrite_x : bool, optional
If set to true, the contents of <code>x</code> can be overwritten. Default is
False.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>z : real ndarray
The returned real array contains::</p>
<p>[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even
[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd</p>
<p>where::</p>
<p>y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)<em>j</em>k<em>2</em>pi/n)
j = 0..n-1</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>fft, irfft, scipy.fft.rfft</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>Within numerical accuracy, <code>y == rfft(irfft(y))</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>To get an output with a complex datatype, consider using the newer
function <code>scipy.fft.rfft</code>.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, rfft
a = [9, -9, 1, 3]
fft(a)
array([  4. +0.j,   8.+12.j,  16. +0.j,   8.-12.j])
rfft(a)
array([  4.,   8.,  12.,  16.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Convolve</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">convolve_z</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">omega_real</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">omega_imag</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>y = convolve_z(x,omega_real,omega_imag,[overwrite_x])</p>
<p>Wrapper for <code>convolve_z</code>.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>x : input rank-1 array('d') with bounds (n)
omega_real : input rank-1 array('d') with bounds (n)
omega_imag : input rank-1 array('d') with bounds (n)</p>
<h2 id="other-parameters">Other Parameters<a class="headerlink" href="#other-parameters" title="Permanent link">&para;</a></h2>
<p>overwrite_x : input int, optional
Default: 0</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>y : rank-1 array('d') with bounds (n) and x storage</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Helper</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">next_fast_len</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Find the next fast size of input data to <code>fft</code>, for zero-padding, etc.</p>
<p>SciPy's FFTPACK has efficient functions for radix {2, 3, 4, 5}, so this
returns the next composite of the prime factors 2, 3, and 5 which is
greater than or equal to <code>target</code>. (These are also known as 5-smooth
numbers, regular numbers, or Hamming numbers.)</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>target : int
Length to start searching from.  Must be a positive integer.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>out : int
The first 5-smooth number greater than or equal to <code>target</code>.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<p>On a particular machine, an FFT of prime length takes 133 ms:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fftpack
min_len = 10007  # prime length is worst case for speed
a = np.random.randn(min_len)
b = fftpack.fft(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Zero-padding to the next 5-smooth length reduces computation time to
211 us, a speedup of 630 times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fftpack.helper.next_fast_len(min_len)
10125
b = fftpack.fft(a, 10125)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rounding up to the next power of 2 is not optimal, taking 367 us to
compute, 1.7 times as long as the 5-smooth size:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = fftpack.fft(a, 16384)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>DFT sample frequencies (for usage with rfft, irfft).</p>
<p>The returned float array contains the frequency bins in
cycles/unit (with zero at the start) given a window length <code>n</code> and a
sample spacing <code>d</code>::</p>
<p>f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2]/(d<em>n)   if n is even
f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2,n/2]/(d</em>n)   if n is odd</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing. Default is 1.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The array of length <code>n</code>, containing the sample frequencies.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fftpack
sig = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
sig_fft = fftpack.rfft(sig)
n = sig_fft.size
timestep = 0.1
freq = fftpack.rfftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  1.25,  2.5 ,  2.5 ,  3.75,  3.75,  5.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Pseudo_diffs</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cc_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = cosh(j<em>a</em>2<em>pi/period)/cosh(j</em>b<em>2</em>pi/period) * x_j</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a,b : float
Defines the parameters of the sinh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is <code>2*pi</code>.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>cc_diff : ndarray
Pseudo-derivative of periodic sequence <code>x</code>.</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p><code>cc_diff(cc_diff(x,a,b),b,a) == x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Cosine element-wise.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding cosine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</p>
<h1 id="example-of-providing-the-optional-output-parameter">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic cosine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) + np.exp(-x))</code> and <code>np.cos(1j*x)</code>.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array of same shape as <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cosh(0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>The hyperbolic cosine describes the shape of a hanging cable:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-4, 4, 1000)
plt.plot(x, np.cosh(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cs_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)<em>cosh(j</em>a<em>2</em>pi/period)/sinh(j<em>b</em>2*pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a, b : float
Defines the parameters of the cosh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence. Default period is <code>2*pi</code>.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>cs_diff : ndarray
Pseudo-derivative of periodic sequence <code>x</code>.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>For even len(<code>x</code>), the Nyquist mode of <code>x</code> is taken as zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return k-th derivative (or integral) of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = pow(sqrt(-1)<em>j</em>2*pi/period, order) * x_j
y_0 = 0 if order is not 0.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
order : int, optional
The order of differentiation. Default order is 1. If order is
negative, then integration is carried out under the assumption
that <code>x_0 == 0</code>.
period : float, optional
The assumed period of the sequence. Default is <code>2*pi</code>.</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) = 0</code> then <code>diff(diff(x, k), -k) == x</code> (within
numerical accuracy).</p>
<p>For odd order and even <code>len(x)</code>, the Nyquist mode is taken zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return Hilbert transform of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)*sign(j) * x_j
y_0 = 0</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array, should be periodic.
_cache : dict, optional
Dictionary that contains the kernel used to do a convolution with.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The transformed input.</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>scipy.signal.hilbert : Compute the analytic signal, using the Hilbert
transform.</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) == 0</code> then <code>hilbert(ihilbert(x)) == x</code>.</p>
<p>For even len(x), the Nyquist mode of x is taken zero.</p>
<p>The sign of the returned transform does not have a factor -1 that is more
often than not found in the definition of the Hilbert transform.  Note also
that <code>scipy.signal.hilbert</code> does have an extra -1 factor compared to this
function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihilbert</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse Hilbert transform of a periodic sequence x.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)*sign(j) * x_j
y_0 = 0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iscomplexobj</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, <code>iscomplexobj</code> evaluates to True.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>x : any
The input can be of any type and shape.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>iscomplexobj : bool
The return value, True if <code>x</code> is of a complex type or has at least
one complex element.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>isrealobj, iscomplex</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.iscomplexobj(1)
False
np.iscomplexobj(1+0j)
True
np.iscomplexobj([3, 1+0j, True])
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse h-Tilbert transform of a periodic sequence x.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)<em>tanh(j</em>h<em>2</em>pi/period) * x_j
y_0 = 0</p>
<p>For more details, see <code>tilbert</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sc_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)<em>sinh(j</em>a<em>2</em>pi/period)/cosh(j<em>b</em>2*pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
a,b : float
Defines the parameters of the sinh/cosh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is 2*pi.</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p><code>sc_diff(cs_diff(x,a,b),b,a) == x</code>
For even <code>len(x)</code>, the Nyquist mode of x is taken as zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift periodic sequence x by a: y(u) = x(u+a).</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = exp(j<em>a</em>2<em>pi/period</em>sqrt(-1)) * x_f</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a : float
Defines the parameters of the sinh/sinh pseudo-differential
period : float, optional
The period of the sequences x and y. Default period is <code>2*pi</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>x : array_like
Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>y : array_like
The sine of each element of x.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>arcsin, sinh, cos</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:<code>+x</code> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:<code>y</code> coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code>  The
function has zeroes where the angle is a multiple of :math:<code>\pi</code>.
Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<p>Print sine of one angle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.pi/2.)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic sine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) - np.exp(-x))</code> or
<code>-1j * np.sin(1j*x)</code>.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding hyperbolic sine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sinh(0)
0.0
np.sinh(np.pi<em>1j/2)
1j
np.sinh(np.pi</em>1j) # (exact value is 0)
1.2246063538223773e-016j</p>
<h1 id="discrepancy-due-to-vagaries-of-floating-point-arithmetic">Discrepancy due to vagaries of floating point arithmetic.<a class="headerlink" href="#discrepancy-due-to-vagaries-of-floating-point-arithmetic" title="Permanent link">&para;</a></h1>
<h1 id="example-of-providing-the-optional-output-parameter_1">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter_1" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.sinh([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_1">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_1" title="Permanent link">&para;</a></h1>
<p>np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sinh(j<em>a</em>2<em>pi/period)/sinh(j</em>b<em>2</em>pi/period) * x_j
y_0 = a/b * x_0</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a,b
Defines the parameters of the sinh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is <code>2*pi</code>.</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p><code>ss_diff(ss_diff(x,a,b),b,a) == x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute hyperbolic tangent element-wise.</p>
<p>Equivalent to <code>np.sinh(x)/np.cosh(x)</code> or <code>-1j * np.tan(1j*x)</code>.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding hyperbolic tangent values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.
http://www.math.sfu.ca/~cbm/aands/</p>
<p>.. [2] Wikipedia, 'Hyperbolic function',
https://en.wikipedia.org/wiki/Hyperbolic_function</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.tanh((0, np.pi<em>1j, np.pi</em>1j/2))
array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])</p>
<h1 id="example-of-providing-the-optional-output-parameter-illustrating">Example of providing the optional output parameter illustrating<a class="headerlink" href="#example-of-providing-the-optional-output-parameter-illustrating" title="Permanent link">&para;</a></h1>
<h1 id="that-what-is-returned-is-a-reference-to-said-parameter">that what is returned is a reference to said parameter<a class="headerlink" href="#that-what-is-returned-is-a-reference-to-said-parameter" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.tanh([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_2">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_2" title="Permanent link">&para;</a></h1>
<p>np.tanh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return h-Tilbert transform of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)<em>coth(j</em>h<em>2</em>pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array to transform.
h : float
Defines the parameter of the Tilbert transform.
period : float, optional
The assumed period of the sequence.  Default period is <code>2*pi</code>.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>tilbert : ndarray
The result of the transform.</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) == 0</code> and <code>n = len(x)</code> is odd then
<code>tilbert(itilbert(x)) == x</code>.</p>
<p>If <code>2 * pi * h / period</code> is approximately 10 or larger, then
numerically <code>tilbert == hilbert</code>
(theoretically oo-Tilbert == Hilbert).</p>
<p>For even <code>len(x)</code>, the Nyquist mode of <code>x</code> is taken zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Realtransforms</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. versionadded:: 1.2.0
Orthonormalization in DCT-I.</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<p>.. versionadded:: 1.2.0
Support for DCT-IV.</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the DCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p>.. versionadded:: 0.11.0</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<p>.. versionadded:: 1.2.0
Support for DST-IV.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the DCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.</p>
<p>IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type
3, and IDCT of type 3 is the DCT of type 2. IDCT of type 4 is the DCT
of type 4. For the definition of these types, see <code>dct</code>.</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1) / 6
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the IDCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_20">See Also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST of type 2, which is the same as DST of type 3.</p>
<p>IDST of type 1 is the DST of type 1, IDST of type 2 is the DST of type
3, and IDST of type 3 is the DST of type 2. For the definition of these
types, see <code>dst</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the IDST is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cc_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = cosh(j<em>a</em>2<em>pi/period)/cosh(j</em>b<em>2</em>pi/period) * x_j</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a,b : float
Defines the parameters of the sinh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is <code>2*pi</code>.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>cc_diff : ndarray
Pseudo-derivative of periodic sequence <code>x</code>.</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p><code>cc_diff(cc_diff(x,a,b),b,a) == x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cs_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)<em>cosh(j</em>a<em>2</em>pi/period)/sinh(j<em>b</em>2*pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a, b : float
Defines the parameters of the cosh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence. Default period is <code>2*pi</code>.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>cs_diff : ndarray
Pseudo-derivative of periodic sequence <code>x</code>.</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>For even len(<code>x</code>), the Nyquist mode of <code>x</code> is taken as zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. versionadded:: 1.2.0
Orthonormalization in DCT-I.</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<p>.. versionadded:: 1.2.0
Support for DCT-IV.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the DCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return k-th derivative (or integral) of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = pow(sqrt(-1)<em>j</em>2*pi/period, order) * x_j
y_0 = 0 if order is not 0.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
order : int, optional
The order of differentiation. Default order is 1. If order is
negative, then integration is carried out under the assumption
that <code>x_0 == 0</code>.
period : float, optional
The assumed period of the sequence. Default is <code>2*pi</code>.</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) = 0</code> then <code>diff(diff(x, k), -k) == x</code> (within
numerical accuracy).</p>
<p>For odd order and even <code>len(x)</code>, the Nyquist mode is taken zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p>.. versionadded:: 0.11.0</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<p>.. versionadded:: 1.2.0
Support for DST-IV.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the DCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return discrete Fourier transform of real or complex sequence.</p>
<p>The returned complex array contains <code>y(0), y(1),..., y(n-1)</code> where</p>
<p><code>y(j) = (x * exp(-2*pi*sqrt(-1)*j*np.arange(n)/n)).sum()</code>.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>x : array_like
Array to Fourier transform.
n : int, optional
Length of the Fourier transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the fft's are computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>z : complex ndarray
with the elements::</p>
<p>[y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even
[y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd</p>
<p>where::</p>
<p>y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)<em>j</em>k<em> 2</em>pi/n), j = 0..n-1</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>ifft : Inverse FFT
rfft : FFT of a real sequence</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>The packing of the result is 'standard': If <code>A = fft(a, n)</code>, then
<code>A[0]</code> contains the zero-frequency term, <code>A[1:n/2]</code> contains the
positive-frequency terms, and <code>A[n/2:]</code> contains the negative-frequency
terms, in order of decreasingly negative frequency. So for an 8-point
transform, the frequencies of the result are [0, 1, 2, 3, -4, -3, -2, -1].
To rearrange the fft output so that the zero-frequency component is
centered, like [-4, -3, -2, -1,  0,  1,  2,  3], use <code>fftshift</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>This function is most efficient when <code>n</code> is a power of two, and least
efficient when <code>n</code> is prime.</p>
<p>Note that if <code>x</code> is real-valued then <code>A[j] == A[n-j].conjugate()</code>.
If <code>x</code> is real-valued and <code>n</code> is even then <code>A[n/2]</code> is real.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, ifft
x = np.arange(5)
np.allclose(fft(ifft(x)), x, atol=1e-15)  # within numerical accuracy.
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>2-D discrete Fourier transform.</p>
<p>Return the two-dimensional discrete Fourier transform of the 2-D argument
<code>x</code>.</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>fftn : for detailed information.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional discrete Fourier transform.</p>
<p>The returned array contains::</p>
<p>y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)<em>2</em>pi/n_i * j_i * k_i)</p>
<p>where d = len(x.shape) and n = x.shape.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>x : array_like
The (n-dimensional) array to transform.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
The axes of <code>x</code> (<code>y</code> if <code>shape</code> is not None) along which the
transform is applied.
The default is over all axes.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed.  Default is False.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>y : complex-valued n-dimensional numpy array
The (n-dimensional) DFT of the input array.</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>ifftn</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>If <code>x</code> is real-valued, then
<code>y[..., j_i, ...] == y[..., n_i-j_i, ...].conjugate()</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fftn, ifftn
y = (-np.arange(16), 8 - np.arange(16), np.arange(16))
np.allclose(y, fftn(ifftn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_29">See Also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return Hilbert transform of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)*sign(j) * x_j
y_0 = 0</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array, should be periodic.
_cache : dict, optional
Dictionary that contains the kernel used to do a convolution with.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The transformed input.</p>
<h2 id="see-also_30">See Also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>scipy.signal.hilbert : Compute the analytic signal, using the Hilbert
transform.</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) == 0</code> then <code>hilbert(ihilbert(x)) == x</code>.</p>
<p>For even len(x), the Nyquist mode of x is taken zero.</p>
<p>The sign of the returned transform does not have a factor -1 that is more
often than not found in the definition of the Hilbert transform.  Note also
that <code>scipy.signal.hilbert</code> does have an extra -1 factor compared to this
function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_31">See Also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.</p>
<p>IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type
3, and IDCT of type 3 is the DCT of type 2. IDCT of type 4 is the DCT
of type 4. For the definition of these types, see <code>dct</code>.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1) / 6
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the IDCT is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_32">See Also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_33">See Also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST of type 2, which is the same as DST of type 3.</p>
<p>IDST of type 1 is the DST of type 1, IDST of type 2 is the DST of type
3, and IDST of type 3 is the DST of type 2. For the definition of these
types, see <code>dst</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
shape : int or array_like of ints or None, optional
The shape of the result.  If both <code>shape</code> and <code>axes</code> (see below) are
None, <code>shape</code> is <code>x.shape</code>; if <code>shape</code> is None but <code>axes</code> is
not None, then <code>shape</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>shape[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>shape[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to
length <code>shape[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding
dimension of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes along which the IDST is computed.
The default is over all axes.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return discrete inverse Fourier transform of real or complex sequence.</p>
<p>The returned complex array contains <code>y(0), y(1),..., y(n-1)</code> where</p>
<p><code>y(j) = (x * exp(2*pi*sqrt(-1)*j*np.arange(n)/n)).mean()</code>.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>x : array_like
Transformed data to invert.
n : int, optional
Length of the inverse Fourier transform.  If <code>n &lt; x.shape[axis]</code>,
<code>x</code> is truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded.
The default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the ifft's are computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>ifft : ndarray of floats
The inverse discrete Fourier transform.</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>fft : Forward FFT</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>This function is most efficient when <code>n</code> is a power of two, and least
efficient when <code>n</code> is prime.</p>
<p>If the data type of <code>x</code> is real, a 'real IFFT' algorithm is automatically
used, which roughly halves the computation time.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, ifft
import numpy as np
x = np.arange(5)
np.allclose(ifft(fft(x)), x, atol=1e-15)  # within numerical accuracy.
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>2-D discrete inverse Fourier transform of real or complex sequence.</p>
<p>Return inverse two-dimensional discrete Fourier transform of
arbitrary type sequence x.</p>
<p>See <code>ifft</code> for more information.</p>
<h2 id="see-also_36">See also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>fft2, ifft</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse multi-dimensional discrete Fourier transform.</p>
<p>The sequence can be of an arbitrary type.</p>
<p>The returned array contains::</p>
<p>y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)<em>2</em>pi/n_i * j_i * k_i)</p>
<p>where <code>d = len(x.shape)</code>, <code>n = x.shape</code>, and <code>p = prod[i=1..d] n_i</code>.</p>
<p>For description of parameters see <code>fftn</code>.</p>
<h2 id="see-also_37">See Also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>fftn : for detailed information.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fftn, ifftn
import numpy as np
y = (-np.arange(16), 8 - np.arange(16), np.arange(16))
np.allclose(y, ifftn(fftn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_38">See Also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihilbert</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse Hilbert transform of a periodic sequence x.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)*sign(j) * x_j
y_0 = 0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse discrete Fourier transform of real sequence x.</p>
<p>The contents of <code>x</code> are interpreted as the output of the <code>rfft</code>
function.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>x : array_like
Transformed data to invert.
n : int, optional
Length of the inverse Fourier transform.
If n &lt; x.shape[axis], x is truncated.
If n &gt; x.shape[axis], x is zero-padded.
The default results in n = x.shape[axis].
axis : int, optional
Axis along which the ifft's are computed; the default is over
the last axis (i.e., axis=-1).
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>irfft : ndarray of floats
The inverse discrete Fourier transform.</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>rfft, ifft, scipy.fft.irfft</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>The returned real array contains::</p>
<p>[y(0),y(1),...,y(n-1)]</p>
<p>where for n is even::</p>
<p>y(j) = 1/n (sum[k=1..n/2-1] (x[2<em>k-1]+sqrt(-1)</em>x[2<em>k])
* exp(sqrt(-1)</em>j<em>k</em> 2<em>pi/n)
+ c.c. + x[0] + (-1)</em>*(j) x[n-1])</p>
<p>and for n is odd::</p>
<p>y(j) = 1/n (sum[k=1..(n-1)/2] (x[2<em>k-1]+sqrt(-1)</em>x[2<em>k])
* exp(sqrt(-1)</em>j<em>k</em> 2*pi/n)
+ c.c. + x[0])</p>
<p>c.c. denotes complex conjugate of preceding expression.</p>
<p>For details on input parameters, see <code>rfft</code>.</p>
<p>To process (conjugate-symmetric) frequency-domain data with a complex
datatype, consider using the newer function <code>scipy.fft.irfft</code>.</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import rfft, irfft
a = [1.0, 2.0, 3.0, 4.0, 5.0]
irfft(a)
array([ 2.6       , -3.16405192,  1.24398433, -1.14955713,  1.46962473])
irfft(rfft(a))
array([1., 2., 3., 4., 5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return inverse h-Tilbert transform of a periodic sequence x.</p>
<p>If <code>x_j</code> and <code>y_j</code> are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = -sqrt(-1)<em>tanh(j</em>h<em>2</em>pi/period) * x_j
y_0 = 0</p>
<p>For more details, see <code>tilbert</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">next_fast_len</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Find the next fast size of input data to <code>fft</code>, for zero-padding, etc.</p>
<p>SciPy's FFTPACK has efficient functions for radix {2, 3, 4, 5}, so this
returns the next composite of the prime factors 2, 3, and 5 which is
greater than or equal to <code>target</code>. (These are also known as 5-smooth
numbers, regular numbers, or Hamming numbers.)</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>target : int
Length to start searching from.  Must be a positive integer.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>out : int
The first 5-smooth number greater than or equal to <code>target</code>.</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<p>On a particular machine, an FFT of prime length takes 133 ms:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fftpack
min_len = 10007  # prime length is worst case for speed
a = np.random.randn(min_len)
b = fftpack.fft(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Zero-padding to the next 5-smooth length reduces computation time to
211 us, a speedup of 630 times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fftpack.helper.next_fast_len(min_len)
10125
b = fftpack.fft(a, 10125)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Rounding up to the next power of 2 is not optimal, taking 367 us to
compute, 1.7 times as long as the 5-smooth size:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = fftpack.fft(a, 16384)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Real_valued</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Discrete Fourier transform of a real sequence.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>x : array_like, real-valued
The data to transform.
n : int, optional
Defines the length of the Fourier transform.  If <code>n</code> is not specified
(the default) then <code>n = x.shape[axis]</code>.  If <code>n &lt; x.shape[axis]</code>,
<code>x</code> is truncated, if <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded.
axis : int, optional
The axis along which the transform is applied.  The default is the
last axis.
overwrite_x : bool, optional
If set to true, the contents of <code>x</code> can be overwritten. Default is
False.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>z : real ndarray
The returned real array contains::</p>
<p>[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even
[y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd</p>
<p>where::</p>
<p>y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)<em>j</em>k<em>2</em>pi/n)
j = 0..n-1</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>fft, irfft, scipy.fft.rfft</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>Within numerical accuracy, <code>y == rfft(irfft(y))</code>.</p>
<p>Both single and double precision routines are implemented.  Half precision
inputs will be converted to single precision.  Non floating-point inputs
will be converted to double precision.  Long-double precision inputs are
not supported.</p>
<p>To get an output with a complex datatype, consider using the newer
function <code>scipy.fft.rfft</code>.</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fftpack import fft, rfft
a = [9, -9, 1, 3]
fft(a)
array([  4. +0.j,   8.+12.j,  16. +0.j,   8.-12.j])
rfft(a)
array([  4.,   8.,  12.,  16.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>DFT sample frequencies (for usage with rfft, irfft).</p>
<p>The returned float array contains the frequency bins in
cycles/unit (with zero at the start) given a window length <code>n</code> and a
sample spacing <code>d</code>::</p>
<p>f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2]/(d<em>n)   if n is even
f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2,n/2]/(d</em>n)   if n is odd</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing. Default is 1.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The array of length <code>n</code>, containing the sample frequencies.</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fftpack
sig = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
sig_fft = fftpack.rfft(sig)
n = sig_fft.size
timestep = 0.1
freq = fftpack.rfftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  1.25,  2.5 ,  2.5 ,  3.75,  3.75,  5.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sc_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)<em>sinh(j</em>a<em>2</em>pi/period)/cosh(j<em>b</em>2*pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
a,b : float
Defines the parameters of the sinh/cosh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is 2*pi.</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p><code>sc_diff(cs_diff(x,a,b),b,a) == x</code>
For even <code>len(x)</code>, the Nyquist mode of x is taken as zero.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift periodic sequence x by a: y(u) = x(u+a).</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = exp(j<em>a</em>2<em>pi/period</em>sqrt(-1)) * x_f</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a : float
Defines the parameters of the sinh/sinh pseudo-differential
period : float, optional
The period of the sequences x and y. Default period is <code>2*pi</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss_diff</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sinh(j<em>a</em>2<em>pi/period)/sinh(j</em>b<em>2</em>pi/period) * x_j
y_0 = a/b * x_0</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>x : array_like
The array to take the pseudo-derivative from.
a,b
Defines the parameters of the sinh/sinh pseudo-differential
operator.
period : float, optional
The period of the sequence x. Default is <code>2*pi</code>.</p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p><code>ss_diff(ss_diff(x,a,b),b,a) == x</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">period</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?_</span><span class="n">cache</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return h-Tilbert transform of a periodic sequence x.</p>
<p>If x_j and y_j are Fourier coefficients of periodic functions x
and y, respectively, then::</p>
<p>y_j = sqrt(-1)<em>coth(j</em>h<em>2</em>pi/period) * x_j
y_0 = 0</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array to transform.
h : float
Defines the parameter of the Tilbert transform.
period : float, optional
The assumed period of the sequence.  Default period is <code>2*pi</code>.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>tilbert : ndarray
The result of the transform.</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>If <code>sum(x, axis=0) == 0</code> and <code>n = len(x)</code> is odd then
<code>tilbert(itilbert(x)) == x</code>.</p>
<p>If <code>2 * pi * h / period</code> is approximately 10 or larger, then
numerically <code>tilbert == hilbert</code>
(theoretically oo-Tilbert == Hilbert).</p>
<p>For even <code>len(x)</code>, the Nyquist mode of <code>x</code> is taken zero.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Fft/" title="Fft" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Fft
              </div>
            </div>
          </a>
        
        
          <a href="../Integrate/" title="Integrate" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Integrate
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>