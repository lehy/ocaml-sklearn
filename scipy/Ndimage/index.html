


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Ndimage - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Ndimage
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Ndimage" class="md-nav__link md-nav__link--active">
      Ndimage
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Ndimage.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Filters</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">convolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional convolution.</p>
<p>The array is convolved with the given kernel.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : array_like
Array of weights, same number of dimensions as input
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>result : ndarray
The result of convolution of <code>input</code> with <code>weights</code>.</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>correlate : Correlate an image with a kernel.</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>Each value in result is :math:<code>C_i = \sum_j{I_{i+k-j} W_j}</code>, where
W is the <code>weights</code> kernel,
j is the n-D spatial index over :math:<code>W</code>,
I is the <code>input</code> and k is the coordinate of the center of
W, specified by <code>origin</code> in the input parameters.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<p>Perhaps the simplest case to understand is <code>mode='constant', cval=0.0</code>,
because in this case borders (i.e. where the <code>weights</code> kernel, centered
on any one value, extends beyond an edge of <code>input</code>) are treated as zeros.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
k = np.array([[1,1,1],[1,1,0],[1,0,0]])
from scipy import ndimage
ndimage.convolve(a, k, mode='constant', cval=0.0)
array([[11, 10,  7,  4],
[10,  3, 11, 11],
[15, 12, 14,  7],
[12,  3,  7,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Setting <code>cval=1.0</code> is equivalent to padding the outer edge of <code>input</code>
with 1.0's (and then extracting only the original region of the result).</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.convolve(a, k, mode='constant', cval=1.0)
array([[13, 11,  8,  7],
[11,  3, 11, 14],
[16, 12, 14, 10],
[15,  6, 10,  5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>mode='reflect'</code> (the default), outer values are reflected at the
edge of <code>input</code> to fill in missing values.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([[2, 0, 0],
...               [1, 0, 0],
...               [0, 0, 0]])
k = np.array([[0,1,0], [0,1,0], [0,1,0]])
ndimage.convolve(b, k, mode='reflect')
array([[5, 0, 0],
[3, 0, 0],
[1, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This includes diagonally at the corners.</p>
<blockquote>
<blockquote>
<blockquote>
<p>k = np.array([[1,0,0],[0,1,0],[0,0,1]])
ndimage.convolve(b, k)
array([[4, 2, 0],
[3, 2, 0],
[1, 1, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>mode='nearest'</code>, the single nearest value in to an edge in
<code>input</code> is repeated as many times as needed to match the overlapping
<code>weights</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([[2, 0, 1],
...               [1, 0, 0],
...               [0, 0, 0]])
k = np.array([[0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0]])
ndimage.convolve(c, k, mode='nearest')
array([[7, 0, 3],
[5, 0, 2],
[3, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional convolution along the given axis.</p>
<p>The lines of the array along the given axis are convolved with the
given weights.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : ndarray
One-dimensional sequence of numbers.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>convolve1d : ndarray
Convolved array with same shape as input</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import convolve1d
convolve1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
array([14, 24,  4, 13, 12, 36, 27,  0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional correlation.</p>
<p>The array is correlated with the given kernel.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : ndarray
array of weights, same number of dimensions as input
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>convolve : Convolve an image with a kernel.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional correlation along the given axis.</p>
<p>The lines of the array along the given axis are correlated with the
given weights.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : array
One-dimensional sequence of numbers.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import correlate1d
correlate1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
array([ 8, 26,  8, 12,  7, 28, 36,  9])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional Gaussian filter.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
Standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.
order : int or sequence of ints, optional
The order of the filter along each axis is given as a sequence
of integers, or as a single number.  An order of 0 corresponds
to convolution with a Gaussian kernel. A positive order
corresponds to convolution with that derivative of a Gaussian.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
truncate : float
Truncate the filter at this many standard deviations.
Default is 4.0.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>gaussian_filter : ndarray
Returned array of same shape as <code>input</code>.</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>The multidimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import gaussian_filter
a = np.arange(50, step=2).reshape((5,5))
a
array([[ 0,  2,  4,  6,  8],
[10, 12, 14, 16, 18],
[20, 22, 24, 26, 28],
[30, 32, 34, 36, 38],
[40, 42, 44, 46, 48]])
gaussian_filter(a, sigma=1)
array([[ 4,  6,  8,  9, 11],
[10, 12, 14, 15, 17],
[20, 22, 24, 25, 27],
[29, 31, 33, 34, 36],
[35, 37, 39, 40, 42]])</p>
<p>from scipy import misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = gaussian_filter(ascent, sigma=5)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>One-dimensional Gaussian filter.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar
standard deviation for Gaussian kernel
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
order : int, optional
An order of 0 corresponds to convolution with a Gaussian
kernel. A positive order corresponds to convolution with
that derivative of a Gaussian.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
truncate : float, optional
Truncate the filter at this many standard deviations.
Default is 4.0.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>gaussian_filter1d : ndarray</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import gaussian_filter1d
gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 1)
array([ 1.42704095,  2.06782203,  3.        ,  3.93217797,  4.57295905])
gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 4)
array([ 2.91948343,  2.95023502,  3.        ,  3.04976498,  3.08051657])
import matplotlib.pyplot as plt
np.random.seed(280490)
x = np.random.randn(101).cumsum()
y3 = gaussian_filter1d(x, 3)
y6 = gaussian_filter1d(x, 6)
plt.plot(x, 'k', label='original data')
plt.plot(y3, '--', label='filtered, sigma=3')
plt.plot(y6, ':', label='filtered, sigma=6')
plt.legend()
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_gradient_magnitude</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional gradient magnitude using Gaussian derivatives.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes..
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
Extra keyword arguments will be passed to gaussian_filter().</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>gaussian_gradient_magnitude : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.gaussian_gradient_magnitude(ascent, sigma=5)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional Laplace filter using gaussian second derivatives.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
Extra keyword arguments will be passed to gaussian_filter().</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
ascent = misc.ascent()</p>
<p>fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side</p>
<p>result = ndimage.gaussian_laplace(ascent, sigma=1)
ax1.imshow(result)</p>
<p>result = ndimage.gaussian_laplace(ascent, sigma=3)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional filter using the given function.</p>
<p>At each element the provided function is called. The input values
within the filter footprint at that element are passed to the function
as a 1D array of double values.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
function : {callable, scipy.LowLevelCallable}
Function to apply at each element.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one of
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int callback(double <em>buffer, npy_intp filter_size,
double </em>return_value, void <em>user_data)
int callback(double </em>buffer, intptr_t filter_size,
double <em>return_value, void </em>user_data)</p>
<p>The calling function iterates over the elements of the input and
output arrays, calling the callback function at each element. The
elements within the footprint of the filter at the current element are
passed through the <code>buffer</code> parameter, and the number of elements
within the footprint through <code>filter_size</code>. The calculated value is
returned in <code>return_value</code>. <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">filter_size</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional filter along the given axis.</p>
<p><code>generic_filter1d</code> iterates over the lines of the array, calling the
given function at each line. The arguments of the line are the
input line, and the output line. The input and output lines are 1D
double arrays.  The input line is extended appropriately according
to the filter size and origin. The output line must be modified
in-place with the result.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
function : {callable, scipy.LowLevelCallable}
Function to apply along given axis.
filter_size : scalar
Length of the filter.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one of
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int function(double <em>input_line, npy_intp input_length,
double </em>output_line, npy_intp output_length,
void <em>user_data)
int function(double </em>input_line, intptr_t input_length,
double <em>output_line, intptr_t output_length,
void </em>user_data)</p>
<p>The calling function iterates over the lines of the input and output
arrays, calling the callback function at each line. The current line
is extended according to the border conditions set by the calling
function, and the result is copied into the array that is passed
through <code>input_line</code>. The length of the input line (after extension)
is passed through <code>input_length</code>. The callback function should apply
the filter and store the result in the array passed through
<code>output_line</code>. The length of the output line is passed through
<code>output_length</code>. <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_gradient_magnitude</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derivative</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gradient magnitude using a provided gradient function.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
derivative : callable
Callable with the following signature::</p>
<p>derivative(input, axis, output, mode, cval,
<em>extra_arguments, </em>*extra_keywords)</p>
<p>See <code>extra_arguments</code>, <code>extra_keywords</code> below.
<code>derivative</code> can assume that <code>input</code> and <code>output</code> are ndarrays.
Note that the output from <code>derivative</code> is modified inplace;
be careful to copy important inputs before returning them.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derivative2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>N-dimensional Laplace filter using a provided second derivative function.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
derivative2 : callable
Callable with the following signature::</p>
<p>derivative2(input, axis, output, mode, cval,
<em>extra_arguments, </em>*extra_keywords)</p>
<p>See <code>extra_arguments</code>, <code>extra_keywords</code> below.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>N-dimensional Laplace filter based on approximate second derivatives.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.laplace(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional maximum filter.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>maximum_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.maximum_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span>
</code></pre></div>

<p>Calculate a one-dimensional maximum filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
maximum filter of given size.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
Length along which to calculate the 1-D maximum.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>maximum1d : ndarray, None
Maximum-filtered array with same shape as input.
None if <code>output</code> is not None</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>This function implements the MAXLIST algorithm [1]<em>, as described by
Richard Harter [2]</em>, and has a guaranteed O(n) performance, <code>n</code> being
the <code>input</code> length, regardless of filter size.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import maximum_filter1d
maximum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([8, 8, 8, 4, 9, 9, 9, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">median_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multidimensional median filter.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>median_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.median_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional minimum filter.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>minimum_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.minimum_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional minimum filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
minimum filter of given size.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
length along which to calculate 1D minimum
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>This function implements the MINLIST algorithm [1]<em>, as described by
Richard Harter [2]</em>, and has a guaranteed O(n) performance, <code>n</code> being
the <code>input</code> length, regardless of filter size.</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import minimum_filter1d
minimum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([2, 0, 0, 0, 1, 1, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">percentile_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">percentile</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional percentile filter.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
percentile : scalar
The percentile parameter may be less then zero, i.e.,
percentile = -20 equals percentile = 80
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>percentile_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.percentile_filter(ascent, percentile=20, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prewitt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a Prewitt filter.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.prewitt(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rank_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional rank filter.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
rank : int
The rank parameter may be less then zero, i.e., rank = -1
indicates the largest element.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>rank_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.rank_filter(ascent, rank=42, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sobel</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a Sobel filter.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.sobel(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">uniform_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional uniform filter.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int or sequence of ints, optional
The sizes of the uniform filter are given for each axis as a
sequence, or as a single number, in which case the size is
equal for all axes.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>uniform_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional uniform filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.uniform_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">uniform_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional uniform filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
uniform filter of given size.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
length of uniform filter
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import uniform_filter1d
uniform_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([4, 3, 4, 1, 4, 6, 6, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Fourier</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">fourier_ellipsoid</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional ellipsoid fourier filter.</p>
<p>The array is multiplied with the fourier transform of a ellipsoid of
given sizes.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : float or sequence
The size of the box used for filtering.
If a float, <code>size</code> is the same for all axes. If a sequence, <code>size</code> has
to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>fourier_ellipsoid : ndarray
The filtered input.</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>This function is implemented for arrays of rank 1, 2, or 3.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_ellipsoid(input_, size=20)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional Gaussian fourier filter.</p>
<p>The array is multiplied with the fourier transform of a Gaussian
kernel.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : float or sequence
The sigma of the Gaussian kernel. If a float, <code>sigma</code> is the same for
all axes. If a sequence, <code>sigma</code> has to contain one value for each
axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>fourier_gaussian : ndarray
The filtered input.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_gaussian(input_, sigma=4)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shift</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional fourier shift filter.</p>
<p>The array is multiplied with the fourier transform of a shift operation.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
shift : float or sequence
The size of the box used for filtering.
If a float, <code>shift</code> is the same for all axes. If a sequence, <code>shift</code>
has to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of shifting the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>fourier_shift : ndarray
The shifted input.</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
import numpy.fft
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_shift(input_, shift=200)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_uniform</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional uniform fourier filter.</p>
<p>The array is multiplied with the fourier transform of a box of given
size.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : float or sequence
The size of the box used for filtering.
If a float, <code>size</code> is the same for all axes. If a sequence, <code>size</code> has
to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>fourier_uniform : ndarray
The filtered input.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_uniform(input_, size=20)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Interpolation</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">affine_transform</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output_shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply an affine transformation.</p>
<p>Given an output image pixel index vector <code>o</code>, the pixel value
is determined from the input image at position
<code>np.dot(matrix, o) + offset</code>.</p>
<p>This does 'pull' (or 'backward') resampling, transforming the output space
to the input to locate data. Affine transformations are often described in
the 'push' (or 'forward') direction, transforming input to output. If you
have a matrix for the 'push' transformation, use its inverse
(:func:<code>numpy.linalg.inv</code>) in this function.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
matrix : ndarray
The inverse coordinate transformation matrix, mapping output
coordinates to input coordinates. If <code>ndim</code> is the number of
dimensions of <code>input</code>, the given matrix must have one of the
following shapes:</p>
<ul>
<li><code>(ndim, ndim)</code>: the linear transformation matrix for each
output coordinate.</li>
<li><code>(ndim,)</code>: assume that the 2D transformation matrix is
diagonal, with the diagonal specified by the given value. A more
efficient algorithm is then used that exploits the separability
of the problem.</li>
<li><code>(ndim + 1, ndim + 1)</code>: assume that the transformation is
specified using homogeneous coordinates [1]_. In this case, any
value passed to <code>offset</code> is ignored.</li>
<li><code>(ndim, ndim + 1)</code>: as above, but the bottom row of a
homogeneous transformation matrix is always <code>[0, 0, ..., 1]</code>,
and may be omitted.</li>
</ul>
<p>offset : float or sequence, optional
The offset into the array where the transform is applied. If a float,
<code>offset</code> is the same for each axis. If a sequence, <code>offset</code> should
contain one value for each axis.
output_shape : tuple of ints, optional
Shape tuple.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>affine_transform : ndarray
The transformed input.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.</p>
<p>.. versionchanged:: 0.18.0
Previously, the exact interpretation of the affine transformation
depended on whether the matrix was supplied as a one-dimensional or
two-dimensional array. If a one-dimensional array was supplied
to the matrix parameter, the output pixel value at index <code>o</code>
was determined from the input image at position
<code>matrix * (o + offset)</code>.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">docfiller</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">geometric_transform</span> <span class="o">:</span> <span class="o">?</span><span class="n">output_shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mapping</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply an arbitrary geometric transform.</p>
<p>The given mapping function is used to find, for each point in the
output, the corresponding coordinates in the input. The value of the
input at those coordinates is determined by spline interpolation of
the requested order.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
mapping : {callable, scipy.LowLevelCallable}
A callable object that accepts a tuple of length equal to the output
array rank, and returns the corresponding input coordinates as a tuple
of length equal to the input array rank.
output_shape : tuple of ints, optional
Shape tuple.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.
extra_arguments : tuple, optional
Extra arguments passed to <code>mapping</code>.
extra_keywords : dict, optional
Extra keywords passed to <code>mapping</code>.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>output : ndarray
The filtered input.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>map_coordinates, affine_transform, spline_filter1d</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int mapping(npy_intp <em>output_coordinates, double </em>input_coordinates,
int output_rank, int input_rank, void <em>user_data)
int mapping(intptr_t </em>output_coordinates, double <em>input_coordinates,
int output_rank, int input_rank, void </em>user_data)</p>
<p>The calling function iterates over the elements of the output array,
calling the callback function at each element. The coordinates of the
current output element are passed through <code>output_coordinates</code>. The
callback function must return the coordinates at which the input must
be interpolated in <code>input_coordinates</code>. The rank of the input and
output arrays are given by <code>input_rank</code> and <code>output_rank</code>
respectively.  <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.ndimage import geometric_transform
a = np.arange(12.).reshape((4, 3))
def shift_func(output_coords):
...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)
...
geometric_transform(a, shift_func)
array([[ 0.   ,  0.   ,  0.   ],
[ 0.   ,  1.362,  2.738],
[ 0.   ,  4.812,  6.187],
[ 0.   ,  8.263,  9.637]])</p>
<p>b = [1, 2, 3, 4, 5]
def shift_func(output_coords):
...     return (output_coords[0] - 3,)
...
geometric_transform(b, shift_func, mode='constant')
array([0, 0, 0, 1, 2])
geometric_transform(b, shift_func, mode='nearest')
array([1, 1, 1, 1, 2])
geometric_transform(b, shift_func, mode='reflect')
array([3, 2, 1, 1, 2])
geometric_transform(b, shift_func, mode='wrap')
array([2, 3, 4, 1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">map_coordinates</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">coordinates</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Map the input array to new coordinates by interpolation.</p>
<p>The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.</p>
<p>The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
coordinates : array_like
The coordinates at which <code>input</code> is evaluated.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>map_coordinates : ndarray
The result of transforming the input. The shape of the output is
derived from that of <code>coordinates</code> by dropping the first axis.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>spline_filter, geometric_transform, scipy.interpolate</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(12.).reshape((4, 3))
a
array([[  0.,   1.,   2.],
[  3.,   4.,   5.],
[  6.,   7.,   8.],
[  9.,  10.,  11.]])
ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)
array([ 2.,  7.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].</p>
<blockquote>
<blockquote>
<blockquote>
<p>inds = np.array([[0.5, 2], [0.5, 4]])
ndimage.map_coordinates(a, inds, order=1, cval=-33.3)
array([  2. , -33.3])
ndimage.map_coordinates(a, inds, order=1, mode='nearest')
array([ 2.,  8.])
ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)
array([ True, False], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rotate</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reshape</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">angle</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Rotate an array.</p>
<p>The array is rotated in the plane defined by the two axes given by the
<code>axes</code> parameter using spline interpolation of the requested order.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
angle : float
The rotation angle in degrees.
axes : tuple of 2 ints, optional
The two axes that define the plane of rotation. Default is the first
two axes.
reshape : bool, optional
If <code>reshape</code> is true, the output shape is adapted so that the input
array is contained completely in the output. Default is True.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>rotate : ndarray
The rotated input.</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(10, 3))
ax1, ax2, ax3 = fig.subplots(1, 3)
img = misc.ascent()
img_45 = ndimage.rotate(img, 45, reshape=False)
full_img_45 = ndimage.rotate(img, 45, reshape=True)
ax1.imshow(img, cmap='gray')
ax1.set_axis_off()
ax2.imshow(img_45, cmap='gray')
ax2.set_axis_off()
ax3.imshow(full_img_45, cmap='gray')
ax3.set_axis_off()
fig.set_tight_layout(True)
plt.show()
print(img.shape)
(512, 512)
print(img_45.shape)
(512, 512)
print(full_img_45.shape)
(724, 724)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shift</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift an array.</p>
<p>The array is shifted using spline interpolation of the requested order.
Points outside the boundaries of the input are filled according to the
given mode.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
shift : float or sequence
The shift along the axes. If a float, <code>shift</code> is the same for each
axis. If a sequence, <code>shift</code> should contain one value for each axis.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>shift : ndarray
The shifted input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional spline filter.</p>
<p>For more details, see <code>spline_filter1d</code>.</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>spline_filter1d</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional spline filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional spline filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered by a
spline filter. The order of the spline must be &gt;= 2 and &lt;= 5.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
order : int, optional
The order of the spline, default is 3.
axis : int, optional
The axis along which the spline filter is applied. Default is the last
axis.
output : ndarray or dtype, optional
The array in which to place the output, or the dtype of the returned
array. Default is <code>numpy.float64</code>.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>spline_filter1d : ndarray
The filtered input.</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>All functions in <code>ndimage.interpolation</code> do spline interpolation of
the input image. If using b-splines of <code>order &gt; 1</code>, the input image
values have to be converted to b-spline coefficients first, which is
done by applying this one-dimensional filter sequentially along all
axes of the input. All functions that require b-spline coefficients
will automatically filter their inputs, a behavior controllable with
the <code>prefilter</code> keyword argument. For functions that accept a <code>mode</code>
parameter, the result will only be correct if it matches the <code>mode</code>
used when filtering.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zoom</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">zoom</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zoom an array.</p>
<p>The array is zoomed using spline interpolation of the requested order.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
zoom : float or sequence
The zoom factor along the axes. If a float, <code>zoom</code> is the same for each
axis. If a sequence, <code>zoom</code> should contain one value for each axis.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>zoom : ndarray
The zoomed input.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt</p>
<p>fig = plt.figure()
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.zoom(ascent, 3.0)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
<p>print(ascent.shape)
(512, 512)</p>
<p>print(result.shape)
(1536, 1536)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Measurements</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">center_of_mass</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the center of mass of the values of an array at labels.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>input : ndarray
Data from which to calculate center-of-mass. The masses can either
be positive or negative.
labels : ndarray, optional
Labels for objects in <code>input</code>, as generated by <code>ndimage.label</code>.
Only used with <code>index</code>.  Dimensions must be the same as <code>input</code>.
index : int or sequence of ints, optional
Labels for which to calculate centers-of-mass. If not specified,
all labels greater than zero are used.  Only used with <code>labels</code>.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>center_of_mass : tuple, or list of tuples
Coordinates of centers-of-mass.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array(([0,0,0,0],
...               [0,1,1,0],
...               [0,1,1,0],
...               [0,1,1,0]))
from scipy import ndimage
ndimage.measurements.center_of_mass(a)
(2.0, 1.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculation of multiple objects in an image</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array(([0,1,1,0],
...               [0,1,0,0],
...               [0,0,0,0],
...               [0,0,1,1],
...               [0,0,1,1]))
lbl = ndimage.label(b)[0]
ndimage.measurements.center_of_mass(b, lbl, [1,2])
[(0.33333333333333331, 1.3333333333333333), (3.5, 2.5)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Negative masses are also accepted, which can occur for example when
bias is removed from measured data due to random noise.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array(([-1,0,0,0],
...               [0,-1,-1,0],
...               [0,1,-1,0],
...               [0,1,1,0]))
ndimage.measurements.center_of_mass(c)
(-4.0, 1.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there are division by zero issues, the function does not raise an
error but rather issues a RuntimeWarning before returning inf and/or NaN.</p>
<blockquote>
<blockquote>
<blockquote>
<p>d = np.array([-1, 1])
ndimage.measurements.center_of_mass(d)
(inf,)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">extrema</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimums and maximums of the values of an array
at labels, along with their positions.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>input : ndarray
Nd-image data to process.
labels : ndarray, optional
Labels of features in input.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
Labels to include in output.  If None (default), all values where
non-zero <code>labels</code> are used.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>minimums, maximums : int or ndarray
Values of minimums and maximums in each feature.
min_positions, max_positions : tuple or list of tuples
Each tuple gives the n-D coordinates of the corresponding minimum
or maximum.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>maximum, minimum, maximum_position, minimum_position, center_of_mass</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.extrema(a)
(0, 9, (0, 2), (3, 0))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.extrema(a, lbl, index=np.arange(1, nlbl+1))
(array([1, 4, 3]),
array([5, 7, 9]),
[(0, 0), (1, 3), (3, 1)],
[(1, 0), (2, 3), (3, 0)])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.extrema(a, lbl)
(1, 9, (0, 0), (3, 0))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_objects</span> <span class="o">:</span> <span class="o">?</span><span class="n">max_label</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find objects in a labeled array.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>input : ndarray of ints
Array containing objects defined by different labels. Labels with
value 0 are ignored.
max_label : int, optional
Maximum label to be searched for in <code>input</code>. If max_label is not
given, the positions of all objects are returned.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>object_slices : list of tuples
A list of tuples, with each tuple containing N slices (with N the
dimension of the input array).  Slices correspond to the minimal
parallelepiped that contains the object. If a number is missing,
None is returned instead of a slice.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>label, center_of_mass</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>This function is very useful for isolating a volume of interest inside
a 3-D array, that cannot be 'seen through'.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((6,6), dtype=int)
a[2:4, 2:4] = 1
a[4, 4] = 1
a[:2, :3] = 2
a[0, 5] = 3
a
array([[2, 2, 2, 0, 0, 3],
[2, 2, 2, 0, 0, 0],
[0, 0, 1, 1, 0, 0],
[0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0]])
ndimage.find_objects(a)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None)), (slice(0, 1, None), slice(5, 6, None))]
ndimage.find_objects(a, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))]
ndimage.find_objects(a == 1, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), None]</p>
<p>loc = ndimage.find_objects(a)[0]
a[loc]
array([[1, 1, 0],
[1, 1, 0],
[0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">histogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">min</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">max</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bins</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the histogram of the values of an array, optionally at labels.</p>
<p>Histogram calculates the frequency of values in an array within bins
determined by <code>min</code>, <code>max</code>, and <code>bins</code>. The <code>labels</code> and <code>index</code>
keywords can limit the scope of the histogram to specified sub-regions
within the array.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>input : array_like
Data for which to calculate histogram.
min, max : int
Minimum and maximum values of range of histogram bins.
bins : int
Number of bins.
labels : array_like, optional
Labels for objects in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
Label or labels for which to calculate histogram. If None, all values
where label is greater than zero are used</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>hist : ndarray
Histogram counts.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ],
...               [ 0.    ,  0.7778,  0.    ,  0.    ],
...               [ 0.    ,  0.    ,  0.    ,  0.    ],
...               [ 0.    ,  0.    ,  0.7181,  0.2787],
...               [ 0.    ,  0.    ,  0.6573,  0.3094]])
from scipy import ndimage
ndimage.measurements.histogram(a, 0, 1, 10)
array([13,  0,  2,  1,  0,  1,  1,  2,  0,  0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With labels and no indices, non-zero elements are counted:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.measurements.histogram(a, 0, 1, 10, lbl)
array([0, 0, 2, 1, 0, 1, 1, 2, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Indices can be used to count only certain objects:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.measurements.histogram(a, 0, 1, 10, lbl, 2)
array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">label</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Label features in an array.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>input : array_like
An array-like object to be labeled.  Any non-zero values in <code>input</code> are
counted as features and zero values are considered the background.
structure : array_like, optional
A structuring element that defines feature connections.
<code>structure</code> must be centrosymmetric
(see Notes).
If no structuring element is provided,
one is automatically generated with a squared connectivity equal to
one.  That is, for a 2-D <code>input</code> array, the default structuring element
is::</p>
<p>[[0,1,0],
[1,1,1],
[0,1,0]]</p>
<p>output : (None, data-type, array_like), optional
If <code>output</code> is a data type, it specifies the type of the resulting
labeled feature array.
If <code>output</code> is an array-like object, then <code>output</code> will be updated
with the labeled features from this function.  This function can
operate in-place, by passing output=input.
Note that the output must be able to store the largest label, or this
function will raise an Exception.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>label : ndarray or int
An integer ndarray where each unique feature in <code>input</code> has a unique
label in the returned array.
num_features : int
How many objects were found.</p>
<p>If <code>output</code> is None, this function returns a tuple of
(<code>labeled_array</code>, <code>num_features</code>).</p>
<p>If <code>output</code> is a ndarray, then it will be updated with values in
<code>labeled_array</code> and only <code>num_features</code> will be returned by this
function.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>find_objects : generate a list of slices for the labeled features (or
objects); useful for finding features' position or
dimensions</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>A centrosymmetric matrix is a matrix that is symmetric about the center.
See [1]_ for more information.</p>
<p>The <code>structure</code> matrix must be centrosymmetric to ensure
two-way connections.
For instance, if the <code>structure</code> matrix is not centrosymmetric
and is defined as::</p>
<p>[[0,1,0],
[1,1,0],
[0,0,0]]</p>
<p>and the <code>input</code> is::</p>
<p>[[1,2],
[0,3]]</p>
<p>then the structure matrix would indicate the
entry 2 in the input is connected to 1,
but 1 is not connected to 2.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<p>Create an image with some features, then label it using the default
(cross-shaped) structuring element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import label, generate_binary_structure
a = np.array([[0,0,1,1,0,0],
...               [0,0,0,1,0,0],
...               [1,1,0,0,1,0],
...               [0,0,0,1,0,0]])
labeled_array, num_features = label(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Each of the 4 features are labeled with a different integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>num_features
4
labeled_array
array([[0, 0, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0],
[2, 2, 0, 0, 3, 0],
[0, 0, 0, 4, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a structuring element that will consider features connected even
if they touch diagonally:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = generate_binary_structure(2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>or,</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = [[1,1,1],
...      [1,1,1],
...      [1,1,1]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Label the image using the new structuring element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>labeled_array, num_features = label(a, structure=s)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Show the 2 labeled features (note that features 1, 3, and 4 from above are
now considered a single feature):</p>
<blockquote>
<blockquote>
<blockquote>
<p>num_features
2
labeled_array
array([[0, 0, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0],
[2, 2, 0, 0, 1, 0],
[0, 0, 0, 1, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>.. [1] James R. Weaver, 'Centrosymmetric (cross-symmetric)
matrices, their basic properties, eigenvalues, and
eigenvectors.' The American Mathematical Monthly 92.10
(1985): 711-717.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labeled_comprehension</span> <span class="o">:</span> <span class="o">?</span><span class="n">pass_positions</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">labels</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">out_dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">default</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Roughly equivalent to [func(input[labels == i]) for i in index].</p>
<p>Sequentially applies an arbitrary function (that works on array_like input)
to subsets of an n-D image array specified by <code>labels</code> and <code>index</code>.
The option exists to provide the function with positional parameters as the
second argument.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>input : array_like
Data from which to select <code>labels</code> to process.
labels : array_like or None
Labels to objects in <code>input</code>.
If not None, array must be same shape as <code>input</code>.
If None, <code>func</code> is applied to raveled <code>input</code>.
index : int, sequence of ints or None
Subset of <code>labels</code> to which to apply <code>func</code>.
If a scalar, a single value is returned.
If None, <code>func</code> is applied to all non-zero values of <code>labels</code>.
func : callable
Python function to apply to <code>labels</code> from <code>input</code>.
out_dtype : dtype
Dtype to use for <code>result</code>.
default : int, float or None
Default return value when a element of <code>index</code> does not exist
in <code>labels</code>.
pass_positions : bool, optional
If True, pass linear indices to <code>func</code> as a second argument.
Default is False.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>result : ndarray
Result of applying <code>func</code> to each of <code>labels</code> to <code>input</code> in <code>index</code>.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
lbl, nlbl = ndimage.label(a)
lbls = np.arange(1, nlbl+1)
ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0)
array([ 2.75,  5.5 ,  6.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Falling back to <code>default</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbls = np.arange(1, nlbl+2)
ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, -1)
array([ 2.75,  5.5 ,  6.  , -1.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Passing positions:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fn(val, pos):
...     print('fn says: %s : %s' % (val, pos))
...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum())
...
ndimage.labeled_comprehension(a, lbl, lbls, fn, float, 0, True)
fn says: [1 2 5 3] : [0 1 4 5]
fn says: [4 7] : [ 7 11]
fn says: [9 3] : [12 13]
array([ 11.,  11., -12.,   0.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the maximum of the values of an array over labeled regions.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
maximal values of <code>input</code> over the region is computed.
labels : array_like, optional
An array of integers marking different regions over which the
maximum value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the maximum
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
maxima. If index is None, the maximum over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>output : float or list of floats
List of maxima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the maximal value of <code>input</code> if <code>labels</code> is None,
and the maximal value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_8">See also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(16).reshape((4,4))
a
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11],
[12, 13, 14, 15]])
labels = np.zeros_like(a)
labels[:2,:2] = 1
labels[2:, 1:3] = 2
labels
array([[1, 1, 0, 0],
[1, 1, 0, 0],
[0, 2, 2, 0],
[0, 2, 2, 0]])
from scipy import ndimage
ndimage.maximum(a)
15.0
ndimage.maximum(a, labels=labels, index=[1,2])
[5.0, 14.0]
ndimage.maximum(a, labels=labels)
14.0</p>
<p>b = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(b)
labels
array([[1, 1, 0, 0],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.maximum(b, labels=labels, index=np.arange(1, labels_nb + 1))
[5.0, 7.0, 9.0]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_position</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the positions of the maximums of the values of an array at labels.</p>
<p>For each region specified by <code>labels</code>, the position of the maximum
value of <code>input</code> within the region is returned.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values.
labels : array_like, optional
An array of integers marking different regions over which the
position of the maximum value of <code>input</code> is to be computed.
<code>labels</code> must have the same shape as <code>input</code>. If <code>labels</code> is not
specified, the location of the first maximum over the whole
array is returned.</p>
<p>The <code>labels</code> argument only works when <code>index</code> is specified.
index : array_like, optional
A list of region labels that are taken into account for finding the
location of the maxima.  If <code>index</code> is None, the first maximum
over all elements where <code>labels</code> is non-zero is returned.</p>
<p>The <code>index</code> argument only works when <code>labels</code> is specified.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>output : list of tuples of ints
List of tuples of ints that specify the location of maxima of
<code>input</code> over the regions determined by <code>labels</code> and whose index
is in <code>index</code>.</p>
<p>If <code>index</code> or <code>labels</code> are not specified, a tuple of ints is
returned specifying the location of the <code>first</code> maximal value
of <code>input</code>.</p>
<h2 id="see-also_9">See also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the mean of the values of an array at labels.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array on which to compute the mean of elements over distinct
regions.
labels : array_like, optional
Array of labels of same shape, or broadcastable to the same shape as
<code>input</code>. All elements sharing the same label form one region over
which the mean of the elements is computed.
index : int or sequence of ints, optional
Labels of the objects over which the mean is to be computed.
Default is None, in which case the mean for all values where label is
greater than 0 is calculated.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>out : list
Sequence of same length as <code>index</code>, with the mean of the different
regions labeled by the labels in <code>index</code>.</p>
<h2 id="see-also_10">See also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>variance, standard_deviation, minimum, maximum, sum, label</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(25).reshape((5,5))
labels = np.zeros_like(a)
labels[3:5,3:5] = 1
index = np.unique(labels)
labels
array([[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1]])
index
array([0, 1])
ndimage.mean(a, labels=labels, index=index)
[10.285714285714286, 21.0]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">median</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the median of the values of an array over labeled regions.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
median value of <code>input</code> over the region is computed.
labels : array_like, optional
An array_like of integers marking different regions over which the
median value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the median
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
medians. If index is None, the median over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>median : float or list of floats
List of medians of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the median value of <code>input</code> if <code>labels</code> is None,
and the median value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_11">See also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>label, minimum, maximum, extrema, sum, mean, variance, standard_deviation</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(a)
labels
array([[1, 1, 0, 2],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1))
[2.5, 4.0, 6.0]
ndimage.median(a)
1.0
ndimage.median(a, labels=labels)
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimum of the values of an array over labeled regions.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
minimal values of <code>input</code> over the region is computed.
labels : array_like, optional
An array_like of integers marking different regions over which the
minimum value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the minimum
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
minima. If index is None, the minimum over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>minimum : float or list of floats
List of minima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the minimal value of <code>input</code> if <code>labels</code> is None,
and the minimal value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_12">See also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>label, maximum, median, minimum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(a)
labels
array([[1, 1, 0, 0],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1))
[1.0, 4.0, 3.0]
ndimage.minimum(a)
0.0
ndimage.minimum(a, labels=labels)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_position</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the positions of the minimums of the values of an array at labels.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values.
labels : array_like, optional
An array of integers marking different regions over which the
position of the minimum value of <code>input</code> is to be computed.
<code>labels</code> must have the same shape as <code>input</code>. If <code>labels</code> is not
specified, the location of the first minimum over the whole
array is returned.</p>
<p>The <code>labels</code> argument only works when <code>index</code> is specified.
index : array_like, optional
A list of region labels that are taken into account for finding the
location of the minima. If <code>index</code> is None, the <code>first</code> minimum
over all elements where <code>labels</code> is non-zero is returned.</p>
<p>The <code>index</code> argument only works when <code>labels</code> is specified.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>output : list of tuples of ints
Tuple of ints or list of tuples of ints that specify the location
of minima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>.</p>
<p>If <code>index</code> or <code>labels</code> are not specified, a tuple of ints is
returned specifying the location of the first minimal value of <code>input</code>.</p>
<h2 id="see-also_13">See also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[10, 20, 30],
...               [40, 80, 100],
...               [1, 100, 200]])
b = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])</p>
<p>from scipy import ndimage</p>
<p>ndimage.minimum_position(a)
(2, 0)
ndimage.minimum_position(b)
(0, 2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>label, pos = ndimage.label(a)
ndimage.minimum_position(a, label, index=np.arange(1, pos+1))
[(2, 0)]</p>
<p>label, pos = ndimage.label(b)
ndimage.minimum_position(b, label, index=np.arange(1, pos+1))
[(0, 0), (0, 3), (3, 1)]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">standard_deviation</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the standard deviation of the values of an n-D image array,
optionally at specified sub-regions.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>input : array_like
Nd-image data to process.
labels : array_like, optional
Labels to identify sub-regions in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
<code>labels</code> to include in output.  If None (default), all values where
<code>labels</code> is non-zero are used.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>standard_deviation : float or ndarray
Values of standard deviation, for each sub-region if <code>labels</code> and
<code>index</code> are specified.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>label, variance, maximum, minimum, extrema</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.standard_deviation(a)
2.7585095613392387</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.standard_deviation(a, lbl, index=np.arange(1, nlbl+1))
array([ 1.479,  1.5  ,  3.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.standard_deviation(a, lbl)
2.4874685927665499</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the sum of the values of the array.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>input : array_like
Values of <code>input</code> inside the regions defined by <code>labels</code>
are summed together.
labels : array_like of ints, optional
Assign labels to the values of the array. Has to have the same shape as
<code>input</code>.
index : array_like, optional
A single label number or a sequence of label numbers of
the objects to be measured.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>sum : ndarray or scalar
An array of the sums of values of <code>input</code> inside the regions defined
by <code>labels</code> with the same shape as <code>index</code>. If 'index' is None or scalar,
a scalar is returned.</p>
<h2 id="see-also_15">See also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>mean, median</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
input =  [0,1,2,3]
labels = [1,1,2,2]
ndimage.sum(input, labels, index=[1,2])
[1.0, 5.0]
ndimage.sum(input, labels, index=1)
1
ndimage.sum(input, labels)
6</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">variance</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the variance of the values of an n-D image array, optionally at
specified sub-regions.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>input : array_like
Nd-image data to process.
labels : array_like, optional
Labels defining sub-regions in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
<code>labels</code> to include in output.  If None (default), all values where
<code>labels</code> is non-zero are used.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>variance : float or ndarray
Values of variance, for each sub-region if <code>labels</code> and <code>index</code> are
specified.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>label, standard_deviation, maximum, minimum, extrema</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.variance(a)
7.609375</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.variance(a, lbl, index=np.arange(1, nlbl+1))
array([ 2.1875,  2.25  ,  9.    ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, all non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.variance(a, lbl)
6.1875</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">watershed_ift</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">markers</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply watershed from markers using image foresting transform algorithm.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
markers : array_like
Markers are points within each watershed that form the beginning
of the process.  Negative markers are considered background markers
which are processed after the other markers.
structure : structure element, optional
A structuring element defining the connectivity of the object can be
provided. If None, an element is generated with a squared
connectivity equal to one.
output : ndarray, optional
An output array can optionally be provided.  The same shape as input.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>watershed_ift : ndarray
Output.  Same shape as <code>input</code>.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] A.X. Falcao, J. Stolfi and R. de Alencar Lotufo, 'The image
foresting transform: theory, algorithms, and applications',
Pattern Analysis and Machine Intelligence, vol. 26, pp. 19-29, 2004.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Morphology</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">binary_closing</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary closing with the given structuring element.</p>
<p>The <em>closing</em> of an input image by a structuring element is the
<em>erosion</em> of the <em>dilation</em> of the image by the structuring element.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be closed. Non-zero (True) elements form
the subset to be closed.
structure : array_like, optional
Structuring element used for the closing. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).
iterations : int, optional
The dilation step of the closing, then the erosion step are each
repeated <code>iterations</code> times (one, by default). If iterations is
less than 1, each operations is repeated until the result does
not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</p>
<p>.. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.</p>
<p>.. versionadded:: 1.1.0
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated in the
current iteration; if true al pixels are considered as candidates for
update, regardless of what happened in the previous iteration.
False by default.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>binary_closing : ndarray of bools
Closing of the input by the structuring element.</p>
<h2 id="see-also_17">See also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>grey_closing, binary_opening, binary_dilation, binary_erosion,
generate_binary_structure</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p><em>Closing</em> [1]<em> is a mathematical morphology operation [2]</em> that
consists in the succession of a dilation and an erosion of the
input with the same structuring element. Closing therefore fills
holes smaller than the structuring element.</p>
<p>Together with <em>opening</em> (<code>binary_opening</code>), closing can be used for
noise removal.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Closing_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5,5), dtype=int)
a[1:-1, 1:-1] = 1; a[2,2] = 0
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="closing-removes-small-holes">Closing removes small holes<a class="headerlink" href="#closing-removes-small-holes" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="closing-is-the-erosion-of-the-dilation-of-the-input">Closing is the erosion of the dilation of the input<a class="headerlink" href="#closing-is-the-erosion-of-the-dilation-of-the-input" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_dilation(a).astype(int)
array([[0, 1, 1, 1, 0],
[1, 1, 1, 1, 1],
[1, 1, 1, 1, 1],
[1, 1, 1, 1, 1],
[0, 1, 1, 1, 0]])
ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<p>a = np.zeros((7,7), dtype=int)
a[1:6, 2:5] = 1; a[1:3,3] = 0
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="in-addition-to-removing-holes-closing-can-also">In addition to removing holes, closing can also<a class="headerlink" href="#in-addition-to-removing-holes-closing-can-also" title="Permanent link">&para;</a></h1>
<h1 id="coarsen-boundaries-with-fine-hollows">coarsen boundaries with fine hollows.<a class="headerlink" href="#coarsen-boundaries-with-fine-hollows" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_closing(a, structure=np.ones((2,2))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_dilation</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary dilation with the given structuring element.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be dilated. Non-zero (True) elements form
the subset to be dilated.
structure : array_like, optional
Structuring element used for the dilation. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one.
iterations : int, optional
The dilation is repeated <code>iterations</code> times (one, by default).
If iterations is less than 1, the dilation is repeated until the
result does not change anymore. Only an integer of iterations is
accepted.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated (dilated)
in the current iteration; if True all pixels are considered as
candidates for dilation, regardless of what happened in the previous
iteration. False by default.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>binary_dilation : ndarray of bools
Dilation of the input by the structuring element.</p>
<h2 id="see-also_18">See also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>grey_dilation, binary_erosion, binary_closing, binary_opening,
generate_binary_structure</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>Dilation [1]<em> is a mathematical morphology operation [2]</em> that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5, 5))
a[2, 2] = 1
a
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a)
array([[False, False, False, False, False],
[False, False,  True, False, False],
[False,  True,  True,  True, False],
[False, False,  True, False, False],
[False, False, False, False, False]], dtype=bool)
ndimage.binary_dilation(a).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])</p>
<h1 id="3x3-structuring-element-with-connectivity-1-used-by-default">3x3 structuring element with connectivity 1, used by default<a class="headerlink" href="#3x3-structuring-element-with-connectivity-1-used-by-default" title="Permanent link">&para;</a></h1>
<p>struct1 = ndimage.generate_binary_structure(2, 1)
struct1
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)</p>
<h1 id="3x3-structuring-element-with-connectivity-2">3x3 structuring element with connectivity 2<a class="headerlink" href="#3x3-structuring-element-with-connectivity-2" title="Permanent link">&para;</a></h1>
<p>struct2 = ndimage.generate_binary_structure(2, 2)
struct2
array([[ True,  True,  True],
[ True,  True,  True],
[ True,  True,  True]], dtype=bool)
ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a, structure=struct1,\
... iterations=2).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 1.,  1.,  1.,  1.,  1.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_erosion</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary erosion with a given structuring element.</p>
<p>Binary erosion is a mathematical morphology operation used for image
processing.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary image to be eroded. Non-zero (True) elements form
the subset to be eroded.
structure : array_like, optional
Structuring element used for the erosion. Non-zero elements are
considered True. If no structuring element is provided, an element
is generated with a square connectivity equal to one.
iterations : int, optional
The erosion is repeated <code>iterations</code> times (one, by default).
If iterations is less than 1, the erosion is repeated until the
result does not change anymore.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated (eroded) in
the current iteration; if True all pixels are considered as candidates
for erosion, regardless of what happened in the previous iteration.
False by default.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>binary_erosion : ndarray of bools
Erosion of the input by the structuring element.</p>
<h2 id="see-also_19">See also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>grey_erosion, binary_dilation, binary_closing, binary_opening,
generate_binary_structure</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>Erosion [1]<em> is a mathematical morphology operation [2]</em> that uses a
structuring element for shrinking the shapes in an image. The binary
erosion of an image by a structuring element is the locus of the points
where a superimposition of the structuring element centered on the point
is entirely contained in the set of non-zero elements of the image.</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1:6, 2:5] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="erosion-removes-objects-smaller-than-the-structure">Erosion removes objects smaller than the structure<a class="headerlink" href="#erosion-removes-objects-smaller-than-the-structure" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_fill_holes</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fill the holes in binary objects.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>input : array_like
n-dimensional binary array with holes to be filled
structure : array_like, optional
Structuring element used in the computation; large-size elements
make computations faster but may miss holes separated from the
background by thin regions. The default element (with a square
connectivity equal to one) yields the intuitive result where all
holes in the input have been filled.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int, tuple of ints, optional
Position of the structuring element.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Transformation of the initial image <code>input</code> where holes have been
filled.</p>
<h2 id="see-also_20">See also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>binary_dilation, binary_propagation, label</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>The algorithm used in this function consists in invading the complementary
of the shapes in <code>input</code> from the outer boundary of the image,
using binary dilations. Holes are not connected to the boundary and are
therefore not invaded. The result is the complementary subset of the
invaded region.</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5, 5), dtype=int)
a[1:4, 1:4] = 1
a[2,2] = 0
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])
ndimage.binary_fill_holes(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="too-big-structuring-element">Too big structuring element<a class="headerlink" href="#too-big-structuring-element" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_hit_or_miss</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin1</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin2</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary hit-or-miss transform.</p>
<p>The hit-or-miss transform finds the locations of a given pattern
inside the input image.</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>input : array_like (cast to booleans)
Binary image where a pattern is to be detected.
structure1 : array_like (cast to booleans), optional
Part of the structuring element to be fitted to the foreground
(non-zero elements) of <code>input</code>. If no value is provided, a
structure of square connectivity 1 is chosen.
structure2 : array_like (cast to booleans), optional
Second part of the structuring element that has to miss completely
the foreground. If no value is provided, the complementary of
<code>structure1</code> is taken.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin1 : int or tuple of ints, optional
Placement of the first part of the structuring element <code>structure1</code>,
by default 0 for a centered structure.
origin2 : int or tuple of ints, optional
Placement of the second part of the structuring element <code>structure2</code>,
by default 0 for a centered structure. If a value is provided for
<code>origin1</code> and not for <code>origin2</code>, then <code>origin2</code> is set to <code>origin1</code>.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>binary_hit_or_miss : ndarray
Hit-or-miss transform of <code>input</code> with the given structuring
element (<code>structure1</code>, <code>structure2</code>).</p>
<h2 id="see-also_21">See also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>binary_erosion</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Hit-or-miss_transform</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0],
[0, 0, 0, 0, 1, 1, 0],
[0, 0, 0, 0, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])
structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])
structure1
array([[1, 0, 0],
[0, 1, 1],
[0, 1, 1]])</p>
<h1 id="find-the-matches-of-structure1-in-the-array-a">Find the matches of structure1 in the array a<a class="headerlink" href="#find-the-matches-of-structure1-in-the-array-a" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="change-the-origin-of-the-filter">Change the origin of the filter<a class="headerlink" href="#change-the-origin-of-the-filter" title="Permanent link">&para;</a></h1>
<h1 id="origin11-is-equivalent-to-origin111-here">origin1=1 is equivalent to origin1=(1,1) here<a class="headerlink" href="#origin11-is-equivalent-to-origin111-here" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_hit_or_miss(a, structure1=structure1,\
... origin1=1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_opening</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary opening with the given structuring element.</p>
<p>The <em>opening</em> of an input image by a structuring element is the
<em>dilation</em> of the <em>erosion</em> of the image by the structuring element.</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be opened. Non-zero (True) elements form
the subset to be opened.
structure : array_like, optional
Structuring element used for the opening. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).
iterations : int, optional
The erosion step of the opening, then the dilation step are each
repeated <code>iterations</code> times (one, by default). If <code>iterations</code> is
less than 1, each operation is repeated until the result does
not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</p>
<p>.. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.</p>
<p>.. versionadded:: 1.1.0
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated in the
current iteration; if true all pixels are considered as candidates for
update, regardless of what happened in the previous iteration.
False by default.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>binary_opening : ndarray of bools
Opening of the input by the structuring element.</p>
<h2 id="see-also_22">See also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>grey_opening, binary_closing, binary_erosion, binary_dilation,
generate_binary_structure</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p><em>Opening</em> [1]<em> is a mathematical morphology operation [2]</em> that
consists in the succession of an erosion and a dilation of the
input with the same structuring element. Opening therefore removes
objects smaller than the structuring element.</p>
<p>Together with <em>closing</em> (<code>binary_closing</code>), opening can be used for
noise removal.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Opening_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5,5), dtype=int)
a[1:4, 1:4] = 1; a[4, 4] = 1
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 1]])</p>
<h1 id="opening-removes-small-objects">Opening removes small objects<a class="headerlink" href="#opening-removes-small-objects" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="opening-can-also-smooth-corners">Opening can also smooth corners<a class="headerlink" href="#opening-can-also-smooth-corners" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="opening-is-the-dilation-of-the-erosion-of-the-input">Opening is the dilation of the erosion of the input<a class="headerlink" href="#opening-is-the-dilation-of-the-erosion-of-the-input" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_erosion(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0]])
ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_propagation</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary propagation with the given structuring element.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary image to be propagated inside <code>mask</code>.
structure : array_like, optional
Structuring element used in the successive dilations. The output
may depend on the structuring element, especially if <code>mask</code> has
several connex components. If no structuring element is
provided, an element is generated with a squared connectivity equal
to one.
mask : array_like, optional
Binary mask defining the region into which <code>input</code> is allowed to
propagate.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>binary_propagation : ndarray
Binary propagation of <code>input</code> inside <code>mask</code>.</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>This function is functionally equivalent to calling binary_dilation
with the number of iterations less than one: iterative dilation until
the result does not change anymore.</p>
<p>The succession of an erosion and propagation inside the original image
can be used instead of an <em>opening</em> for deleting small objects while
keeping the contours of larger objects untouched.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.
.. [2] I.T. Young, J.J. Gerbrands, and L.J. van Vliet, 'Fundamentals of
image processing', 1998
ftp://qiftp.tudelft.nl/DIPimage/docs/FIP2.3.pdf</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
input = np.zeros((8, 8), dtype=int)
input[2, 2] = 1
mask = np.zeros((8, 8), dtype=int)
mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1
input
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])
mask
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 1, 1],
[0, 0, 0, 0, 0, 0, 1, 1]])
ndimage.binary_propagation(input, mask=mask).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_propagation(input, mask=mask,\
... structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="comparison-between-opening-and-erosionpropagation">Comparison between opening and erosion+propagation<a class="headerlink" href="#comparison-between-opening-and-erosionpropagation" title="Permanent link">&para;</a></h1>
<p>a = np.zeros((6,6), dtype=int)
a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1
a
array([[1, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 1]])
ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0]])
b = ndimage.binary_erosion(a)
b.astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0]])
ndimage.binary_propagation(b, mask=a).astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">black_tophat</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional black tophat filter.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : tuple of ints, optional
Shape of a flat and full structuring element used for the filter.
Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the black tophat filter.
structure : array of ints, optional
Structuring element used for the filter. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>black_tophat : ndarray
Result of the filter of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_23">See also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>white_tophat, grey_opening, grey_closing</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_bf</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sampling</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Distance transform function by a brute force algorithm.</p>
<p>This function calculates the distance transform of the <code>input</code>, by
replacing each foreground (non-zero) element, with its
shortest distance to the background (any zero-valued element).</p>
<p>In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input
metric : str, optional
Three types of distance metric are supported: 'euclidean', 'taxicab'
and 'chessboard'.
sampling : {int, sequence of ints}, optional
This parameter is only used in the case of the euclidean <code>metric</code>
distance transform.</p>
<p>The sampling along each axis can be given by the <code>sampling</code> parameter
which should be a sequence of length equal to the input rank, or a
single number in which the <code>sampling</code> is assumed to be equal along all
axes.
return_distances : bool, optional
The <code>return_distances</code> flag can be used to indicate if the distance
transform is returned.</p>
<p>The default is True.
return_indices : bool, optional
The <code>return_indices</code> flags can be used to indicate if the feature
transform is returned.</p>
<p>The default is False.
distances : float64 ndarray, optional
Optional output array to hold distances (if <code>return_distances</code> is
True).
indices : int64 ndarray, optional
Optional output array to hold indices (if <code>return_indices</code> is True).</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>distances : ndarray
Distance array if <code>return_distances</code> is True.
indices : ndarray
Indices array if <code>return_indices</code> is True.</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>This function employs a slow brute force algorithm, see also the
function distance_transform_cdt for more efficient taxicab and
chessboard algorithms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_cdt</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Chessboard</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Taxicab</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Distance transform for chamfer type of transforms.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input
metric : {'chessboard', 'taxicab'}, optional
The <code>metric</code> determines the type of chamfering that is done. If the
<code>metric</code> is equal to 'taxicab' a structure is generated using
generate_binary_structure with a squared distance equal to 1. If
the <code>metric</code> is equal to 'chessboard', a <code>metric</code> is generated
using generate_binary_structure with a squared distance equal to
the dimensionality of the array. These choices correspond to the
common interpretations of the 'taxicab' and the 'chessboard'
distance metrics in two dimensions.</p>
<p>The default for <code>metric</code> is 'chessboard'.
return_distances, return_indices : bool, optional
The <code>return_distances</code>, and <code>return_indices</code> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>If the feature transform is returned (<code>return_indices=True</code>),
the index of the closest background element is returned along
the first axis of the result.</p>
<p>The <code>return_distances</code> default is True, and the
<code>return_indices</code> default is False.
distances, indices : ndarrays of int32, optional
The <code>distances</code> and <code>indices</code> arguments can be used to give optional
output arrays that must be the same shape as <code>input</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_edt</span> <span class="o">:</span> <span class="o">?</span><span class="n">sampling</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_same</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exact euclidean distance transform.</p>
<p>In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input data to transform. Can be any type but will be converted
into binary: 1 wherever input equates to True, 0 elsewhere.
sampling : float or int, or sequence of same, optional
Spacing of elements along each dimension. If a sequence, must be of
length equal to the input rank; if a single number, this is used for
all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
Whether to return distance matrix. At least one of
return_distances/return_indices must be True. Default is True.
return_indices : bool, optional
Whether to return indices matrix. Default is False.
distances : ndarray, optional
Used for output of distance array, must be of type float64.
indices : ndarray, optional
Used for output of indices, must be of type int32.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>distance_transform_edt : ndarray or list of ndarrays
Either distance matrix, index matrix, or a list of the two,
depending on <code>return_x</code> flags and <code>distance</code> and <code>indices</code>
input parameters.</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>The euclidean distance transform gives values of the euclidean
distance::</p>
<p>n
y_i = sqrt(sum (x[i]-b[i])**2)
i</p>
<p>where b[i] is the background point (value 0) with the smallest
Euclidean distance to input points x[i], and n is the
number of dimensions.</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array(([0,1,1,1,1],
...               [0,0,1,1,1],
...               [0,1,1,1,1],
...               [0,1,1,1,0],
...               [0,1,1,0,0]))
ndimage.distance_transform_edt(a)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
[ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
[ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
[ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With a sampling of 2 units along x, 1 along y:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.distance_transform_edt(a, sampling=[2,1])
array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],
[ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],
[ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],
[ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Asking for indices as well:</p>
<blockquote>
<blockquote>
<blockquote>
<p>edt, inds = ndimage.distance_transform_edt(a, return_indices=True)
inds
array([[[0, 0, 1, 1, 3],
[1, 1, 1, 1, 3],
[2, 2, 1, 3, 3],
[3, 3, 4, 4, 3],
[4, 4, 4, 4, 4]],
[[0, 0, 1, 1, 4],
[0, 1, 1, 1, 4],
[0, 0, 1, 4, 4],
[0, 0, 3, 3, 4],
[0, 0, 3, 3, 4]]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With arrays provided for inplace outputs:</p>
<blockquote>
<blockquote>
<blockquote>
<p>indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)
ndimage.distance_transform_edt(a, return_indices=True, indices=indices)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
[ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
[ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
[ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])
indices
array([[[0, 0, 1, 1, 3],
[1, 1, 1, 1, 3],
[2, 2, 1, 3, 3],
[3, 3, 4, 4, 3],
[4, 4, 4, 4, 4]],
[[0, 0, 1, 1, 4],
[0, 1, 1, 1, 4],
[0, 0, 1, 4, 4],
[0, 0, 3, 3, 4],
[0, 0, 3, 3, 4]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generate_binary_structure</span> <span class="o">:</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">connectivity</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a binary structure for binary morphological operations.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>rank : int
Number of dimensions of the array to which the structuring element
will be applied, as returned by <code>np.ndim</code>.
connectivity : int
<code>connectivity</code> determines which elements of the output array belong
to the structure, i.e. are considered as neighbors of the central
element. Elements up to a squared distance of <code>connectivity</code> from
the center are considered neighbors. <code>connectivity</code> may range from 1
(no diagonal elements are neighbors) to <code>rank</code> (all elements are
neighbors).</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>output : ndarray of bools
Structuring element which may be used for binary morphological
operations, with <code>rank</code> dimensions and all dimensions equal to 3.</p>
<h2 id="see-also_24">See also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>iterate_structure, binary_dilation, binary_erosion</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p><code>generate_binary_structure</code> can only create structuring elements with
dimensions equal to 3, i.e. minimal dimensions. For larger structuring
elements, that are useful e.g. for eroding large objects, one may either
use   <code>iterate_structure</code>, or create directly custom arrays with
numpy functions such as <code>numpy.ones</code>.</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
struct = ndimage.generate_binary_structure(2, 1)
struct
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)
a = np.zeros((5,5))
a[2, 2] = 1
a
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)
b
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(b, structure=struct).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 1.,  1.,  1.,  1.,  1.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.]])
struct = ndimage.generate_binary_structure(2, 2)
struct
array([[ True,  True,  True],
[ True,  True,  True],
[ True,  True,  True]], dtype=bool)
struct = ndimage.generate_binary_structure(3, 1)
struct # no diagonal elements
array([[[False, False, False],
[False,  True, False],
[False, False, False]],
[[False,  True, False],
[ True,  True,  True],
[False,  True, False]],
[[False, False, False],
[False,  True, False],
[False, False, False]]], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_closing</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional greyscale closing.</p>
<p>A greyscale closing consists in the succession of a greyscale dilation,
and a greyscale erosion.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale closing is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
closing. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale closing.
structure : array of ints, optional
Structuring element used for the grayscale closing. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the closing may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>grey_closing : ndarray
Result of the grayscale closing of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_25">See also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>binary_closing, grey_dilation, grey_erosion, grey_opening,
generate_binary_structure</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>The action of a grayscale closing with a flat structuring element amounts
to smoothen deep local minima, whereas binary closing fills small holes.</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(36).reshape((6,6))
a[3,3] = 0
a
array([[ 0,  1,  2,  3,  4,  5],
[ 6,  7,  8,  9, 10, 11],
[12, 13, 14, 15, 16, 17],
[18, 19, 20,  0, 22, 23],
[24, 25, 26, 27, 28, 29],
[30, 31, 32, 33, 34, 35]])
ndimage.grey_closing(a, size=(3,3))
array([[ 7,  7,  8,  9, 10, 11],
[ 7,  7,  8,  9, 10, 11],
[13, 13, 14, 15, 16, 17],
[19, 19, 20, 20, 22, 23],
[25, 25, 26, 27, 28, 29],
[31, 31, 32, 33, 34, 35]])</p>
<h1 id="note-that-the-local-minimum-a33-has-disappeared">Note that the local minimum a[3,3] has disappeared<a class="headerlink" href="#note-that-the-local-minimum-a33-has-disappeared" title="Permanent link">&para;</a></h1>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_dilation</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a greyscale dilation, using either a structuring element,
or a footprint corresponding to a flat structuring element.</p>
<p>Grayscale dilation is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a maximum filter over a sliding window.</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale dilation is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
dilation. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale dilation. Non-zero values give the set of
neighbors of the center over which the maximum is chosen.
structure : array of ints, optional
Structuring element used for the grayscale dilation. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the dilation may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>grey_dilation : ndarray
Grayscale dilation of <code>input</code>.</p>
<h2 id="see-also_26">See also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>binary_dilation, grey_erosion, grey_closing, grey_opening
generate_binary_structure, maximum_filter</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>The grayscale dilation of an image input by a structuring element s defined
over a domain E is given by:</p>
<p>(input+s)(x) = max {input(y) + s(x-y), for y in E}</p>
<p>In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale dilation computes the maximum of the
input image inside a sliding window defined by E.</p>
<p>Grayscale dilation [1]<em> is a <em>mathematical morphology</em> operation [2]</em>.</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
a[4,4] = 2; a[2,3] = 3
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, footprint=np.ones((3,3)))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])
s = ndimage.generate_binary_structure(2,1)
s
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)
ndimage.grey_dilation(a, footprint=s)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 1, 3, 2, 1, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))
array([[1, 1, 1, 1, 1, 1, 1],
[1, 2, 4, 4, 4, 2, 1],
[1, 2, 4, 4, 4, 2, 1],
[1, 2, 4, 4, 4, 3, 1],
[1, 2, 2, 3, 3, 3, 1],
[1, 2, 2, 3, 3, 3, 1],
[1, 1, 1, 1, 1, 1, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_erosion</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a greyscale erosion, using either a structuring element,
or a footprint corresponding to a flat structuring element.</p>
<p>Grayscale erosion is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a minimum filter over a sliding window.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale erosion is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
erosion. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale erosion. Non-zero values give the set of
neighbors of the center over which the minimum is chosen.
structure : array of ints, optional
Structuring element used for the grayscale erosion. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the erosion may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Grayscale erosion of <code>input</code>.</p>
<h2 id="see-also_27">See also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>binary_erosion, grey_dilation, grey_opening, grey_closing
generate_binary_structure, minimum_filter</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>The grayscale erosion of an image input by a structuring element s defined
over a domain E is given by:</p>
<p>(input+s)(x) = min {input(y) - s(x-y), for y in E}</p>
<p>In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale erosion computes the minimum of the
input image inside a sliding window defined by E.</p>
<p>Grayscale erosion [1]<em> is a <em>mathematical morphology</em> operation [2]</em>.</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1:6, 1:6] = 3
a[4,4] = 2; a[2,3] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 1, 3, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 3, 2, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 3, 2, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
footprint = ndimage.generate_binary_structure(2, 1)
footprint
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)</p>
<h1 id="diagonally-connected-elements-are-not-considered-neighbors">Diagonally-connected elements are not considered neighbors<a class="headerlink" href="#diagonally-connected-elements-are-not-considered-neighbors" title="Permanent link">&para;</a></h1>
<p>ndimage.grey_erosion(a, size=(3,3), footprint=footprint)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 3, 1, 2, 0, 0],
[0, 0, 3, 2, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_opening</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional greyscale opening.</p>
<p>A greyscale opening consists in the succession of a greyscale erosion,
and a greyscale dilation.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale opening is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
opening. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale opening.
structure : array of ints, optional
Structuring element used for the grayscale opening. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the opening may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>grey_opening : ndarray
Result of the grayscale opening of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_28">See also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>binary_opening, grey_dilation, grey_erosion, grey_closing
generate_binary_structure</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>The action of a grayscale opening with a flat structuring element amounts
to smoothen high local maxima, whereas binary opening erases small objects.</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(36).reshape((6,6))
a[3, 3] = 50
a
array([[ 0,  1,  2,  3,  4,  5],
[ 6,  7,  8,  9, 10, 11],
[12, 13, 14, 15, 16, 17],
[18, 19, 20, 50, 22, 23],
[24, 25, 26, 27, 28, 29],
[30, 31, 32, 33, 34, 35]])
ndimage.grey_opening(a, size=(3,3))
array([[ 0,  1,  2,  3,  4,  4],
[ 6,  7,  8,  9, 10, 10],
[12, 13, 14, 15, 16, 16],
[18, 19, 20, 22, 22, 22],
[24, 25, 26, 27, 28, 28],
[24, 25, 26, 27, 28, 28]])</p>
<h1 id="note-that-the-local-maximum-a33-has-disappeared">Note that the local maximum a[3,3] has disappeared<a class="headerlink" href="#note-that-the-local-maximum-a33-has-disappeared" title="Permanent link">&para;</a></h1>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterate_structure</span> <span class="o">:</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Iterate a structure by dilating it with itself.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>structure : array_like
Structuring element (an array of bools, for example), to be dilated with
itself.
iterations : int
number of dilations performed on the structure with itself
origin : optional
If origin is None, only the iterated structure is returned. If
not, a tuple of the iterated structure and the modified origin is
returned.</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>iterate_structure : ndarray of bools
A new structuring element obtained by dilating <code>structure</code>
(<code>iterations</code> - 1) times with itself.</p>
<h2 id="see-also_29">See also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>generate_binary_structure</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
struct = ndimage.generate_binary_structure(2, 1)
struct.astype(int)
array([[0, 1, 0],
[1, 1, 1],
[0, 1, 0]])
ndimage.iterate_structure(struct, 2).astype(int)
array([[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[1, 1, 1, 1, 1],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0]])
ndimage.iterate_structure(struct, 3).astype(int)
array([[0, 0, 0, 1, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[1, 1, 1, 1, 1, 1, 1],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morphological_gradient</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional morphological gradient.</p>
<p>The morphological gradient is calculated as the difference between a
dilation and an erosion of the input with a given structuring element.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which to compute the morphlogical gradient.
size : tuple of ints
Shape of a flat and full structuring element used for the mathematical
morphology operations. Optional if <code>footprint</code> or <code>structure</code> is
provided. A larger <code>size</code> yields a more blurred gradient.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the morphology operations. Larger footprints
give a more blurred morphological gradient.
structure : array of ints, optional
Structuring element used for the morphology operations.
<code>structure</code> may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the morphological gradient
may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>morphological_gradient : ndarray
Morphological gradient of <code>input</code>.</p>
<h2 id="see-also_30">See also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>grey_dilation, grey_erosion, gaussian_gradient_magnitude</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>For a flat structuring element, the morphological gradient
computed at a given point corresponds to the maximal difference
between elements of the input among the elements covered by the
structuring element centered on the point.</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 0, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="the-morphological-gradient-is-computed-as-the-difference">The morphological gradient is computed as the difference<a class="headerlink" href="#the-morphological-gradient-is-computed-as-the-difference" title="Permanent link">&para;</a></h1>
<h1 id="between-a-dilation-and-an-erosion">between a dilation and an erosion<a class="headerlink" href="#between-a-dilation-and-an-erosion" title="Permanent link">&para;</a></h1>
<p>ndimage.grey_dilation(a, size=(3,3)) -\
...  ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 0, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
a[4,4] = 2; a[2,3] = 3
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 2, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morphological_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional morphological laplace.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : int or sequence of ints, optional
See <code>structure</code>.
footprint : bool or ndarray, optional
See <code>structure</code>.
structure : structure, optional
Either <code>size</code>, <code>footprint</code>, or the <code>structure</code> must be provided.
output : ndarray, optional
An output array can optionally be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The mode parameter determines how the array borders are handled.
For 'constant' mode, values beyond borders are set to be <code>cval</code>.
Default is 'reflect'.
cval : scalar, optional
Value to fill past edges of input if mode is 'constant'.
Default is 0.0
origin : origin, optional
The origin parameter controls the placement of the filter.</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>morphological_laplace : ndarray
Output</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">white_tophat</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional white tophat filter.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : tuple of ints
Shape of a flat and full structuring element used for the filter.
Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of elements of a flat structuring element
used for the white tophat filter.
structure : array of ints, optional
Structuring element used for the filter. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'.
Default is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default is 0.</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Result of the filter of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_31">See also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>black_tophat</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">affine_transform</span> <span class="o">:</span> <span class="o">?</span><span class="n">offset</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output_shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply an affine transformation.</p>
<p>Given an output image pixel index vector <code>o</code>, the pixel value
is determined from the input image at position
<code>np.dot(matrix, o) + offset</code>.</p>
<p>This does 'pull' (or 'backward') resampling, transforming the output space
to the input to locate data. Affine transformations are often described in
the 'push' (or 'forward') direction, transforming input to output. If you
have a matrix for the 'push' transformation, use its inverse
(:func:<code>numpy.linalg.inv</code>) in this function.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
matrix : ndarray
The inverse coordinate transformation matrix, mapping output
coordinates to input coordinates. If <code>ndim</code> is the number of
dimensions of <code>input</code>, the given matrix must have one of the
following shapes:</p>
<ul>
<li><code>(ndim, ndim)</code>: the linear transformation matrix for each
output coordinate.</li>
<li><code>(ndim,)</code>: assume that the 2D transformation matrix is
diagonal, with the diagonal specified by the given value. A more
efficient algorithm is then used that exploits the separability
of the problem.</li>
<li><code>(ndim + 1, ndim + 1)</code>: assume that the transformation is
specified using homogeneous coordinates [1]_. In this case, any
value passed to <code>offset</code> is ignored.</li>
<li><code>(ndim, ndim + 1)</code>: as above, but the bottom row of a
homogeneous transformation matrix is always <code>[0, 0, ..., 1]</code>,
and may be omitted.</li>
</ul>
<p>offset : float or sequence, optional
The offset into the array where the transform is applied. If a float,
<code>offset</code> is the same for each axis. If a sequence, <code>offset</code> should
contain one value for each axis.
output_shape : tuple of ints, optional
Shape tuple.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>affine_transform : ndarray
The transformed input.</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.</p>
<p>.. versionchanged:: 0.18.0
Previously, the exact interpretation of the affine transformation
depended on whether the matrix was supplied as a one-dimensional or
two-dimensional array. If a one-dimensional array was supplied
to the matrix parameter, the output pixel value at index <code>o</code>
was determined from the input image at position
<code>matrix * (o + offset)</code>.</p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Homogeneous_coordinates</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_closing</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary closing with the given structuring element.</p>
<p>The <em>closing</em> of an input image by a structuring element is the
<em>erosion</em> of the <em>dilation</em> of the image by the structuring element.</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be closed. Non-zero (True) elements form
the subset to be closed.
structure : array_like, optional
Structuring element used for the closing. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).
iterations : int, optional
The dilation step of the closing, then the erosion step are each
repeated <code>iterations</code> times (one, by default). If iterations is
less than 1, each operations is repeated until the result does
not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</p>
<p>.. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.</p>
<p>.. versionadded:: 1.1.0
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated in the
current iteration; if true al pixels are considered as candidates for
update, regardless of what happened in the previous iteration.
False by default.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>binary_closing : ndarray of bools
Closing of the input by the structuring element.</p>
<h2 id="see-also_32">See also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>grey_closing, binary_opening, binary_dilation, binary_erosion,
generate_binary_structure</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p><em>Closing</em> [1]<em> is a mathematical morphology operation [2]</em> that
consists in the succession of a dilation and an erosion of the
input with the same structuring element. Closing therefore fills
holes smaller than the structuring element.</p>
<p>Together with <em>opening</em> (<code>binary_opening</code>), closing can be used for
noise removal.</p>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Closing_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5,5), dtype=int)
a[1:-1, 1:-1] = 1; a[2,2] = 0
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="closing-removes-small-holes_1">Closing removes small holes<a class="headerlink" href="#closing-removes-small-holes_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="closing-is-the-erosion-of-the-dilation-of-the-input_1">Closing is the erosion of the dilation of the input<a class="headerlink" href="#closing-is-the-erosion-of-the-dilation-of-the-input_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_dilation(a).astype(int)
array([[0, 1, 1, 1, 0],
[1, 1, 1, 1, 1],
[1, 1, 1, 1, 1],
[1, 1, 1, 1, 1],
[0, 1, 1, 1, 0]])
ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<p>a = np.zeros((7,7), dtype=int)
a[1:6, 2:5] = 1; a[1:3,3] = 0
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="in-addition-to-removing-holes-closing-can-also_1">In addition to removing holes, closing can also<a class="headerlink" href="#in-addition-to-removing-holes-closing-can-also_1" title="Permanent link">&para;</a></h1>
<h1 id="coarsen-boundaries-with-fine-hollows_1">coarsen boundaries with fine hollows.<a class="headerlink" href="#coarsen-boundaries-with-fine-hollows_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_closing(a).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_closing(a, structure=np.ones((2,2))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_dilation</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary dilation with the given structuring element.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be dilated. Non-zero (True) elements form
the subset to be dilated.
structure : array_like, optional
Structuring element used for the dilation. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one.
iterations : int, optional
The dilation is repeated <code>iterations</code> times (one, by default).
If iterations is less than 1, the dilation is repeated until the
result does not change anymore. Only an integer of iterations is
accepted.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated (dilated)
in the current iteration; if True all pixels are considered as
candidates for dilation, regardless of what happened in the previous
iteration. False by default.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>binary_dilation : ndarray of bools
Dilation of the input by the structuring element.</p>
<h2 id="see-also_33">See also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>grey_dilation, binary_erosion, binary_closing, binary_opening,
generate_binary_structure</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>Dilation [1]<em> is a mathematical morphology operation [2]</em> that uses a
structuring element for expanding the shapes in an image. The binary
dilation of an image by a structuring element is the locus of the points
covered by the structuring element, when its center lies within the
non-zero points of the image.</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5, 5))
a[2, 2] = 1
a
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a)
array([[False, False, False, False, False],
[False, False,  True, False, False],
[False,  True,  True,  True, False],
[False, False,  True, False, False],
[False, False, False, False, False]], dtype=bool)
ndimage.binary_dilation(a).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])</p>
<h1 id="3x3-structuring-element-with-connectivity-1-used-by-default_1">3x3 structuring element with connectivity 1, used by default<a class="headerlink" href="#3x3-structuring-element-with-connectivity-1-used-by-default_1" title="Permanent link">&para;</a></h1>
<p>struct1 = ndimage.generate_binary_structure(2, 1)
struct1
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)</p>
<h1 id="3x3-structuring-element-with-connectivity-2_1">3x3 structuring element with connectivity 2<a class="headerlink" href="#3x3-structuring-element-with-connectivity-2_1" title="Permanent link">&para;</a></h1>
<p>struct2 = ndimage.generate_binary_structure(2, 2)
struct2
array([[ True,  True,  True],
[ True,  True,  True],
[ True,  True,  True]], dtype=bool)
ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(a, structure=struct1,\
... iterations=2).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 1.,  1.,  1.,  1.,  1.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_erosion</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary erosion with a given structuring element.</p>
<p>Binary erosion is a mathematical morphology operation used for image
processing.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary image to be eroded. Non-zero (True) elements form
the subset to be eroded.
structure : array_like, optional
Structuring element used for the erosion. Non-zero elements are
considered True. If no structuring element is provided, an element
is generated with a square connectivity equal to one.
iterations : int, optional
The erosion is repeated <code>iterations</code> times (one, by default).
If iterations is less than 1, the erosion is repeated until the
result does not change anymore.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated (eroded) in
the current iteration; if True all pixels are considered as candidates
for erosion, regardless of what happened in the previous iteration.
False by default.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>binary_erosion : ndarray of bools
Erosion of the input by the structuring element.</p>
<h2 id="see-also_34">See also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>grey_erosion, binary_dilation, binary_closing, binary_opening,
generate_binary_structure</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>Erosion [1]<em> is a mathematical morphology operation [2]</em> that uses a
structuring element for shrinking the shapes in an image. The binary
erosion of an image by a structuring element is the locus of the points
where a superimposition of the structuring element centered on the point
is entirely contained in the set of non-zero elements of the image.</p>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1:6, 2:5] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_erosion(a).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="erosion-removes-objects-smaller-than-the-structure_1">Erosion removes objects smaller than the structure<a class="headerlink" href="#erosion-removes-objects-smaller-than-the-structure_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_fill_holes</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Fill the holes in binary objects.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>input : array_like
n-dimensional binary array with holes to be filled
structure : array_like, optional
Structuring element used in the computation; large-size elements
make computations faster but may miss holes separated from the
background by thin regions. The default element (with a square
connectivity equal to one) yields the intuitive result where all
holes in the input have been filled.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int, tuple of ints, optional
Position of the structuring element.</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Transformation of the initial image <code>input</code> where holes have been
filled.</p>
<h2 id="see-also_35">See also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>binary_dilation, binary_propagation, label</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>The algorithm used in this function consists in invading the complementary
of the shapes in <code>input</code> from the outer boundary of the image,
using binary dilations. Holes are not connected to the boundary and are
therefore not invaded. The result is the complementary subset of the
invaded region.</p>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5, 5), dtype=int)
a[1:4, 1:4] = 1
a[2,2] = 0
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])
ndimage.binary_fill_holes(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="too-big-structuring-element_1">Too big structuring element<a class="headerlink" href="#too-big-structuring-element_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 0, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_hit_or_miss</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin1</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin2</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary hit-or-miss transform.</p>
<p>The hit-or-miss transform finds the locations of a given pattern
inside the input image.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>input : array_like (cast to booleans)
Binary image where a pattern is to be detected.
structure1 : array_like (cast to booleans), optional
Part of the structuring element to be fitted to the foreground
(non-zero elements) of <code>input</code>. If no value is provided, a
structure of square connectivity 1 is chosen.
structure2 : array_like (cast to booleans), optional
Second part of the structuring element that has to miss completely
the foreground. If no value is provided, the complementary of
<code>structure1</code> is taken.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin1 : int or tuple of ints, optional
Placement of the first part of the structuring element <code>structure1</code>,
by default 0 for a centered structure.
origin2 : int or tuple of ints, optional
Placement of the second part of the structuring element <code>structure2</code>,
by default 0 for a centered structure. If a value is provided for
<code>origin1</code> and not for <code>origin2</code>, then <code>origin2</code> is set to <code>origin1</code>.</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>binary_hit_or_miss : ndarray
Hit-or-miss transform of <code>input</code> with the given structuring
element (<code>structure1</code>, <code>structure2</code>).</p>
<h2 id="see-also_36">See also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>binary_erosion</p>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Hit-or-miss_transform</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0],
[0, 0, 0, 0, 1, 1, 0],
[0, 0, 0, 0, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])
structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])
structure1
array([[1, 0, 0],
[0, 1, 1],
[0, 1, 1]])</p>
<h1 id="find-the-matches-of-structure1-in-the-array-a_1">Find the matches of structure1 in the array a<a class="headerlink" href="#find-the-matches-of-structure1-in-the-array-a_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="change-the-origin-of-the-filter_1">Change the origin of the filter<a class="headerlink" href="#change-the-origin-of-the-filter_1" title="Permanent link">&para;</a></h1>
<h1 id="origin11-is-equivalent-to-origin111-here_1">origin1=1 is equivalent to origin1=(1,1) here<a class="headerlink" href="#origin11-is-equivalent-to-origin111-here_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_hit_or_miss(a, structure1=structure1,\
... origin1=1).astype(int)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_opening</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">brute_force</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary opening with the given structuring element.</p>
<p>The <em>opening</em> of an input image by a structuring element is the
<em>dilation</em> of the <em>erosion</em> of the image by the structuring element.</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary array_like to be opened. Non-zero (True) elements form
the subset to be opened.
structure : array_like, optional
Structuring element used for the opening. Non-zero elements are
considered True. If no structuring element is provided an element
is generated with a square connectivity equal to one (i.e., only
nearest neighbors are connected to the center, diagonally-connected
elements are not considered neighbors).
iterations : int, optional
The erosion step of the opening, then the dilation step are each
repeated <code>iterations</code> times (one, by default). If <code>iterations</code> is
less than 1, each operation is repeated until the result does
not change anymore. Only an integer of iterations is accepted.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.
mask : array_like, optional
If a mask is given, only those elements with a True value at
the corresponding mask element are modified at each iteration.</p>
<p>.. versionadded:: 1.1.0
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.</p>
<p>.. versionadded:: 1.1.0
brute_force : boolean, optional
Memory condition: if False, only the pixels whose value was changed in
the last iteration are tracked as candidates to be updated in the
current iteration; if true all pixels are considered as candidates for
update, regardless of what happened in the previous iteration.
False by default.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>binary_opening : ndarray of bools
Opening of the input by the structuring element.</p>
<h2 id="see-also_37">See also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>grey_opening, binary_closing, binary_erosion, binary_dilation,
generate_binary_structure</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p><em>Opening</em> [1]<em> is a mathematical morphology operation [2]</em> that
consists in the succession of an erosion and a dilation of the
input with the same structuring element. Opening therefore removes
objects smaller than the structuring element.</p>
<p>Together with <em>closing</em> (<code>binary_closing</code>), opening can be used for
noise removal.</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Opening_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((5,5), dtype=int)
a[1:4, 1:4] = 1; a[4, 4] = 1
a
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 1]])</p>
<h1 id="opening-removes-small-objects_1">Opening removes small objects<a class="headerlink" href="#opening-removes-small-objects_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 1, 1, 1, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="opening-can-also-smooth-corners_1">Opening can also smooth corners<a class="headerlink" href="#opening-can-also-smooth-corners_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])</p>
<h1 id="opening-is-the-dilation-of-the-erosion-of-the-input_1">Opening is the dilation of the erosion of the input<a class="headerlink" href="#opening-is-the-dilation-of-the-erosion-of-the-input_1" title="Permanent link">&para;</a></h1>
<p>ndimage.binary_erosion(a).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0]])
ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int)
array([[0, 0, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">binary_propagation</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">border_value</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional binary propagation with the given structuring element.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>input : array_like
Binary image to be propagated inside <code>mask</code>.
structure : array_like, optional
Structuring element used in the successive dilations. The output
may depend on the structuring element, especially if <code>mask</code> has
several connex components. If no structuring element is
provided, an element is generated with a squared connectivity equal
to one.
mask : array_like, optional
Binary mask defining the region into which <code>input</code> is allowed to
propagate.
output : ndarray, optional
Array of the same shape as input, into which the output is placed.
By default, a new array is created.
border_value : int (cast to 0 or 1), optional
Value at the border in the output array.
origin : int or tuple of ints, optional
Placement of the filter, by default 0.</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>binary_propagation : ndarray
Binary propagation of <code>input</code> inside <code>mask</code>.</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>This function is functionally equivalent to calling binary_dilation
with the number of iterations less than one: iterative dilation until
the result does not change anymore.</p>
<p>The succession of an erosion and propagation inside the original image
can be used instead of an <em>opening</em> for deleting small objects while
keeping the contours of larger objects untouched.</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>.. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.
.. [2] I.T. Young, J.J. Gerbrands, and L.J. van Vliet, 'Fundamentals of
image processing', 1998
ftp://qiftp.tudelft.nl/DIPimage/docs/FIP2.3.pdf</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
input = np.zeros((8, 8), dtype=int)
input[2, 2] = 1
mask = np.zeros((8, 8), dtype=int)
mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1
input
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])
mask
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 1, 1],
[0, 0, 0, 0, 0, 0, 1, 1]])
ndimage.binary_propagation(input, mask=mask).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])
ndimage.binary_propagation(input, mask=mask,\
... structure=np.ones((3,3))).astype(int)
array([[0, 0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="comparison-between-opening-and-erosionpropagation_1">Comparison between opening and erosion+propagation<a class="headerlink" href="#comparison-between-opening-and-erosionpropagation_1" title="Permanent link">&para;</a></h1>
<p>a = np.zeros((6,6), dtype=int)
a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1
a
array([[1, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 1]])
ndimage.binary_opening(a).astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0]])
b = ndimage.binary_erosion(a)
b.astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 1, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0]])
ndimage.binary_propagation(b, mask=a).astype(int)
array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">black_tophat</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional black tophat filter.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : tuple of ints, optional
Shape of a flat and full structuring element used for the filter.
Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the black tophat filter.
structure : array of ints, optional
Structuring element used for the filter. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>black_tophat : ndarray
Result of the filter of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_38">See also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>white_tophat, grey_opening, grey_closing</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">center_of_mass</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the center of mass of the values of an array at labels.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>input : ndarray
Data from which to calculate center-of-mass. The masses can either
be positive or negative.
labels : ndarray, optional
Labels for objects in <code>input</code>, as generated by <code>ndimage.label</code>.
Only used with <code>index</code>.  Dimensions must be the same as <code>input</code>.
index : int or sequence of ints, optional
Labels for which to calculate centers-of-mass. If not specified,
all labels greater than zero are used.  Only used with <code>labels</code>.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>center_of_mass : tuple, or list of tuples
Coordinates of centers-of-mass.</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array(([0,0,0,0],
...               [0,1,1,0],
...               [0,1,1,0],
...               [0,1,1,0]))
from scipy import ndimage
ndimage.measurements.center_of_mass(a)
(2.0, 1.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculation of multiple objects in an image</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array(([0,1,1,0],
...               [0,1,0,0],
...               [0,0,0,0],
...               [0,0,1,1],
...               [0,0,1,1]))
lbl = ndimage.label(b)[0]
ndimage.measurements.center_of_mass(b, lbl, [1,2])
[(0.33333333333333331, 1.3333333333333333), (3.5, 2.5)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Negative masses are also accepted, which can occur for example when
bias is removed from measured data due to random noise.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array(([-1,0,0,0],
...               [0,-1,-1,0],
...               [0,1,-1,0],
...               [0,1,1,0]))
ndimage.measurements.center_of_mass(c)
(-4.0, 1.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there are division by zero issues, the function does not raise an
error but rather issues a RuntimeWarning before returning inf and/or NaN.</p>
<blockquote>
<blockquote>
<blockquote>
<p>d = np.array([-1, 1])
ndimage.measurements.center_of_mass(d)
(inf,)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional convolution.</p>
<p>The array is convolved with the given kernel.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : array_like
Array of weights, same number of dimensions as input
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>result : ndarray
The result of convolution of <code>input</code> with <code>weights</code>.</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>correlate : Correlate an image with a kernel.</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>Each value in result is :math:<code>C_i = \sum_j{I_{i+k-j} W_j}</code>, where
W is the <code>weights</code> kernel,
j is the n-D spatial index over :math:<code>W</code>,
I is the <code>input</code> and k is the coordinate of the center of
W, specified by <code>origin</code> in the input parameters.</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<p>Perhaps the simplest case to understand is <code>mode='constant', cval=0.0</code>,
because in this case borders (i.e. where the <code>weights</code> kernel, centered
on any one value, extends beyond an edge of <code>input</code>) are treated as zeros.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
k = np.array([[1,1,1],[1,1,0],[1,0,0]])
from scipy import ndimage
ndimage.convolve(a, k, mode='constant', cval=0.0)
array([[11, 10,  7,  4],
[10,  3, 11, 11],
[15, 12, 14,  7],
[12,  3,  7,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Setting <code>cval=1.0</code> is equivalent to padding the outer edge of <code>input</code>
with 1.0's (and then extracting only the original region of the result).</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.convolve(a, k, mode='constant', cval=1.0)
array([[13, 11,  8,  7],
[11,  3, 11, 14],
[16, 12, 14, 10],
[15,  6, 10,  5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>mode='reflect'</code> (the default), outer values are reflected at the
edge of <code>input</code> to fill in missing values.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([[2, 0, 0],
...               [1, 0, 0],
...               [0, 0, 0]])
k = np.array([[0,1,0], [0,1,0], [0,1,0]])
ndimage.convolve(b, k, mode='reflect')
array([[5, 0, 0],
[3, 0, 0],
[1, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This includes diagonally at the corners.</p>
<blockquote>
<blockquote>
<blockquote>
<p>k = np.array([[1,0,0],[0,1,0],[0,0,1]])
ndimage.convolve(b, k)
array([[4, 2, 0],
[3, 2, 0],
[1, 1, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>mode='nearest'</code>, the single nearest value in to an edge in
<code>input</code> is repeated as many times as needed to match the overlapping
<code>weights</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([[2, 0, 1],
...               [1, 0, 0],
...               [0, 0, 0]])
k = np.array([[0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0],
...               [0, 1, 0]])
ndimage.convolve(c, k, mode='nearest')
array([[7, 0, 3],
[5, 0, 2],
[3, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional convolution along the given axis.</p>
<p>The lines of the array along the given axis are convolved with the
given weights.</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : ndarray
One-dimensional sequence of numbers.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>convolve1d : ndarray
Convolved array with same shape as input</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import convolve1d
convolve1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
array([14, 24,  4, 13, 12, 36, 27,  0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional correlation.</p>
<p>The array is correlated with the given kernel.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : ndarray
array of weights, same number of dimensions as input
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>convolve : Convolve an image with a kernel.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional correlation along the given axis.</p>
<p>The lines of the array along the given axis are correlated with the
given weights.</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
weights : array
One-dimensional sequence of numbers.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import correlate1d
correlate1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3])
array([ 8, 26,  8, 12,  7, 28, 36,  9])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_bf</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sampling</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Distance transform function by a brute force algorithm.</p>
<p>This function calculates the distance transform of the <code>input</code>, by
replacing each foreground (non-zero) element, with its
shortest distance to the background (any zero-valued element).</p>
<p>In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input
metric : str, optional
Three types of distance metric are supported: 'euclidean', 'taxicab'
and 'chessboard'.
sampling : {int, sequence of ints}, optional
This parameter is only used in the case of the euclidean <code>metric</code>
distance transform.</p>
<p>The sampling along each axis can be given by the <code>sampling</code> parameter
which should be a sequence of length equal to the input rank, or a
single number in which the <code>sampling</code> is assumed to be equal along all
axes.
return_distances : bool, optional
The <code>return_distances</code> flag can be used to indicate if the distance
transform is returned.</p>
<p>The default is True.
return_indices : bool, optional
The <code>return_indices</code> flags can be used to indicate if the feature
transform is returned.</p>
<p>The default is False.
distances : float64 ndarray, optional
Optional output array to hold distances (if <code>return_distances</code> is
True).
indices : int64 ndarray, optional
Optional output array to hold indices (if <code>return_indices</code> is True).</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>distances : ndarray
Distance array if <code>return_distances</code> is True.
indices : ndarray
Indices array if <code>return_indices</code> is True.</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>This function employs a slow brute force algorithm, see also the
function distance_transform_cdt for more efficient taxicab and
chessboard algorithms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_cdt</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Chessboard</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Taxicab</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Distance transform for chamfer type of transforms.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input
metric : {'chessboard', 'taxicab'}, optional
The <code>metric</code> determines the type of chamfering that is done. If the
<code>metric</code> is equal to 'taxicab' a structure is generated using
generate_binary_structure with a squared distance equal to 1. If
the <code>metric</code> is equal to 'chessboard', a <code>metric</code> is generated
using generate_binary_structure with a squared distance equal to
the dimensionality of the array. These choices correspond to the
common interpretations of the 'taxicab' and the 'chessboard'
distance metrics in two dimensions.</p>
<p>The default for <code>metric</code> is 'chessboard'.
return_distances, return_indices : bool, optional
The <code>return_distances</code>, and <code>return_indices</code> flags can be used to
indicate if the distance transform, the feature transform, or both
must be returned.</p>
<p>If the feature transform is returned (<code>return_indices=True</code>),
the index of the closest background element is returned along
the first axis of the result.</p>
<p>The <code>return_distances</code> default is True, and the
<code>return_indices</code> default is False.
distances, indices : ndarrays of int32, optional
The <code>distances</code> and <code>indices</code> arguments can be used to give optional
output arrays that must be the same shape as <code>input</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_transform_edt</span> <span class="o">:</span> <span class="o">?</span><span class="n">sampling</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_same</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_distances</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distances</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">indices</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exact euclidean distance transform.</p>
<p>In addition to the distance transform, the feature transform can
be calculated. In this case the index of the closest background
element is returned along the first axis of the result.</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input data to transform. Can be any type but will be converted
into binary: 1 wherever input equates to True, 0 elsewhere.
sampling : float or int, or sequence of same, optional
Spacing of elements along each dimension. If a sequence, must be of
length equal to the input rank; if a single number, this is used for
all axes. If not specified, a grid spacing of unity is implied.
return_distances : bool, optional
Whether to return distance matrix. At least one of
return_distances/return_indices must be True. Default is True.
return_indices : bool, optional
Whether to return indices matrix. Default is False.
distances : ndarray, optional
Used for output of distance array, must be of type float64.
indices : ndarray, optional
Used for output of indices, must be of type int32.</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>distance_transform_edt : ndarray or list of ndarrays
Either distance matrix, index matrix, or a list of the two,
depending on <code>return_x</code> flags and <code>distance</code> and <code>indices</code>
input parameters.</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>The euclidean distance transform gives values of the euclidean
distance::</p>
<p>n
y_i = sqrt(sum (x[i]-b[i])**2)
i</p>
<p>where b[i] is the background point (value 0) with the smallest
Euclidean distance to input points x[i], and n is the
number of dimensions.</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array(([0,1,1,1,1],
...               [0,0,1,1,1],
...               [0,1,1,1,1],
...               [0,1,1,1,0],
...               [0,1,1,0,0]))
ndimage.distance_transform_edt(a)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
[ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
[ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
[ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With a sampling of 2 units along x, 1 along y:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.distance_transform_edt(a, sampling=[2,1])
array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],
[ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],
[ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],
[ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Asking for indices as well:</p>
<blockquote>
<blockquote>
<blockquote>
<p>edt, inds = ndimage.distance_transform_edt(a, return_indices=True)
inds
array([[[0, 0, 1, 1, 3],
[1, 1, 1, 1, 3],
[2, 2, 1, 3, 3],
[3, 3, 4, 4, 3],
[4, 4, 4, 4, 4]],
[[0, 0, 1, 1, 4],
[0, 1, 1, 1, 4],
[0, 0, 1, 4, 4],
[0, 0, 3, 3, 4],
[0, 0, 3, 3, 4]]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With arrays provided for inplace outputs:</p>
<blockquote>
<blockquote>
<blockquote>
<p>indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)
ndimage.distance_transform_edt(a, return_indices=True, indices=indices)
array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],
[ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],
[ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],
[ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],
[ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])
indices
array([[[0, 0, 1, 1, 3],
[1, 1, 1, 1, 3],
[2, 2, 1, 3, 3],
[3, 3, 4, 4, 3],
[4, 4, 4, 4, 4]],
[[0, 0, 1, 1, 4],
[0, 1, 1, 1, 4],
[0, 0, 1, 4, 4],
[0, 0, 3, 3, 4],
[0, 0, 3, 3, 4]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">extrema</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimums and maximums of the values of an array
at labels, along with their positions.</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>input : ndarray
Nd-image data to process.
labels : ndarray, optional
Labels of features in input.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
Labels to include in output.  If None (default), all values where
non-zero <code>labels</code> are used.</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>minimums, maximums : int or ndarray
Values of minimums and maximums in each feature.
min_positions, max_positions : tuple or list of tuples
Each tuple gives the n-D coordinates of the corresponding minimum
or maximum.</p>
<h2 id="see-also_41">See Also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>maximum, minimum, maximum_position, minimum_position, center_of_mass</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.extrema(a)
(0, 9, (0, 2), (3, 0))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.extrema(a, lbl, index=np.arange(1, nlbl+1))
(array([1, 4, 3]),
array([5, 7, 9]),
[(0, 0), (1, 3), (3, 1)],
[(1, 0), (2, 3), (3, 0)])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.extrema(a, lbl)
(1, 9, (0, 0), (3, 0))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_objects</span> <span class="o">:</span> <span class="o">?</span><span class="n">max_label</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find objects in a labeled array.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>input : ndarray of ints
Array containing objects defined by different labels. Labels with
value 0 are ignored.
max_label : int, optional
Maximum label to be searched for in <code>input</code>. If max_label is not
given, the positions of all objects are returned.</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>object_slices : list of tuples
A list of tuples, with each tuple containing N slices (with N the
dimension of the input array).  Slices correspond to the minimal
parallelepiped that contains the object. If a number is missing,
None is returned instead of a slice.</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>label, center_of_mass</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>This function is very useful for isolating a volume of interest inside
a 3-D array, that cannot be 'seen through'.</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((6,6), dtype=int)
a[2:4, 2:4] = 1
a[4, 4] = 1
a[:2, :3] = 2
a[0, 5] = 3
a
array([[2, 2, 2, 0, 0, 3],
[2, 2, 2, 0, 0, 0],
[0, 0, 1, 1, 0, 0],
[0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0]])
ndimage.find_objects(a)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None)), (slice(0, 1, None), slice(5, 6, None))]
ndimage.find_objects(a, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))]
ndimage.find_objects(a == 1, max_label=2)
[(slice(2, 5, None), slice(2, 5, None)), None]</p>
<p>loc = ndimage.find_objects(a)[0]
a[loc]
array([[1, 1, 0],
[1, 1, 0],
[0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_ellipsoid</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional ellipsoid fourier filter.</p>
<p>The array is multiplied with the fourier transform of a ellipsoid of
given sizes.</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : float or sequence
The size of the box used for filtering.
If a float, <code>size</code> is the same for all axes. If a sequence, <code>size</code> has
to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>fourier_ellipsoid : ndarray
The filtered input.</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>This function is implemented for arrays of rank 1, 2, or 3.</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_ellipsoid(input_, size=20)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional Gaussian fourier filter.</p>
<p>The array is multiplied with the fourier transform of a Gaussian
kernel.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : float or sequence
The sigma of the Gaussian kernel. If a float, <code>sigma</code> is the same for
all axes. If a sequence, <code>sigma</code> has to contain one value for each
axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>fourier_gaussian : ndarray
The filtered input.</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_gaussian(input_, sigma=4)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shift</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional fourier shift filter.</p>
<p>The array is multiplied with the fourier transform of a shift operation.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
shift : float or sequence
The size of the box used for filtering.
If a float, <code>shift</code> is the same for all axes. If a sequence, <code>shift</code>
has to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of shifting the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>fourier_shift : ndarray
The shifted input.</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
import numpy.fft
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_shift(input_, shift=200)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fourier_uniform</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional uniform fourier filter.</p>
<p>The array is multiplied with the fourier transform of a box of given
size.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : float or sequence
The size of the box used for filtering.
If a float, <code>size</code> is the same for all axes. If a sequence, <code>size</code> has
to contain one value for each axis.
n : int, optional
If <code>n</code> is negative (default), then the input is assumed to be the
result of a complex fft.
If <code>n</code> is larger than or equal to zero, the input is assumed to be the
result of a real fft, and <code>n</code> gives the length of the array before
transformation along the real transform direction.
axis : int, optional
The axis of the real transform.
output : ndarray, optional
If given, the result of filtering the input is placed in this array.
None is returned in this case.</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>fourier_uniform : ndarray
The filtered input.</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import numpy.fft
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2)
plt.gray()  # show the filtered result in grayscale
ascent = misc.ascent()
input_ = numpy.fft.fft2(ascent)
result = ndimage.fourier_uniform(input_, size=20)
result = numpy.fft.ifft2(result)
ax1.imshow(ascent)
ax2.imshow(result.real)  # the imaginary part is an artifact
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional Gaussian filter.</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
Standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.
order : int or sequence of ints, optional
The order of the filter along each axis is given as a sequence
of integers, or as a single number.  An order of 0 corresponds
to convolution with a Gaussian kernel. A positive order
corresponds to convolution with that derivative of a Gaussian.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
truncate : float
Truncate the filter at this many standard deviations.
Default is 4.0.</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>gaussian_filter : ndarray
Returned array of same shape as <code>input</code>.</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>The multidimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import gaussian_filter
a = np.arange(50, step=2).reshape((5,5))
a
array([[ 0,  2,  4,  6,  8],
[10, 12, 14, 16, 18],
[20, 22, 24, 26, 28],
[30, 32, 34, 36, 38],
[40, 42, 44, 46, 48]])
gaussian_filter(a, sigma=1)
array([[ 4,  6,  8,  9, 11],
[10, 12, 14, 15, 17],
[20, 22, 24, 25, 27],
[29, 31, 33, 34, 36],
[35, 37, 39, 40, 42]])</p>
<p>from scipy import misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = gaussian_filter(ascent, sigma=5)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>One-dimensional Gaussian filter.</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar
standard deviation for Gaussian kernel
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
order : int, optional
An order of 0 corresponds to convolution with a Gaussian
kernel. A positive order corresponds to convolution with
that derivative of a Gaussian.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
truncate : float, optional
Truncate the filter at this many standard deviations.
Default is 4.0.</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>gaussian_filter1d : ndarray</p>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import gaussian_filter1d
gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 1)
array([ 1.42704095,  2.06782203,  3.        ,  3.93217797,  4.57295905])
gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 4)
array([ 2.91948343,  2.95023502,  3.        ,  3.04976498,  3.08051657])
import matplotlib.pyplot as plt
np.random.seed(280490)
x = np.random.randn(101).cumsum()
y3 = gaussian_filter1d(x, 3)
y6 = gaussian_filter1d(x, 6)
plt.plot(x, 'k', label='original data')
plt.plot(y3, '--', label='filtered, sigma=3')
plt.plot(y6, ':', label='filtered, sigma=6')
plt.legend()
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_gradient_magnitude</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional gradient magnitude using Gaussian derivatives.</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes..
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
Extra keyword arguments will be passed to gaussian_filter().</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>gaussian_gradient_magnitude : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.gaussian_gradient_magnitude(ascent, sigma=5)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sigma</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multidimensional Laplace filter using gaussian second derivatives.</p>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
sigma : scalar or sequence of scalars
The standard deviations of the Gaussian filter are given for
each axis as a sequence, or as a single number, in which case
it is equal for all axes.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
Extra keyword arguments will be passed to gaussian_filter().</p>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
ascent = misc.ascent()</p>
<p>fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side</p>
<p>result = ndimage.gaussian_laplace(ascent, sigma=1)
ax1.imshow(result)</p>
<p>result = ndimage.gaussian_laplace(ascent, sigma=3)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generate_binary_structure</span> <span class="o">:</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">connectivity</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate a binary structure for binary morphological operations.</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>rank : int
Number of dimensions of the array to which the structuring element
will be applied, as returned by <code>np.ndim</code>.
connectivity : int
<code>connectivity</code> determines which elements of the output array belong
to the structure, i.e. are considered as neighbors of the central
element. Elements up to a squared distance of <code>connectivity</code> from
the center are considered neighbors. <code>connectivity</code> may range from 1
(no diagonal elements are neighbors) to <code>rank</code> (all elements are
neighbors).</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>output : ndarray of bools
Structuring element which may be used for binary morphological
operations, with <code>rank</code> dimensions and all dimensions equal to 3.</p>
<h2 id="see-also_43">See also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>iterate_structure, binary_dilation, binary_erosion</p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p><code>generate_binary_structure</code> can only create structuring elements with
dimensions equal to 3, i.e. minimal dimensions. For larger structuring
elements, that are useful e.g. for eroding large objects, one may either
use   <code>iterate_structure</code>, or create directly custom arrays with
numpy functions such as <code>numpy.ones</code>.</p>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
struct = ndimage.generate_binary_structure(2, 1)
struct
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)
a = np.zeros((5,5))
a[2, 2] = 1
a
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)
b
array([[ 0.,  0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  0.,  0.]])
ndimage.binary_dilation(b, structure=struct).astype(a.dtype)
array([[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  1.,  1.,  1.,  0.],
[ 1.,  1.,  1.,  1.,  1.],
[ 0.,  1.,  1.,  1.,  0.],
[ 0.,  0.,  1.,  0.,  0.]])
struct = ndimage.generate_binary_structure(2, 2)
struct
array([[ True,  True,  True],
[ True,  True,  True],
[ True,  True,  True]], dtype=bool)
struct = ndimage.generate_binary_structure(3, 1)
struct # no diagonal elements
array([[[False, False, False],
[False,  True, False],
[False, False, False]],
[[False,  True, False],
[ True,  True,  True],
[False,  True, False]],
[[False, False, False],
[False,  True, False],
[False, False, False]]], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional filter using the given function.</p>
<p>At each element the provided function is called. The input values
within the filter footprint at that element are passed to the function
as a 1D array of double values.</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
function : {callable, scipy.LowLevelCallable}
Function to apply at each element.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one of
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int callback(double <em>buffer, npy_intp filter_size,
double </em>return_value, void <em>user_data)
int callback(double </em>buffer, intptr_t filter_size,
double <em>return_value, void </em>user_data)</p>
<p>The calling function iterates over the elements of the input and
output arrays, calling the callback function at each element. The
elements within the footprint of the filter at the current element are
passed through the <code>buffer</code> parameter, and the number of elements
within the footprint through <code>filter_size</code>. The calculated value is
returned in <code>return_value</code>. <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">filter_size</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional filter along the given axis.</p>
<p><code>generic_filter1d</code> iterates over the lines of the array, calling the
given function at each line. The arguments of the line are the
input line, and the output line. The input and output lines are 1D
double arrays.  The input line is extended appropriately according
to the filter size and origin. The output line must be modified
in-place with the result.</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
function : {callable, scipy.LowLevelCallable}
Function to apply along given axis.
filter_size : scalar
Length of the filter.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one of
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int function(double <em>input_line, npy_intp input_length,
double </em>output_line, npy_intp output_length,
void <em>user_data)
int function(double </em>input_line, intptr_t input_length,
double <em>output_line, intptr_t output_length,
void </em>user_data)</p>
<p>The calling function iterates over the lines of the input and output
arrays, calling the callback function at each line. The current line
is extended according to the border conditions set by the calling
function, and the result is copied into the array that is passed
through <code>input_line</code>. The length of the input line (after extension)
is passed through <code>input_length</code>. The callback function should apply
the filter and store the result in the array passed through
<code>output_line</code>. The length of the output line is passed through
<code>output_length</code>. <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_gradient_magnitude</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derivative</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gradient magnitude using a provided gradient function.</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
derivative : callable
Callable with the following signature::</p>
<p>derivative(input, axis, output, mode, cval,
<em>extra_arguments, </em>*extra_keywords)</p>
<p>See <code>extra_arguments</code>, <code>extra_keywords</code> below.
<code>derivative</code> can assume that <code>input</code> and <code>output</code> are ndarrays.
Note that the output from <code>derivative</code> is modified inplace;
be careful to copy important inputs before returning them.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">generic_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">derivative2</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>N-dimensional Laplace filter using a provided second derivative function.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
derivative2 : callable
Callable with the following signature::</p>
<p>derivative2(input, axis, output, mode, cval,
<em>extra_arguments, </em>*extra_keywords)</p>
<p>See <code>extra_arguments</code>, <code>extra_keywords</code> below.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
extra_keywords : dict, optional
dict of extra keyword arguments to pass to passed function.
extra_arguments : sequence, optional
Sequence of extra positional arguments to pass to passed function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">geometric_transform</span> <span class="o">:</span> <span class="o">?</span><span class="n">output_shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_arguments</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">extra_keywords</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mapping</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Scipy_LowLevelCallable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply an arbitrary geometric transform.</p>
<p>The given mapping function is used to find, for each point in the
output, the corresponding coordinates in the input. The value of the
input at those coordinates is determined by spline interpolation of
the requested order.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
mapping : {callable, scipy.LowLevelCallable}
A callable object that accepts a tuple of length equal to the output
array rank, and returns the corresponding input coordinates as a tuple
of length equal to the input array rank.
output_shape : tuple of ints, optional
Shape tuple.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.
extra_arguments : tuple, optional
Extra arguments passed to <code>mapping</code>.
extra_keywords : dict, optional
Extra keywords passed to <code>mapping</code>.</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>output : ndarray
The filtered input.</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>map_coordinates, affine_transform, spline_filter1d</p>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p>This function also accepts low-level callback functions with one
the following signatures and wrapped in <code>scipy.LowLevelCallable</code>:</p>
<p>.. code:: c</p>
<p>int mapping(npy_intp <em>output_coordinates, double </em>input_coordinates,
int output_rank, int input_rank, void <em>user_data)
int mapping(intptr_t </em>output_coordinates, double <em>input_coordinates,
int output_rank, int input_rank, void </em>user_data)</p>
<p>The calling function iterates over the elements of the output array,
calling the callback function at each element. The coordinates of the
current output element are passed through <code>output_coordinates</code>. The
callback function must return the coordinates at which the input must
be interpolated in <code>input_coordinates</code>. The rank of the input and
output arrays are given by <code>input_rank</code> and <code>output_rank</code>
respectively.  <code>user_data</code> is the data pointer provided
to <code>scipy.LowLevelCallable</code> as-is.</p>
<p>The callback function must return an integer error status that is zero
if something went wrong and one otherwise. If an error occurs, you should
normally set the python error status with an informative message
before returning, otherwise a default error message is set by the
calling function.</p>
<p>In addition, some other low-level function pointer specifications
are accepted, but these are for backward compatibility only and should
not be used in new code.</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.ndimage import geometric_transform
a = np.arange(12.).reshape((4, 3))
def shift_func(output_coords):
...     return (output_coords[0] - 0.5, output_coords[1] - 0.5)
...
geometric_transform(a, shift_func)
array([[ 0.   ,  0.   ,  0.   ],
[ 0.   ,  1.362,  2.738],
[ 0.   ,  4.812,  6.187],
[ 0.   ,  8.263,  9.637]])</p>
<p>b = [1, 2, 3, 4, 5]
def shift_func(output_coords):
...     return (output_coords[0] - 3,)
...
geometric_transform(b, shift_func, mode='constant')
array([0, 0, 0, 1, 2])
geometric_transform(b, shift_func, mode='nearest')
array([1, 1, 1, 1, 2])
geometric_transform(b, shift_func, mode='reflect')
array([3, 2, 1, 1, 2])
geometric_transform(b, shift_func, mode='wrap')
array([2, 3, 4, 1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_closing</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional greyscale closing.</p>
<p>A greyscale closing consists in the succession of a greyscale dilation,
and a greyscale erosion.</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale closing is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
closing. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale closing.
structure : array of ints, optional
Structuring element used for the grayscale closing. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the closing may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>grey_closing : ndarray
Result of the grayscale closing of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_45">See also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>binary_closing, grey_dilation, grey_erosion, grey_opening,
generate_binary_structure</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p>The action of a grayscale closing with a flat structuring element amounts
to smoothen deep local minima, whereas binary closing fills small holes.</p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(36).reshape((6,6))
a[3,3] = 0
a
array([[ 0,  1,  2,  3,  4,  5],
[ 6,  7,  8,  9, 10, 11],
[12, 13, 14, 15, 16, 17],
[18, 19, 20,  0, 22, 23],
[24, 25, 26, 27, 28, 29],
[30, 31, 32, 33, 34, 35]])
ndimage.grey_closing(a, size=(3,3))
array([[ 7,  7,  8,  9, 10, 11],
[ 7,  7,  8,  9, 10, 11],
[13, 13, 14, 15, 16, 17],
[19, 19, 20, 20, 22, 23],
[25, 25, 26, 27, 28, 29],
[31, 31, 32, 33, 34, 35]])</p>
<h1 id="note-that-the-local-minimum-a33-has-disappeared_1">Note that the local minimum a[3,3] has disappeared<a class="headerlink" href="#note-that-the-local-minimum-a33-has-disappeared_1" title="Permanent link">&para;</a></h1>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_dilation</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a greyscale dilation, using either a structuring element,
or a footprint corresponding to a flat structuring element.</p>
<p>Grayscale dilation is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a maximum filter over a sliding window.</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale dilation is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
dilation. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale dilation. Non-zero values give the set of
neighbors of the center over which the maximum is chosen.
structure : array of ints, optional
Structuring element used for the grayscale dilation. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the dilation may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>grey_dilation : ndarray
Grayscale dilation of <code>input</code>.</p>
<h2 id="see-also_46">See also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>binary_dilation, grey_erosion, grey_closing, grey_opening
generate_binary_structure, maximum_filter</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>The grayscale dilation of an image input by a structuring element s defined
over a domain E is given by:</p>
<p>(input+s)(x) = max {input(y) + s(x-y), for y in E}</p>
<p>In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale dilation computes the maximum of the
input image inside a sliding window defined by E.</p>
<p>Grayscale dilation [1]<em> is a <em>mathematical morphology</em> operation [2]</em>.</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
a[4,4] = 2; a[2,3] = 3
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, footprint=np.ones((3,3)))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])
s = ndimage.generate_binary_structure(2,1)
s
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)
ndimage.grey_dilation(a, footprint=s)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 1, 3, 2, 1, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))
array([[1, 1, 1, 1, 1, 1, 1],
[1, 2, 4, 4, 4, 2, 1],
[1, 2, 4, 4, 4, 2, 1],
[1, 2, 4, 4, 4, 3, 1],
[1, 2, 2, 3, 3, 3, 1],
[1, 2, 2, 3, 3, 3, 1],
[1, 1, 1, 1, 1, 1, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_erosion</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a greyscale erosion, using either a structuring element,
or a footprint corresponding to a flat structuring element.</p>
<p>Grayscale erosion is a mathematical morphology operation. For the
simple case of a full and flat structuring element, it can be viewed
as a minimum filter over a sliding window.</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale erosion is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
erosion. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale erosion. Non-zero values give the set of
neighbors of the center over which the minimum is chosen.
structure : array of ints, optional
Structuring element used for the grayscale erosion. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the erosion may be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Grayscale erosion of <code>input</code>.</p>
<h2 id="see-also_47">See also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>binary_erosion, grey_dilation, grey_opening, grey_closing
generate_binary_structure, minimum_filter</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>The grayscale erosion of an image input by a structuring element s defined
over a domain E is given by:</p>
<p>(input+s)(x) = min {input(y) - s(x-y), for y in E}</p>
<p>In particular, for structuring elements defined as
s(y) = 0 for y in E, the grayscale erosion computes the minimum of the
input image inside a sliding window defined by E.</p>
<p>Grayscale erosion [1]<em> is a <em>mathematical morphology</em> operation [2]</em>.</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29
.. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[1:6, 1:6] = 3
a[4,4] = 2; a[2,3] = 1
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 1, 3, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 3, 3, 3, 2, 3, 0],
[0, 3, 3, 3, 3, 3, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 3, 2, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
footprint = ndimage.generate_binary_structure(2, 1)
footprint
array([[False,  True, False],
[ True,  True,  True],
[False,  True, False]], dtype=bool)</p>
<h1 id="diagonally-connected-elements-are-not-considered-neighbors_1">Diagonally-connected elements are not considered neighbors<a class="headerlink" href="#diagonally-connected-elements-are-not-considered-neighbors_1" title="Permanent link">&para;</a></h1>
<p>ndimage.grey_erosion(a, size=(3,3), footprint=footprint)
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 3, 1, 2, 0, 0],
[0, 0, 3, 2, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">grey_opening</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional greyscale opening.</p>
<p>A greyscale opening consists in the succession of a greyscale erosion,
and a greyscale dilation.</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which the grayscale opening is to be computed.
size : tuple of ints
Shape of a flat and full structuring element used for the grayscale
opening. Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the grayscale opening.
structure : array of ints, optional
Structuring element used for the grayscale opening. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the opening may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>grey_opening : ndarray
Result of the grayscale opening of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_48">See also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>binary_opening, grey_dilation, grey_erosion, grey_closing
generate_binary_structure</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>The action of a grayscale opening with a flat structuring element amounts
to smoothen high local maxima, whereas binary opening erases small objects.</p>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(36).reshape((6,6))
a[3, 3] = 50
a
array([[ 0,  1,  2,  3,  4,  5],
[ 6,  7,  8,  9, 10, 11],
[12, 13, 14, 15, 16, 17],
[18, 19, 20, 50, 22, 23],
[24, 25, 26, 27, 28, 29],
[30, 31, 32, 33, 34, 35]])
ndimage.grey_opening(a, size=(3,3))
array([[ 0,  1,  2,  3,  4,  4],
[ 6,  7,  8,  9, 10, 10],
[12, 13, 14, 15, 16, 16],
[18, 19, 20, 22, 22, 22],
[24, 25, 26, 27, 28, 28],
[24, 25, 26, 27, 28, 28]])</p>
<h1 id="note-that-the-local-maximum-a33-has-disappeared_1">Note that the local maximum a[3,3] has disappeared<a class="headerlink" href="#note-that-the-local-maximum-a33-has-disappeared_1" title="Permanent link">&para;</a></h1>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">histogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">min</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">max</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">bins</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the histogram of the values of an array, optionally at labels.</p>
<p>Histogram calculates the frequency of values in an array within bins
determined by <code>min</code>, <code>max</code>, and <code>bins</code>. The <code>labels</code> and <code>index</code>
keywords can limit the scope of the histogram to specified sub-regions
within the array.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>input : array_like
Data for which to calculate histogram.
min, max : int
Minimum and maximum values of range of histogram bins.
bins : int
Number of bins.
labels : array_like, optional
Labels for objects in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
Label or labels for which to calculate histogram. If None, all values
where label is greater than zero are used</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>hist : ndarray
Histogram counts.</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ],
...               [ 0.    ,  0.7778,  0.    ,  0.    ],
...               [ 0.    ,  0.    ,  0.    ,  0.    ],
...               [ 0.    ,  0.    ,  0.7181,  0.2787],
...               [ 0.    ,  0.    ,  0.6573,  0.3094]])
from scipy import ndimage
ndimage.measurements.histogram(a, 0, 1, 10)
array([13,  0,  2,  1,  0,  1,  1,  2,  0,  0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With labels and no indices, non-zero elements are counted:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.measurements.histogram(a, 0, 1, 10, lbl)
array([0, 0, 2, 1, 0, 1, 1, 2, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Indices can be used to count only certain objects:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.measurements.histogram(a, 0, 1, 10, lbl, 2)
array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterate_structure</span> <span class="o">:</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterations</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Iterate a structure by dilating it with itself.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>structure : array_like
Structuring element (an array of bools, for example), to be dilated with
itself.
iterations : int
number of dilations performed on the structure with itself
origin : optional
If origin is None, only the iterated structure is returned. If
not, a tuple of the iterated structure and the modified origin is
returned.</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>iterate_structure : ndarray of bools
A new structuring element obtained by dilating <code>structure</code>
(<code>iterations</code> - 1) times with itself.</p>
<h2 id="see-also_49">See also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>generate_binary_structure</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
struct = ndimage.generate_binary_structure(2, 1)
struct.astype(int)
array([[0, 1, 0],
[1, 1, 1],
[0, 1, 0]])
ndimage.iterate_structure(struct, 2).astype(int)
array([[0, 0, 1, 0, 0],
[0, 1, 1, 1, 0],
[1, 1, 1, 1, 1],
[0, 1, 1, 1, 0],
[0, 0, 1, 0, 0]])
ndimage.iterate_structure(struct, 3).astype(int)
array([[0, 0, 0, 1, 0, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[1, 1, 1, 1, 1, 1, 1],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">label</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Label features in an array.</p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>input : array_like
An array-like object to be labeled.  Any non-zero values in <code>input</code> are
counted as features and zero values are considered the background.
structure : array_like, optional
A structuring element that defines feature connections.
<code>structure</code> must be centrosymmetric
(see Notes).
If no structuring element is provided,
one is automatically generated with a squared connectivity equal to
one.  That is, for a 2-D <code>input</code> array, the default structuring element
is::</p>
<p>[[0,1,0],
[1,1,1],
[0,1,0]]</p>
<p>output : (None, data-type, array_like), optional
If <code>output</code> is a data type, it specifies the type of the resulting
labeled feature array.
If <code>output</code> is an array-like object, then <code>output</code> will be updated
with the labeled features from this function.  This function can
operate in-place, by passing output=input.
Note that the output must be able to store the largest label, or this
function will raise an Exception.</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>label : ndarray or int
An integer ndarray where each unique feature in <code>input</code> has a unique
label in the returned array.
num_features : int
How many objects were found.</p>
<p>If <code>output</code> is None, this function returns a tuple of
(<code>labeled_array</code>, <code>num_features</code>).</p>
<p>If <code>output</code> is a ndarray, then it will be updated with values in
<code>labeled_array</code> and only <code>num_features</code> will be returned by this
function.</p>
<h2 id="see-also_50">See Also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>find_objects : generate a list of slices for the labeled features (or
objects); useful for finding features' position or
dimensions</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>A centrosymmetric matrix is a matrix that is symmetric about the center.
See [1]_ for more information.</p>
<p>The <code>structure</code> matrix must be centrosymmetric to ensure
two-way connections.
For instance, if the <code>structure</code> matrix is not centrosymmetric
and is defined as::</p>
<p>[[0,1,0],
[1,1,0],
[0,0,0]]</p>
<p>and the <code>input</code> is::</p>
<p>[[1,2],
[0,3]]</p>
<p>then the structure matrix would indicate the
entry 2 in the input is connected to 1,
but 1 is not connected to 2.</p>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<p>Create an image with some features, then label it using the default
(cross-shaped) structuring element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import label, generate_binary_structure
a = np.array([[0,0,1,1,0,0],
...               [0,0,0,1,0,0],
...               [1,1,0,0,1,0],
...               [0,0,0,1,0,0]])
labeled_array, num_features = label(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Each of the 4 features are labeled with a different integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>num_features
4
labeled_array
array([[0, 0, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0],
[2, 2, 0, 0, 3, 0],
[0, 0, 0, 4, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a structuring element that will consider features connected even
if they touch diagonally:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = generate_binary_structure(2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>or,</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = [[1,1,1],
...      [1,1,1],
...      [1,1,1]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Label the image using the new structuring element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>labeled_array, num_features = label(a, structure=s)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Show the 2 labeled features (note that features 1, 3, and 4 from above are
now considered a single feature):</p>
<blockquote>
<blockquote>
<blockquote>
<p>num_features
2
labeled_array
array([[0, 0, 1, 1, 0, 0],
[0, 0, 0, 1, 0, 0],
[2, 2, 0, 0, 1, 0],
[0, 0, 0, 1, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>.. [1] James R. Weaver, 'Centrosymmetric (cross-symmetric)
matrices, their basic properties, eigenvalues, and
eigenvectors.' The American Mathematical Monthly 92.10
(1985): 711-717.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">labeled_comprehension</span> <span class="o">:</span> <span class="o">?</span><span class="n">pass_positions</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">labels</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">out_dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">default</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Roughly equivalent to [func(input[labels == i]) for i in index].</p>
<p>Sequentially applies an arbitrary function (that works on array_like input)
to subsets of an n-D image array specified by <code>labels</code> and <code>index</code>.
The option exists to provide the function with positional parameters as the
second argument.</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>input : array_like
Data from which to select <code>labels</code> to process.
labels : array_like or None
Labels to objects in <code>input</code>.
If not None, array must be same shape as <code>input</code>.
If None, <code>func</code> is applied to raveled <code>input</code>.
index : int, sequence of ints or None
Subset of <code>labels</code> to which to apply <code>func</code>.
If a scalar, a single value is returned.
If None, <code>func</code> is applied to all non-zero values of <code>labels</code>.
func : callable
Python function to apply to <code>labels</code> from <code>input</code>.
out_dtype : dtype
Dtype to use for <code>result</code>.
default : int, float or None
Default return value when a element of <code>index</code> does not exist
in <code>labels</code>.
pass_positions : bool, optional
If True, pass linear indices to <code>func</code> as a second argument.
Default is False.</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>result : ndarray
Result of applying <code>func</code> to each of <code>labels</code> to <code>input</code> in <code>index</code>.</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
lbl, nlbl = ndimage.label(a)
lbls = np.arange(1, nlbl+1)
ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0)
array([ 2.75,  5.5 ,  6.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Falling back to <code>default</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbls = np.arange(1, nlbl+2)
ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, -1)
array([ 2.75,  5.5 ,  6.  , -1.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Passing positions:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def fn(val, pos):
...     print('fn says: %s : %s' % (val, pos))
...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum())
...
ndimage.labeled_comprehension(a, lbl, lbls, fn, float, 0, True)
fn says: [1 2 5 3] : [0 1 4 5]
fn says: [4 7] : [ 7 11]
fn says: [9 3] : [12 13]
array([ 11.,  11., -12.,   0.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>N-dimensional Laplace filter based on approximate second derivatives.</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.laplace(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">map_coordinates</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">coordinates</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Map the input array to new coordinates by interpolation.</p>
<p>The array of coordinates is used to find, for each point in the output,
the corresponding coordinates in the input. The value of the input at
those coordinates is determined by spline interpolation of the
requested order.</p>
<p>The shape of the output is derived from that of the coordinate
array by dropping the first axis. The values of the array along
the first axis are the coordinates in the input array at which the
output value is found.</p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
coordinates : array_like
The coordinates at which <code>input</code> is evaluated.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>map_coordinates : ndarray
The result of transforming the input. The shape of the output is
derived from that of <code>coordinates</code> by dropping the first axis.</p>
<h2 id="see-also_51">See Also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>spline_filter, geometric_transform, scipy.interpolate</p>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(12.).reshape((4, 3))
a
array([[  0.,   1.,   2.],
[  3.,   4.,   5.],
[  6.,   7.,   8.],
[  9.,  10.,  11.]])
ndimage.map_coordinates(a, [[0.5, 2], [0.5, 1]], order=1)
array([ 2.,  7.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while
a[2, 1] is output[1].</p>
<blockquote>
<blockquote>
<blockquote>
<p>inds = np.array([[0.5, 2], [0.5, 4]])
ndimage.map_coordinates(a, inds, order=1, cval=-33.3)
array([  2. , -33.3])
ndimage.map_coordinates(a, inds, order=1, mode='nearest')
array([ 2.,  8.])
ndimage.map_coordinates(a, inds, order=1, cval=0, output=bool)
array([ True, False], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the maximum of the values of an array over labeled regions.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
maximal values of <code>input</code> over the region is computed.
labels : array_like, optional
An array of integers marking different regions over which the
maximum value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the maximum
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
maxima. If index is None, the maximum over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>output : float or list of floats
List of maxima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the maximal value of <code>input</code> if <code>labels</code> is None,
and the maximal value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_52">See also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(16).reshape((4,4))
a
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11],
[12, 13, 14, 15]])
labels = np.zeros_like(a)
labels[:2,:2] = 1
labels[2:, 1:3] = 2
labels
array([[1, 1, 0, 0],
[1, 1, 0, 0],
[0, 2, 2, 0],
[0, 2, 2, 0]])
from scipy import ndimage
ndimage.maximum(a)
15.0
ndimage.maximum(a, labels=labels, index=[1,2])
[5.0, 14.0]
ndimage.maximum(a, labels=labels)
14.0</p>
<p>b = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(b)
labels
array([[1, 1, 0, 0],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.maximum(b, labels=labels, index=np.arange(1, labels_nb + 1))
[5.0, 7.0, 9.0]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional maximum filter.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>maximum_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.maximum_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span>
</code></pre></div>

<p>Calculate a one-dimensional maximum filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
maximum filter of given size.</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
Length along which to calculate the 1-D maximum.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>maximum1d : ndarray, None
Maximum-filtered array with same shape as input.
None if <code>output</code> is not None</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>This function implements the MAXLIST algorithm [1]<em>, as described by
Richard Harter [2]</em>, and has a guaranteed O(n) performance, <code>n</code> being
the <code>input</code> length, regardless of filter size.</p>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import maximum_filter1d
maximum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([8, 8, 8, 4, 9, 9, 9, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maximum_position</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the positions of the maximums of the values of an array at labels.</p>
<p>For each region specified by <code>labels</code>, the position of the maximum
value of <code>input</code> within the region is returned.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values.
labels : array_like, optional
An array of integers marking different regions over which the
position of the maximum value of <code>input</code> is to be computed.
<code>labels</code> must have the same shape as <code>input</code>. If <code>labels</code> is not
specified, the location of the first maximum over the whole
array is returned.</p>
<p>The <code>labels</code> argument only works when <code>index</code> is specified.
index : array_like, optional
A list of region labels that are taken into account for finding the
location of the maxima.  If <code>index</code> is None, the first maximum
over all elements where <code>labels</code> is non-zero is returned.</p>
<p>The <code>index</code> argument only works when <code>labels</code> is specified.</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>output : list of tuples of ints
List of tuples of ints that specify the location of maxima of
<code>input</code> over the regions determined by <code>labels</code> and whose index
is in <code>index</code>.</p>
<p>If <code>index</code> or <code>labels</code> are not specified, a tuple of ints is
returned specifying the location of the <code>first</code> maximal value
of <code>input</code>.</p>
<h2 id="see-also_53">See also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the mean of the values of an array at labels.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array on which to compute the mean of elements over distinct
regions.
labels : array_like, optional
Array of labels of same shape, or broadcastable to the same shape as
<code>input</code>. All elements sharing the same label form one region over
which the mean of the elements is computed.
index : int or sequence of ints, optional
Labels of the objects over which the mean is to be computed.
Default is None, in which case the mean for all values where label is
greater than 0 is calculated.</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>out : list
Sequence of same length as <code>index</code>, with the mean of the different
regions labeled by the labels in <code>index</code>.</p>
<h2 id="see-also_54">See also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>variance, standard_deviation, minimum, maximum, sum, label</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.arange(25).reshape((5,5))
labels = np.zeros_like(a)
labels[3:5,3:5] = 1
index = np.unique(labels)
labels
array([[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 1, 1],
[0, 0, 0, 1, 1]])
index
array([0, 1])
ndimage.mean(a, labels=labels, index=index)
[10.285714285714286, 21.0]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">median</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the median of the values of an array over labeled regions.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
median value of <code>input</code> over the region is computed.
labels : array_like, optional
An array_like of integers marking different regions over which the
median value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the median
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
medians. If index is None, the median over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>median : float or list of floats
List of medians of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the median value of <code>input</code> if <code>labels</code> is None,
and the median value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_55">See also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>label, minimum, maximum, extrema, sum, mean, variance, standard_deviation</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(a)
labels
array([[1, 1, 0, 2],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1))
[2.5, 4.0, 6.0]
ndimage.median(a)
1.0
ndimage.median(a, labels=labels)
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">median_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multidimensional median filter.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>median_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.median_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimum of the values of an array over labeled regions.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values. For each region specified by <code>labels</code>, the
minimal values of <code>input</code> over the region is computed.
labels : array_like, optional
An array_like of integers marking different regions over which the
minimum value of <code>input</code> is to be computed. <code>labels</code> must have the
same shape as <code>input</code>. If <code>labels</code> is not specified, the minimum
over the whole array is returned.
index : array_like, optional
A list of region labels that are taken into account for computing the
minima. If index is None, the minimum over all elements where <code>labels</code>
is non-zero is returned.</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>minimum : float or list of floats
List of minima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>. If <code>index</code> or <code>labels</code> are not specified, a
float is returned: the minimal value of <code>input</code> if <code>labels</code> is None,
and the minimal value of elements where <code>labels</code> is greater than zero
if <code>index</code> is None.</p>
<h2 id="see-also_56">See also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>label, maximum, median, minimum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>The function returns a Python list and not a NumPy array, use
<code>np.array</code> to convert the list to an array.</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
labels, labels_nb = ndimage.label(a)
labels
array([[1, 1, 0, 0],
[1, 1, 0, 2],
[0, 0, 0, 2],
[3, 3, 0, 0]])
ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1))
[1.0, 4.0, 3.0]
ndimage.minimum(a)
0.0
ndimage.minimum(a, labels=labels)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional minimum filter.</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>minimum_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.minimum_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional minimum filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
minimum filter of given size.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
length along which to calculate 1D minimum
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p>This function implements the MINLIST algorithm [1]<em>, as described by
Richard Harter [2]</em>, and has a guaranteed O(n) performance, <code>n</code> being
the <code>input</code> length, regardless of filter size.</p>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777
.. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import minimum_filter1d
minimum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([2, 0, 0, 0, 1, 1, 0, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_position</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the positions of the minimums of the values of an array at labels.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array_like of values.
labels : array_like, optional
An array of integers marking different regions over which the
position of the minimum value of <code>input</code> is to be computed.
<code>labels</code> must have the same shape as <code>input</code>. If <code>labels</code> is not
specified, the location of the first minimum over the whole
array is returned.</p>
<p>The <code>labels</code> argument only works when <code>index</code> is specified.
index : array_like, optional
A list of region labels that are taken into account for finding the
location of the minima. If <code>index</code> is None, the <code>first</code> minimum
over all elements where <code>labels</code> is non-zero is returned.</p>
<p>The <code>index</code> argument only works when <code>labels</code> is specified.</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>output : list of tuples of ints
Tuple of ints or list of tuples of ints that specify the location
of minima of <code>input</code> over the regions determined by <code>labels</code> and
whose index is in <code>index</code>.</p>
<p>If <code>index</code> or <code>labels</code> are not specified, a tuple of ints is
returned specifying the location of the first minimal value of <code>input</code>.</p>
<h2 id="see-also_57">See also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>label, minimum, median, maximum_position, extrema, sum, mean, variance,
standard_deviation</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[10, 20, 30],
...               [40, 80, 100],
...               [1, 100, 200]])
b = np.array([[1, 2, 0, 1],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])</p>
<p>from scipy import ndimage</p>
<p>ndimage.minimum_position(a)
(2, 0)
ndimage.minimum_position(b)
(0, 2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>label, pos = ndimage.label(a)
ndimage.minimum_position(a, label, index=np.arange(1, pos+1))
[(2, 0)]</p>
<p>label, pos = ndimage.label(b)
ndimage.minimum_position(b, label, index=np.arange(1, pos+1))
[(0, 0), (0, 3), (3, 1)]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morphological_gradient</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional morphological gradient.</p>
<p>The morphological gradient is calculated as the difference between a
dilation and an erosion of the input with a given structuring element.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>input : array_like
Array over which to compute the morphlogical gradient.
size : tuple of ints
Shape of a flat and full structuring element used for the mathematical
morphology operations. Optional if <code>footprint</code> or <code>structure</code> is
provided. A larger <code>size</code> yields a more blurred gradient.
footprint : array of ints, optional
Positions of non-infinite elements of a flat structuring element
used for the morphology operations. Larger footprints
give a more blurred morphological gradient.
structure : array of ints, optional
Structuring element used for the morphology operations.
<code>structure</code> may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the morphological gradient
may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default 0</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>morphological_gradient : ndarray
Morphological gradient of <code>input</code>.</p>
<h2 id="see-also_58">See also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>grey_dilation, grey_erosion, gaussian_gradient_magnitude</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p>For a flat structuring element, the morphological gradient
computed at a given point corresponds to the maximal difference
between elements of the input among the elements covered by the
structuring element centered on the point.</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 0, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
<h1 id="the-morphological-gradient-is-computed-as-the-difference_1">The morphological gradient is computed as the difference<a class="headerlink" href="#the-morphological-gradient-is-computed-as-the-difference_1" title="Permanent link">&para;</a></h1>
<h1 id="between-a-dilation-and-an-erosion_1">between a dilation and an erosion<a class="headerlink" href="#between-a-dilation-and-an-erosion_1" title="Permanent link">&para;</a></h1>
<p>ndimage.grey_dilation(a, size=(3,3)) -\
...  ndimage.grey_erosion(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 0, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 1, 1, 1, 1, 1, 0],
[0, 0, 0, 0, 0, 0, 0]])
a = np.zeros((7,7), dtype=int)
a[2:5, 2:5] = 1
a[4,4] = 2; a[2,3] = 3
a
array([[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 1, 3, 1, 0, 0],
[0, 0, 1, 1, 1, 0, 0],
[0, 0, 1, 1, 2, 0, 0],
[0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0]])
ndimage.morphological_gradient(a, size=(3,3))
array([[0, 0, 0, 0, 0, 0, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 3, 3, 1, 0],
[0, 1, 3, 2, 3, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 1, 1, 2, 2, 2, 0],
[0, 0, 0, 0, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morphological_laplace</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional morphological laplace.</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : int or sequence of ints, optional
See <code>structure</code>.
footprint : bool or ndarray, optional
See <code>structure</code>.
structure : structure, optional
Either <code>size</code>, <code>footprint</code>, or the <code>structure</code> must be provided.
output : ndarray, optional
An output array can optionally be provided.
mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional
The mode parameter determines how the array borders are handled.
For 'constant' mode, values beyond borders are set to be <code>cval</code>.
Default is 'reflect'.
cval : scalar, optional
Value to fill past edges of input if mode is 'constant'.
Default is 0.0
origin : origin, optional
The origin parameter controls the placement of the filter.</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>morphological_laplace : ndarray
Output</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">percentile_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">percentile</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional percentile filter.</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
percentile : scalar
The percentile parameter may be less then zero, i.e.,
percentile = -20 equals percentile = 80
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>percentile_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.percentile_filter(ascent, percentile=20, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prewitt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a Prewitt filter.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.prewitt(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rank_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a multi-dimensional rank filter.</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
rank : int
The rank parameter may be less then zero, i.e., rank = -1
indicates the largest element.
size : scalar or tuple, optional
See footprint, below. Ignored if footprint is given.
footprint : array, optional
Either <code>size</code> or <code>footprint</code> must be defined.  <code>size</code> gives
the shape that is taken from the input array, at every element
position, to define the input to the filter function.
<code>footprint</code> is a boolean array that specifies (implicitly) a
shape, but also which of the elements within this shape will get
passed to the filter function.  Thus <code>size=(n,m)</code> is equivalent
to <code>footprint=np.ones((n,m))</code>.  We adjust <code>size</code> to the number
of dimensions of the input array, so that, if the input array is
shape (10,10,10), and <code>size</code> is 2, then the actual size used is
(2,2,2). When <code>footprint</code> is given, <code>size</code> is ignored.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>rank_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.rank_filter(ascent, rank=42, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rotate</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">reshape</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">angle</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Rotate an array.</p>
<p>The array is rotated in the plane defined by the two axes given by the
<code>axes</code> parameter using spline interpolation of the requested order.</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
angle : float
The rotation angle in degrees.
axes : tuple of 2 ints, optional
The two axes that define the plane of rotation. Default is the first
two axes.
reshape : bool, optional
If <code>reshape</code> is true, the output shape is adapted so that the input
array is contained completely in the output. Default is True.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>rotate : ndarray
The rotated input.</p>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(10, 3))
ax1, ax2, ax3 = fig.subplots(1, 3)
img = misc.ascent()
img_45 = ndimage.rotate(img, 45, reshape=False)
full_img_45 = ndimage.rotate(img, 45, reshape=True)
ax1.imshow(img, cmap='gray')
ax1.set_axis_off()
ax2.imshow(img_45, cmap='gray')
ax2.set_axis_off()
ax3.imshow(full_img_45, cmap='gray')
ax3.set_axis_off()
fig.set_tight_layout(True)
plt.show()
print(img.shape)
(512, 512)
print(img_45.shape)
(512, 512)
print(full_img_45.shape)
(724, 724)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">shift</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shift</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift an array.</p>
<p>The array is shifted using spline interpolation of the requested order.
Points outside the boundaries of the input are filled according to the
given mode.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
shift : float or sequence
The shift along the axes. If a float, <code>shift</code> is the same for each
axis. If a sequence, <code>shift</code> should contain one value for each axis.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>shift : ndarray
The shifted input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sobel</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a Sobel filter.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.sobel(ascent)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional spline filter.</p>
<p>For more details, see <code>spline_filter1d</code>.</p>
<h2 id="see-also_59">See Also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>spline_filter1d</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional spline filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional spline filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered by a
spline filter. The order of the spline must be &gt;= 2 and &lt;= 5.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
order : int, optional
The order of the spline, default is 3.
axis : int, optional
The axis along which the spline filter is applied. Default is the last
axis.
output : ndarray or dtype, optional
The array in which to place the output, or the dtype of the returned
array. Default is <code>numpy.float64</code>.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>spline_filter1d : ndarray
The filtered input.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p>All functions in <code>ndimage.interpolation</code> do spline interpolation of
the input image. If using b-splines of <code>order &gt; 1</code>, the input image
values have to be converted to b-spline coefficients first, which is
done by applying this one-dimensional filter sequentially along all
axes of the input. All functions that require b-spline coefficients
will automatically filter their inputs, a behavior controllable with
the <code>prefilter</code> keyword argument. For functions that accept a <code>mode</code>
parameter, the result will only be correct if it matches the <code>mode</code>
used when filtering.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">standard_deviation</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the standard deviation of the values of an n-D image array,
optionally at specified sub-regions.</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>input : array_like
Nd-image data to process.
labels : array_like, optional
Labels to identify sub-regions in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
<code>labels</code> to include in output.  If None (default), all values where
<code>labels</code> is non-zero are used.</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>standard_deviation : float or ndarray
Values of standard deviation, for each sub-region if <code>labels</code> and
<code>index</code> are specified.</p>
<h2 id="see-also_60">See Also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>label, variance, maximum, minimum, extrema</p>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.standard_deviation(a)
2.7585095613392387</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.standard_deviation(a, lbl, index=np.arange(1, nlbl+1))
array([ 1.479,  1.5  ,  3.   ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.standard_deviation(a, lbl)
2.4874685927665499</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sum</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the sum of the values of the array.</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>input : array_like
Values of <code>input</code> inside the regions defined by <code>labels</code>
are summed together.
labels : array_like of ints, optional
Assign labels to the values of the array. Has to have the same shape as
<code>input</code>.
index : array_like, optional
A single label number or a sequence of label numbers of
the objects to be measured.</p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>sum : ndarray or scalar
An array of the sums of values of <code>input</code> inside the regions defined
by <code>labels</code> with the same shape as <code>index</code>. If 'index' is None or scalar,
a scalar is returned.</p>
<h2 id="see-also_61">See also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>mean, median</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage
input =  [0,1,2,3]
labels = [1,1,2,2]
ndimage.sum(input, labels, index=[1,2])
[1.0, 5.0]
ndimage.sum(input, labels, index=1)
1
ndimage.sum(input, labels)
6</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">uniform_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional uniform filter.</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int or sequence of ints, optional
The sizes of the uniform filter are given for each axis as a
sequence, or as a single number, in which case the size is
equal for all axes.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : str or sequence, optional
The <code>mode</code> parameter determines how the input array is extended
when the filter overlaps a border. By passing a sequence of modes
with length equal to the number of dimensions of the input array,
different modes can be specified along each axis. Default value is
'reflect'. The valid values and their behavior is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int or sequence, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right. By passing a sequence of origins with length equal to
the number of dimensions of the input array, different shifts can
be specified along each axis.</p>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>uniform_filter : ndarray
Filtered array. Has the same shape as <code>input</code>.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional uniform filters. The intermediate arrays are stored
in the same data type as the output. Therefore, for output types
with a limited precision, the results may be imprecise because
intermediate results may be stored with insufficient precision.</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt
fig = plt.figure()
plt.gray()  # show the filtered result in grayscale
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.uniform_filter(ascent, size=20)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">uniform_filter1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate a one-dimensional uniform filter along the given axis.</p>
<p>The lines of the array along the given axis are filtered with a
uniform filter of given size.</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
size : int
length of uniform filter
axis : int, optional
The axis of <code>input</code> along which to calculate. Default is -1.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'reflect'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
origin : int, optional
Controls the placement of the filter on the input array's pixels.
A value of 0 (the default) centers the filter over the pixel, with
positive values shifting the filter to the left, and negative ones
to the right.</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.ndimage import uniform_filter1d
uniform_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3)
array([4, 3, 4, 1, 4, 6, 6, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">variance</span> <span class="o">:</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">index</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the variance of the values of an n-D image array, optionally at
specified sub-regions.</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>input : array_like
Nd-image data to process.
labels : array_like, optional
Labels defining sub-regions in <code>input</code>.
If not None, must be same shape as <code>input</code>.
index : int or sequence of ints, optional
<code>labels</code> to include in output.  If None (default), all values where
<code>labels</code> is non-zero are used.</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>variance : float or ndarray
Values of variance, for each sub-region if <code>labels</code> and <code>index</code> are
specified.</p>
<h2 id="see-also_62">See Also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>label, standard_deviation, maximum, minimum, extrema</p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 0, 0],
...               [5, 3, 0, 4],
...               [0, 0, 0, 7],
...               [9, 3, 0, 0]])
from scipy import ndimage
ndimage.variance(a)
7.609375</p>
</blockquote>
</blockquote>
</blockquote>
<p>Features to process can be specified using <code>labels</code> and <code>index</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lbl, nlbl = ndimage.label(a)
ndimage.variance(a, lbl, index=np.arange(1, nlbl+1))
array([ 2.1875,  2.25  ,  9.    ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If no index is given, all non-zero <code>labels</code> are processed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ndimage.variance(a, lbl)
6.1875</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">watershed_ift</span> <span class="o">:</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">markers</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply watershed from markers using image foresting transform algorithm.</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
markers : array_like
Markers are points within each watershed that form the beginning
of the process.  Negative markers are considered background markers
which are processed after the other markers.
structure : structure element, optional
A structuring element defining the connectivity of the object can be
provided. If None, an element is generated with a squared
connectivity equal to one.
output : ndarray, optional
An output array can optionally be provided.  The same shape as input.</p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>watershed_ift : ndarray
Output.  Same shape as <code>input</code>.</p>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [1] A.X. Falcao, J. Stolfi and R. de Alencar Lotufo, 'The image
foresting transform: theory, algorithms, and applications',
Pattern Analysis and Machine Intelligence, vol. 26, pp. 19-29, 2004.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">white_tophat</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">footprint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">structure</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">origin</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Multi-dimensional white tophat filter.</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>input : array_like
Input.
size : tuple of ints
Shape of a flat and full structuring element used for the filter.
Optional if <code>footprint</code> or <code>structure</code> is provided.
footprint : array of ints, optional
Positions of elements of a flat structuring element
used for the white tophat filter.
structure : array of ints, optional
Structuring element used for the filter. <code>structure</code>
may be a non-flat structuring element.
output : array, optional
An array used for storing the output of the filter may be provided.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the array borders are
handled, where <code>cval</code> is the value when mode is equal to
'constant'. Default is 'reflect'
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'.
Default is 0.0.
origin : scalar, optional
The <code>origin</code> parameter controls the placement of the filter.
Default is 0.</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Result of the filter of <code>input</code> with <code>structure</code>.</p>
<h2 id="see-also_63">See also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>black_tophat</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zoom</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Reflect</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mirror</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prefilter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">zoom</span><span class="o">:[`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zoom an array.</p>
<p>The array is zoomed using spline interpolation of the requested order.</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>input : array_like
The input array.
zoom : float or sequence
The zoom factor along the axes. If a float, <code>zoom</code> is the same for each
axis. If a sequence, <code>zoom</code> should contain one value for each axis.
output : array or dtype, optional
The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.
order : int, optional
The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.
mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional
The <code>mode</code> parameter determines how the input array is extended
beyond its boundaries. Default is 'constant'. Behavior for each valid
value is as follows:</p>
<p>'reflect' (<code>d c b a | a b c d | d c b a</code>)
The input is extended by reflecting about the edge of the last
pixel.</p>
<p>'constant' (<code>k k k k | a b c d | k k k k</code>)
The input is extended by filling all values beyond the edge with
the same constant value, defined by the <code>cval</code> parameter.</p>
<p>'nearest' (<code>a a a a | a b c d | d d d d</code>)
The input is extended by replicating the last pixel.</p>
<p>'mirror' (<code>d c b | a b c d | c b a</code>)
The input is extended by reflecting about the center of the last
pixel.</p>
<p>'wrap' (<code>a b c d | a b c d | a b c d</code>)
The input is extended by wrapping around to the opposite edge.
cval : scalar, optional
Value to fill past edges of input if <code>mode</code> is 'constant'. Default
is 0.0.
prefilter : bool, optional
Determines if the input array is prefiltered with <code>spline_filter</code>
before interpolation. The default is True, which will create a
temporary <code>float64</code> array of filtered values if <code>order &gt; 1</code>. If
setting this to False, the output will be slightly blurred if
<code>order &gt; 1</code>, unless the input is prefiltered, i.e. it is the result
of calling <code>spline_filter</code> on the original input.</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>zoom : ndarray
The zoomed input.</p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import ndimage, misc
import matplotlib.pyplot as plt</p>
<p>fig = plt.figure()
ax1 = fig.add_subplot(121)  # left side
ax2 = fig.add_subplot(122)  # right side
ascent = misc.ascent()
result = ndimage.zoom(ascent, 3.0)
ax1.imshow(ascent)
ax2.imshow(result)
plt.show()</p>
<p>print(ascent.shape)
(512, 512)</p>
<p>print(result.shape)
(1536, 1536)</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Misc/" title="Misc" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Misc
              </div>
            </div>
          </a>
        
        
          <a href="../Odr/" title="Odr" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Odr
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>