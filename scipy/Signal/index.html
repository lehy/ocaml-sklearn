


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Signal - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Signal
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Signal" class="md-nav__link md-nav__link--active">
      Signal
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Signal.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">BadCoefficients</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BadCoefficients</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BadCoefficients</span> <span class="o">|</span> <span class="o">`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">StateSpace</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">StateSpace</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">StateSpace</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Linear Time Invariant system in state-space form.</p>
<p>Represents the system as the continuous-time, first order differential
equation :math:<code>\dot{x} = A x + B u</code> or the discrete-time difference
equation :math:<code>x[k+1] = A x[k] + B u[k]</code>. <code>StateSpace</code> systems
inherit additional functionality from the <code>lti</code>, respectively the <code>dlti</code>
classes, depending on which system representation is used.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>StateSpace</code> class can be instantiated with 1 or 3 arguments.
The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> or <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>4: array_like: (A, B, C, D)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>None</code>
(continuous-time). Must be specified as a keyword argument, for
example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>TransferFunction, ZerosPolesGain, lti, dlti
ss2zpk, ss2tf, zpk2sos</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>StateSpace</code> system representation (such as <code>zeros</code> or <code>poles</code>) is very
inefficient and may lead to numerical inaccuracies.  It is better to
convert to the specific system representation first. For example, call
<code>sys = sys.to_zpk()</code> before accessing/changing the zeros, poles or gain.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>a = np.array([[0, 1], [0, 0]])
b = np.array([[0], [1]])
c = np.array([[1, 0]])
d = np.array([[0]])</p>
<p>sys = signal.StateSpace(a, b, c, d)
print(sys)
StateSpaceContinuous(
array([[0, 1],
[0, 0]]),
array([[0],
[1]]),
array([[1, 0]]),
array([[0]]),
dt: None
)</p>
<p>sys.to_discrete(0.1)
StateSpaceDiscrete(
array([[1. , 0.1],
[0. , 1. ]]),
array([[0.005],
[0.1  ]]),
array([[1, 0]]),
array([[0]]),
dt: 0.1
)</p>
<p>a = np.array([[1, 0.1], [0, 1]])
b = np.array([[0.005], [0.1]])</p>
<p>signal.StateSpace(a, b, c, d, dt=0.1)
StateSpaceDiscrete(
array([[1. , 0.1],
[0. , 1. ]]),
array([[0.005],
[0.1  ]]),
array([[1, 0]]),
array([[0]]),
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>StateSpace</code> system.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">TransferFunction</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">TransferFunction</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">TransferFunction</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Linear Time Invariant system class in transfer function form.</p>
<p>Represents the system as the continuous-time transfer function
:math:<code>H(s)=\sum_{i=0}^N b[N-i] s^i / \sum_{j=0}^M a[M-j] s^j</code> or the
discrete-time transfer function
:math:<code>H(s)=\sum_{i=0}^N b[N-i] z^i / \sum_{j=0}^M a[M-j] z^j</code>, where
:math:<code>b</code> are elements of the numerator <code>num</code>, :math:<code>a</code> are elements of
the denominator <code>den</code>, and <code>N == len(b) - 1</code>, <code>M == len(a) - 1</code>.
<code>TransferFunction</code> systems inherit additional
functionality from the <code>lti</code>, respectively the <code>dlti</code> classes, depending on
which system representation is used.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>TransferFunction</code> class can be instantiated with 1 or 2
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> or <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>2: array_like: (numerator, denominator)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>None</code>
(continuous-time). Must be specified as a keyword argument, for
example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>ZerosPolesGain, StateSpace, lti, dlti
tf2ss, tf2zpk, tf2sos</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>TransferFunction</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.  It is better to convert to the specific system
representation first. For example, call <code>sys = sys.to_ss()</code> before
accessing/changing the A, B, C, D system matrices.</p>
<p>If (numerator, denominator) is passed in for <code>*system</code>, coefficients
for both the numerator and denominator should be specified in descending
exponent order (e.g. <code>s^2 + 3s + 5</code> or <code>z^2 + 3z + 5</code> would be
represented as <code>[1, 3, 5]</code>)</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<p>Construct the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
<p>signal.TransferFunction(num, den)
TransferFunctionContinuous(
array([1., 3., 3.]),
array([1., 2., 1.]),
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Construct the transfer function with a sampling time of 0.1 seconds:</p>
<p>.. math:: H(z) = \frac{z^2 + 3z + 3}{z^2 + 2z + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.TransferFunction(num, den, dt=0.1)
TransferFunctionDiscrete(
array([1., 3., 3.]),
array([1., 2., 1.]),
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>TransferFunction</code> system.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ZerosPolesGain</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ZerosPolesGain</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ZerosPolesGain</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Linear Time Invariant system class in zeros, poles, gain form.</p>
<p>Represents the system as the continuous- or discrete-time transfer function
:math:<code>H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])</code>, where :math:<code>k</code> is
the <code>gain</code>, :math:<code>z</code> are the <code>zeros</code> and :math:<code>p</code> are the <code>poles</code>.
<code>ZerosPolesGain</code> systems inherit additional functionality from the <code>lti</code>,
respectively the <code>dlti</code> classes, depending on which system representation
is used.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>*system : arguments
The <code>ZerosPolesGain</code> class can be instantiated with 1 or 3
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> or <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>3: array_like: (zeros, poles, gain)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>None</code>
(continuous-time). Must be specified as a keyword argument, for
example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>TransferFunction, StateSpace, lti, dlti
zpk2ss, zpk2tf, zpk2sos</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>ZerosPolesGain</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.  It is better to convert to the specific system
representation first. For example, call <code>sys = sys.to_ss()</code> before
accessing/changing the A, B, C, D system matrices.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(s) = 5(s - 1)(s - 2) / (s - 3)(s - 4)</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.ZerosPolesGain([1, 2], [3, 4], 5)
ZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 5(z - 1)(z - 2) / (z - 3)(z - 4)</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.ZerosPolesGain([1, 2], [3, 4], 5, dt=0.1)
ZerosPolesGainDiscrete(
array([1, 2]),
array([3, 4]),
5,
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current 'ZerosPolesGain' system.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
The current system (copy)</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Dlti</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Dlti</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Dlti</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Discrete-time linear time invariant system base class.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>dlti</code> class can be instantiated with either 2, 3 or 4 arguments.
The following gives the number of arguments and the corresponding
discrete-time subclass that is created:</p>
<ul>
<li>2: <code>TransferFunction</code>:  (numerator, denominator)</li>
<li>3: <code>ZerosPolesGain</code>: (zeros, poles, gain)</li>
<li>4: <code>StateSpace</code>:  (A, B, C, D)</li>
</ul>
<p>Each argument can be an array or a sequence.
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>True</code>
(unspecified sampling time). Must be specified as a keyword argument,
for example, <code>dt=0.1</code>.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>ZerosPolesGain, StateSpace, TransferFunction, lti</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p><code>dlti</code> instances do not exist directly. Instead, <code>dlti</code> creates an instance
of one of its subclasses: <code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>.</p>
<p>Changing the value of properties that are not directly part of the current
system representation (such as the <code>zeros</code> of a <code>StateSpace</code> system) is
very inefficient and may lead to numerical inaccuracies.  It is better to
convert to the specific system representation first. For example, call
<code>sys = sys.to_zpk()</code> before accessing/changing the zeros, poles or gain.</p>
<p>If (numerator, denominator) is passed in for <code>*system</code>, coefficients for
both the numerator and denominator should be specified in descending
exponent order (e.g., <code>z^2 + 3z + 5</code> would be represented as <code>[1, 3,
5]</code>).</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>signal.dlti(1, 2, 3, 4)
StateSpaceDiscrete(
array([[1]]),
array([[2]]),
array([[3]]),
array([[4]]),
dt: True
)</p>
<p>signal.dlti(1, 2, 3, 4, dt=0.1)
StateSpaceDiscrete(
array([[1]]),
array([[2]]),
array([[3]]),
array([[4]]),
dt: 0.1
)</p>
<p>signal.dlti([1, 2], [3, 4], 5, dt=0.1)
ZerosPolesGainDiscrete(
array([1, 2]),
array([3, 4]),
5,
dt: 0.1
)</p>
<p>signal.dlti([3, 4], [1, 2], dt=0.1)
TransferFunctionDiscrete(
array([3., 4.]),
array([1., 2.]),
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>dbode</code> for details.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3) with sampling time 0.5s</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: signal.dbode(sys)</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>dfreqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of the discrete-time <code>dlti</code> system.
See <code>dimpulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of the discrete-time system to input <code>u</code>.
See <code>dlsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of the discrete-time <code>dlti</code> system.
See <code>dstep</code> for details.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Lti</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Lti</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Lti</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Continuous-time linear time invariant system base class.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>*system : arguments
The <code>lti</code> class can be instantiated with either 2, 3 or 4 arguments.
The following gives the number of arguments and the corresponding
continuous-time subclass that is created:</p>
<ul>
<li>2: <code>TransferFunction</code>:  (numerator, denominator)</li>
<li>3: <code>ZerosPolesGain</code>: (zeros, poles, gain)</li>
<li>4: <code>StateSpace</code>:  (A, B, C, D)</li>
</ul>
<p>Each argument can be an array or a sequence.</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>ZerosPolesGain, StateSpace, TransferFunction, dlti</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p><code>lti</code> instances do not exist directly. Instead, <code>lti</code> creates an instance
of one of its subclasses: <code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>.</p>
<p>If (numerator, denominator) is passed in for <code>*system</code>, coefficients for
both the numerator and denominator should be specified in descending
exponent order (e.g., <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3,
5]</code>).</p>
<p>Changing the value of properties that are not directly part of the current
system representation (such as the <code>zeros</code> of a <code>StateSpace</code> system) is
very inefficient and may lead to numerical inaccuracies. It is better to
convert to the specific system representation first. For example, call
<code>sys = sys.to_zpk()</code> before accessing/changing the zeros, poles or gain.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>signal.lti(1, 2, 3, 4)
StateSpaceContinuous(
array([[1]]),
array([[2]]),
array([[3]]),
array([[4]]),
dt: None
)</p>
<p>signal.lti([1, 2], [3, 4], 5)
ZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)</p>
<p>signal.lti([3, 4], [1, 2])
TransferFunctionContinuous(
array([3., 4.]),
array([1., 2.]),
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>bode</code> for details.</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>freqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of a continuous-time system.
See <code>impulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of a continuous-time system to input <code>U</code>.
See <code>lsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of a continuous-time system.
See <code>step</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a discretized version of the current system.</p>
<p>Parameters: See <code>cont2discrete</code> for details.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>sys: instance of <code>dlti</code></p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Bsplines</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Add arguments element-wise.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
The arrays to be added. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>add : ndarray or scalar
The sum of <code>x1</code> and <code>x2</code>, element-wise.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>Equivalent to <code>x1</code> + <code>x2</code> in terms of array broadcasting.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.add(1.0, 4.0)
5.0
x1 = np.arange(9.0).reshape((3, 3))
x2 = np.arange(3.0)
np.add(x1, x2)
array([[  0.,   2.,   4.],
[  3.,   5.,   7.],
[  6.,   8.,  10.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arange</span> <span class="o">:</span> <span class="o">?</span><span class="n">start</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">step</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stop</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arange([start,] stop[, step,], dtype=None)</p>
<p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <code>[start, stop)</code>
(in other words, the interval including <code>start</code> but excluding <code>stop</code>).
For integer arguments the function is equivalent to the Python built-in
<code>range</code> function, but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <code>numpy.linspace</code> for these cases.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>start : number, optional
Start of interval.  The interval includes this value.  The default
start value is 0.
stop : number
End of interval.  The interval does not include this value, except
in some cases where <code>step</code> is not an integer and floating point
round-off affects the length of <code>out</code>.
step : number, optional
Spacing between values.  For any output <code>out</code>, this is the distance
between two adjacent values, <code>out[i+1] - out[i]</code>.  The default
step size is 1.  If <code>step</code> is specified as a position argument,
<code>start</code> must also be given.
dtype : dtype
The type of the output array.  If <code>dtype</code> is not given, infer the data
type from the other input arguments.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>arange : ndarray
Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<code>ceil((stop - start)/step)</code>.  Because of floating point overflow,
this rule may result in the last element of <code>out</code> being greater
than <code>stop</code>.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.arange(3)
array([0, 1, 2])
np.arange(3.0)
array([ 0.,  1.,  2.])
np.arange(3,7)
array([3, 4, 5, 6])
np.arange(3,7,2)
array([3, 5])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan2</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise arc tangent of <code>x1/x2</code> choosing the quadrant correctly.</p>
<p>The quadrant (i.e., branch) is chosen so that <code>arctan2(x1, x2)</code> is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (<code>x2</code>, <code>x1</code>).  (Note the role reversal: the
'<code>y</code>-coordinate' is the first function parameter, the '<code>x</code>-coordinate'
is the second.)  By IEEE convention, this function is defined for
<code>x2</code> = +/-0 and for either or both of <code>x1</code> and <code>x2</code> = +/-inf (see
Notes for specific values).</p>
<p>This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use <code>angle</code>.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>x1 : array_like, real-valued
<code>y</code>-coordinates.
x2 : array_like, real-valued
<code>x</code>-coordinates. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>angle : ndarray
Array of angles in radians, in the range <code>[-pi, pi]</code>.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>arctan, tan, angle</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p><em>arctan2</em> is identical to the <code>atan2</code> function of the underlying
C library.  The following special values are defined in the C
standard: [1]_</p>
<p>====== ====== ================
<code>x1</code>   <code>x2</code>   <code>arctan2(x1,x2)</code>
====== ====== ================
+/- 0  +0     +/- 0
+/- 0  -0     +/- pi</p>
<blockquote>
<p>0   +/-inf +0 / +pi
&lt; 0   +/-inf -0 / -pi
+/-inf +inf   +/- (pi/4)
+/-inf -inf   +/- (3*pi/4)
====== ====== ================</p>
</blockquote>
<p>Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] ISO/IEC standard 9899:1999, 'Programming language C.'</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<p>Consider four points in different quadrants:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([-1, +1, +1, -1])
y = np.array([-1, -1, +1, +1])
np.arctan2(y, x) * 180 / np.pi
array([-135.,  -45.,   45.,  135.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note the order of the parameters. <code>arctan2</code> is defined also when <code>x2</code> = 0
and at several other special points, obtaining values in
the range <code>[-pi, pi]</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.arctan2([1., -1.], [0., 0.])
array([ 1.57079633, -1.57079633])
np.arctan2([0., 0., np.inf], [+0., -0., np.inf])
array([ 0.        ,  3.14159265,  0.78539816])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bspline</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>B-spline basis function of order n.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>Uses numpy.piecewise and automatic function-generator.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">comb</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">repetition</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The number of combinations of N things taken k at a time.</p>
<p>This is often expressed as 'N choose k'.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>N : int, ndarray
Number of things.
k : int, ndarray
Number of elements taken.
exact : bool, optional
If <code>exact</code> is False, then floating point precision is used, otherwise
exact long integer is computed.
repetition : bool, optional
If <code>repetition</code> is True, then the number of combinations with
repetition is computed.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>val : int, float, ndarray
The total number of combinations.</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>binom : Binomial coefficient ufunc</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<ul>
<li>Array arguments accepted only for exact=False case.</li>
<li>If N &lt; 0, or k &lt; 0, then 0 is returned.</li>
<li>If k &gt; N and repetition=False, then 0 is returned.</li>
</ul>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import comb
k = np.array([3, 4])
n = np.array([10, 10])
comb(n, k, exact=False)
array([ 120.,  210.])
comb(10, 3, exact=True)
120L
comb(10, 3, exact=True, repetition=True)
220L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Cosine element-wise.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding cosine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</p>
<h1 id="example-of-providing-the-optional-output-parameter">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cspline1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">lamb</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute cubic spline coefficients for rank-1 array.</p>
<p>Find the cubic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 4.0, 1.0]/ 6.0 .</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>signal : ndarray
A rank-1 array representing samples of a signal.
lamb : float, optional
Smoothing coefficient, default is 0.0.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>c : ndarray
Cubic spline coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cspline1d_eval</span> <span class="o">:</span> <span class="o">?</span><span class="n">dx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cj</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">newx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a spline at the new set of points.</p>
<p><code>dx</code> is the old sample-spacing while <code>x0</code> was the old origin.  In
other-words the old-sample points (knot-points) for which the <code>cj</code>
represent spline coefficients were at equally-spaced points of:</p>
<p>oldx = x0 + j*dx  j=0...N-1, with N=len(cj)</p>
<p>Edges are handled using mirror-symmetric boundary conditions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cubic</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A cubic B-spline.</p>
<p>This is a special case of <code>bspline</code>, and equivalent to <code>bspline(x, 3)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise exponential of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array.
exp2  : Calculate <code>2**x</code> for all elements in the array.</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>The irrational number <code>e</code> is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>,
then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write
:math:<code>e^x = e^a e^{ib}</code>.  The first term, :math:<code>e^a</code>, is already
known (it is the real argument, described above).  The second term,
:math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with
magnitude 1 and a periodic phase.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Exponential function',
https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
http://www.math.sfu.ca/~cbm/aands/page_69.htm</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-2<em>np.pi, 2</em>np.pi, 100)
xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
out = np.exp(xx)</p>
<p>plt.subplot(121)
plt.imshow(np.abs(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='gray')
plt.title('Magnitude of exp(x)')</p>
<p>plt.subplot(122)
plt.imshow(np.angle(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='hsv')
plt.title('Phase (angle) of exp(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorial</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">floor</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the floor of the input, element-wise.</p>
<p>The floor of the scalar <code>x</code> is the largest integer <code>i</code>, such that
<code>i &lt;= x</code>.  It is often denoted as :math:<code>\lfloor x \rfloor</code>.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input data.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>y : ndarray or scalar
The floor of each element in <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>ceil, trunc, rint</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>Some spreadsheet programs calculate the 'floor-towards-zero', in other
words <code>floor(-2.5) == -2</code>.  NumPy instead uses the definition of
<code>floor</code> where <code>floor(-2.5) == -3</code>.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.floor(a)
array([-2., -2., -1.,  0.,  1.,  1.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gamma</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>gamma(z)</p>
<p>Gamma function.</p>
<p>The Gamma function is defined as</p>
<p>.. math::</p>
<p>\Gamma(z) = \int_0^\infty t^{z-1} e^{-t} dt</p>
<p>for :math:<code>\Re(z) &gt; 0</code> and is extended to the rest of the complex
plane by analytic continuation. See [dlmf]_ for more details.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>z : array_like
Real or complex valued argument</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Values of the Gamma function</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>The Gamma function is often referred to as the generalized
factorial since :math:<code>\Gamma(n + 1) = n!</code> for natural numbers
:math:<code>n</code>. More generally it satisfies the recurrence relation
:math:<code>\Gamma(z + 1) = z \cdot \Gamma(z)</code> for complex :math:<code>z</code>,
which, combined with the fact that :math:<code>\Gamma(1) = 1</code>, implies
the above identity for :math:<code>z = n</code>.</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>.. [dlmf] NIST Digital Library of Mathematical Functions
https://dlmf.nist.gov/5.2#E1</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import gamma, factorial</p>
<p>gamma([0, 0.5, 1, 5])
array([         inf,   1.77245385,   1.        ,  24.        ])</p>
<p>z = 2.5 + 1j
gamma(z)
(0.77476210455108352+0.70763120437959293j)
gamma(z+1), z*gamma(z)  # Recurrence property
((1.2292740569981171+2.5438401155000685j),
(1.2292740569981158+2.5438401155000658j))</p>
<p>gamma(0.5)**2  # gamma(0.5) = sqrt(pi)
3.1415926535897927</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot gamma(x) for real x</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-3.5, 5.5, 2251)
y = gamma(x)</p>
<p>import matplotlib.pyplot as plt
plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')
k = np.arange(1, 7)
plt.plot(k, factorial(k-1), 'k*', alpha=0.6,
...          label='(x-1)!, x = 1, 2, ...')
plt.xlim(-3.5, 5.5)
plt.ylim(-10, 25)
plt.grid()
plt.xlabel('x')
plt.legend(loc='lower right')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gauss_spline</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gaussian approximation to B-spline basis function of order n.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the spline. Must be nonnegative, i.e. n &gt;= 0</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] Bouma H., Vilanova A., Bescos J.O., ter Haar Romeny B.M., Gerritsen
F.A. (2007) Fast and Accurate Gaussian Derivatives Based on B-Splines. In:
Sgallari F., Murli A., Paragios N. (eds) Scale Space and Variational
Methods in Computer Vision. SSVM 2007. Lecture Notes in Computer
Science, vol 4485. Springer, Berlin, Heidelberg</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">greater</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &gt; x2) element-wise.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.
Typically of type bool, unless <code>dtype=object</code> is passed.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>greater_equal, less, less_equal, equal, not_equal</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.greater([4,2],[2,2])
array([ True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the inputs are ndarrays, then np.greater is equivalent to '&gt;'.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([4,2])
b = np.array([2,2])
a &gt; b
array([ True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">greater_equal</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &gt;= x2) element-wise.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>out : bool or ndarray of bool
Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.
Typically of type bool, unless <code>dtype=object</code> is passed.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>greater, less, less_equal, equal, not_equal</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.greater_equal([4, 2, 1], [2, 2, 2])
array([ True, True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">less</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &lt; x2) element-wise.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.
Typically of type bool, unless <code>dtype=object</code> is passed.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>greater, less_equal, greater_equal, equal, not_equal</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.less([1, 2], [2, 2])
array([ True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">less_equal</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 =&lt; x2) element-wise.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.
Typically of type bool, unless <code>dtype=object</code> is passed.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>greater, less, greater_equal, equal, not_equal</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.less_equal([4, 2, 1], [2, 2, 2])
array([False,  True,  True])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logical_and</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of x1 AND x2 element-wise.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>x1, x2 : array_like
Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>y : ndarray or bool
Boolean result of the logical AND operation applied to the elements
of <code>x1</code> and <code>x2</code>; the shape is determined by broadcasting.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>logical_or, logical_not, logical_xor
bitwise_and</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.logical_and(True, False)
False
np.logical_and([True, False], [False, False])
array([False, False])</p>
<p>x = np.arange(5)
np.logical_and(x&gt;1, x&lt;4)
array([False, False,  True,  True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">piecewise</span> <span class="o">:</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">condlist</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">funclist</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a piecewise-defined function.</p>
<p>Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>x : ndarray or scalar
The input domain.
condlist : list of bool arrays or bool scalars
Each boolean array corresponds to a function in <code>funclist</code>.  Wherever
<code>condlist[i]</code> is True, <code>funclist[i](x)</code> is used as the output value.</p>
<p>Each boolean array in <code>condlist</code> selects a piece of <code>x</code>,
and should therefore be of the same shape as <code>x</code>.</p>
<p>The length of <code>condlist</code> must correspond to that of <code>funclist</code>.
If one extra function is given, i.e. if
<code>len(funclist) == len(condlist) + 1</code>, then that extra function
is the default value, used wherever all conditions are false.
funclist : list of callables, f(x,<em>args,</em>*kw), or scalars
Each function is evaluated over <code>x</code> wherever its corresponding
condition is True.  It should take a 1d array as input and give an 1d
array or a scalar value as output.  If, instead of a callable,
a scalar is provided then a constant function (<code>lambda x: scalar</code>) is
assumed.
args : tuple, optional
Any further arguments given to <code>piecewise</code> are passed to the functions
upon execution, i.e., if called <code>piecewise(..., ..., 1, 'a')</code>, then
each function is called as <code>f(x, 1, 'a')</code>.
kw : dict, optional
Keyword arguments used in calling <code>piecewise</code> are passed to the
functions upon execution, i.e., if called
<code>piecewise(..., ..., alpha=1)</code>, then each function is called as
<code>f(x, alpha=1)</code>.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The output is the same shape and type as x and is found by
calling the functions in <code>funclist</code> on the appropriate portions of <code>x</code>,
as defined by the boolean arrays in <code>condlist</code>.  Portions not covered
by any condition have a default value of 0.</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>choose, select, where</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>This is similar to choose or select, except that functions are
evaluated on elements of <code>x</code> that satisfy the corresponding condition from
<code>condlist</code>.</p>
<p>The result is::</p>
<p>|--
|funclist<a href="x[condlist[0]]">0</a>
out = |funclist<a href="x[condlist[1]]">1</a>
|...
|funclist<a href="x[condlist[n2]]">n2</a>
|--</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<p>Define the sigma function, which is -1 for <code>x &lt; 0</code> and +1 for <code>x &gt;= 0</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(-2.5, 2.5, 6)
np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])
array([-1., -1., -1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the absolute value, which is <code>-x</code> for <code>x &lt;0</code> and <code>x</code> for
<code>x &gt;= 0</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])
array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the same function to a scalar value.</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = -2
np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])
array(2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qspline1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">lamb</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute quadratic spline coefficients for rank-1 array.</p>
<p>Find the quadratic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 6.0, 1.0]/ 8.0 .</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>signal : ndarray
A rank-1 array representing samples of a signal.
lamb : float, optional
Smoothing coefficient (must be zero for now).</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>c : ndarray
Cubic spline coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qspline1d_eval</span> <span class="o">:</span> <span class="o">?</span><span class="n">dx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cj</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">newx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a quadratic spline at the new set of points.</p>
<p><code>dx</code> is the old sample-spacing while <code>x0</code> was the old origin.  In
other-words the old-sample points (knot-points) for which the <code>cj</code>
represent spline coefficients were at equally-spaced points of::</p>
<p>oldx = x0 + j*dx  j=0...N-1, with N=len(cj)</p>
<p>Edges are handled using mirror-symmetric boundary conditions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">quadratic</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A quadratic B-spline.</p>
<p>This is a special case of <code>bspline</code>, and equivalent to <code>bspline(x, 2)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sepfir2d</span> <span class="o">:</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hrow</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hcol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sepfir2d(input, hrow, hcol) -&gt; output</p>
<p>Description:</p>
<p>Convolve the rank-2 input array with the separable filter defined by the
rank-1 arrays hrow, and hcol. Mirror symmetric boundary conditions are
assumed.  This function can be used to find an image given its B-spline
representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>x : array_like
Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>y : array_like
The sine of each element of x.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>arcsin, sinh, cos</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:<code>+x</code> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:<code>y</code> coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code>  The
function has zeroes where the angle is a multiple of :math:<code>\pi</code>.
Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<p>Print sine of one angle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.pi/2.)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">lmbda</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Smoothing spline (cubic) filtering of a rank-2 array.</p>
<p>Filter an input data set, <code>Iin</code>, using a (cubic) smoothing spline of
fall-off <code>lmbda</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute tangent element-wise.</p>
<p>Equivalent to <code>np.sin(x)/np.cos(x)</code> element-wise.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding tangent values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from math import pi
np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])</p>
<h1 id="example-of-providing-the-optional-output-parameter-illustrating">Example of providing the optional output parameter illustrating<a class="headerlink" href="#example-of-providing-the-optional-output-parameter-illustrating" title="Permanent link">&para;</a></h1>
<h1 id="that-what-is-returned-is-a-reference-to-said-parameter">that what is returned is a reference to said parameter<a class="headerlink" href="#that-what-is-returned-is-a-reference-to-said-parameter" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_1">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_1" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_20">See Also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros_like</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array of zeros with the same shape and type as a given array.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>a : array_like
The shape and data-type of <code>a</code> define these same attributes of
the returned array.
dtype : data-type, optional
Overrides the data type of the result.</p>
<p>.. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
Overrides the memory layout of the result. 'C' means C-order,
'F' means F-order, 'A' means 'F' if <code>a</code> is Fortran contiguous,
'C' otherwise. 'K' means match the layout of <code>a</code> as closely
as possible.</p>
<p>.. versionadded:: 1.6.0
subok : bool, optional.
If True, then the newly created array will use the sub-class
type of 'a', otherwise it will be a base-class array. Defaults
to True.
shape : int or sequence of ints, optional.
Overrides the shape of the result. If order='K' and the number of
dimensions is unchanged, will try to keep order, otherwise,
order='C' is implied.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the same shape and type as <code>a</code>.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(6)
x = x.reshape((2, 3))
x
array([[0, 1, 2],
[3, 4, 5]])
np.zeros_like(x)
array([[0, 0, 0],
[0, 0, 0]])</p>
<p>y = np.arange(3, dtype=float)
y
array([0., 1., 2.])
np.zeros_like(y)
array([0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Filter_design</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Sp_fft</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on <code>dct</code> and the <code>idct</code> is scaled by
<code>1/N</code> where <code>N</code> is the 'logical' size of the DCT. For <code>norm='ortho'</code>
both directions are scaled by the same factor <code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on the <code>dst</code> and the <code>idst</code> is
scaled by <code>1/N</code> where <code>N</code> is the 'logical' size of the DST. For
<code>norm='ortho'</code> both directions are scaled by the same factor
<code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding dimension
of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [1]_.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT.  If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode. Default is None, meaning no normalization on the
forward transforms and scaling by <code>1/n</code> on the <code>ifft</code>.
For <code>norm='ortho'</code>, both directions are scaled by <code>1/sqrt(n)</code>.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See the notes below for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>. See below for more
details.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>IndexError
if <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>ifft : The inverse of <code>fft</code>.
fft2 : The two-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.
next_fast_len : Size to pad input to for most efficient transforms</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform
(DFT) can be calculated efficiently, by using symmetries in the calculated
terms. The symmetry is highest when <code>n</code> is a power of 2, and the transform
is therefore most efficient for these sizes. For poorly factorizable sizes,
<code>scipy.fft</code> uses Bluestein's algorithm [2]_ and so is never worse than
O(<code>n</code> log <code>n</code>). Further performance improvements may be seen by zero-padding
the input using <code>next_fast_len</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>fft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(-2j * np.pi * k * np.arange(n)/n))</p>
<p>The frequency term <code>f=k/n</code> is found at <code>y[k]</code>. At <code>y[n/2]</code> we reach
the Nyquist frequency and wrap around to the negative-frequency terms. So,
for an 8-point transform, the frequencies of the result are
[0, 1, 2, 3, -4, -3, -2, -1]. To rearrange the fft output so that the
zero-frequency component is centered, like [-4, -3, -2, -1, 0, 1, 2, 3],
use <code>fftshift</code>.</p>
<p>Transforms can be done in single, double or extended precision (long
double) floating point. Half precision inputs will be converted to single
precision and non floating-point inputs will be converted to double
precision.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<p>When <code>overwrite_x=True</code> is specified, the memory referenced by <code>x</code> may
be used by the implementation in any way. This may include reusing the
memory for the result, but this is in no way guaranteed. You should not
rely on the contents of <code>x</code> after the transform as this may change in
future without warning.</p>
<p>The <code>workers</code> argument specifies the maximum number of parallel jobs to
split the FFT computation into. This will execute independent 1-dimensional
FFTs within <code>x</code>. So, <code>x</code> must be at least 2-dimensional and the
non-transformed axes must be large enough to split into chunks. If <code>x</code> is
too small, fewer jobs may be used than requested.</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
machine calculation of complex Fourier series,' <em>Math. Comput.</em>
19: 297-301.
.. [2] Bluestein, L., 1970, 'A linear filtering approach to the
computation of discrete Fourier transform'. <em>IEEE Transactions on
Audio and Electroacoustics.</em> 18 (4): 451-455.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, fftfreq, fftshift
import matplotlib.pyplot as plt
t = np.arange(256)
sp = fftshift(fft(np.sin(t)))
freq = fftshift(fftfreq(t.shape[-1]))
plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional discrete Fourier Transform</p>
<p>This function computes the <em>n</em>-dimensional discrete Fourier Transform
over any axes in an <em>M</em>-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT. If not given, the last two axes are
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_1">Raises<a class="headerlink" href="#raises_1" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
For two-dimensional input, swaps first and third quadrants, and second
and fourth quadrants.</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p><code>fft2</code> is just <code>fftn</code> with a different default for <code>axes</code>.</p>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.</p>
<p>See <code>fftn</code> for details and a plotting example, and <code>fft</code> for
definitions and conventions used.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:5, :5][0]
scipy.fft.fft2(x)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
0.  +0.j        ,   0.  +0.j        ],
[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform.</p>
<p>This function computes the <em>N</em>-dimensional discrete Fourier Transform over
any number of axes in an <em>M</em>-dimensional array by means of the Fast Fourier
Transform (FFT).</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_2">Raises<a class="headerlink" href="#raises_2" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>ifftn : The inverse of <code>fftn</code>, the inverse <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The <em>n</em>-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:3, :3, :3][0]
scipy.fft.fftn(x, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[ 9.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[18.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]]])
scipy.fft.fftn(x, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
[ 0.+0.j,  0.+0.j,  0.+0.j]],
[[-2.+0.j, -2.+0.j, -2.+0.j],
[ 0.+0.j,  0.+0.j,  0.+0.j]]])</p>
<p>import matplotlib.pyplot as plt
[X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
FS = scipy.fft.fftn(S)
plt.imshow(np.log(np.abs(scipy.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_29">See Also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_workers</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the default number of workers within the current context</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft
fft.get_workers()
1
with fft.set_workers(4):
...     fft.get_workers()
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output. For <code>n</code> output
points, <code>n//2 + 1</code> input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros. If <code>n</code> is not given, it is taken to be <code>2*(m-1)</code>
where <code>m</code> is the length of the input along the axis specified by
<code>axis</code>.
axis : int, optional
Axis over which to compute the FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*m - 2</code> where <code>m</code> is the length of the transformed axis of
the input. To get an odd number of output points, <code>n</code> must be
specified, for instance as <code>2*m - 1</code> in the typical case,</p>
<h2 id="raises_3">Raises<a class="headerlink" href="#raises_3" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_30">See also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of <code>hfft</code>.
hfftn : Compute the n-dimensional FFT of a Hermitian signal.</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd.
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, hfft
a = 2 * np.pi * np.arange(10) / 10
signal = np.cos(a) + 3j * np.sin(3 * a)
fft(signal).round(10)
array([ -0.+0.j,   5.+0.j,  -0.+0.j,  15.-0.j,   0.+0.j,   0.+0.j,
-0.+0.j, -15.-0.j,   0.+0.j,   5.+0.j])
hfft(signal[:6]).round(10) # Input first half of signal
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])
hfft(signal, 10)  # Input entire signal and truncate
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a Hermitian complex array.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be Hermitian complex.
s : sequence of ints, optional
Shape of the real output.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The real result of the 2D Hermitian complex real FFT.</p>
<h2 id="see-also_31">See Also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>hfftn : Compute the N-dimensional discrete Fourier Transform for Hermitian
complex input.</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>This is really just <code>hfftn</code> with different default behavior.
For more details see <code>hfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional FFT of Hermitian symmetric complex input, i.e. a
signal with a real spectrum.</p>
<p>This function computes the N-dimensional discrete Fourier Transform for a
Hermitian symmetric complex input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT). In other
words, <code>ihfftn(hfftn(x, s)) == x</code> to within numerical accuracy. (<code>s</code>
here is <code>x.shape</code> with <code>s[-1] = x.shape[-1] * 2 - 1</code>, this is necessary
for the same reason <code>x.shape</code> would be necessary for <code>irfft</code>.)</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_4">Raises<a class="headerlink" href="#raises_4" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_32">See Also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>ihfftn : The inverse n-dimensional FFT with real spectrum. Inverse of <code>hfftn</code>.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : Forward FFT of real input</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>For a 1 dimensional signal <code>x</code> to have a real spectrum, it must satisfy
the Hermitian property::</p>
<p>x[i] == np.conj(x[-i]) for all i</p>
<p>This generalizes into higher dimensions by reflecting over each axis in
turn::</p>
<p>x[i, j, k, ...] == np.conj(x[-i, -j, -k, ...]) for all i, j, k, ...</p>
<p>This should not be confused with a Hermitian matrix, for which the
transpose is it's own conjugate::</p>
<p>x[i, j] == np.conj(x[j, i]) for all i, j</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((3, 2, 2))
scipy.fft.hfftn(x)
array([[[12.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_33">See Also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT-II, which is the same as the normalized DCT-III.</p>
<p>The IDCT is equivalent to a normal DCT except for the normalization and
type. DCT type 1 and 4 are their own inverse and DCTs 2 and 3 are each
other's inverses.</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1)
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are
None, <code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is
not None, then <code>s</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST-II, which is the same as the normalized DST-III.</p>
<p>The IDST is equivalent to a normal DST except for the normalization and
type. DST type 1 and 4 are their own inverse and DSTs 2 and 3 are each
other's inverses.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_36">See Also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <code>fft</code>.  In other words,
<code>ifft(fft(x)) == x</code> to within numerical accuracy.</p>
<p>The input should be ordered in the same way as is returned by <code>fft</code>,
i.e.,</p>
<ul>
<li><code>x[0]</code> should contain the zero frequency term,</li>
<li><code>x[1:n//2]</code> should contain the positive-frequency terms,</li>
<li><code>x[n//2 + 1:]</code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</li>
</ul>
<p>For an even number of input points, <code>x[n//2]</code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <code>fft</code> for details.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
See notes about padding issues.
axis : int, optional
Axis over which to compute the inverse DFT.  If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_5">Raises<a class="headerlink" href="#raises_5" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_37">See Also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>fft : The one-dimensional (forward) FFT, of which <code>ifft</code> is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>If the input parameter <code>n</code> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <code>ifft</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>ifft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(2j * np.pi * k * np.arange(n)/n)) / len(x)</p>
<p>As with <code>fft</code>, <code>ifft</code> has support for all floating point types and is
optimized for real input.</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot a band-limited signal with random phases:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(400)
n = np.zeros((400,), dtype=complex)
n[40:60] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20,)))
s = scipy.fft.ifft(n)
plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, <code>ifft2(fft2(x)) == x</code>
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fft2</code>, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each axis) of the output (<code>s[0]</code> refers to axis 0,
<code>s[1]</code> to axis 1, etc.).  This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last two
axes are used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_6">Raises<a class="headerlink" href="#raises_6" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_38">See Also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>fft2 : The forward 2-dimensional FFT, of which <code>ifft2</code> is the inverse.
ifftn : The inverse of the <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p><code>ifft2</code> is just <code>ifftn</code> with a different default for <code>axes</code>.</p>
<p>See <code>ifftn</code> for details and a plotting example, and <code>fft</code> for
definition and conventions used.</p>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifft2</code> is called.</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = 4 * np.eye(4)
scipy.fft.ifft2(x)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
<code>ifftn(fftn(x)) == x</code> to within numerical accuracy.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fftn</code>, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the IFFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_7">Raises<a class="headerlink" href="#raises_7" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>fftn : The forward <em>n</em>-dimensional FFT, of which <code>ifftn</code> is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes <code>fftshift</code>, shifts zero-frequency terms to beginning
of array.</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifftn</code> is called.</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.eye(4)
scipy.fft.ifftn(scipy.fft.fftn(x, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot an image with band-limited frequency content:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
n = np.zeros((200,200), dtype=complex)
n[60:80, 20:40] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20, 20)))
im = scipy.fft.ifftn(n).real
plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
n : int, optional
Length of the inverse FFT, the number of points along
transformation axis in the input to use.  If <code>n</code> is smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. If <code>n</code> is not given, the length of
the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n//2 + 1</code>.</p>
<h2 id="see-also_41">See also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>hfft, irfft</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd:
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, ihfft
spectrum = np.array([ 15, -4, 0, -1, 0, -4])
ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real spectrum.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real input to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>ihfftn : Compute the inverse of the N-dimensional FFT of Hermitian input.</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p>This is really <code>ihfftn</code> with different defaults.
For more details see <code>ihfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform for a real
spectrum.</p>
<p>This function computes the N-dimensional inverse discrete Fourier Transform
over any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT). By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining transforms
are complex.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_8">Raises<a class="headerlink" href="#raises_8" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_43">See Also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>hfftn : The forward n-dimensional FFT of Hermitian input.
hfft : The one-dimensional FFT of Hermitian input.
fft : The one-dimensional FFT, with definitions and conventions used.
fftn : The n-dimensional FFT.
hfft2 : The two-dimensional FFT of Hermitian input.</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>ihfft</code>, then the transform over the remaining axes is
performed as by <code>ifftn</code>. The order of the output is the positive part of
the Hermitian output signal, in the same format as <code>rfft</code>.</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.ihfftn(x)
array([[[1.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])
scipy.fft.ihfftn(x, axes=(2, 0))
array([[[1.+0.j,  0.+0.j], # may vary
[1.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <code>rfft</code>.
In other words, <code>irfft(rfft(x), len(x)) == x</code> to within numerical
accuracy. (See Notes below for why <code>len(a)</code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <code>rfft</code>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output.
For <code>n</code> output points, <code>n//2+1</code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <code>n</code> is not given, it is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along the axis
specified by <code>axis</code>.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*(m-1)</code> where <code>m</code> is the length of the transformed axis of the
input. To get an odd number of output points, <code>n</code> must be specified.</p>
<h2 id="raises_9">Raises<a class="headerlink" href="#raises_9" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>rfft : The one-dimensional FFT of real input, of which <code>irfft</code> is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>Returns the real valued <code>n</code>-point inverse discrete Fourier transform
of <code>x</code>, where <code>x</code> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <code>n</code> is the length of the result, not the
input.</p>
<p>If you specify an <code>n</code> such that <code>a</code> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <code>m</code> points via Fourier interpolation by:
<code>a_resamp = irfft(rfft(a), m)</code>.</p>
<p>The default value of <code>n</code> assumes an even output length. By the Hermitian
symmetry, the last imaginary component must be 0 and so is ignored. To
avoid losing information, the correct length of the real input <em>must</em> be
given.</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
scipy.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the last term in the input to the ordinary <code>ifft</code> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <code>irfft</code>, the negative frequencies are not
specified, and the output array is purely real.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real array.</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real output to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_45">See Also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>irfftn : Compute the inverse of the N-dimensional FFT of real input.</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>This is really <code>irfftn</code> with different defaults.
For more details see <code>irfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the N-dimensional FFT of real input.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, <code>irfftn(rfftn(x), x.shape) == x</code> to within numerical
accuracy. (The <code>a.shape</code> is necessary like <code>len(a)</code> is for <code>irfft</code>,
and for the same reason.)</p>
<p>The input should be ordered in the same way as is returned by <code>rfftn</code>,
i.e. as for <code>irfft</code> for the final transformation axis, and as for <code>ifftn</code>
along all the other axes.</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_10">Raises<a class="headerlink" href="#raises_10" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_46">See Also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>rfftn : The forward n-dimensional FFT of real input,
of which <code>ifftn</code> is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p>See <code>fft</code> for definitions and conventions used.</p>
<p>See <code>rfft</code> for definitions and conventions used for real input.</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.zeros((3, 2, 2))
x[0, 0, 0] = 3 * 2 * 2
scipy.fft.irfftn(x)
array([[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">register_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Register a backend for permanent use.</p>
<p>Registered backends have the lowest priority and will be tried after the
global backend.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_11">Raises<a class="headerlink" href="#raises_11" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array
n : int, optional
Number of points along transformation axis in the input to use.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT. If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
If <code>n</code> is even, the length of the transformed axis is <code>(n/2)+1</code>.
If <code>n</code> is odd, the length is <code>(n+1)/2</code>.</p>
<h2 id="raises_12">Raises<a class="headerlink" href="#raises_12" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_47">See Also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>irfft : The inverse of <code>rfft</code>.
fft : The one-dimensional FFT of general (complex) input.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore <code>n//2 + 1</code>.</p>
<p>When <code>X = rfft(x)</code> and fs is the sampling frequency, <code>X[0]</code> contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</p>
<p>If <code>n</code> is even, <code>A[-1]</code> contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If <code>n</code> is odd, there is no term at fs/2; <code>A[-1]</code> contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.</p>
<p>If the input <code>a</code> contains an imaginary part, it is silently discarded.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
scipy.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the final element of the <code>fft</code> output is the complex conjugate
of the second element, for real input. For <code>rfft</code>, this symmetry is
exploited to compute only the non-negative frequency terms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a real array.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be real.
s : sequence of ints, optional
Shape of the FFT.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the real 2-D FFT.</p>
<h2 id="see-also_48">See Also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>rfftn : Compute the N-dimensional discrete Fourier Transform for real
input.</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>This is really just <code>rfftn</code> with different default behavior.
For more details see <code>rfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,     n/2-1,     n/2] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d</em>n)   if n is odd</p>
<p>Unlike <code>fftfreq</code> (but like <code>scipy.fftpack.rfftfreq</code>)
the Nyquist frequency component is considered to be positive.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n//2 + 1</code> containing the sample frequencies.</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
fourier = np.fft.rfft(signal)
n = signal.size
sample_rate = 100
freq = np.fft.fftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
freq = np.fft.rfftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20.,  30.,  40.,  50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
The final element of <code>s</code> corresponds to <code>n</code> for <code>rfft(x, n)</code>, while
for the remaining axes, it corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_13">Raises<a class="headerlink" href="#raises_13" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_49">See Also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>irfftn : The inverse of <code>rfftn</code>, i.e. the inverse of the n-dimensional FFT
of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>rfft</code>, then the transform over the remaining axes is
performed as by <code>fftn</code>.  The order of the output is as for <code>rfft</code> for the
final transformation axis, and as for <code>fftn</code> for the remaining
transformation axes.</p>
<p>See <code>fft</code> for details, definitions and conventions used.</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.rfftn(x)
array([[[8.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
<p>scipy.fft.rfftn(x, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
[4.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_backend</span> <span class="o">:</span> <span class="o">?</span><span class="n">coerce</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">backend</span><span class="o">:[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to set the backend within a fixed scope.</p>
<p>Upon entering the <code>with</code> statement, the given backend will be added to
the list of available backends with the highest priority. Upon exit, the
backend is reset to the state before entering the scope.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.
coerce: bool, optional
Whether to allow expensive conversions for the <code>x</code> parameter. e.g.
copying a numpy array to the GPU for a CuPy backend. Implies <code>only</code>.
only: bool, optional
If only is <code>True</code> and this backend returns <code>NotImplemented</code> then a
BackendNotImplemented error will be raised immediately. Ignoring any
lower priority backends.</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
with fft.set_backend('scipy', only=True):
...     fft.fft([1])  # Always calls the scipy implementation
array([1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_global_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sets the global fft backend</p>
<p>The global backend has higher priority than registered backends, but lower
priority than context-specific backends set with <code>set_backend</code>.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_14">Raises<a class="headerlink" href="#raises_14" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p>This will overwrite the previously set global backend, which by default is
the SciPy implementation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_workers</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager for the default number of workers used in <code>scipy.fft</code></p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>workers : int
The default number of workers to use</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft, signal
x = np.random.randn(128, 64)
with fft.set_workers(4):
...     y = signal.fftconvolve(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">skip_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to skip a backend within a fixed scope.</p>
<p>Within the context of a <code>with</code> statement, the given backend will not be
called. This covers backends registered both locally and globally. Upon
exit, the backend will again be considered.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to skip.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
fft.fft([1])  # Calls default scipy backend
array([1.+0.j])
with fft.skip_backend('scipy'):  # We expicitly skip the scipy backend
...     fft.fft([1])                 # leaving no implementation available
Traceback (most recent call last):
...
BackendNotImplementedError: No selected backends had an implementation ...</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">abs</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>absolute : ndarray
An ndarray containing the absolute value of
each element in <code>x</code>.  For complex input, <code>a + ib</code>, the
absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([-1.2, 1.2])
np.absolute(x)
array([ 1.2,  1.2])
np.absolute(1.2 + 1j)
1.5620499351813308</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(start=-10, stop=10, num=101)
plt.plot(x, np.absolute(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xx = x + 1j * x[:, np.newaxis]
plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">absolute</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>absolute : ndarray
An ndarray containing the absolute value of
each element in <code>x</code>.  For complex input, <code>a + ib</code>, the
absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([-1.2, 1.2])
np.absolute(x)
array([ 1.2,  1.2])
np.absolute(1.2 + 1j)
1.5620499351813308</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(start=-10, stop=10, num=101)
plt.plot(x, np.absolute(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xx = x + 1j * x[:, np.newaxis]
plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">append</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">arr</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">values</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Append values to the end of an array.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>arr : array_like
Values are appended to a copy of this array.
values : array_like
These values are appended to a copy of <code>arr</code>.  It must be of the
correct shape (the same shape as <code>arr</code>, excluding <code>axis</code>).  If
<code>axis</code> is not specified, <code>values</code> can be any shape and will be
flattened before use.
axis : int, optional
The axis along which <code>values</code> are appended.  If <code>axis</code> is not
given, both <code>arr</code> and <code>values</code> are flattened before use.</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>append : ndarray
A copy of <code>arr</code> with <code>values</code> appended to <code>axis</code>.  Note that
<code>append</code> does not occur in-place: a new array is allocated and
filled.  If <code>axis</code> is None, <code>out</code> is a flattened array.</p>
<h2 id="see-also_50">See Also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>insert : Insert elements into an array.
delete : Delete elements from an array.</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
array([1, 2, 3, ..., 7, 8, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>axis</code> is specified, <code>values</code> must have the correct shape.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
[4, 5, 6],
[7, 8, 9]])
np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
Traceback (most recent call last):
...
ValueError: all the input arrays must have same number of dimensions</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arccosh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse hyperbolic cosine, element-wise.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>arccosh : ndarray
Array of the same shape as <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_51">See Also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>cosh, arcsinh, sinh, arctanh, tanh</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p><code>arccosh</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that <code>cosh(z) = x</code>. The convention is to return the
<code>z</code> whose imaginary part lies in <code>[-pi, pi]</code> and the real part in
<code>[0, inf]</code>.</p>
<p>For real-valued input data types, <code>arccosh</code> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccosh</code> is a complex analytical function that
has a branch cut <code>[-inf, 1]</code> and is continuous from above on it.</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
https://en.wikipedia.org/wiki/Arccosh</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.arccosh([np.e, 10.0])
array([ 1.65745445,  2.99322285])
np.arccosh(1)
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsinh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse hyperbolic sine element-wise.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Array of the same shape as <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p><code>arcsinh</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that <code>sinh(z) = x</code>. The convention is to return the
<code>z</code> whose imaginary part lies in <code>[-pi/2, pi/2]</code>.</p>
<p>For real-valued input data types, <code>arcsinh</code> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytical function that
has branch cuts <code>[1j, infj]</code> and <code>[-1j, -infj]</code> and is continuous from
the right on the former and from the left on the latter.</p>
<p>The inverse hyperbolic sine is also known as <code>asinh</code> or <code>sinh^-1</code>.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Inverse hyperbolic function',
https://en.wikipedia.org/wiki/Arcsinh</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arctan</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse tangent, element-wise.</p>
<p>The inverse of tan, so that if <code>y = tan(x)</code> then <code>x = arctan(y)</code>.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>x : array_like
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Out has the same shape as <code>x</code>.  Its real part is in
<code>[-pi/2, pi/2]</code> (<code>arctan(+/-inf)</code> returns <code>+/-pi/2</code>).
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_52">See Also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>arctan2 : The 'four quadrant' arctan of the angle formed by (<code>x</code>, <code>y</code>)
and the positive <code>x</code>-axis.
angle : Argument of complex values.</p>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p><code>arctan</code> is a multi-valued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that tan(<code>z</code>) = <code>x</code>.  The convention is to return
the angle <code>z</code> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <code>arctan</code> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arctan</code> is a complex analytic function that
has [<code>1j, infj</code>] and [<code>-1j, -infj</code>] as branch cuts, and is continuous
from the left on the former and from the right on the latter.</p>
<p>The inverse tangent is also known as <code>atan</code> or tan^{-1}.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79.
http://www.math.sfu.ca/~cbm/aands/</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<p>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.arctan([0, 1])
array([ 0.        ,  0.78539816])</p>
<p>np.pi/4
0.78539816339744828</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot arctan:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-10, 10)
plt.plot(x, np.arctan(x))
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_53">See Also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_54">See Also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also_55">See Also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">band_stop_obj</span> <span class="o">:</span> <span class="n">wp</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">ind</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">passb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stopb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">type_</span><span class="o">:[`</span><span class="nc">Butter</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cheby</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ellip</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Band Stop Objective Function for order minimization.</p>
<p>Returns the non-integer order for an analog band stop filter.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>wp : scalar
Edge of passband <code>passb</code>.
ind : int, {0, 1}
Index specifying which <code>passb</code> edge to vary (0 or 1).
passb : ndarray
Two element sequence of fixed passband edges.
stopb : ndarray
Two element sequence of fixed stopband edges.
gstop : float
Amount of attenuation in stopband in dB.
gpass : float
Amount of ripple in the passband in dB.
type : {'butter', 'cheby', 'ellip'}
Type of filter.</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>n : scalar
Filter order (possibly non-integer).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bessel</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">Phase</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Delay</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mag</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Bessel/Thomson digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Bessel filter and return the
filter coefficients.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies (defined
by the <code>norm</code> parameter).
For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.  (See Notes.)
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.
norm : {'phase', 'delay', 'mag'}, optional
Critical frequency normalization:</p>
<p><code>phase</code>
The filter is normalized such that the phase response reaches its
midpoint at angular (e.g. rad/s) frequency <code>Wn</code>.  This happens for
both low-pass and high-pass filters, so this is the
'phase-matched' case.</p>
<p>The magnitude response asymptotes are the same as a Butterworth
filter of the same order with a cutoff of <code>Wn</code>.</p>
<p>This is the default, and matches MATLAB's implementation.</p>
<p><code>delay</code>
The filter is normalized such that the group delay in the passband
is 1/<code>Wn</code> (e.g. seconds).  This is the 'natural' type obtained by
solving Bessel polynomials.</p>
<p><code>mag</code>
The filter is normalized such that the gain magnitude is -3 dB at
angular frequency <code>Wn</code>.</p>
<p>.. versionadded:: 0.18.0
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>Also known as a Thomson filter, the analog Bessel filter has maximally
flat group delay and maximally linear phase response, with very little
ringing in the step response. [1]_</p>
<p>The Bessel is inherently an analog filter.  This function generates digital
Bessel filters using the bilinear transform, which does not preserve the
phase response of the analog filter.  As such, it is only approximately
correct at frequencies below about fs/4.  To get maximally-flat group
delay at higher frequencies, the analog Bessel filter must be transformed
using phase-preserving techniques.</p>
<p>See <code>besselap</code> for implementation details and references.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<p>Plot the phase-normalized frequency response, showing the relationship
to the Butterworth's cutoff frequency (green):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.butter(4, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')
b, a = signal.bessel(4, 100, 'low', analog=True, norm='phase')
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)))
plt.title('Bessel filter magnitude response (with Butterworth)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green')  # cutoff frequency
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>and the phase midpoint:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.semilogx(w, np.unwrap(np.angle(h)))
plt.axvline(100, color='green')  # cutoff frequency
plt.axhline(-np.pi, color='red')  # phase midpoint
plt.title('Bessel filter phase response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Phase [radians]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the magnitude-normalized frequency response, showing the -3 dB cutoff:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.bessel(3, 10, 'low', analog=True, norm='mag')
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)))
plt.axhline(-3, color='red')  # -3 dB magnitude
plt.axvline(10, color='green')  # cutoff frequency
plt.title('Magnitude-normalized Bessel filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the delay-normalized filter, showing the maximally-flat group delay
at 0.1 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.bessel(5, 1/0.1, 'low', analog=True, norm='delay')
w, h = signal.freqs(b, a)
plt.figure()
plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))
plt.axhline(0.1, color='red')  # 0.1 seconds group delay
plt.title('Bessel filter group delay')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Group delay [seconds]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [1] Thomson, W.E., 'Delay Networks having Maximally Flat Frequency
Characteristics', Proceedings of the Institution of Electrical
Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">besselap</span> <span class="o">:</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">Phase</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Delay</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mag</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return (z,p,k) for analog prototype of an Nth-order Bessel filter.</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
norm : {'phase', 'delay', 'mag'}, optional
Frequency normalization:</p>
<p><code>phase</code>
The filter is normalized such that the phase response reaches its
midpoint at an angular (e.g. rad/s) cutoff frequency of 1.  This
happens for both low-pass and high-pass filters, so this is the
'phase-matched' case. [6]_</p>
<p>The magnitude response asymptotes are the same as a Butterworth
filter of the same order with a cutoff of <code>Wn</code>.</p>
<p>This is the default, and matches MATLAB's implementation.</p>
<p><code>delay</code>
The filter is normalized such that the group delay in the passband
is 1 (e.g. 1 second).  This is the 'natural' type obtained by
solving Bessel polynomials</p>
<p><code>mag</code>
The filter is normalized such that the gain magnitude is -3 dB at
angular frequency 1.  This is called 'frequency normalization' by
Bond. [1]_</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function. Is always an empty array.
p : ndarray
Poles of the transfer function.
k : scalar
Gain of the transfer function.  For phase-normalized, this is always 1.</p>
<h2 id="see-also_56">See Also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>bessel : Filter design function using this prototype</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>To find the pole locations, approximate starting points are generated [2]<em>
for the zeros of the ordinary Bessel polynomial [3]</em>, then the
Aberth-Ehrlich method [4]<em> [5]</em> is used on the Kv(x) Bessel function to
calculate more accurate zeros, and these locations are then inverted about
the unit circle.</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] C.R. Bond, 'Bessel Filter Constants',
http://www.crbond.com/papers/bsf.pdf
.. [2] Campos and Calderon, 'Approximate closed-form formulas for the
zeros of the Bessel Polynomials', :arXiv:<code>1105.0957</code>.
.. [3] Thomson, W.E., 'Delay Networks having Maximally Flat Frequency
Characteristics', Proceedings of the Institution of Electrical
Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.
.. [4] Aberth, 'Iteration Methods for Finding all Zeros of a Polynomial
Simultaneously', Mathematics of Computation, Vol. 27, No. 122,
April 1973
.. [5] Ehrlich, 'A modified Newton method for polynomials', Communications
of the ACM, Vol. 10, Issue 2, pp. 107-108, Feb. 1967,
:DOI:<code>10.1145/363067.363115</code>
.. [6] Miller and Bohn, 'A Bessel Filter Crossover, and Its Relation to
Others', RaneNote 147, 1998, http://www.rane.com/note147.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bilinear</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a digital IIR filter from an analog one using a bilinear transform.</p>
<p>Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes <code>(z-1) / (z+1)</code> for
<code>s</code>, maintaining the shape of the frequency response.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of the analog filter transfer function.
a : array_like
Denominator of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g. hertz). No prewarping is
done in this function.</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Numerator of the transformed digital filter transfer function.
p : ndarray
Denominator of the transformed digital filter transfer function.</p>
<h2 id="see-also_57">See Also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bp, lp2bs
bilinear_zpk</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 100
bf = 2 * np.pi * np.array([7, 13])
filts = signal.lti( <em>signal.butter(4, bf, btype='bandpass', analog=True))
filtz = signal.lti( </em>signal.bilinear(filts.num, filts.den, fs))
wz, hz = signal.freqz(filtz.num, filtz.den)
ws, hs = signal.freqs(filts.num, filts.den, worN=fs*wz)</p>
<p>plt.semilogx(wz<em>fs/(2</em>np.pi), 20<em>np.log10(np.abs(hz).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H(j \omega)|</span><script type="math/tex">|H(j \omega)|</script></span>')
plt.semilogx(wz</em>fs/(2<em>np.pi), 20</em>np.log10(np.abs(hs).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H_z(e^{j \omega})|</span><script type="math/tex">|H_z(e^{j \omega})|</script></span>')
plt.legend()
plt.xlabel('Frequency [Hz]')
plt.ylabel('Magnitude [dB]')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bilinear_zpk</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return a digital IIR filter from an analog one using a bilinear transform.</p>
<p>Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes <code>(z-1) / (z+1)</code> for
<code>s</code>, maintaining the shape of the frequency response.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g. hertz). No prewarping is
done in this function.</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed digital filter transfer function.
p : ndarray
Poles of the transformed digital filter transfer function.
k : float
System gain of the transformed digital filter.</p>
<h2 id="see-also_58">See Also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, lp2bs_zpk
bilinear</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 100
bf = 2 * np.pi * np.array([7, 13])
filts = signal.lti( <em>signal.butter(4, bf, btype='bandpass', analog=True, output='zpk'))
filtz = signal.lti( </em>signal.bilinear_zpk(filts.zeros, filts.poles, filts.gain, fs))
wz, hz = signal.freqz_zpk(filtz.zeros, filtz.poles, filtz.gain)
ws, hs = signal.freqs_zpk(filts.zeros, filts.poles, filts.gain, worN=fs<em>wz)
plt.semilogx(wz</em>fs/(2<em>np.pi), 20</em>np.log10(np.abs(hz).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H(j \omega)|</span><script type="math/tex">|H(j \omega)|</script></span>')
plt.semilogx(wz<em>fs/(2</em>np.pi), 20*np.log10(np.abs(hs).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H_z(e^{j \omega})|</span><script type="math/tex">|H_z(e^{j \omega})|</script></span>')
plt.legend()
plt.xlabel('Frequency [Hz]')
plt.ylabel('Magnitude [dB]')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">buttap</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for analog prototype of Nth-order Butterworth filter.</p>
<p>The filter will have an angular (e.g. rad/s) cutoff frequency of 1.</p>
<h2 id="see-also_59">See Also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>butter : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">butter</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Butterworth digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Butterworth filter and return
the filter coefficients.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
The critical frequency or frequencies. For lowpass and highpass
filters, Wn is a scalar; for bandpass and bandstop filters,
Wn is a length-2 sequence.</p>
<p>For a Butterworth filter, this is the point at which the gain
drops to 1/sqrt(2) that of the passband (the '-3 dB point').</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_60">See Also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>buttord, buttap</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>The Butterworth filter has maximally flat frequency response in the
passband.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.butter(4, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Butterworth filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.butter(10, 15, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 15 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">buttord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Butterworth filter order selection.</p>
<p>Return the order of the lowest order digital or analog Butterworth filter
that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Butterworth filter which meets specs.
wn : ndarray or float
The Butterworth natural frequency (i.e. the '3dB frequency').  Should
be used with <code>butter</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>butter</code>.</p>
<h2 id="see-also_61">See Also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheb1ord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<p>Design an analog bandpass filter with passband within 3 dB from 20 to
50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.
Plot its frequency response, showing the passband and stopband
constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)
b, a = signal.butter(N, Wn, 'band', True)
w, h = signal.freqs(b, a, np.logspace(1, 2, 500))
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Butterworth bandpass filter fit to constraints')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop
plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass
plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop
plt.axis([10, 100, -60, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the ceiling of the input, element-wise.</p>
<p>The ceil of the scalar <code>x</code> is the smallest integer <code>i</code>, such that
<code>i &gt;= x</code>.  It is often denoted as :math:<code>\lceil x \rceil</code>.</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input data.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>y : ndarray or scalar
The ceiling of each element in <code>x</code>, with <code>float</code> dtype.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_62">See Also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>floor, trunc, rint</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb1ap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p>
<p>The returned filter prototype has <code>rp</code> decibels of ripple in the passband.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below <code>-rp</code>.</p>
<h2 id="see-also_63">See Also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>cheby1 : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb1ord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Chebyshev type I filter order selection.</p>
<p>Return the order of the lowest order digital or analog Chebyshev Type I
filter that loses no more than <code>gpass</code> dB in the passband and has at
least <code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Chebyshev type I filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>cheby1</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>cheby1</code>.</p>
<h2 id="see-also_64">See Also<a class="headerlink" href="#see-also_64" title="Permanent link">&para;</a></h2>
<p>cheby1 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<p>Design a digital lowpass filter such that the passband is within 3 dB up
to 0.2<em>(fs/2), while rejecting at least -40 dB above 0.3</em>(fs/2).  Plot its
frequency response, showing the passband and stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)
b, a = signal.cheby1(N, 3, Wn, 'low')
w, h = signal.freqz(b, a)
plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
plt.title('Chebyshev I lowpass filter fit to constraints')
plt.xlabel('Normalized frequency')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop
plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass
plt.axis([0.08, 1, -60, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb2ap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p>
<p>The returned filter prototype has <code>rs</code> decibels of ripple in the stopband.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first reaches <code>-rs</code>.</p>
<h2 id="see-also_65">See Also<a class="headerlink" href="#see-also_65" title="Permanent link">&para;</a></h2>
<p>cheby2 : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb2ord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Chebyshev type II filter order selection.</p>
<p>Return the order of the lowest order digital or analog Chebyshev Type II
filter that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Chebyshev type II filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>cheby2</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>cheby2</code>.</p>
<h2 id="see-also_66">See Also<a class="headerlink" href="#see-also_66" title="Permanent link">&para;</a></h2>
<p>cheby2 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<p>Design a digital bandstop filter which rejects -60 dB from 0.2<em>(fs/2) to
0.5</em>(fs/2), while staying within 3 dB below 0.1<em>(fs/2) or above
0.6</em>(fs/2).  Plot its frequency response, showing the passband and
stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)
b, a = signal.cheby2(N, 60, Wn, 'stop')
w, h = signal.freqz(b, a)
plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
plt.title('Chebyshev II bandstop filter fit to constraints')
plt.xlabel('Normalized frequency')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop
plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass
plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop
plt.axis([0.06, 1, -80, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheby1</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev type I digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Chebyshev type I filter and
return the filter coefficients.</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rp : float
The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For Type I filters, this is the point in the transition band at which
the gain first drops below -<code>rp</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_67">See Also<a class="headerlink" href="#see-also_67" title="Permanent link">&para;</a></h2>
<p>cheb1ord, cheb1ap</p>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.</p>
<p>Type I filters roll off faster than Type II (<code>cheby2</code>), but Type II
filters do not have any ripple in the passband.</p>
<p>The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Chebyshev Type I frequency response (rp=5)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-5, color='green') # rp
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.cheby1(10, 1, 15, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 15 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheby2</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev type II digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Chebyshev type II filter and
return the filter coefficients.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rs : float
The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For Type II filters, this is the point in the transition band at which
the gain first reaches -<code>rs</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_68">See Also<a class="headerlink" href="#see-also_68" title="Permanent link">&para;</a></h2>
<p>cheb2ord, cheb2ap</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>The Chebyshev type II filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the stopband and increased ringing in the step response.</p>
<p>Type II filters do not roll off as fast as Type I (<code>cheby1</code>).</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.cheby2(4, 40, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Chebyshev Type II frequency response (rs=40)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-40, color='green') # rs
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.cheby2(12, 20, 17, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 17 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">comb</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">repetition</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The number of combinations of N things taken k at a time.</p>
<p>This is often expressed as 'N choose k'.</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>N : int, ndarray
Number of things.
k : int, ndarray
Number of elements taken.
exact : bool, optional
If <code>exact</code> is False, then floating point precision is used, otherwise
exact long integer is computed.
repetition : bool, optional
If <code>repetition</code> is True, then the number of combinations with
repetition is computed.</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>val : int, float, ndarray
The total number of combinations.</p>
<h2 id="see-also_69">See Also<a class="headerlink" href="#see-also_69" title="Permanent link">&para;</a></h2>
<p>binom : Binomial coefficient ufunc</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<ul>
<li>Array arguments accepted only for exact=False case.</li>
<li>If N &lt; 0, or k &lt; 0, then 0 is returned.</li>
<li>If k &gt; N and repetition=False, then 0 is returned.</li>
</ul>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import comb
k = np.array([3, 4])
n = np.array([10, 10])
comb(n, k, exact=False)
array([ 120.,  210.])
comb(10, 3, exact=True)
120L
comb(10, 3, exact=True, repetition=True)
220L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">concatenate</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>concatenate((a1, a2, ...), axis=0, out=None)</p>
<p>Join a sequence of arrays along an existing axis.</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>a1, a2, ... : sequence of array_like
The arrays must have the same shape, except in the dimension
corresponding to <code>axis</code> (the first, by default).
axis : int, optional
The axis along which the arrays will be joined.  If axis is None,
arrays are flattened before use.  Default is 0.
out : ndarray, optional
If provided, the destination to place the result. The shape must be
correct, matching that of what concatenate would have returned if no
out argument were specified.</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>res : ndarray
The concatenated array.</p>
<h2 id="see-also_70">See Also<a class="headerlink" href="#see-also_70" title="Permanent link">&para;</a></h2>
<p>ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)
block : Assemble arrays from blocks.</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])
np.concatenate((a, b), axis=0)
array([[1, 2],
[3, 4],
[5, 6]])
np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
[3, 4, 6]])
np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.ma.arange(3)
a[1] = np.ma.masked
b = np.arange(2, 5)
a
masked_array(data=[0, --, 2],
mask=[False,  True, False],
fill_value=999999)
b
array([2, 3, 4])
np.concatenate([a, b])
masked_array(data=[0, 1, 2, 2, 3, 4],
mask=False,
fill_value=999999)
np.ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
mask=[False,  True, False, False, False, False],
fill_value=999999)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input value.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.conj is np.conjugate
True</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.conjugate(1+2j)
(1-2j)</p>
<p>x = np.eye(2) + 1j * np.eye(2)
np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
[ 0.-0.j,  1.-1.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic cosine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) + np.exp(-x))</code> and <code>np.cos(1j*x)</code>.</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array of same shape as <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cosh(0)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>The hyperbolic cosine describes the shape of a hanging cable:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-4, 4, 1000)
plt.plot(x, np.cosh(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellip</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Elliptic (Cauer) digital and analog filter design.</p>
<p>Design an Nth-order digital or analog elliptic filter and return
the filter coefficients.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rp : float
The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.
rs : float
The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For elliptic filters, this is the point in the transition band at
which the gain first drops below -<code>rp</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_71">See Also<a class="headerlink" href="#see-also_71" title="Permanent link">&para;</a></h2>
<p>ellipord, ellipap</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p>Also known as Cauer or Zolotarev filters, the elliptical filter maximizes
the rate of transition between the frequency response's passband and
stopband, at the expense of ripple in both, and increased ringing in the
step response.</p>
<p>As <code>rp</code> approaches 0, the elliptical filter becomes a Chebyshev
type II filter (<code>cheby2</code>).  As <code>rs</code> approaches 0, it becomes a Chebyshev
type I filter (<code>cheby1</code>).  As both approach 0, it becomes a Butterworth
filter (<code>butter</code>).</p>
<p>The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Elliptic filter frequency response (rp=5, rs=40)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-40, color='green') # rs
plt.axhline(-5, color='green') # rp
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.ellip(8, 1, 100, 17, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 17 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) of Nth-order elliptic analog lowpass filter.</p>
<p>The filter is a normalized prototype that has <code>rp</code> decibels of ripple
in the passband and a stopband <code>rs</code> decibels down.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below <code>-rp</code>.</p>
<h2 id="see-also_72">See Also<a class="headerlink" href="#see-also_72" title="Permanent link">&para;</a></h2>
<p>ellip : Filter design function using this prototype</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] Lutova, Tosic, and Evans, 'Filter Design for Signal Processing',
Chapters 5 and 12.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Elliptic (Cauer) filter order selection.</p>
<p>Return the order of the lowest order digital or analog elliptic filter
that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for an Elliptic (Cauer) filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>ellip</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>ellip</code>.</p>
<h2 id="see-also_73">See Also<a class="headerlink" href="#see-also_73" title="Permanent link">&para;</a></h2>
<p>ellip : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<p>Design an analog highpass filter such that the passband is within 3 dB
above 30 rad/s, while rejecting -60 dB at 10 rad/s.  Plot its
frequency response, showing the passband and stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.ellipord(30, 10, 3, 60, True)
b, a = signal.ellip(N, 3, 60, Wn, 'high', True)
w, h = signal.freqs(b, a, np.logspace(0, 3, 500))
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Elliptical highpass filter fit to constraints')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop
plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass
plt.axis([1, 300, -80, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise exponential of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_74">See Also<a class="headerlink" href="#see-also_74" title="Permanent link">&para;</a></h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array.
exp2  : Calculate <code>2**x</code> for all elements in the array.</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>The irrational number <code>e</code> is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>,
then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write
:math:<code>e^x = e^a e^{ib}</code>.  The first term, :math:<code>e^a</code>, is already
known (it is the real argument, described above).  The second term,
:math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with
magnitude 1 and a periodic phase.</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Exponential function',
https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
http://www.math.sfu.ca/~cbm/aands/page_69.htm</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-2<em>np.pi, 2</em>np.pi, 100)
xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
out = np.exp(xx)</p>
<p>plt.subplot(121)
plt.imshow(np.abs(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='gray')
plt.title('Magnitude of exp(x)')</p>
<p>plt.subplot(122)
plt.imshow(np.angle(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='hsv')
plt.title('Phase (angle) of exp(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorial</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The factorial of a number or array of numbers.</p>
<p>The factorial of non-negative integer <code>n</code> is the product of all
positive integers less than or equal to <code>n</code>::</p>
<p>n! = n * (n - 1) * (n - 2) * ... * 1</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>n : int or array_like of ints
Input values.  If <code>n &lt; 0</code>, the return value is 0.
exact : bool, optional
If True, calculate the answer exactly using long integer arithmetic.
If False, result is approximated in floating point rapidly using the
<code>gamma</code> function.
Default is False.</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>nf : float or int or ndarray
Factorial of <code>n</code>, as integer or float depending on <code>exact</code>.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p>For arrays with <code>exact=True</code>, the factorial is computed only once, for
the largest input, with each other result computed in the process.
The output dtype is increased to <code>int64</code> or <code>object</code> if necessary.</p>
<p>With <code>exact=False</code> the factorial is approximated using the gamma
function:</p>
<p>.. math:: n! = \Gamma(n+1)</p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import factorial
arr = np.array([3, 4, 5])
factorial(arr, exact=False)
array([   6.,   24.,  120.])
factorial(arr, exact=True)
array([  6,  24, 120])
factorial(5, exact=True)
120L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">findfreqs</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">den</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find array of frequencies for computing the response of an analog filter.</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>num, den : array_like, 1-D
The polynomial coefficients of the numerator and denominator of the
transfer function of the filter or LTI system, where the coefficients
are ordered from highest to lowest degree. Or, the roots  of the
transfer function numerator and denominator (i.e. zeroes and poles).
N : int
The length of the array to be computed.
kind : str {'ba', 'zp'}, optional
Specifies whether the numerator and denominator are specified by their
polynomial coefficients ('ba'), or their roots ('zp').</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>w : (N,) ndarray
A 1-D array of frequencies, logarithmically spaced.</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<p>Find a set of nine frequencies that span the 'interesting part' of the
frequency response for the filter with the transfer function</p>
<p>H(s) = s / (s^2 + 8s + 25)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.findfreqs([1, 0], [1, 8, 25], N=9)
array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,
3.16227766e-01,   1.00000000e+00,   3.16227766e+00,
1.00000000e+01,   3.16227766e+01,   1.00000000e+02])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of an analog
filter, compute its frequency response::</p>
<p>b[0]<em>(jw)</em><em>M + b[1]</em>(jw)<strong>(M-1) + ... + b[M]
H(w) = ----------------------------------------------
a[0]*(jw)</strong>N + a[1]<em>(jw)</em>*(N-1) + ... + a[N]</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.
a : array_like
Denominator of a linear filter.
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.
plot : callable, optional
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqs</code>.</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_75">See Also<a class="headerlink" href="#see-also_75" title="Permanent link">&para;</a></h2>
<p>freqz : Compute the frequency response of a digital filter.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's 'plot' function as the callable for <code>plot</code> produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try <code>lambda w, h: plot(w, abs(h))</code>.</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs, iirfilter</p>
<p>b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')</p>
<p>w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code> of a filter, compute its
frequency response::</p>
<p>(jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1])
H(w) = k * ----------------------------------------
(jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1])</p>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_76">See Also<a class="headerlink" href="#see-also_76" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqz : Compute the frequency response of a digital filter in TF form
freqz_zpk : Compute the frequency response of a digital filter in ZPK form</p>
<h2 id="notes_62">Notes<a class="headerlink" href="#notes_62" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs_zpk, iirfilter</p>
<p>z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1',
...                     output='zpk')</p>
<p>w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of a digital
filter, compute its frequency response::</p>
<p>jw                 -jw              -jwM
jw    B(e  )    b[0] + b[1]e    + ... + b[M]e
H(e  ) = ------ = -----------------------------------
jw                 -jw              -jwN
A(e  )    a[0] + a[1]e    + ... + a[N]e</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
a : array_like
Denominator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).  This is a convenient alternative to::</p>
<p>np.linspace(0, fs if whole else fs/2, N, endpoint=False)</p>
<p>Using a number that is fast for FFT computations can result in
faster computations (see Notes).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
plot : callable
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqz</code>.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_77">See Also<a class="headerlink" href="#see-also_77" title="Permanent link">&para;</a></h2>
<p>freqz_zpk
sosfreqz</p>
<h2 id="notes_63">Notes<a class="headerlink" href="#notes_63" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's :func:<code>matplotlib.pyplot.plot</code> function as the callable
for <code>plot</code> produces unexpected results, as this plots the real part of the
complex transfer function, not the magnitude.
Try <code>lambda w, h: plot(w, np.abs(h))</code>.</p>
<p>A direct computation via (R)FFT is used to compute the frequency response
when the following conditions are met:</p>
<ol>
<li>An integer value is given for <code>worN</code>.</li>
<li><code>worN</code> is fast to compute via FFT (i.e.,
<code>next_fast_len(worN) &lt;scipy.fft.next_fast_len&gt;</code> equals <code>worN</code>).</li>
<li>The denominator coefficients are a single value (<code>a.shape[0] == 1</code>).</li>
<li><code>worN</code> is at least as long as the numerator coefficients
(<code>worN &gt;= b.shape[0]</code>).</li>
<li>If <code>b.ndim &gt; 1</code>, then <code>b.shape[-1] == 1</code>.</li>
</ol>
<p>For long FIR filters, the FFT approach can have lower error and be much
faster than the equivalent direct polynomial calculation.</p>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
b = signal.firwin(80, 0.5, window=('kaiser', 8))
w, h = signal.freqz(b)</p>
<p>import matplotlib.pyplot as plt
fig, ax1 = plt.subplots()
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [rad/sample]')</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle (radians)', color='g')
ax2.grid()
ax2.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting Examples</p>
<p>Suppose we have two FIR filters whose coefficients are stored in the
rows of an array with shape (2, 25).  For this demonstration we'll
use random data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(42)
b = np.random.rand(2, 25)</p>
</blockquote>
</blockquote>
</blockquote>
<p>To compute the frequency response for these two filters with one call
to <code>freqz</code>, we must pass in <code>b.T</code>, because <code>freqz</code> expects the first
axis to hold the coefficients. We must then extend the shape with a
trivial dimension of length 1 to allow broadcasting with the array
of frequencies.  That is, we pass in <code>b.T[..., np.newaxis]</code>, which has
shape (25, 2, 1):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b.T[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now suppose we have two transfer functions, with the same numerator
coefficients <code>b = [0.5, 0.5]</code>. The coefficients for the two denominators
are stored in the first dimension of the two-dimensional array  <code>a</code>::</p>
<p>a = [   1      1  ]
[ -0.25, -0.5 ]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0.5, 0.5])
a = np.array([[1, 1], [-0.25, -0.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Only <code>a</code> is more than one-dimensional.  To make it compatible for
broadcasting with the frequencies, we extend it with a trivial dimension
in the call to <code>freqz</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b, a[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter in ZPK form.</p>
<p>Given the Zeros, Poles and Gain of a digital filter, compute its frequency
response:</p>
<p>:math:<code>H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])</code></p>
<p>where :math:<code>k</code> is the <code>gain</code>, :math:<code>Z</code> are the <code>zeros</code> and :math:<code>P</code> are
the <code>poles</code>.</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_78">See Also<a class="headerlink" href="#see-also_78" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqs_zpk : Compute the frequency response of an analog filter in ZPK form
freqz : Compute the frequency response of a digital filter in TF form</p>
<h2 id="notes_64">Notes<a class="headerlink" href="#notes_64" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<p>Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a
system with sample rate of 1000 Hz, and plot the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
z, p, k = signal.butter(4, 100, output='zpk', fs=1000)
w, h = signal.freqz_zpk(z, p, k, fs=1000)</p>
<p>import matplotlib.pyplot as plt
fig = plt.figure()
ax1 = fig.add_subplot(1, 1, 1)
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [Hz]')
ax1.grid()</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle [radians]', color='g')</p>
<p>plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">full</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">fill_value</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a new array of given shape and type, filled with <code>fill_value</code>.</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>shape : int or sequence of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
fill_value : scalar
Fill value.
dtype : data-type, optional
The desired data-type for the array  The default, None, means
<code>np.array(fill_value).dtype</code>.
order : {'C', 'F'}, optional
Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of <code>fill_value</code> with the given shape, dtype, and order.</p>
<h2 id="see-also_79">See Also<a class="headerlink" href="#see-also_79" title="Permanent link">&para;</a></h2>
<p>full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.full((2, 2), np.inf)
array([[inf, inf],
[inf, inf]])
np.full((2, 2), 10)
array([[10, 10],
[10, 10]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">group_delay</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the group delay of a digital filter.</p>
<p>The group delay measures by how many samples amplitude envelopes of
various spectral components of a signal are delayed by a filter.
It is formally defined as the derivative of continuous (unwrapped) phase::</p>
<p>d        jw
D(w) = - -- arg H(e)
dw</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like (b, a)
Numerator and denominator coefficients of a filter transfer function.
w : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).</p>
<p>If an array_like, compute the delay at the frequencies given.  These
are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which group delay was computed, in the same units
as <code>fs</code>.  By default, <code>w</code> is normalized to the range [0, pi)
(radians/sample).
gd : ndarray
The group delay.</p>
<h2 id="notes_65">Notes<a class="headerlink" href="#notes_65" title="Permanent link">&para;</a></h2>
<p>The similar function in MATLAB is called <code>grpdelay</code>.</p>
<p>If the transfer function :math:<code>H(z)</code> has zeros or poles on the unit
circle, the group delay at corresponding frequencies is undefined.
When such a case arises the warning is raised and the group delay
is set to 0 at those frequencies.</p>
<p>For the details of numerical computation of the group delay refer to [1]_.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="see-also_80">See Also<a class="headerlink" href="#see-also_80" title="Permanent link">&para;</a></h2>
<p>freqz : Frequency response of a digital filter</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] Richard G. Lyons, 'Understanding Digital Signal Processing,
3rd edition', p. 830.</p>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype='cheby1')
w, gd = signal.group_delay((b, a))</p>
<p>import matplotlib.pyplot as plt
plt.title('Digital filter group delay')
plt.plot(w, gd)
plt.ylabel('Group delay [samples]')
plt.xlabel('Frequency [rad/sample]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirdesign</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complete IIR digital and analog filter design.</p>
<p>Given passband and stopband frequencies and gains, construct an analog or
digital IIR filter of minimum order for a given basic type.  Return the
output in numerator, denominator ('ba'), pole-zero ('zpk') or second order
sections ('sos') form.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.
For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
ftype : str, optional
The type of IIR filter to design:</p>
<ul>
<li>Butterworth   : 'butter'</li>
<li>Chebyshev I   : 'cheby1'</li>
<li>Chebyshev II  : 'cheby2'</li>
<li>Cauer/elliptic: 'ellip'</li>
<li>Bessel/Thomson: 'bessel'</li>
</ul>
<p>output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_81">See Also<a class="headerlink" href="#see-also_81" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies</p>
<h2 id="notes_66">Notes<a class="headerlink" href="#notes_66" title="Permanent link">&para;</a></h2>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
import matplotlib.ticker</p>
<p>wp = 0.2
ws = 0.3
gpass = 1
gstop = 40</p>
<p>system = signal.iirdesign(wp, ws, gpass, gstop)
w, h = signal.freqz( *system)</p>
<p>fig, ax1 = plt.subplots()
ax1.set_title('Digital filter frequency response')
ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [rad/sample]')
ax1.grid()
ax1.set_ylim([-120, 20])
ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle (radians)', color='g')
ax2.grid()
ax2.axis('tight')
ax2.set_ylim([-6, 1])
nticks = 8
ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirfilter</span> <span class="o">:</span> <span class="o">?</span><span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>IIR digital and analog filter design given order and critical points.</p>
<p>Design an Nth-order digital or analog filter and return the filter
coefficients.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
rp : float, optional
For Chebyshev and elliptic filters, provides the maximum ripple
in the passband. (dB)
rs : float, optional
For Chebyshev and elliptic filters, provides the minimum attenuation
in the stop band. (dB)
btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
The type of filter.  Default is 'bandpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
ftype : str, optional
The type of IIR filter to design:</p>
<ul>
<li>Butterworth   : 'butter'</li>
<li>Chebyshev I   : 'cheby1'</li>
<li>Chebyshev II  : 'cheby2'</li>
<li>Cauer/elliptic: 'ellip'</li>
<li>Bessel/Thomson: 'bessel'</li>
</ul>
<p>output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_82">See Also<a class="headerlink" href="#see-also_82" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="notes_67">Notes<a class="headerlink" href="#notes_67" title="Permanent link">&para;</a></h2>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<p>Generate a 17th-order Chebyshev II analog bandpass filter from 50 Hz to
200 Hz and plot the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.iirfilter(17, [2<em>np.pi</em>50, 2<em>np.pi</em>200], rs=60,
...                         btype='band', analog=True, ftype='cheby2')
w, h = signal.freqs(b, a, 1000)
fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.semilogx(w / (2*np.pi), 20 * np.log10(np.maximum(abs(h), 1e-5)))
ax.set_title('Chebyshev Type II bandpass frequency response')
ax.set_xlabel('Frequency [Hz]')
ax.set_ylabel('Amplitude [dB]')
ax.axis((10, 1000, -100, 10))
ax.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a digital filter with the same properties, in a system with
sampling rate of 2000 Hz, and plot the frequency response.  (Second-order
sections implementation is required to ensure stability of a filter of
this order):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.iirfilter(17, [50, 200], rs=60, btype='band',
...                        analog=False, ftype='cheby2', fs=2000,
...                        output='sos')
w, h = signal.sosfreqz(sos, 2000, fs=2000)
fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.semilogx(w, 20 * np.log10(np.maximum(abs(h), 1e-5)))
ax.set_title('Chebyshev Type II bandpass frequency response')
ax.set_xlabel('Frequency [Hz]')
ax.set_ylabel('Amplitude [dB]')
ax.axis((10, 1000, -100, 10))
ax.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirnotch</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Design second-order IIR notch digital filter.</p>
<p>A notch filter is a band-stop filter with a narrow bandwidth
(high quality factor). It rejects a narrow frequency band and
leaves the rest of the spectrum little changed.</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>w0 : float
Frequency to remove from a signal. If <code>fs</code> is specified, this is in
the same units as <code>fs</code>. By default, it is a normalized scalar that must
satisfy  <code>0 &lt; w0 &lt; 1</code>, with <code>w0 = 1</code> corresponding to half of the
sampling frequency.
Q : float
Quality factor. Dimensionless parameter that characterizes
notch filter -3 dB bandwidth <code>bw</code> relative to its center
frequency, <code>Q = w0/bw</code>.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials
of the IIR filter.</p>
<h2 id="see-also_83">See Also<a class="headerlink" href="#see-also_83" title="Permanent link">&para;</a></h2>
<p>iirpeak</p>
<h2 id="notes_68">Notes<a class="headerlink" href="#notes_68" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] Sophocles J. Orfanidis, 'Introduction To Signal Processing',
Prentice-Hall, 1996</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<p>Design and plot filter to remove the 60 Hz component from a
signal sampled at 200 Hz, using a quality factor Q = 30</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 200.0  # Sample frequency (Hz)
f0 = 60.0  # Frequency to be removed from signal (Hz)
Q = 30.0  # Quality factor</p>
<h1 id="design-notch-filter">Design notch filter<a class="headerlink" href="#design-notch-filter" title="Permanent link">&para;</a></h1>
<p>b, a = signal.iirnotch(f0, Q, fs)</p>
<h1 id="frequency-response">Frequency response<a class="headerlink" href="#frequency-response" title="Permanent link">&para;</a></h1>
<p>freq, h = signal.freqz(b, a, fs=fs)</p>
<h1 id="plot">Plot<a class="headerlink" href="#plot" title="Permanent link">&para;</a></h1>
<p>fig, ax = plt.subplots(2, 1, figsize=(8, 6))
ax[0].plot(freq, 20<em>np.log10(abs(h)), color='blue')
ax[0].set_title('Frequency Response')
ax[0].set_ylabel('Amplitude (dB)', color='blue')
ax[0].set_xlim([0, 100])
ax[0].set_ylim([-25, 10])
ax[0].grid()
ax[1].plot(freq, np.unwrap(np.angle(h))</em>180/np.pi, color='green')
ax[1].set_ylabel('Angle (degrees)', color='green')
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_xlim([0, 100])
ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
ax[1].set_ylim([-90, 90])
ax[1].grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirpeak</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Design second-order IIR peak (resonant) digital filter.</p>
<p>A peak filter is a band-pass filter with a narrow bandwidth
(high quality factor). It rejects components outside a narrow
frequency band.</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>w0 : float
Frequency to be retained in a signal. If <code>fs</code> is specified, this is in
the same units as <code>fs</code>. By default, it is a normalized scalar that must
satisfy  <code>0 &lt; w0 &lt; 1</code>, with <code>w0 = 1</code> corresponding to half of the
sampling frequency.
Q : float
Quality factor. Dimensionless parameter that characterizes
peak filter -3 dB bandwidth <code>bw</code> relative to its center
frequency, <code>Q = w0/bw</code>.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials
of the IIR filter.</p>
<h2 id="see-also_84">See Also<a class="headerlink" href="#see-also_84" title="Permanent link">&para;</a></h2>
<p>iirnotch</p>
<h2 id="notes_69">Notes<a class="headerlink" href="#notes_69" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] Sophocles J. Orfanidis, 'Introduction To Signal Processing',
Prentice-Hall, 1996</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<p>Design and plot filter to remove the frequencies other than the 300 Hz
component from a signal sampled at 1000 Hz, using a quality factor Q = 30</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 1000.0  # Sample frequency (Hz)
f0 = 300.0  # Frequency to be retained (Hz)
Q = 30.0  # Quality factor</p>
<h1 id="design-peak-filter">Design peak filter<a class="headerlink" href="#design-peak-filter" title="Permanent link">&para;</a></h1>
<p>b, a = signal.iirpeak(f0, Q, fs)</p>
<h1 id="frequency-response_1">Frequency response<a class="headerlink" href="#frequency-response_1" title="Permanent link">&para;</a></h1>
<p>freq, h = signal.freqz(b, a, fs=fs)</p>
<h1 id="plot_1">Plot<a class="headerlink" href="#plot_1" title="Permanent link">&para;</a></h1>
<p>fig, ax = plt.subplots(2, 1, figsize=(8, 6))
ax[0].plot(freq, 20<em>np.log10(np.maximum(abs(h), 1e-5)), color='blue')
ax[0].set_title('Frequency Response')
ax[0].set_ylabel('Amplitude (dB)', color='blue')
ax[0].set_xlim([0, 500])
ax[0].set_ylim([-50, 10])
ax[0].grid()
ax[1].plot(freq, np.unwrap(np.angle(h))</em>180/np.pi, color='green')
ax[1].set_ylabel('Angle (degrees)', color='green')
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_xlim([0, 500])
ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
ax[1].set_ylim([-90, 90])
ax[1].grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log10</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the base 10 logarithm of the input array, element-wise.</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The logarithm to the base 10 of <code>x</code>, element-wise. NaNs are
returned where x is negative.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_85">See Also<a class="headerlink" href="#see-also_85" title="Permanent link">&para;</a></h2>
<p>emath.log10</p>
<h2 id="notes_70">Notes<a class="headerlink" href="#notes_70" title="Permanent link">&para;</a></h2>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite
number of <code>z</code> such that <code>10**z = x</code>. The convention is to return the
<code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log10</code> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log10</code> is a complex analytical function that
has a branch cut <code>[-inf, 0]</code> and is continuous from above on it.
<code>log10</code> handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.log10([1e-15, -3.])
array([-15.,  nan])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logspace</span> <span class="o">:</span> <span class="o">?</span><span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">endpoint</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">base</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">start</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stop</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return numbers spaced evenly on a log scale.</p>
<p>In linear space, the sequence starts at <code>base ** start</code>
(<code>base</code> to the power of <code>start</code>) and ends with <code>base ** stop</code>
(see <code>endpoint</code> below).</p>
<p>.. versionchanged:: 1.16.0
Non-scalar <code>start</code> and <code>stop</code> are now supported.</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>start : array_like
<code>base ** start</code> is the starting value of the sequence.
stop : array_like
<code>base ** stop</code> is the final value of the sequence, unless <code>endpoint</code>
is False.  In that case, <code>num + 1</code> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <code>num</code>) are returned.
num : integer, optional
Number of samples to generate.  Default is 50.
endpoint : boolean, optional
If true, <code>stop</code> is the last sample. Otherwise, it is not included.
Default is True.
base : float, optional
The base of the log space. The step size between the elements in
<code>ln(samples) / ln(base)</code> (or <code>log_base(samples)</code>) is uniform.
Default is 10.0.
dtype : dtype
The type of the output array.  If <code>dtype</code> is not given, infer the data
type from the other input arguments.
axis : int, optional
The axis in the result to store the samples.  Relevant only if start
or stop are array-like.  By default (0), the samples will be along a
new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<p>.. versionadded:: 1.16.0</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>samples : ndarray
<code>num</code> samples, equally spaced on a log scale.</p>
<h2 id="see-also_86">See Also<a class="headerlink" href="#see-also_86" title="Permanent link">&para;</a></h2>
<p>arange : Similar to linspace, with the step size specified instead of the
number of samples. Note that, when used with a float endpoint, the
endpoint may or may not be included.
linspace : Similar to logspace, but with the samples uniformly distributed
in linear space, instead of log space.
geomspace : Similar to logspace, but with endpoints specified directly.</p>
<h2 id="notes_71">Notes<a class="headerlink" href="#notes_71" title="Permanent link">&para;</a></h2>
<p>Logspace is equivalent to the code</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = np.linspace(start, stop, num=num, endpoint=endpoint)
... # doctest: +SKIP
power(base, y).astype(dtype)
... # doctest: +SKIP</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.logspace(2.0, 3.0, num=4)
array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])
np.logspace(2.0, 3.0, num=4, endpoint=False)
array([100.        ,  177.827941  ,  316.22776602,  562.34132519])
np.logspace(2.0, 3.0, num=4, base=2.0)
array([4.        ,  5.0396842 ,  6.34960421,  8.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Graphical illustration:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
N = 10
x1 = np.logspace(0.1, 1, N, endpoint=True)
x2 = np.logspace(0.1, 1, N, endpoint=False)
y = np.zeros(N)
plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
plt.ylim([-0.5, 1])
(-0.5, 1)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandpass filter.</p>
<p>Return an analog band-pass filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired passband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired passband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed band-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed band-pass filter.</p>
<h2 id="see-also_87">See Also<a class="headerlink" href="#see-also_87" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bs, bilinear
lp2bp_zpk</p>
<h2 id="notes_72">Notes<a class="headerlink" href="#notes_72" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</p>
<p>This is the 'wideband' transformation, producing a passband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
bp = signal.lti( *signal.lp2bp(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_bp, p_bp = bp.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_bp, label='Bandpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandpass filter.</p>
<p>Return an analog band-pass filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired passband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired passband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed band-pass filter transfer function.
p : ndarray
Poles of the transformed band-pass filter transfer function.
k : float
System gain of the transformed band-pass filter.</p>
<h2 id="see-also_88">See Also<a class="headerlink" href="#see-also_88" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bs_zpk, bilinear
lp2bp</p>
<h2 id="notes_73">Notes<a class="headerlink" href="#notes_73" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</p>
<p>This is the 'wideband' transformation, producing a passband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bs</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandstop filter.</p>
<p>Return an analog band-stop filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired stopband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired stopband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed band-stop filter.
a : array_like
Denominator polynomial coefficients of the transformed band-stop filter.</p>
<h2 id="see-also_89">See Also<a class="headerlink" href="#see-also_89" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bp, bilinear
lp2bs_zpk</p>
<h2 id="notes_74">Notes<a class="headerlink" href="#notes_74" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</p>
<p>This is the 'wideband' transformation, producing a stopband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.5])
bs = signal.lti( *signal.lp2bs(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_bs, p_bs = bs.bode(w)
plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_bs, label='Bandstop')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bs_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandstop filter.</p>
<p>Return an analog band-stop filter with center frequency <code>wo</code> and
stopband width <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired stopband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired stopband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed band-stop filter transfer function.
p : ndarray
Poles of the transformed band-stop filter transfer function.
k : float
System gain of the transformed band-stop filter.</p>
<h2 id="see-also_90">See Also<a class="headerlink" href="#see-also_90" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, bilinear
lp2bs</p>
<h2 id="notes_75">Notes<a class="headerlink" href="#notes_75" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</p>
<p>This is the 'wideband' transformation, producing a stopband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2hp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a highpass filter.</p>
<p>Return an analog high-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed high-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed high-pass filter.</p>
<h2 id="see-also_91">See Also<a class="headerlink" href="#see-also_91" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2bp, lp2bs, bilinear
lp2hp_zpk</p>
<h2 id="notes_76">Notes<a class="headerlink" href="#notes_76" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{\omega_0}{s}</p>
<p>This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
hp = signal.lti( *signal.lp2hp(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_hp, p_hp = hp.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_hp, label='Highpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2hp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a highpass filter.</p>
<p>Return an analog high-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed high-pass filter transfer function.
p : ndarray
Poles of the transformed high-pass filter transfer function.
k : float
System gain of the transformed high-pass filter.</p>
<h2 id="see-also_92">See Also<a class="headerlink" href="#see-also_92" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2hp</p>
<h2 id="notes_77">Notes<a class="headerlink" href="#notes_77" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{\omega_0}{s}</p>
<p>This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2lp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a different frequency.</p>
<p>Return an analog low-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed low-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed low-pass filter.</p>
<h2 id="see-also_93">See Also<a class="headerlink" href="#see-also_93" title="Permanent link">&para;</a></h2>
<p>lp2hp, lp2bp, lp2bs, bilinear
lp2lp_zpk</p>
<h2 id="notes_78">Notes<a class="headerlink" href="#notes_78" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s}{\omega_0}</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
lp2 = signal.lti( *signal.lp2lp(lp.num, lp.den, 2))
w, mag_lp, p_lp = lp.bode()
w, mag_lp2, p_lp2 = lp2.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_lp2, label='Transformed Lowpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2lp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a different frequency.</p>
<p>Return an analog low-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed low-pass filter transfer function.
p : ndarray
Poles of the transformed low-pass filter transfer function.
k : float
System gain of the transformed low-pass filter.</p>
<h2 id="see-also_94">See Also<a class="headerlink" href="#see-also_94" title="Permanent link">&para;</a></h2>
<p>lp2hp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2lp</p>
<h2 id="notes_79">Notes<a class="headerlink" href="#notes_79" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s}{\omega_0}</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxflat</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mintypecode</span> <span class="o">:</span> <span class="o">?</span><span class="n">typeset</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">typechars</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Return the character for the minimum-size type to which given types can
be safely cast.</p>
<p>The returned type character must represent the smallest size dtype such
that an array of the returned type can handle the data from an array of
all types in <code>typechars</code> (or if <code>typechars</code> is an array, then its
dtype.char).</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>typechars : list of str or array_like
If a list of strings, each string should represent a dtype.
If array_like, the character representation of the array dtype is used.
typeset : str or list of str, optional
The set of characters that the returned character is chosen from.
The default set is 'GDFgdf'.
default : str, optional
The default character, this is returned if none of the characters in
<code>typechars</code> matches a character in <code>typeset</code>.</p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>typechar : str
The character representing the minimum-size type that was found.</p>
<h2 id="see-also_95">See Also<a class="headerlink" href="#see-also_95" title="Permanent link">&para;</a></h2>
<p>dtype, sctype2char, maximum_sctype</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.mintypecode(['d', 'f', 'S'])
'd'
x = np.array([1.1, 2-3.j])
np.mintypecode(x)
'D'</p>
<p>np.mintypecode('abceh', default='G')
'G'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">normalize</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Normalize numerator/denominator of a continuous-time transfer function.</p>
<p>If values of <code>b</code> are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>b: array_like
Numerator of the transfer function. Can be a 2d array to normalize
multiple transfer functions.
a: array_like
Denominator of the transfer function. At most 1d.</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>num: array
The numerator of the normalized transfer function. At least a 1d
array. A 2d-array if the input <code>num</code> is a 2d array.
den: 1d-array
The denominator of the normalized transfer function.</p>
<h2 id="notes_80">Notes<a class="headerlink" href="#notes_80" title="Permanent link">&para;</a></h2>
<p>Coefficients for both the numerator and denominator should be specified in
descending exponent order (e.g., <code>s^2 + 3s + 5</code> would be represented as
<code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">npp_polyval</span> <span class="o">:</span> <span class="o">?</span><span class="n">tensor</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Compatible_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a polynomial at points x.</p>
<p>If <code>c</code> is of length <code>n + 1</code>, this function returns the value</p>
<p>.. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n</p>
<p>The parameter <code>x</code> is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either <code>x</code>
or its elements must support multiplication and addition both with
themselves and with the elements of <code>c</code>.</p>
<p>If <code>c</code> is a 1-D array, then <code>p(x)</code> will have the same shape as <code>x</code>.  If
<code>c</code> is multidimensional, then the shape of the result depends on the
value of <code>tensor</code>. If <code>tensor</code> is true the shape will be c.shape[1:] +
x.shape. If <code>tensor</code> is false the shape will be c.shape[1:]. Note that
scalars have shape (,).</p>
<p>Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>x : array_like, compatible object
If <code>x</code> is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, <code>x</code>
or its elements must support addition and multiplication with
with themselves and with the elements of <code>c</code>.
c : array_like
Array of coefficients ordered so that the coefficients for terms of
degree n are contained in c[n]. If <code>c</code> is multidimensional the
remaining indices enumerate multiple polynomials. In the two
dimensional case the coefficients may be thought of as stored in
the columns of <code>c</code>.
tensor : boolean, optional
If True, the shape of the coefficient array is extended with ones
on the right, one for each dimension of <code>x</code>. Scalars have dimension 0
for this action. The result is that every column of coefficients in
<code>c</code> is evaluated for every element of <code>x</code>. If False, <code>x</code> is broadcast
over the columns of <code>c</code> for the evaluation.  This keyword is useful
when <code>c</code> is multidimensional. The default value is True.</p>
<p>.. versionadded:: 1.7.0</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>values : ndarray, compatible object
The shape of the returned array is described above.</p>
<h2 id="see-also_96">See Also<a class="headerlink" href="#see-also_96" title="Permanent link">&para;</a></h2>
<p>polyval2d, polygrid2d, polyval3d, polygrid3d</p>
<h2 id="notes_81">Notes<a class="headerlink" href="#notes_81" title="Permanent link">&para;</a></h2>
<p>The evaluation uses Horner's method.</p>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy.polynomial.polynomial import polyval
polyval(1, [1,2,3])
6.0
a = np.arange(4).reshape(2,2)
a
array([[0, 1],
[2, 3]])
polyval(a, [1,2,3])
array([[ 1.,   6.],
[17.,  34.]])
coef = np.arange(4).reshape(2,2) # multidimensional coefficients
coef
array([[0, 1],
[2, 3]])
polyval([1,2], coef, tensor=True)
array([[2.,  4.],
[4.,  7.]])
polyval([1,2], coef, tensor=False)
array([2.,  7.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ones</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a new array of given shape and type, filled with ones.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>shape : int or sequence of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: C
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_116">Returns<a class="headerlink" href="#returns_116" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of ones with the given shape, dtype, and order.</p>
<h2 id="see-also_97">See Also<a class="headerlink" href="#see-also_97" title="Permanent link">&para;</a></h2>
<p>ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.ones(5)
array([1., 1., 1., 1., 1.])</p>
<p>np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])</p>
<p>np.ones((2, 1))
array([[1.],
[1.]])</p>
<p>s = (2,2)
np.ones(s)
array([[1.,  1.],
[1.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">poly</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the coefficients of a polynomial with the given sequence of roots.</p>
<p>Returns the coefficients of the polynomial whose leading coefficient
is one for the given sequence of zeros (multiple roots must be included
in the sequence as many times as their multiplicity; see Examples).
A square matrix (or array, which will be treated as a matrix) can also
be given, in which case the coefficients of the characteristic polynomial
of the matrix are returned.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>seq_of_zeros : array_like, shape (N,) or (N, N)
A sequence of polynomial roots, or a square array or matrix object.</p>
<h2 id="returns_117">Returns<a class="headerlink" href="#returns_117" title="Permanent link">&para;</a></h2>
<p>c : ndarray
1D array of polynomial coefficients from highest to lowest degree:</p>
<p><code>c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]</code>
where c[0] always equals 1.</p>
<h2 id="raises_15">Raises<a class="headerlink" href="#raises_15" title="Permanent link">&para;</a></h2>
<p>ValueError
If input is the wrong shape (the input must be a 1-D or square
2-D array).</p>
<h2 id="see-also_98">See Also<a class="headerlink" href="#see-also_98" title="Permanent link">&para;</a></h2>
<p>polyval : Compute polynomial values.
roots : Return the roots of a polynomial.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<h2 id="notes_82">Notes<a class="headerlink" href="#notes_82" title="Permanent link">&para;</a></h2>
<p>Specifying the roots of a polynomial still leaves one degree of
freedom, typically represented by an undetermined leading
coefficient. [1]_ In the case of this function, that coefficient -
the first one in the returned array - is always taken as one. (If
for some reason you have one other point, the only automatic way
presently to leverage that information is to use <code>polyfit</code>.)</p>
<p>The characteristic polynomial, :math:<code>p_a(t)</code>, of an <code>n</code>-by-<code>n</code>
matrix <strong>A</strong> is given by</p>
<p>:math:<code>p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})</code>,</p>
<p>where <strong>I</strong> is the <code>n</code>-by-<code>n</code> identity matrix. [2]_</p>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Sullivan and M. Sullivan, III, 'Algebra and Trignometry,
Enhanced With Graphing Utilities,' Prentice-Hall, pg. 318, 1996.</p>
<p>.. [2] G. Strang, 'Linear Algebra and Its Applications, 2nd Edition,'
Academic Press, pg. 182, 1980.</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<p>Given a sequence of a polynomial's zeros:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((0, 0, 0)) # Multiple root example
array([1., 0., 0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The line above represents z<strong>3 + 0*z</strong>2 + 0*z + 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((-1./2, 0, 1./2))
array([ 1.  ,  0.  , -0.25,  0.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The line above represents z**3 - z/4</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))
array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a square array object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>P = np.array([[0, 1./3], [-1./2, 0]])
np.poly(P)
array([1.        , 0.        , 0.16666667])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how in all cases the leading coefficient is always 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polyval</span> <span class="o">:</span> <span class="n">p</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Poly1d_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Poly1d_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a polynomial at specific values.</p>
<p>If <code>p</code> is of length N, this function returns the value:</p>
<p><code>p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]</code></p>
<p>If <code>x</code> is a sequence, then <code>p(x)</code> is returned for each element of <code>x</code>.
If <code>x</code> is another polynomial then the composite polynomial <code>p(x(t))</code>
is returned.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>p : array_like or poly1d object
1D array of polynomial coefficients (including coefficients equal
to zero) from highest degree to the constant term, or an
instance of poly1d.
x : array_like or poly1d object
A number, an array of numbers, or an instance of poly1d, at
which to evaluate <code>p</code>.</p>
<h2 id="returns_118">Returns<a class="headerlink" href="#returns_118" title="Permanent link">&para;</a></h2>
<p>values : ndarray or poly1d
If <code>x</code> is a poly1d instance, the result is the composition of the two
polynomials, i.e., <code>x</code> is 'substituted' in <code>p</code> and the simplified
result is returned. In addition, the type of <code>x</code> - array_like or
poly1d - governs the type of the output: <code>x</code> array_like =&gt; <code>values</code>
array_like, <code>x</code> a poly1d object =&gt; <code>values</code> is also.</p>
<h2 id="see-also_99">See Also<a class="headerlink" href="#see-also_99" title="Permanent link">&para;</a></h2>
<p>poly1d: A polynomial class.</p>
<h2 id="notes_83">Notes<a class="headerlink" href="#notes_83" title="Permanent link">&para;</a></h2>
<p>Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.</p>
<p>If <code>x</code> is a subtype of <code>ndarray</code> the return value will be of the same type.</p>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand
Reinhold Co., 1985, pg. 720.</p>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.polyval([3,0,1], 5)  # 3 * 5<strong>2 + 0 * 5</strong>1 + 1
76
np.polyval([3,0,1], np.poly1d(5))
poly1d([76.])
np.polyval(np.poly1d([3,0,1]), 5)
76
np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
poly1d([76.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polyvalfromroots</span> <span class="o">:</span> <span class="o">?</span><span class="n">tensor</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Compatible_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a polynomial specified by its roots at points x.</p>
<p>If <code>r</code> is of length <code>N</code>, this function returns the value</p>
<p>.. math:: p(x) = \prod_{n=1}^{N} (x - r_n)</p>
<p>The parameter <code>x</code> is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either <code>x</code>
or its elements must support multiplication and addition both with
themselves and with the elements of <code>r</code>.</p>
<p>If <code>r</code> is a 1-D array, then <code>p(x)</code> will have the same shape as <code>x</code>.  If <code>r</code>
is multidimensional, then the shape of the result depends on the value of
<code>tensor</code>. If <code>tensor is ``True`` the shape will be r.shape[1:] + x.shape;
that is, each polynomial is evaluated at every value of</code>x<code>. If</code>tensor<code>is
``False``, the shape will be r.shape[1:]; that is, each polynomial is
evaluated only for the corresponding broadcast value of</code>x`. Note that
scalars have shape (,).</p>
<p>.. versionadded:: 1.12</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>x : array_like, compatible object
If <code>x</code> is a list or tuple, it is converted to an ndarray, otherwise
it is left unchanged and treated as a scalar. In either case, <code>x</code>
or its elements must support addition and multiplication with
with themselves and with the elements of <code>r</code>.
r : array_like
Array of roots. If <code>r</code> is multidimensional the first index is the
root index, while the remaining indices enumerate multiple
polynomials. For instance, in the two dimensional case the roots
of each polynomial may be thought of as stored in the columns of <code>r</code>.
tensor : boolean, optional
If True, the shape of the roots array is extended with ones on the
right, one for each dimension of <code>x</code>. Scalars have dimension 0 for this
action. The result is that every column of coefficients in <code>r</code> is
evaluated for every element of <code>x</code>. If False, <code>x</code> is broadcast over the
columns of <code>r</code> for the evaluation.  This keyword is useful when <code>r</code> is
multidimensional. The default value is True.</p>
<h2 id="returns_119">Returns<a class="headerlink" href="#returns_119" title="Permanent link">&para;</a></h2>
<p>values : ndarray, compatible object
The shape of the returned array is described above.</p>
<h2 id="see-also_100">See Also<a class="headerlink" href="#see-also_100" title="Permanent link">&para;</a></h2>
<p>polyroots, polyfromroots, polyval</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy.polynomial.polynomial import polyvalfromroots
polyvalfromroots(1, [1,2,3])
0.0
a = np.arange(4).reshape(2,2)
a
array([[0, 1],
[2, 3]])
polyvalfromroots(a, [-1, 0, 1])
array([[-0.,   0.],
[ 6.,  24.]])
r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients
r # each column of r defines one polynomial
array([[-2, -1],
[ 0,  1]])
b = [-2, 1]
polyvalfromroots(b, r, tensor=True)
array([[-0.,  3.],
[ 3., 0.]])
polyvalfromroots(b, r, tensor=False)
array([-0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of array elements over a given axis.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.
dtype : dtype, optional
The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <code>a</code> is used by
default unless <code>a</code> has an integer dtype of less precision than the
default platform integer.  In that case, if <code>a</code> is signed then the
platform integer is used while if <code>a</code> is unsigned then an unsigned
integer of the same precision as the platform integer is used.
out : ndarray, optional
Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.
keepdims : bool, optional
If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>prod</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.
initial : scalar, optional
The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
<p>where : array_like of bool, optional
Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_120">Returns<a class="headerlink" href="#returns_120" title="Permanent link">&para;</a></h2>
<p>product_along_axis : ndarray, see <code>dtype</code> parameter above.
An array shaped as <code>a</code> but with the specified axis removed.
Returns a reference to <code>out</code> if specified.</p>
<h2 id="see-also_101">See Also<a class="headerlink" href="#see-also_101" title="Permanent link">&para;</a></h2>
<p>ndarray.prod : equivalent method
ufuncs-output-type</p>
<h2 id="notes_84">Notes<a class="headerlink" href="#notes_84" title="Permanent link">&para;</a></h2>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([536870910, 536870910, 536870910, 536870910])
np.prod(x)
16 # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>The product of an empty array is the neutral element 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<p>By default, calculate the product of all elements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1.,2.])
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even when the input array is two-dimensional:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]])
24.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>But we can also specify the axis over which to multiply:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Or select specific elements to include:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1., np.nan, 3.], where=[True, False, True])
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the type of <code>x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.uint8)
np.prod(x).dtype == np.uint
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.int8)
np.prod(x).dtype == int
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can also start the product with a value other than one:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1, 2], initial=5)
10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">real</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the real part of the complex argument.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>val : array_like
Input array.</p>
<h2 id="returns_121">Returns<a class="headerlink" href="#returns_121" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
The real component of the complex argument. If <code>val</code> is real, the type
of <code>val</code> is used for the output.  If <code>val</code> has complex elements, the
returned type is float.</p>
<h2 id="see-also_102">See Also<a class="headerlink" href="#see-also_102" title="Permanent link">&para;</a></h2>
<p>real_if_close, imag, angle</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1+2j, 3+4j, 5+6j])
a.real
array([1.,  3.,  5.])
a.real = 9
a
array([9.+2.j,  9.+4.j,  9.+6.j])
a.real = np.array([9, 8, 7])
a
array([9.+2.j,  8.+4.j,  7.+6.j])
np.real(1 + 1j)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resize</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">new_shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new
array is filled with repeated copies of <code>a</code>.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of <code>a</code>.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>a : array_like
Array to be resized.</p>
<p>new_shape : int or tuple of int
Shape of resized array.</p>
<h2 id="returns_122">Returns<a class="headerlink" href="#returns_122" title="Permanent link">&para;</a></h2>
<p>reshaped_array : ndarray
The new array is formed from the data in the old array, repeated
if necessary to fill out the required number of elements.  The
data are repeated in the order that they are stored in memory.</p>
<h2 id="see-also_103">See Also<a class="headerlink" href="#see-also_103" title="Permanent link">&para;</a></h2>
<p>ndarray.resize : resize an array in-place.</p>
<h2 id="notes_85">Notes<a class="headerlink" href="#notes_85" title="Permanent link">&para;</a></h2>
<p>Warning: This functionality does <strong>not</strong> consider axes separately,
i.e. it does not apply interpolation/extrapolation.
It fills the return array with the required number of elements, taken
from <code>a</code> as they are laid out in memory, disregarding strides and axes.
(This is in case the new shape is smaller. For larger, see above.)
This functionality is therefore not suitable to resize images,
or data where each axis represents a separate and distinct entity.</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a=np.array([[0,1],[2,3]])
np.resize(a,(2,3))
array([[0, 1, 2],
[3, 0, 1]])
np.resize(a,(1,4))
array([[0, 1, 2, 3]])
np.resize(a,(2,4))
array([[0, 1, 2, 3],
[0, 1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">roots</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the roots of a polynomial with coefficients given in p.</p>
<p>The values in the rank-1 array <code>p</code> are coefficients of a polynomial.
If the length of <code>p</code> is n+1 then the polynomial is described by::</p>
<p>p[0] * x<strong>n + p[1] * x</strong>(n-1) + ... + p[n-1]*x + p[n]</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>p : array_like
Rank-1 array of polynomial coefficients.</p>
<h2 id="returns_123">Returns<a class="headerlink" href="#returns_123" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array containing the roots of the polynomial.</p>
<h2 id="raises_16">Raises<a class="headerlink" href="#raises_16" title="Permanent link">&para;</a></h2>
<p>ValueError
When <code>p</code> cannot be converted to a rank-1 array.</p>
<h2 id="see-also_104">See also<a class="headerlink" href="#see-also_104" title="Permanent link">&para;</a></h2>
<p>poly : Find the coefficients of a polynomial with a given sequence
of roots.
polyval : Compute polynomial values.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<h2 id="notes_86">Notes<a class="headerlink" href="#notes_86" title="Permanent link">&para;</a></h2>
<p>The algorithm relies on computing the eigenvalues of the
companion matrix [1]_.</p>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
Cambridge University Press, 1999, pp. 146-7.</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>coeff = [3.2, 2, 1]
np.roots(coeff)
array([-0.3125+0.46351241j, -0.3125-0.46351241j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>x : array_like
Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_124">Returns<a class="headerlink" href="#returns_124" title="Permanent link">&para;</a></h2>
<p>y : array_like
The sine of each element of x.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_105">See Also<a class="headerlink" href="#see-also_105" title="Permanent link">&para;</a></h2>
<p>arcsin, sinh, cos</p>
<h2 id="notes_87">Notes<a class="headerlink" href="#notes_87" title="Permanent link">&para;</a></h2>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:<code>+x</code> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:<code>y</code> coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code>  The
function has zeroes where the angle is a multiple of :math:<code>\pi</code>.
Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<p>Print sine of one angle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.pi/2.)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinh</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic sine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) - np.exp(-x))</code> or
<code>-1j * np.sin(1j*x)</code>.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_125">Returns<a class="headerlink" href="#returns_125" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding hyperbolic sine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_88">Notes<a class="headerlink" href="#notes_88" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.</p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sinh(0)
0.0
np.sinh(np.pi<em>1j/2)
1j
np.sinh(np.pi</em>1j) # (exact value is 0)
1.2246063538223773e-016j</p>
<h1 id="discrepancy-due-to-vagaries-of-floating-point-arithmetic">Discrepancy due to vagaries of floating point arithmetic.<a class="headerlink" href="#discrepancy-due-to-vagaries-of-floating-point-arithmetic" title="Permanent link">&para;</a></h1>
<h1 id="example-of-providing-the-optional-output-parameter_1">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter_1" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.sinh([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_2">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_2" title="Permanent link">&para;</a></h1>
<p>np.sinh(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sos2tf</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a single transfer function from a series of second-order sections</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_126">Returns<a class="headerlink" href="#returns_126" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="notes_89">Notes<a class="headerlink" href="#notes_89" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sos2zpk</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zeros, poles, and gain of a series of second-order sections</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_127">Returns<a class="headerlink" href="#returns_127" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_90">Notes<a class="headerlink" href="#notes_90" title="Permanent link">&para;</a></h2>
<p>The number of zeros and poles returned will be <code>n_sections * 2</code>
even if some of these are (effectively) zero.</p>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfreqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter in SOS format.</p>
<p>Given <code>sos</code>, an array with shape (n, 6) of second order sections of
a digital filter, compute the frequency response of the system function::</p>
<p>B0(z)   B1(z)         B{n-1}(z)
H(z) = ----- * ----- * ... * ---------
A0(z)   A1(z)         A{n-1}(z)</p>
<p>for z = exp(omega*1j), where B{k}(z) and A{k}(z) are numerator and
denominator of the transfer function of the k-th second order section.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).  Using a number that is fast for FFT computations can result
in faster computations (see Notes of <code>freqz</code>).</p>
<p>If an array_like, compute the response at the frequencies given (must
be 1D).  These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_128">Returns<a class="headerlink" href="#returns_128" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_106">See Also<a class="headerlink" href="#see-also_106" title="Permanent link">&para;</a></h2>
<p>freqz, sosfilt</p>
<h2 id="notes_91">Notes<a class="headerlink" href="#notes_91" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_112">Examples<a class="headerlink" href="#examples_112" title="Permanent link">&para;</a></h2>
<p>Design a 15th-order bandpass filter in SOS format.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sos = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='sos')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the frequency response at 1500 points from DC to Nyquist.</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.sosfreqz(sos, worN=1500)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the response.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.subplot(2, 1, 1)
db = 20<em>np.log10(np.maximum(np.abs(h), 1e-5))
plt.plot(w/np.pi, db)
plt.ylim(-75, 5)
plt.grid(True)
plt.yticks([0, -20, -40, -60])
plt.ylabel('Gain [dB]')
plt.title('Frequency Response')
plt.subplot(2, 1, 2)
plt.plot(w/np.pi, np.angle(h))
plt.grid(True)
plt.yticks([-np.pi, -0.5</em>np.pi, 0, 0.5*np.pi, np.pi],
...            [r'<span><span class="MathJax_Preview">-\pi</span><script type="math/tex">-\pi</script></span>', r'<span><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span>', '0', r'<span><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>', r'<span><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>'])
plt.ylabel('Phase [rad]')
plt.xlabel('Normalized frequency (1.0 = Nyquist)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the same filter is implemented as a single transfer function,
numerical error corrupts the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='ba')
w, h = signal.freqz(b, a, worN=1500)
plt.subplot(2, 1, 1)
db = 20<em>np.log10(np.maximum(np.abs(h), 1e-5))
plt.plot(w/np.pi, db)
plt.ylim(-75, 5)
plt.grid(True)
plt.yticks([0, -20, -40, -60])
plt.ylabel('Gain [dB]')
plt.title('Frequency Response')
plt.subplot(2, 1, 2)
plt.plot(w/np.pi, np.angle(h))
plt.grid(True)
plt.yticks([-np.pi, -0.5</em>np.pi, 0, 0.5*np.pi, np.pi],
...            [r'<span><span class="MathJax_Preview">-\pi</span><script type="math/tex">-\pi</script></span>', r'<span><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span>', '0', r'<span><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>', r'<span><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>'])
plt.ylabel('Phase [rad]')
plt.xlabel('Normalized frequency (1.0 = Nyquist)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sp_fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>==============================================
Discrete Fourier transforms (:mod:<code>scipy.fft</code>)
==============================================</p>
<p>.. currentmodule:: scipy.fft</p>
<h1 id="fast-fourier-transforms-ffts">Fast Fourier Transforms (FFTs)<a class="headerlink" href="#fast-fourier-transforms-ffts" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fft - Fast (discrete) Fourier Transform (FFT)
ifft - Inverse FFT
fft2 - Two dimensional FFT
ifft2 - Two dimensional inverse FFT
fftn - n-dimensional FFT
ifftn - n-dimensional inverse FFT
rfft - FFT of strictly real-valued sequence
irfft - Inverse of rfft
rfft2 - Two dimensional FFT of real sequence
irfft2 - Inverse of rfft2
rfftn - n-dimensional FFT of real sequence
irfftn - Inverse of rfftn
hfft - FFT of a Hermitian sequence (real spectrum)
ihfft - Inverse of hfft
hfft2 - Two dimensional FFT of a Hermitian sequence
ihfft2 - Inverse of hfft2
hfftn - n-dimensional FFT of a Hermitian sequence
ihfftn - Inverse of hfftn</p>
<h1 id="discrete-sin-and-cosine-transforms-dst-and-dct">Discrete Sin and Cosine Transforms (DST and DCT)<a class="headerlink" href="#discrete-sin-and-cosine-transforms-dst-and-dct" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>dct - Discrete cosine transform
idct - Inverse discrete cosine transform
dctn - n-dimensional Discrete cosine transform
idctn - n-dimensional Inverse discrete cosine transform
dst - Discrete sine transform
idst - Inverse discrete sine transform
dstn - n-dimensional Discrete sine transform
idstn - n-dimensional Inverse discrete sine transform</p>
<h1 id="helper-functions">Helper functions<a class="headerlink" href="#helper-functions" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fftshift - Shift the zero-frequency component to the center of the spectrum
ifftshift - The inverse of <code>fftshift</code>
fftfreq - Return the Discrete Fourier Transform sample frequencies
rfftfreq - DFT sample frequencies (for usage with rfft, irfft)
next_fast_len - Find the optimal length to zero-pad an FFT for speed
set_workers - Context manager to set default number of workers
get_workers - Get the current default number of workers</p>
<h1 id="backend-control">Backend control<a class="headerlink" href="#backend-control" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>set_backend - Context manager to set the backend within a fixed scope
skip_backend - Context manager to skip a backend within a fixed scope
set_global_backend - Sets the global fft backend
register_backend - Register a backend for permanent use</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_129">Returns<a class="headerlink" href="#returns_129" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_107">See Also<a class="headerlink" href="#see-also_107" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_92">Notes<a class="headerlink" href="#notes_92" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_113">Examples<a class="headerlink" href="#examples_113" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tan</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute tangent element-wise.</p>
<p>Equivalent to <code>np.sin(x)/np.cos(x)</code> element-wise.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_130">Returns<a class="headerlink" href="#returns_130" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding tangent values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_93">Notes<a class="headerlink" href="#notes_93" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_114">Examples<a class="headerlink" href="#examples_114" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from math import pi
np.tan(np.array([-pi,pi/2,pi]))
array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])</p>
<h1 id="example-of-providing-the-optional-output-parameter-illustrating_1">Example of providing the optional output parameter illustrating<a class="headerlink" href="#example-of-providing-the-optional-output-parameter-illustrating_1" title="Permanent link">&para;</a></h1>
<h1 id="that-what-is-returned-is-a-reference-to-said-parameter_1">that what is returned is a reference to said parameter<a class="headerlink" href="#that-what-is-returned-is-a-reference-to-said-parameter_1" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_3">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_3" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2sos</span> <span class="o">:</span> <span class="o">?</span><span class="n">pairing</span><span class="o">:[`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Keep_odd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return second-order sections from transfer function representation</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
pairing : {'nearest', 'keep_odd'}, optional
The method to use to combine pairs of poles and zeros into sections.
See <code>zpk2sos</code>.</p>
<h2 id="returns_131">Returns<a class="headerlink" href="#returns_131" title="Permanent link">&para;</a></h2>
<p>sos : ndarray
Array of second-order filter coefficients, with shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="see-also_108">See Also<a class="headerlink" href="#see-also_108" title="Permanent link">&para;</a></h2>
<p>zpk2sos, sosfilt</p>
<h2 id="notes_94">Notes<a class="headerlink" href="#notes_94" title="Permanent link">&para;</a></h2>
<p>It is generally discouraged to convert from TF to SOS format, since doing
so usually will not improve numerical precision errors. Instead, consider
designing filters in ZPK format and converting directly to SOS. TF is
converted to SOS by first converting to ZPK format, then converting
ZPK to SOS.</p>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2zpk</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.</p>
<h2 id="returns_132">Returns<a class="headerlink" href="#returns_132" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_95">Notes<a class="headerlink" href="#notes_95" title="Permanent link">&para;</a></h2>
<p>If some values of <code>b</code> are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.</p>
<p>The <code>b</code> and <code>a</code> arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable.  So the inputs
:math:<code>b = [b_0, b_1, ..., b_M]</code> and :math:<code>a =[a_0, a_1, ..., a_N]</code>
can represent an analog filter of the form:</p>
<p>.. math::</p>
<p>H(s) = \frac
{b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
{a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}</p>
<p>or a discrete-time filter of the form:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
{a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}</p>
<p>This 'positive powers' form is found more commonly in controls
engineering.  If <code>M</code> and <code>N</code> are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the 'negative powers' discrete-time form preferred in DSP:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}</p>
<p>Although this is true for common filters, remember that this is not true
in the general case.  If <code>M</code> and <code>N</code> are not equal, the discrete-time
transfer function coefficients must first be converted to the 'positive
powers' form before finding the poles and zeros.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yulewalk</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_133">Returns<a class="headerlink" href="#returns_133" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_109">See Also<a class="headerlink" href="#see-also_109" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_115">Examples<a class="headerlink" href="#examples_115" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2sos</span> <span class="o">:</span> <span class="o">?</span><span class="n">pairing</span><span class="o">:[`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Keep_odd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return second-order sections from zeros, poles, and gain of a system</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.
pairing : {'nearest', 'keep_odd'}, optional
The method to use to combine pairs of poles and zeros into sections.
See Notes below.</p>
<h2 id="returns_134">Returns<a class="headerlink" href="#returns_134" title="Permanent link">&para;</a></h2>
<p>sos : ndarray
Array of second-order filter coefficients, with shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="see-also_110">See Also<a class="headerlink" href="#see-also_110" title="Permanent link">&para;</a></h2>
<p>sosfilt</p>
<h2 id="notes_96">Notes<a class="headerlink" href="#notes_96" title="Permanent link">&para;</a></h2>
<p>The algorithm used to convert ZPK to SOS format is designed to
minimize errors due to numerical precision issues. The pairing
algorithm attempts to minimize the peak gain of each biquadratic
section. This is done by pairing poles with the nearest zeros, starting
with the poles closest to the unit circle.</p>
<p><em>Algorithms</em></p>
<p>The current algorithms are designed specifically for use with digital
filters. (The output coefficients are not correct for analog filters.)</p>
<p>The steps in the <code>pairing='nearest'</code> and <code>pairing='keep_odd'</code>
algorithms are mostly shared. The <code>nearest</code> algorithm attempts to
minimize the peak gain, while <code>'keep_odd'</code> minimizes peak gain under
the constraint that odd-order systems should retain one section
as first order. The algorithm steps and are as follows:</p>
<p>As a pre-processing step, add poles or zeros to the origin as
necessary to obtain the same number of poles and zeros for pairing.
If <code>pairing == 'nearest'</code> and there are an odd number of poles,
add an additional pole and a zero at the origin.</p>
<p>The following steps are then iterated over until no more poles or
zeros remain:</p>
<ol>
<li>
<p>Take the (next remaining) pole (complex or real) closest to the
unit circle to begin a new filter section.</p>
</li>
<li>
<p>If the pole is real and there are no other remaining real poles [#]_,
add the closest real zero to the section and leave it as a first
order section. Note that after this step we are guaranteed to be
left with an even number of real poles, complex poles, real zeros,
and complex zeros for subsequent pairing iterations.</p>
</li>
<li>
<p>Else:</p>
</li>
<li>
<p>If the pole is complex and the zero is the only remaining real
zero<em>, then pair the pole with the </em>next* closest zero
(guaranteed to be complex). This is necessary to ensure that
there will be a real zero remaining to eventually create a
first-order section (thus keeping the odd order).</p>
</li>
<li>
<p>Else pair the pole with the closest remaining zero (complex or
real).</p>
</li>
<li>
<p>Proceed to complete the second-order section by adding another
pole and zero to the current pole and zero in the section:</p>
</li>
<li>
<p>If the current pole and zero are both complex, add their
conjugates.</p>
</li>
<li>
<p>Else if the pole is complex and the zero is real, add the
conjugate pole and the next closest real zero.</p>
</li>
<li>
<p>Else if the pole is real and the zero is complex, add the
conjugate zero and the real pole closest to those zeros.</p>
</li>
<li>
<p>Else (we must have a real pole and real zero) add the next
real pole closest to the unit circle, and then add the real
zero closest to that pole.</p>
</li>
</ol>
<p>.. [#] This conditional can only be met for specific odd-order inputs
with the <code>pairing == 'keep_odd'</code> method.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_116">Examples<a class="headerlink" href="#examples_116" title="Permanent link">&para;</a></h2>
<p>Design a 6th order low-pass elliptic digital filter for a system with a
sampling rate of 8000 Hz that has a pass-band corner frequency of
1000 Hz.  The ripple in the pass-band should not exceed 0.087 dB, and
the attenuation in the stop-band should be at least 90 dB.</p>
<p>In the following call to <code>signal.ellip</code>, we could use <code>output='sos'</code>,
but for this example, we'll use <code>output='zpk'</code>, and then convert to SOS
format with <code>zpk2sos</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now convert to SOS format.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.zpk2sos(z, p, k)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The coefficients of the numerators of the sections:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos[:, :3]
array([[ 0.0014154 ,  0.00248707,  0.0014154 ],
[ 1.        ,  0.72965193,  1.        ],
[ 1.        ,  0.17594966,  1.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The symmetry in the coefficients occurs because all the zeros are on the
unit circle.</p>
<p>The coefficients of the denominators of the sections:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos[:, 3:]
array([[ 1.        , -1.32543251,  0.46989499],
[ 1.        , -1.26117915,  0.6262586 ],
[ 1.        , -1.25707217,  0.86199667]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The next example shows the effect of the <code>pairing</code> option.  We have a
system with three poles and three zeros, so the SOS array will have
shape (2, 6).  The means there is, in effect, an extra pole and an extra
zero at the origin in the SOS representation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j])
p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>pairing='nearest'</code> (the default), we obtain</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.zpk2sos(z1, p1, 1)
array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],
[ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles
{0, 0.75}, and the second section has the zeros {-1, 0} and poles
{0.8+0.1j, 0.8-0.1j}.  Note that the extra pole and zero at the origin
have been assigned to different sections.</p>
<p>With <code>pairing='keep_odd'</code>, we obtain:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.zpk2sos(z1, p1, 1, pairing='keep_odd')
array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],
[ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The extra pole and zero at the origin are in the same section.
The first section is, in effect, a first-order section.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2tf</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return polynomial transfer function representation from zeros and poles</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="returns_135">Returns<a class="headerlink" href="#returns_135" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Fir_filter_design</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">ceil</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the ceiling of x as an Integral.</p>
<p>This is the smallest integer &gt;= x.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT.  If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
.. versionadded:: 1.10.0</p>
<p>Normalization mode (see <code>numpy.fft</code>). Default is None.</p>
<h2 id="returns_136">Returns<a class="headerlink" href="#returns_136" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_17">Raises<a class="headerlink" href="#raises_17" title="Permanent link">&para;</a></h2>
<p>IndexError
if <code>axes</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_111">See Also<a class="headerlink" href="#see-also_111" title="Permanent link">&para;</a></h2>
<p>numpy.fft : for definition of the DFT and conventions used.
ifft : The inverse of <code>fft</code>.
fft2 : The two-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.</p>
<h2 id="notes_97">Notes<a class="headerlink" href="#notes_97" title="Permanent link">&para;</a></h2>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest when <code>n</code> is a power of 2, and
the transform is therefore most efficient for these sizes.</p>
<p>The DFT is defined, with the conventions used in this implementation, in
the documentation for the <code>numpy.fft</code> module.</p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [CT] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
machine calculation of complex Fourier series,' <em>Math. Comput.</em>
19: 297-301.</p>
<h2 id="examples_117">Examples<a class="headerlink" href="#examples_117" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
the <code>numpy.fft</code> documentation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(256)
sp = np.fft.fft(np.sin(t))
freq = np.fft.fftfreq(t.shape[-1])
plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firls</span> <span class="o">:</span> <span class="o">?</span><span class="n">weight</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">bands</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">desired</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using least-squares error minimization.</p>
<p>Calculate the filter coefficients for the linear-phase finite
impulse response (FIR) filter which has the best approximation
to the desired frequency response described by <code>bands</code> and
<code>desired</code> in the least squares sense (i.e., the integral of the
weighted mean-squared error within the specified bands is
minimized).</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.  <code>numtaps</code> must be odd.
bands : array_like
A monotonic nondecreasing sequence containing the band edges in
Hz. All elements must be non-negative and less than or equal to
the Nyquist frequency given by <code>nyq</code>.
desired : array_like
A sequence the same size as <code>bands</code> containing the desired gain
at the start and end point of each band.
weight : array_like, optional
A relative weighting to give to each band region when solving
the least squares problem. <code>weight</code> has to be half the size of
<code>bands</code>.
nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>
Nyquist frequency. Each frequency in <code>bands</code> must be between 0
and <code>nyq</code> (inclusive).  Default is 1.
fs : float, optional
The sampling frequency of the signal. Each frequency in <code>bands</code>
must be between 0 and <code>fs/2</code> (inclusive).  Default is 2.</p>
<h2 id="returns_137">Returns<a class="headerlink" href="#returns_137" title="Permanent link">&para;</a></h2>
<p>coeffs : ndarray
Coefficients of the optimal (in a least squares sense) FIR filter.</p>
<h2 id="see-also_112">See also<a class="headerlink" href="#see-also_112" title="Permanent link">&para;</a></h2>
<p>firwin
firwin2
minimum_phase
remez</p>
<h2 id="notes_98">Notes<a class="headerlink" href="#notes_98" title="Permanent link">&para;</a></h2>
<p>This implementation follows the algorithm given in [1]_.
As noted there, least squares design has multiple advantages:</p>
<ol>
<li>Optimal in a least-squares sense.</li>
<li>Simple, non-iterative method.</li>
<li>The general solution can obtained by solving a linear
system of equations.</li>
<li>Allows the use of a frequency dependent weighting function.</li>
</ol>
<p>This function constructs a Type I linear phase FIR filter, which
contains an odd number of <code>coeffs</code> satisfying for :math:<code>n &lt; numtaps</code>:</p>
<p>.. math:: coeffs(n) = coeffs(numtaps - 1 - n)</p>
<p>The odd number of coefficients and filter symmetry avoid boundary
conditions that could otherwise occur at the Nyquist and 0 frequencies
(e.g., for Type II, III, or IV variants).</p>
<p>.. versionadded:: 0.18</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares.
OpenStax CNX. Aug 9, 2005.
http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7</p>
<h2 id="examples_118">Examples<a class="headerlink" href="#examples_118" title="Permanent link">&para;</a></h2>
<p>We want to construct a band-pass filter. Note that the behavior in the
frequency ranges between our stop bands and pass bands is unspecified,
and thus may overshoot depending on the parameters of our filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
fig, axs = plt.subplots(2)
fs = 10.0  # Hz
desired = (0, 0, 1, 1, 0, 0)
for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):
...     fir_firls = signal.firls(73, bands, desired, fs=fs)
...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs)
...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs)
...     hs = list()
...     ax = axs[bi]
...     for fir in (fir_firls, fir_remez, fir_firwin2):
...         freq, response = signal.freqz(fir)
...         hs.append(ax.semilogy(0.5<em>fs</em>freq/np.pi, np.abs(response))[0])
...     for band, gains in zip(zip(bands[::2], bands[1::2]),
...                            zip(desired[::2], desired[1::2])):
...         ax.semilogy(band, np.maximum(gains, 1e-7), 'k--', linewidth=2)
...     if bi == 0:
...         ax.legend(hs, ('firls', 'remez', 'firwin2'),
...                   loc='lower center', frameon=False)
...     else:
...         ax.set_xlabel('Frequency (Hz)')
...     ax.grid(True)
...     ax.set(title='Band-pass %d-%d Hz' % bands[2:4], ylabel='Magnitude')
...
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple_of_string_and_parameter_values</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pass_zero</span><span class="o">:[`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">cutoff</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T1D_array_like</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using the window method.</p>
<p>This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
<code>numtaps</code> is odd and Type II if <code>numtaps</code> is even.</p>
<p>Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with <code>numtaps</code> even and
having a passband whose right end is at the Nyquist frequency.</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>numtaps : int
Length of the filter (number of coefficients, i.e. the filter
order + 1).  <code>numtaps</code> must be odd if a passband includes the
Nyquist frequency.
cutoff : float or 1D array_like
Cutoff frequency of filter (expressed in the same units as <code>fs</code>)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in <code>cutoff</code> should be positive and
monotonically increasing between 0 and <code>fs/2</code>.  The values 0 and
<code>fs/2</code> must not be included in <code>cutoff</code>.
width : float or None, optional
If <code>width</code> is not None, then assume it is the approximate width
of the transition region (expressed in the same units as <code>fs</code>)
for use in Kaiser FIR filter design.  In this case, the <code>window</code>
argument is ignored.
window : string or tuple of string and parameter values, optional
Desired window to use. See <code>scipy.signal.get_window</code> for a list
of windows and required parameters.
pass_zero : {True, False, 'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
If True, the gain at the frequency 0 (i.e. the 'DC gain') is 1.
If False, the DC gain is 0. Can also be a string argument for the
desired filter type (equivalent to <code>btype</code> in IIR design functions).</p>
<p>.. versionadded:: 1.3.0
Support for string arguments.
scale : bool, optional
Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:</p>
<ul>
<li>0 (DC) if the first passband starts at 0 (i.e. pass_zero
is True)</li>
<li><code>fs/2</code> (the Nyquist frequency) if the first passband ends at
<code>fs/2</code> (i.e the filter is a single band highpass filter);
center of first passband otherwise</li>
</ul>
<p>nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>  This is the Nyquist frequency.
Each frequency in <code>cutoff</code> must be between 0 and <code>nyq</code>. Default
is 1.
fs : float, optional
The sampling frequency of the signal.  Each frequency in <code>cutoff</code>
must be between 0 and <code>fs/2</code>.  Default is 2.</p>
<h2 id="returns_138">Returns<a class="headerlink" href="#returns_138" title="Permanent link">&para;</a></h2>
<p>h : (numtaps,) ndarray
Coefficients of length <code>numtaps</code> FIR filter.</p>
<h2 id="raises_18">Raises<a class="headerlink" href="#raises_18" title="Permanent link">&para;</a></h2>
<p>ValueError
If any value in <code>cutoff</code> is less than or equal to 0 or greater
than or equal to <code>fs/2</code>, if the values in <code>cutoff</code> are not strictly
monotonically increasing, or if <code>numtaps</code> is even but a passband
includes the Nyquist frequency.</p>
<h2 id="see-also_113">See Also<a class="headerlink" href="#see-also_113" title="Permanent link">&para;</a></h2>
<p>firwin2
firls
minimum_phase
remez</p>
<h2 id="examples_119">Examples<a class="headerlink" href="#examples_119" title="Permanent link">&para;</a></h2>
<p>Low-pass from 0 to f:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
numtaps = 3
f = 0.1
signal.firwin(numtaps, f)
array([ 0.06799017,  0.86401967,  0.06799017])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use a specific window function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, window='nuttall')
array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</p>
</blockquote>
</blockquote>
</blockquote>
<p>High-pass ('stop' from 0 to f):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, pass_zero=False)
array([-0.00859313,  0.98281375, -0.00859313])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-pass:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f1, f2 = 0.1, 0.2
signal.firwin(numtaps, [f1, f2], pass_zero=False)
array([ 0.06301614,  0.88770441,  0.06301614])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-stop:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2])
array([-0.00801395,  1.0160279 , -0.00801395])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>f3, f4 = 0.3, 0.4
signal.firwin(numtaps, [f1, f2, f3, f4])
array([-0.01376344,  1.02752689, -0.01376344])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [f1, f2] and [f3,f4]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)
array([ 0.04890915,  0.91284326,  0.04890915])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firwin2</span> <span class="o">:</span> <span class="o">?</span><span class="n">nfreqs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">T_string_float_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">antisymmetric</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">freq</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T1D</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">gain</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using the window method.</p>
<p>From the given frequencies <code>freq</code> and corresponding gains <code>gain</code>,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.</p>
<h2 id="parameters_142">Parameters<a class="headerlink" href="#parameters_142" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.  <code>numtaps</code> must be less than
<code>nfreqs</code>.
freq : array_like, 1D
The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
Nyquist.  The Nyquist frequency is half <code>fs</code>.
The values in <code>freq</code> must be nondecreasing.  A value can be repeated
once to implement a discontinuity.  The first value in <code>freq</code> must
be 0, and the last value must be <code>fs/2</code>. Values 0 and <code>fs/2</code> must
not be repeated.
gain : array_like
The filter gains at the frequency sampling points. Certain
constraints to gain values, depending on the filter type, are applied,
see Notes for details.
nfreqs : int, optional
The size of the interpolation mesh used to construct the filter.
For most efficient behavior, this should be a power of 2 plus 1
(e.g, 129, 257, etc).  The default is one more than the smallest
power of 2 that is not less than <code>numtaps</code>.  <code>nfreqs</code> must be greater
than <code>numtaps</code>.
window : string or (string, float) or float, or None, optional
Window function to use. Default is 'hamming'.  See
<code>scipy.signal.get_window</code> for the complete list of possible values.
If None, no window function is applied.
nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>  This is the Nyquist frequency.
Each frequency in <code>freq</code> must be between 0 and <code>nyq</code>.  Default is 1.
antisymmetric : bool, optional
Whether resulting impulse response is symmetric/antisymmetric.
See Notes for more details.
fs : float, optional
The sampling frequency of the signal.  Each frequency in <code>cutoff</code>
must be between 0 and <code>fs/2</code>.  Default is 2.</p>
<h2 id="returns_139">Returns<a class="headerlink" href="#returns_139" title="Permanent link">&para;</a></h2>
<p>taps : ndarray
The filter coefficients of the FIR filter, as a 1-D array of length
<code>numtaps</code>.</p>
<h2 id="see-also_114">See also<a class="headerlink" href="#see-also_114" title="Permanent link">&para;</a></h2>
<p>firls
firwin
minimum_phase
remez</p>
<h2 id="notes_99">Notes<a class="headerlink" href="#notes_99" title="Permanent link">&para;</a></h2>
<p>From the given set of frequencies and gains, the desired response is
constructed in the frequency domain.  The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first <code>numtaps</code> coefficients of this kernel, scaled by <code>window</code>, are
returned.</p>
<p>The FIR filter will have linear phase. The type of filter is determined by
the value of 'numtaps<code>and</code>antisymmetric` flag.
There are four possible combinations:</p>
<ul>
<li>odd  <code>numtaps</code>, <code>antisymmetric</code> is False, type I filter is produced</li>
<li>even <code>numtaps</code>, <code>antisymmetric</code> is False, type II filter is produced</li>
<li>odd  <code>numtaps</code>, <code>antisymmetric</code> is True, type III filter is produced</li>
<li>even <code>numtaps</code>, <code>antisymmetric</code> is True, type IV filter is produced</li>
</ul>
<p>Magnitude response of all but type I filters are subjects to following
constraints:</p>
<ul>
<li>type II  -- zero at the Nyquist frequency</li>
<li>type III -- zero at zero and Nyquist frequencies</li>
<li>type IV  -- zero at zero frequency</li>
</ul>
<p>.. versionadded:: 0.9.0</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, A. V. and Schafer, R. W., 'Discrete-Time Signal
Processing', Prentice-Hall, Englewood Cliffs, New Jersey (1989).
(See, for example, Section 7.4.)</p>
<p>.. [2] Smith, Steven W., 'The Scientist and Engineer's Guide to Digital
Signal Processing', Ch. 17. http://www.dspguide.com/ch17/1.htm</p>
<h2 id="examples_120">Examples<a class="headerlink" href="#examples_120" title="Permanent link">&para;</a></h2>
<p>A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and
that decreases linearly on [0.5, 1.0] from 1 to 0:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])
print(taps[72:78])
[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hankel matrix.</p>
<p>The Hankel matrix has constant anti-diagonals, with <code>c</code> as its
first column and <code>r</code> as its last row.  If <code>r</code> is not given, then
<code>r = zeros_like(c)</code> is assumed.</p>
<h2 id="parameters_143">Parameters<a class="headerlink" href="#parameters_143" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
Last row of the matrix. If None, <code>r = zeros_like(c)</code> is assumed.
r[0] is ignored; the last row of the returned matrix is
<code>[c[-1], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_140">Returns<a class="headerlink" href="#returns_140" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Hankel matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_115">See Also<a class="headerlink" href="#see-also_115" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix
circulant : circulant matrix</p>
<h2 id="examples_121">Examples<a class="headerlink" href="#examples_121" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hankel
hankel([1, 17, 99])
array([[ 1, 17, 99],
[17, 99,  0],
[99,  0,  0]])
hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
[2, 3, 4, 7, 7],
[3, 4, 7, 7, 8],
[4, 7, 7, 8, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <code>fft</code>.  In other words,
<code>ifft(fft(a)) == a</code> to within numerical accuracy.
For a general description of the algorithm and definitions,
see <code>numpy.fft</code>.</p>
<p>The input should be ordered in the same way as is returned by <code>fft</code>,
i.e.,</p>
<ul>
<li><code>a[0]</code> should contain the zero frequency term,</li>
<li><code>a[1:n//2]</code> should contain the positive-frequency terms,</li>
<li><code>a[n//2 + 1:]</code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</li>
</ul>
<p>For an even number of input points, <code>A[n//2]</code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <code>numpy.fft</code> for details.</p>
<h2 id="parameters_144">Parameters<a class="headerlink" href="#parameters_144" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
See notes about padding issues.
axis : int, optional
Axis over which to compute the inverse DFT.  If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
.. versionadded:: 1.10.0</p>
<p>Normalization mode (see <code>numpy.fft</code>). Default is None.</p>
<h2 id="returns_141">Returns<a class="headerlink" href="#returns_141" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_19">Raises<a class="headerlink" href="#raises_19" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axes</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_116">See Also<a class="headerlink" href="#see-also_116" title="Permanent link">&para;</a></h2>
<p>numpy.fft : An introduction, with definitions and general explanations.
fft : The one-dimensional (forward) FFT, of which <code>ifft</code> is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.</p>
<h2 id="notes_100">Notes<a class="headerlink" href="#notes_100" title="Permanent link">&para;</a></h2>
<p>If the input parameter <code>n</code> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <code>ifft</code>.</p>
<h2 id="examples_122">Examples<a class="headerlink" href="#examples_122" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot a band-limited signal with random phases:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(400)
n = np.zeros((400,), dtype=complex)
n[40:60] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20,)))
s = np.fft.ifft(n)
plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <code>rfft</code>.
In other words, <code>irfft(rfft(a), len(a)) == a</code> to within numerical
accuracy. (See Notes below for why <code>len(a)</code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <code>rfft</code>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<h2 id="parameters_145">Parameters<a class="headerlink" href="#parameters_145" title="Permanent link">&para;</a></h2>
<p>a : array_like
The input array.
n : int, optional
Length of the transformed axis of the output.
For <code>n</code> output points, <code>n//2+1</code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <code>n</code> is not given, it is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along the axis
specified by <code>axis</code>.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
.. versionadded:: 1.10.0</p>
<p>Normalization mode (see <code>numpy.fft</code>). Default is None.</p>
<h2 id="returns_142">Returns<a class="headerlink" href="#returns_142" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*(m-1)</code> where <code>m</code> is the length of the transformed axis of the
input. To get an odd number of output points, <code>n</code> must be specified.</p>
<h2 id="raises_20">Raises<a class="headerlink" href="#raises_20" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_117">See Also<a class="headerlink" href="#see-also_117" title="Permanent link">&para;</a></h2>
<p>numpy.fft : For definition of the DFT and conventions used.
rfft : The one-dimensional FFT of real input, of which <code>irfft</code> is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_101">Notes<a class="headerlink" href="#notes_101" title="Permanent link">&para;</a></h2>
<p>Returns the real valued <code>n</code>-point inverse discrete Fourier transform
of <code>a</code>, where <code>a</code> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <code>n</code> is the length of the result, not the
input.</p>
<p>If you specify an <code>n</code> such that <code>a</code> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <code>m</code> points via Fourier interpolation by:
<code>a_resamp = irfft(rfft(a), m)</code>.</p>
<p>The correct interpretation of the hermitian input depends on the length of
the original data, as given by <code>n</code>. This is because each input shape could
correspond to either an odd or even length signal. By default, <code>irfft</code>
assumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
correct length of the real input <strong>must</strong> be given.</p>
<h2 id="examples_123">Examples<a class="headerlink" href="#examples_123" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
np.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the last term in the input to the ordinary <code>ifft</code> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <code>irfft</code>, the negative frequencies are not
specified, and the output array is purely real.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser_atten</span> <span class="o">:</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the attenuation of a Kaiser FIR filter.</p>
<p>Given the number of taps <code>N</code> and the transition width <code>width</code>, compute the
attenuation <code>a</code> in dB, given by Kaiser's formula:</p>
<p>a = 2.285 * (N - 1) * pi * width + 7.95</p>
<h2 id="parameters_146">Parameters<a class="headerlink" href="#parameters_146" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.
width : float
The desired width of the transition region between passband and
stopband (or, in general, at any discontinuity) for the filter,
expressed as a fraction of the Nyquist frequency.</p>
<h2 id="returns_143">Returns<a class="headerlink" href="#returns_143" title="Permanent link">&para;</a></h2>
<p>a : float
The attenuation of the ripple, in dB.</p>
<h2 id="see-also_118">See Also<a class="headerlink" href="#see-also_118" title="Permanent link">&para;</a></h2>
<p>kaiserord, kaiser_beta</p>
<h2 id="examples_124">Examples<a class="headerlink" href="#examples_124" title="Permanent link">&para;</a></h2>
<p>Suppose we want to design a FIR filter using the Kaiser window method
that will have 211 taps and a transition width of 9 Hz for a signal that
is sampled at 480 Hz.  Expressed as a fraction of the Nyquist frequency,
the width is 9/(0.5*480) = 0.0375.  The approximate attenuation (in dB)
is computed as follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiser_atten
kaiser_atten(211, 0.0375)
64.48099630593983</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser_beta</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Kaiser parameter <code>beta</code>, given the attenuation <code>a</code>.</p>
<h2 id="parameters_147">Parameters<a class="headerlink" href="#parameters_147" title="Permanent link">&para;</a></h2>
<p>a : float
The desired attenuation in the stopband and maximum ripple in
the passband, in dB.  This should be a <em>positive</em> number.</p>
<h2 id="returns_144">Returns<a class="headerlink" href="#returns_144" title="Permanent link">&para;</a></h2>
<p>beta : float
The <code>beta</code> parameter to be used in the formula for a Kaiser window.</p>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>Oppenheim, Schafer, 'Discrete-Time Signal Processing', p.475-476.</p>
<h2 id="examples_125">Examples<a class="headerlink" href="#examples_125" title="Permanent link">&para;</a></h2>
<p>Suppose we want to design a lowpass filter, with 65 dB attenuation
in the stop band.  The Kaiser window parameter to be used in the
window method is computed by <code>kaiser_beta(65)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiser_beta
kaiser_beta(65)
6.20426</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiserord</span> <span class="o">:</span> <span class="n">ripple</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Determine the filter window parameters for the Kaiser window method.</p>
<p>The parameters returned by this function are generally used to create
a finite impulse response filter using the window method, with either
<code>firwin</code> or <code>firwin2</code>.</p>
<h2 id="parameters_148">Parameters<a class="headerlink" href="#parameters_148" title="Permanent link">&para;</a></h2>
<p>ripple : float
Upper bound for the deviation (in dB) of the magnitude of the
filter's frequency response from that of the desired filter (not
including frequencies in any transition intervals).  That is, if w
is the frequency expressed as a fraction of the Nyquist frequency,
A(w) is the actual frequency response of the filter and D(w) is the
desired frequency response, the design requirement is that::</p>
<p>abs(A(w) - D(w))) &lt; 10**(-ripple/20)</p>
<p>for 0 &lt;= w &lt;= 1 and w not in a transition interval.
width : float
Width of transition region, normalized so that 1 corresponds to pi
radians / sample.  That is, the frequency is expressed as a fraction
of the Nyquist frequency.</p>
<h2 id="returns_145">Returns<a class="headerlink" href="#returns_145" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The length of the Kaiser window.
beta : float
The beta parameter for the Kaiser window.</p>
<h2 id="see-also_119">See Also<a class="headerlink" href="#see-also_119" title="Permanent link">&para;</a></h2>
<p>kaiser_beta, kaiser_atten</p>
<h2 id="notes_102">Notes<a class="headerlink" href="#notes_102" title="Permanent link">&para;</a></h2>
<p>There are several ways to obtain the Kaiser window:</p>
<ul>
<li><code>signal.kaiser(numtaps, beta, sym=True)</code></li>
<li><code>signal.get_window(beta, numtaps)</code></li>
<li><code>signal.get_window(('kaiser', beta), numtaps)</code></li>
</ul>
<p>The empirical equations discovered by Kaiser are used.</p>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>Oppenheim, Schafer, 'Discrete-Time Signal Processing', p.475-476.</p>
<h2 id="examples_126">Examples<a class="headerlink" href="#examples_126" title="Permanent link">&para;</a></h2>
<p>We will use the Kaiser window method to design a lowpass FIR filter
for a signal that is sampled at 1000 Hz.</p>
<p>We want at least 65 dB rejection in the stop band, and in the pass
band the gain should vary no more than 0.5%.</p>
<p>We want a cutoff frequency of 175 Hz, with a transition between the
pass band and the stop band of 24 Hz.  That is, in the band [0, 163],
the gain varies no more than 0.5%, and in the band [187, 500], the
signal is attenuated by at least 65 dB.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiserord, firwin, freqz
import matplotlib.pyplot as plt
fs = 1000.0
cutoff = 175
width = 24</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Kaiser method accepts just a single parameter to control the pass
band ripple and the stop band rejection, so we use the more restrictive
of the two.  In this case, the pass band ripple is 0.005, or 46.02 dB,
so we will use 65 dB as the design parameter.</p>
<p>Use <code>kaiserord</code> to determine the length of the filter and the
parameter for the Kaiser window.</p>
<blockquote>
<blockquote>
<blockquote>
<p>numtaps, beta = kaiserord(65, width/(0.5*fs))
numtaps
167
beta
6.20426</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use <code>firwin</code> to create the FIR filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>taps = firwin(numtaps, cutoff, window=('kaiser', beta),
...               scale=False, nyq=0.5*fs)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the frequency response of the filter.  <code>w</code> is the array of
frequencies, and <code>h</code> is the corresponding complex array of frequency
responses.</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = freqz(taps, worN=8000)
w <em>= 0.5</em>fs/np.pi  # Convert w to Hz.</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the deviation of the magnitude of the filter's response from
that of the ideal lowpass filter.  Values in the transition region are
set to <code>nan</code>, so they won't appear in the plot.</p>
<blockquote>
<blockquote>
<blockquote>
<p>ideal = w &lt; cutoff  # The 'ideal' frequency response.
deviation = np.abs(np.abs(h) - ideal)
deviation[(w &gt; cutoff - 0.5<em>width) &amp; (w &lt; cutoff + 0.5</em>width)] = np.nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the deviation.  A close look at the left end of the stop band shows
that the requirement for 65 dB attenuation is violated in the first lobe
by about 0.125 dB.  This is not unusual for the Kaiser window method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(w, 20<em>np.log10(np.abs(deviation)))
plt.xlim(0, 0.5</em>fs)
plt.ylim(-90, -60)
plt.grid(alpha=0.25)
plt.axhline(-65, color='r', ls='--', alpha=0.3)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Deviation from ideal (dB)')
plt.title('Lowpass Filter Frequency Response')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lstsq</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Compute least-squares solution to equation Ax = b.</p>
<p>Compute a vector x such that the 2-norm <code>|b - A x|</code> is minimized.</p>
<h2 id="parameters_149">Parameters<a class="headerlink" href="#parameters_149" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Left hand side array
b : (M,) or (M, K) array_like
Right hand side array
cond : float, optional
Cutoff for 'small' singular values; used to determine effective
rank of a. Singular values smaller than
<code>rcond * largest_singular_value</code> are considered zero.
overwrite_a : bool, optional
Discard data in <code>a</code> (may enhance performance). Default is False.
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
Which LAPACK driver is used to solve the least-squares problem.
Options are <code>'gelsd'</code>, <code>'gelsy'</code>, <code>'gelss'</code>. Default
(<code>'gelsd'</code>) is a good choice.  However, <code>'gelsy'</code> can be slightly
faster on many problems.  <code>'gelss'</code> was used historically.  It is
generally slow but uses less memory.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="returns_146">Returns<a class="headerlink" href="#returns_146" title="Permanent link">&para;</a></h2>
<p>x : (N,) or (N, K) ndarray
Least-squares solution.  Return shape matches shape of <code>b</code>.
residues : (K,) ndarray or float
Square of the 2-norm for each column in <code>b - a x</code>, if <code>M &gt; N</code> and
<code>ndim(A) == n</code> (returns a scalar if b is 1-D). Otherwise a
(0,)-shaped array is returned.
rank : int
Effective rank of <code>a</code>.
s : (min(M, N),) ndarray or None
Singular values of <code>a</code>. The condition number of a is
<code>abs(s[0] / s[-1])</code>.</p>
<h2 id="raises_21">Raises<a class="headerlink" href="#raises_21" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If computation does not converge.</p>
<p>ValueError
When parameters are not compatible.</p>
<h2 id="see-also_120">See Also<a class="headerlink" href="#see-also_120" title="Permanent link">&para;</a></h2>
<p>scipy.optimize.nnls : linear least squares with non-negativity constraint</p>
<h2 id="notes_103">Notes<a class="headerlink" href="#notes_103" title="Permanent link">&para;</a></h2>
<p>When <code>'gelsy'</code> is used as a driver, <code>residues</code> is set to a (0,)-shaped
array and <code>s</code> is always <code>None</code>.</p>
<h2 id="examples_127">Examples<a class="headerlink" href="#examples_127" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lstsq
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Suppose we have the following data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to fit a quadratic polynomial of the form <code>y = a + b*x**2</code>
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing <code>x**2</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = x[:, np.newaxis]**[0, 2]
M
array([[  1.  ,   1.  ],
[  1.  ,   6.25],
[  1.  ,  12.25],
[  1.  ,  16.  ],
[  1.  ,  25.  ],
[  1.  ,  49.  ],
[  1.  ,  72.25]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to find the least-squares solution to <code>M.dot(p) = y</code>,
where <code>p</code> is a vector with length 2 that holds the parameters
<code>a</code> and <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>p, res, rnk, s = lstsq(M, y)
p
array([ 0.20925829,  0.12013861])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the data and the fitted curve.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(x, y, 'o', label='data')
xx = np.linspace(0, 9, 101)
yy = p[0] + p[1]<em>xx</em>*2
plt.plot(xx, yy, label='least squares fit, <span><span class="MathJax_Preview">y = a + bx^2</span><script type="math/tex">y = a + bx^2</script></span>')
plt.xlabel('x')
plt.ylabel('y')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_phase</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Hilbert</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Homomorphic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n_fft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a linear-phase FIR filter to minimum phase</p>
<h2 id="parameters_150">Parameters<a class="headerlink" href="#parameters_150" title="Permanent link">&para;</a></h2>
<p>h : array
Linear-phase FIR filter coefficients.
method : {'hilbert', 'homomorphic'}
The method to use:</p>
<p>'homomorphic' (default)
This method [4]<em> [5]</em> works best with filters with an
odd number of taps, and the resulting minimum phase filter
will have a magnitude response that approximates the square
root of the the original filter's magnitude response.</p>
<p>'hilbert'
This method [1]_ is designed to be used with equiripple
filters (e.g., from <code>remez</code>) with unity or zero gain
regions.</p>
<p>n_fft : int
The number of points to use for the FFT. Should be at least a
few times larger than the signal length (see Notes).</p>
<h2 id="returns_147">Returns<a class="headerlink" href="#returns_147" title="Permanent link">&para;</a></h2>
<p>h_minimum : array
The minimum-phase version of the filter, with length
<code>(length(h) + 1) // 2</code>.</p>
<h2 id="see-also_121">See Also<a class="headerlink" href="#see-also_121" title="Permanent link">&para;</a></h2>
<p>firwin
firwin2
remez</p>
<h2 id="notes_104">Notes<a class="headerlink" href="#notes_104" title="Permanent link">&para;</a></h2>
<p>Both the Hilbert [1]<em> or homomorphic [4]</em> [5]_ methods require selection
of an FFT length to estimate the complex cepstrum of the filter.</p>
<p>In the case of the Hilbert method, the deviation from the ideal
spectrum <code>epsilon</code> is related to the number of stopband zeros
<code>n_stop</code> and FFT length <code>n_fft</code> as::</p>
<p>epsilon = 2. * n_stop / n_fft</p>
<p>For example, with 100 stopband zeros and a FFT length of 2048,
<code>epsilon = 0.0976</code>. If we conservatively assume that the number of
stopband zeros is one less than the filter length, we can take the FFT
length to be the next power of 2 that satisfies <code>epsilon=0.01</code> as::</p>
<p>n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))</p>
<p>This gives reasonable results for both the Hilbert and homomorphic
methods, and gives the value used when <code>n_fft=None</code>.</p>
<p>Alternative implementations exist for creating minimum-phase filters,
including zero inversion [2]<em> and spectral factorization [3]</em> [4]_.
For more information, see:</p>
<p>http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters</p>
<h2 id="examples_128">Examples<a class="headerlink" href="#examples_128" title="Permanent link">&para;</a></h2>
<p>Create an optimal linear-phase filter, then convert it to minimum phase:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import remez, minimum_phase, freqz, group_delay
import matplotlib.pyplot as plt
freq = [0, 0.2, 0.3, 1.0]
desired = [1, 0]
h_linear = remez(151, freq, desired, Hz=2.)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert it to minimum phase:</p>
<blockquote>
<blockquote>
<blockquote>
<p>h_min_hom = minimum_phase(h_linear, method='homomorphic')
h_min_hil = minimum_phase(h_linear, method='hilbert')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare the three filters:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fig, axs = plt.subplots(4, figsize=(4, 8))
for h, style, color in zip((h_linear, h_min_hom, h_min_hil),
...                            ('-', '-', '--'), ('k', 'r', 'c')):
...     w, H = freqz(h)
...     w, gd = group_delay((h, 1))
...     w /= np.pi
...     axs[0].plot(h, color=color, linestyle=style)
...     axs[1].plot(w, np.abs(H), color=color, linestyle=style)
...     axs[2].plot(w, 20 * np.log10(np.abs(H)), color=color, linestyle=style)
...     axs[3].plot(w, gd, color=color, linestyle=style)
for ax in axs:
...     ax.grid(True, color='0.5')
...     ax.fill_between(freq[1:3], *ax.get_ylim(), color='#ffeeaa', zorder=1)
axs[0].set(xlim=[0, len(h_linear) - 1], ylabel='Amplitude', xlabel='Samples')
axs[1].legend(['Linear', 'Min-Hom', 'Min-Hil'], title='Phase')
for ax, ylim in zip(axs[1:], ([0, 1.1], [-150, 10], [-60, 60])):
...     ax.set(xlim=[0, 1], ylim=ylim, xlabel='Frequency')
axs[1].set(ylabel='Magnitude')
axs[2].set(ylabel='Magnitude (dB)')
axs[3].set(ylabel='Group delay')
plt.tight_layout()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [1] N. Damera-Venkata and B. L. Evans, 'Optimal design of real and
complex minimum phase digital FIR filters,' Acoustics, Speech,
and Signal Processing, 1999. Proceedings., 1999 IEEE International
Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.
doi: 10.1109/ICASSP.1999.756179
.. [2] X. Chen and T. W. Parks, 'Design of optimal minimum phase FIR
filters by direct factorization,' Signal Processing,
vol. 10, no. 4, pp. 369-383, Jun. 1986.
.. [3] T. Saramaki, 'Finite Impulse Response Filter Design,' in
Handbook for Digital Signal Processing, chapter 4,
New York: Wiley-Interscience, 1993.
.. [4] J. S. Lim, Advanced Topics in Signal Processing.
Englewood Cliffs, N.J.: Prentice Hall, 1988.
.. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck,
'Discrete-Time Signal Processing,' 2nd edition.
Upper Saddle River, N.J.: Prentice Hall, 1999.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">remez</span> <span class="o">:</span> <span class="o">?</span><span class="n">weight</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hz</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Differentiator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Hilbert</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">grid_density</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">bands</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">desired</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimax optimal filter using the Remez exchange algorithm.</p>
<p>Calculate the filter-coefficients for the finite impulse response
(FIR) filter whose transfer function minimizes the maximum error
between the desired gain and the realized gain in the specified
frequency bands using the Remez exchange algorithm.</p>
<h2 id="parameters_151">Parameters<a class="headerlink" href="#parameters_151" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The desired number of taps in the filter. The number of taps is
the number of terms in the filter, or the filter order plus one.
bands : array_like
A monotonic sequence containing the band edges.
All elements must be non-negative and less than half the sampling
frequency as given by <code>fs</code>.
desired : array_like
A sequence half the size of bands containing the desired gain
in each of the specified bands.
weight : array_like, optional
A relative weighting to give to each band region. The length of
<code>weight</code> has to be half the length of <code>bands</code>.
Hz : scalar, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>
The sampling frequency in Hz. Default is 1.
type : {'bandpass', 'differentiator', 'hilbert'}, optional
The type of filter:</p>
<ul>
<li>
<p>'bandpass' : flat response in bands. This is the default.</p>
</li>
<li>
<p>'differentiator' : frequency proportional response in bands.</p>
</li>
<li>
<p>'hilbert' : filter with odd symmetry, that is, type III
(for even order) or type IV (for odd order)
linear phase filters.</p>
</li>
</ul>
<p>maxiter : int, optional
Maximum number of iterations of the algorithm. Default is 25.
grid_density : int, optional
Grid density. The dense grid used in <code>remez</code> is of size
<code>(numtaps + 1) * grid_density</code>. Default is 16.
fs : float, optional
The sampling frequency of the signal.  Default is 1.</p>
<h2 id="returns_148">Returns<a class="headerlink" href="#returns_148" title="Permanent link">&para;</a></h2>
<p>out : ndarray
A rank-1 array containing the coefficients of the optimal
(in a minimax sense) filter.</p>
<h2 id="see-also_122">See Also<a class="headerlink" href="#see-also_122" title="Permanent link">&para;</a></h2>
<p>firls
firwin
firwin2
minimum_phase</p>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [1] J. H. McClellan and T. W. Parks, 'A unified approach to the
design of optimum FIR linear phase digital filters',
IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.
.. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, 'A Computer
Program for Designing Optimum FIR Linear Phase Digital
Filters', IEEE Trans. Audio Electroacoust., vol. AU-21,
pp. 506-525, 1973.</p>
<h2 id="examples_129">Examples<a class="headerlink" href="#examples_129" title="Permanent link">&para;</a></h2>
<p>In these examples <code>remez</code> gets used creating a bandpass, bandstop, lowpass
and highpass filter.  The used parameters are the filter order, an array
with according frequency boundaries, the desired attenuation values and the
sampling frequency.  Using <code>freqz</code> the corresponding frequency response
gets calculated and plotted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>def plot_response(fs, w, h, title):
...     'Utility function to plot response functions'
...     fig = plt.figure()
...     ax = fig.add_subplot(111)
...     ax.plot(0.5<em>fs</em>w/np.pi, 20<em>np.log10(np.abs(h)))
...     ax.set_ylim(-40, 5)
...     ax.set_xlim(0, 0.5</em>fs)
...     ax.grid(True)
...     ax.set_xlabel('Frequency (Hz)')
...     ax.set_ylabel('Gain (dB)')
...     ax.set_title(title)</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows a steep low pass transition according to the small
transition width and high filter order:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22050.0       # Sample rate, Hz
cutoff = 8000.0    # Desired cutoff frequency, Hz
trans_width = 100  # Width of transition from pass band to stop band, Hz
numtaps = 400      # Size of the FIR filter.
taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], [1, 0], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Low-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows a high pass filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22050.0       # Sample rate, Hz
cutoff = 2000.0    # Desired cutoff frequency, Hz
trans_width = 250  # Width of transition from pass band to stop band, Hz
numtaps = 125      # Size of the FIR filter.
taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs],
...                     [0, 1], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'High-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>For a signal sampled with 22 kHz a bandpass filter with a pass band of 2-5
kHz gets calculated using the Remez algorithm.  The transition width is 260
Hz and the filter order 10:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22000.0         # Sample rate, Hz
band = [2000, 5000]  # Desired pass band, Hz
trans_width = 260    # Width of transition from pass band to stop band, Hz
numtaps = 10        # Size of the FIR filter.
edges = [0, band[0] - trans_width, band[0], band[1],
...          band[1] + trans_width, 0.5*fs]
taps = signal.remez(numtaps, edges, [0, 1, 0], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Band-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be seen that for this bandpass filter, the low order leads to higher
ripple and less steep transitions.  There is very low attenuation in the
stop band and little overshoot in the pass band.  Of course the desired
gain can be better approximated with a higher filter order.</p>
<p>The next example shows a bandstop filter. Because of the high filter order
the transition is quite steep:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 20000.0         # Sample rate, Hz
band = [6000, 8000]  # Desired stop band, Hz
trans_width = 200    # Width of transition from pass band to stop band, Hz
numtaps = 175        # Size of the FIR filter.
edges = [0, band[0] - trans_width, band[0], band[1], band[1] + trans_width, 0.5*fs]
taps = signal.remez(numtaps, edges, [1, 0, 1], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Band-stop Filter')</p>
<p>plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinc</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the sinc function.</p>
<p>The sinc function is :math:<code>\sin(\pi x)/(\pi x)</code>.</p>
<h2 id="parameters_152">Parameters<a class="headerlink" href="#parameters_152" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Array (possibly multi-dimensional) of values for which to to
calculate <code>sinc(x)</code>.</p>
<h2 id="returns_149">Returns<a class="headerlink" href="#returns_149" title="Permanent link">&para;</a></h2>
<p>out : ndarray
<code>sinc(x)</code>, which has the same shape as the input.</p>
<h2 id="notes_105">Notes<a class="headerlink" href="#notes_105" title="Permanent link">&para;</a></h2>
<p><code>sinc(0)</code> is the limit value 1.</p>
<p>The name sinc is short for 'sine cardinal' or 'sinus cardinalis'.</p>
<p>The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [1] Weisstein, Eric W. 'Sinc Function.' From MathWorld--A Wolfram Web
Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, 'Sinc function',
https://en.wikipedia.org/wiki/Sinc_function</p>
<h2 id="examples_130">Examples<a class="headerlink" href="#examples_130" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-4, 4, 41)
np.sinc(x)
array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
-8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
-1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
-2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
-3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
-5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
-4.92362781e-02,  -3.89804309e-17])</p>
<p>plt.plot(x, np.sinc(x))
[<matplotlib.lines.Line2D object at 0x...>]
plt.title('Sinc Function')
Text(0.5, 1.0, 'Sinc Function')
plt.ylabel('Amplitude')
Text(0, 0.5, 'Amplitude')
plt.xlabel('X')
Text(0.5, 0, 'X')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_153">Parameters<a class="headerlink" href="#parameters_153" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_150">Returns<a class="headerlink" href="#returns_150" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_22">Raises<a class="headerlink" href="#raises_22" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_131">Examples<a class="headerlink" href="#examples_131" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_106">Notes<a class="headerlink" href="#notes_106" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toeplitz</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Toeplitz matrix.</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h2 id="parameters_154">Parameters<a class="headerlink" href="#parameters_154" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
First row of the matrix. If None, <code>r = conjugate(c)</code> is assumed;
in this case, if c[0] is real, the result is a Hermitian matrix.
r[0] is ignored; the first row of the returned matrix is
<code>[c[0], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_151">Returns<a class="headerlink" href="#returns_151" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Toeplitz matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_123">See Also<a class="headerlink" href="#see-also_123" title="Permanent link">&para;</a></h2>
<p>circulant : circulant matrix
hankel : Hankel matrix
solve_toeplitz : Solve a Toeplitz system.</p>
<h2 id="notes_107">Notes<a class="headerlink" href="#notes_107" title="Permanent link">&para;</a></h2>
<p>The behavior when <code>c</code> or <code>r</code> is a scalar, or when <code>c</code> is complex and
<code>r</code> is None, was changed in version 0.8.0.  The behavior in previous
versions was undocumented and is no longer supported.</p>
<h2 id="examples_132">Examples<a class="headerlink" href="#examples_132" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import toeplitz
toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
[2, 1, 4, 5],
[3, 2, 1, 4]])
toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
[ 2.+3.j,  1.+0.j,  2.-3.j],
[ 4.-1.j,  2.+3.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Lti_conversion</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">abcd_normalize</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">d</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check state-space matrices and ensure they are two-dimensional.</p>
<p>If enough information on the system is provided, that is, enough
properly-shaped arrays are passed to the function, the missing ones
are built from this information, ensuring the correct number of
rows and columns. Otherwise a ValueError is raised.</p>
<h2 id="parameters_155">Parameters<a class="headerlink" href="#parameters_155" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array_like, optional
State-space matrices. All of them are None (missing) by default.
See <code>ss2tf</code> for format.</p>
<h2 id="returns_152">Returns<a class="headerlink" href="#returns_152" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array
Properly shaped state-space matrices.</p>
<h2 id="raises_23">Raises<a class="headerlink" href="#raises_23" title="Permanent link">&para;</a></h2>
<p>ValueError
If not enough information on the system was provided.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_156">Parameters<a class="headerlink" href="#parameters_156" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_153">Returns<a class="headerlink" href="#returns_153" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_124">See Also<a class="headerlink" href="#see-also_124" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_108">Notes<a class="headerlink" href="#notes_108" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_133">Examples<a class="headerlink" href="#examples_133" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_157">Parameters<a class="headerlink" href="#parameters_157" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_154">Returns<a class="headerlink" href="#returns_154" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_125">See Also<a class="headerlink" href="#see-also_125" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_134">Examples<a class="headerlink" href="#examples_134" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h2 id="parameters_158">Parameters<a class="headerlink" href="#parameters_158" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
<h2 id="returns_155">Returns<a class="headerlink" href="#returns_155" title="Permanent link">&para;</a></h2>
<p>res, res2, ... : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
<h2 id="see-also_126">See Also<a class="headerlink" href="#see-also_126" title="Permanent link">&para;</a></h2>
<p>atleast_1d, atleast_3d</p>
<h2 id="examples_135">Examples<a class="headerlink" href="#examples_135" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_2d(3.0)
array([[3.]])</p>
<p>x = np.arange(3.0)
np.atleast_2d(x)
array([[0., 1., 2.]])
np.atleast_2d(x).base is x
True</p>
<p>np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cont2discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform a continuous to a discrete state-space system.</p>
<h2 id="parameters_159">Parameters<a class="headerlink" href="#parameters_159" title="Permanent link">&para;</a></h2>
<p>system : a tuple describing the system or an instance of <code>lti</code>
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>dt : float
The discretization time step.
method : str, optional
Which method to use:</p>
<ul>
<li>gbt: generalized bilinear transformation</li>
<li>bilinear: Tustin's approximation ('gbt' with alpha=0.5)</li>
<li>euler: Euler (or forward differencing) method ('gbt' with alpha=0)</li>
<li>backward_diff: Backwards differencing ('gbt' with alpha=1.0)</li>
<li>zoh: zero-order hold (default)</li>
<li>foh: first-order hold ( <em>versionadded: 1.3.0</em> )</li>
<li>impulse: equivalent impulse response ( <em>versionadded: 1.3.0</em> )</li>
</ul>
<p>alpha : float within [0, 1], optional
The generalized bilinear transformation weighting parameter, which
should only be specified with method='gbt', and is ignored otherwise</p>
<h2 id="returns_156">Returns<a class="headerlink" href="#returns_156" title="Permanent link">&para;</a></h2>
<p>sysd : tuple containing the discrete system
Based on the input type, the output will be of the form</p>
<ul>
<li>(num, den, dt)   for transfer function input</li>
<li>(zeros, poles, gain, dt)   for zeros-poles-gain input</li>
<li>(A, B, C, D, dt) for state-space system input</li>
</ul>
<h2 id="notes_109">Notes<a class="headerlink" href="#notes_109" title="Permanent link">&para;</a></h2>
<p>By default, the routine uses a Zero-Order Hold (zoh) method to perform
the transformation.  Alternatively, a generalized bilinear transformation
may be used, which includes the common Tustin's bilinear approximation,
an Euler's method technique, or a backwards differencing technique.</p>
<p>The Zero-Order Hold (zoh) method is based on [1]<em>, the generalized bilinear
approximation is based on [2]</em> and [3]<em>, the First-Order Hold (foh) method
is based on [4]</em>.</p>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Discretization#Discretization_of_linear_state_space_models</p>
<p>.. [2] http://techteach.no/publications/discretetime_signals_systems/discrete.pdf</p>
<p>.. [3] G. Zhang, X. Chen, and T. Chen, Digital redesign via the generalized
bilinear transformation, Int. J. Control, vol. 82, no. 4, pp. 741-754,
2009.
(https://www.mypolyuweb.hk/~magzhang/Research/ZCC09_IJC.pdf)</p>
<p>.. [4] G. F. Franklin, J. D. Powell, and M. L. Workman, Digital control
of dynamic systems, 3rd ed. Menlo Park, Calif: Addison-Wesley,
pp. 204-206, 1998.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_160">Parameters<a class="headerlink" href="#parameters_160" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_157">Returns<a class="headerlink" href="#returns_157" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_24">Raises<a class="headerlink" href="#raises_24" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_127">See Also<a class="headerlink" href="#see-also_127" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_136">Examples<a class="headerlink" href="#examples_136" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h2 id="parameters_161">Parameters<a class="headerlink" href="#parameters_161" title="Permanent link">&para;</a></h2>
<p>N : int
Number of rows in the output.
M : int, optional
Number of columns in the output. If None, defaults to <code>N</code>.
k : int, optional
Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.
dtype : data-type, optional
Data-type of the returned array.
order : {'C', 'F'}, optional
Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<p>.. versionadded:: 1.14.0</p>
<h2 id="returns_158">Returns<a class="headerlink" href="#returns_158" title="Permanent link">&para;</a></h2>
<p>I : ndarray of shape (N,M)
An array where all elements are equal to zero, except for the <code>k</code>-th
diagonal, whose values are equal to one.</p>
<h2 id="see-also_128">See Also<a class="headerlink" href="#see-also_128" title="Permanent link">&para;</a></h2>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<h2 id="examples_137">Examples<a class="headerlink" href="#examples_137" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.eye(2, dtype=int)
array([[1, 0],
[0, 1]])
np.eye(3, k=1)
array([[0.,  1.,  0.],
[0.,  0.,  1.],
[0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">normalize</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Normalize numerator/denominator of a continuous-time transfer function.</p>
<p>If values of <code>b</code> are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.</p>
<h2 id="parameters_162">Parameters<a class="headerlink" href="#parameters_162" title="Permanent link">&para;</a></h2>
<p>b: array_like
Numerator of the transfer function. Can be a 2d array to normalize
multiple transfer functions.
a: array_like
Denominator of the transfer function. At most 1d.</p>
<h2 id="returns_159">Returns<a class="headerlink" href="#returns_159" title="Permanent link">&para;</a></h2>
<p>num: array
The numerator of the normalized transfer function. At least a 1d
array. A 2d-array if the input <code>num</code> is a 2d array.
den: 1d-array
The denominator of the normalized transfer function.</p>
<h2 id="notes_110">Notes<a class="headerlink" href="#notes_110" title="Permanent link">&para;</a></h2>
<p>Coefficients for both the numerator and denominator should be specified in
descending exponent order (e.g., <code>s^2 + 3s + 5</code> would be represented as
<code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">outer</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the outer product of two vectors.</p>
<p>Given two vectors, <code>a = [a0, a1, ..., aM]</code> and
<code>b = [b0, b1, ..., bN]</code>,
the outer product [1]_ is::</p>
<p>[[a0<em>b0  a0</em>b1 ... a0<em>bN ]
[a1</em>b0    .
[ ...          .
[aM<em>b0            aM</em>bN ]]</p>
<h2 id="parameters_163">Parameters<a class="headerlink" href="#parameters_163" title="Permanent link">&para;</a></h2>
<p>a : (M,) array_like
First input vector.  Input is flattened if
not already 1-dimensional.
b : (N,) array_like
Second input vector.  Input is flattened if
not already 1-dimensional.
out : (M, N) ndarray, optional
A location where the result is stored</p>
<p>.. versionadded:: 1.9.0</p>
<h2 id="returns_160">Returns<a class="headerlink" href="#returns_160" title="Permanent link">&para;</a></h2>
<p>out : (M, N) ndarray
<code>out[i, j] = a[i] * b[j]</code></p>
<h2 id="see-also_129">See also<a class="headerlink" href="#see-also_129" title="Permanent link">&para;</a></h2>
<p>inner
einsum : <code>einsum('i,j-&gt;ij', a.ravel(), b.ravel())</code> is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
<code>np.multiply.outer(a.ravel(), b.ravel())</code> is the equivalent.</p>
<h2 id="references_34">References<a class="headerlink" href="#references_34" title="Permanent link">&para;</a></h2>
<p>.. [1] : G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd
ed., Baltimore, MD, Johns Hopkins University Press, 1996,
pg. 8.</p>
<h2 id="examples_138">Examples<a class="headerlink" href="#examples_138" title="Permanent link">&para;</a></h2>
<p>Make a ( <em>very</em> coarse) grid for computing a Mandelbrot set:</p>
<blockquote>
<blockquote>
<blockquote>
<p>rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
rl
array([[-2., -1.,  0.,  1.,  2.],
[-2., -1.,  0.,  1.,  2.],
[-2., -1.,  0.,  1.,  2.],
[-2., -1.,  0.,  1.,  2.],
[-2., -1.,  0.,  1.,  2.]])
im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
[0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
[0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
[0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
grid = rl + im
grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
[-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
[-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
[-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
[-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An example using a 'vector' of letters:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array(['a', 'b', 'c'], dtype=object)
np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
['b', 'bb', 'bbb'],
['c', 'cc', 'ccc']], dtype=object)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">poly</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the coefficients of a polynomial with the given sequence of roots.</p>
<p>Returns the coefficients of the polynomial whose leading coefficient
is one for the given sequence of zeros (multiple roots must be included
in the sequence as many times as their multiplicity; see Examples).
A square matrix (or array, which will be treated as a matrix) can also
be given, in which case the coefficients of the characteristic polynomial
of the matrix are returned.</p>
<h2 id="parameters_164">Parameters<a class="headerlink" href="#parameters_164" title="Permanent link">&para;</a></h2>
<p>seq_of_zeros : array_like, shape (N,) or (N, N)
A sequence of polynomial roots, or a square array or matrix object.</p>
<h2 id="returns_161">Returns<a class="headerlink" href="#returns_161" title="Permanent link">&para;</a></h2>
<p>c : ndarray
1D array of polynomial coefficients from highest to lowest degree:</p>
<p><code>c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]</code>
where c[0] always equals 1.</p>
<h2 id="raises_25">Raises<a class="headerlink" href="#raises_25" title="Permanent link">&para;</a></h2>
<p>ValueError
If input is the wrong shape (the input must be a 1-D or square
2-D array).</p>
<h2 id="see-also_130">See Also<a class="headerlink" href="#see-also_130" title="Permanent link">&para;</a></h2>
<p>polyval : Compute polynomial values.
roots : Return the roots of a polynomial.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<h2 id="notes_111">Notes<a class="headerlink" href="#notes_111" title="Permanent link">&para;</a></h2>
<p>Specifying the roots of a polynomial still leaves one degree of
freedom, typically represented by an undetermined leading
coefficient. [1]_ In the case of this function, that coefficient -
the first one in the returned array - is always taken as one. (If
for some reason you have one other point, the only automatic way
presently to leverage that information is to use <code>polyfit</code>.)</p>
<p>The characteristic polynomial, :math:<code>p_a(t)</code>, of an <code>n</code>-by-<code>n</code>
matrix <strong>A</strong> is given by</p>
<p>:math:<code>p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})</code>,</p>
<p>where <strong>I</strong> is the <code>n</code>-by-<code>n</code> identity matrix. [2]_</p>
<h2 id="references_35">References<a class="headerlink" href="#references_35" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Sullivan and M. Sullivan, III, 'Algebra and Trignometry,
Enhanced With Graphing Utilities,' Prentice-Hall, pg. 318, 1996.</p>
<p>.. [2] G. Strang, 'Linear Algebra and Its Applications, 2nd Edition,'
Academic Press, pg. 182, 1980.</p>
<h2 id="examples_139">Examples<a class="headerlink" href="#examples_139" title="Permanent link">&para;</a></h2>
<p>Given a sequence of a polynomial's zeros:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((0, 0, 0)) # Multiple root example
array([1., 0., 0., 0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The line above represents z<strong>3 + 0*z</strong>2 + 0*z + 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((-1./2, 0, 1./2))
array([ 1.  ,  0.  , -0.25,  0.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The line above represents z**3 - z/4</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))
array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a square array object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>P = np.array([[0, 1./3], [-1./2, 0]])
np.poly(P)
array([1.        , 0.        , 0.16666667])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how in all cases the leading coefficient is always 1.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of array elements over a given axis.</p>
<h2 id="parameters_165">Parameters<a class="headerlink" href="#parameters_165" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.
dtype : dtype, optional
The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <code>a</code> is used by
default unless <code>a</code> has an integer dtype of less precision than the
default platform integer.  In that case, if <code>a</code> is signed then the
platform integer is used while if <code>a</code> is unsigned then an unsigned
integer of the same precision as the platform integer is used.
out : ndarray, optional
Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.
keepdims : bool, optional
If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>prod</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.
initial : scalar, optional
The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
<p>where : array_like of bool, optional
Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_162">Returns<a class="headerlink" href="#returns_162" title="Permanent link">&para;</a></h2>
<p>product_along_axis : ndarray, see <code>dtype</code> parameter above.
An array shaped as <code>a</code> but with the specified axis removed.
Returns a reference to <code>out</code> if specified.</p>
<h2 id="see-also_131">See Also<a class="headerlink" href="#see-also_131" title="Permanent link">&para;</a></h2>
<p>ndarray.prod : equivalent method
ufuncs-output-type</p>
<h2 id="notes_112">Notes<a class="headerlink" href="#notes_112" title="Permanent link">&para;</a></h2>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([536870910, 536870910, 536870910, 536870910])
np.prod(x)
16 # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>The product of an empty array is the neutral element 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_140">Examples<a class="headerlink" href="#examples_140" title="Permanent link">&para;</a></h2>
<p>By default, calculate the product of all elements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1.,2.])
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even when the input array is two-dimensional:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]])
24.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>But we can also specify the axis over which to multiply:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Or select specific elements to include:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1., np.nan, 3.], where=[True, False, True])
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the type of <code>x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.uint8)
np.prod(x).dtype == np.uint
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.int8)
np.prod(x).dtype == int
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can also start the product with a value other than one:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1, 2], initial=5)
10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>State-space to transfer function.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_166">Parameters<a class="headerlink" href="#parameters_166" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_163">Returns<a class="headerlink" href="#returns_163" title="Permanent link">&para;</a></h2>
<p>num : 2-D ndarray
Numerator(s) of the resulting transfer function(s).  <code>num</code> has one row
for each of the system's outputs. Each row is a sequence representation
of the numerator polynomial.
den : 1-D ndarray
Denominator of the resulting transfer function(s).  <code>den</code> is a sequence
representation of the denominator polynomial.</p>
<h2 id="examples_141">Examples<a class="headerlink" href="#examples_141" title="Permanent link">&para;</a></h2>
<p>Convert the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = [[-2, -1], [1, 0]]
B = [[1], [0]]  # 2-dimensional column vector
C = [[1, 2]]    # 2-dimensional row vector
D = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import ss2tf
ss2tf(A, B, C, D)
(array([[1, 3, 3]]), array([ 1.,  2.,  1.]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>State-space representation to zero-pole-gain representation.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_167">Parameters<a class="headerlink" href="#parameters_167" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_164">Returns<a class="headerlink" href="#returns_164" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2ss</span> <span class="o">:</span> <span class="n">num</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">den</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transfer function to state-space representation.</p>
<h2 id="parameters_168">Parameters<a class="headerlink" href="#parameters_168" title="Permanent link">&para;</a></h2>
<p>num, den : array_like
Sequences representing the coefficients of the numerator and
denominator polynomials, in order of descending degree. The
denominator needs to be at least as long as the numerator.</p>
<h2 id="returns_165">Returns<a class="headerlink" href="#returns_165" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<h2 id="examples_142">Examples<a class="headerlink" href="#examples_142" title="Permanent link">&para;</a></h2>
<p>Convert the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import tf2ss
A, B, C, D = tf2ss(num, den)
A
array([[-2., -1.],
[ 1.,  0.]])
B
array([[ 1.],
[ 0.]])
C
array([[ 1.,  2.]])
D
array([[ 1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2zpk</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.</p>
<h2 id="parameters_169">Parameters<a class="headerlink" href="#parameters_169" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.</p>
<h2 id="returns_166">Returns<a class="headerlink" href="#returns_166" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_113">Notes<a class="headerlink" href="#notes_113" title="Permanent link">&para;</a></h2>
<p>If some values of <code>b</code> are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.</p>
<p>The <code>b</code> and <code>a</code> arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable.  So the inputs
:math:<code>b = [b_0, b_1, ..., b_M]</code> and :math:<code>a =[a_0, a_1, ..., a_N]</code>
can represent an analog filter of the form:</p>
<p>.. math::</p>
<p>H(s) = \frac
{b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
{a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}</p>
<p>or a discrete-time filter of the form:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
{a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}</p>
<p>This 'positive powers' form is found more commonly in controls
engineering.  If <code>M</code> and <code>N</code> are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the 'negative powers' discrete-time form preferred in DSP:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}</p>
<p>Although this is true for common filters, remember that this is not true
in the general case.  If <code>M</code> and <code>N</code> are not equal, the discrete-time
transfer function coefficients must first be converted to the 'positive
powers' form before finding the poles and zeros.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_170">Parameters<a class="headerlink" href="#parameters_170" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_167">Returns<a class="headerlink" href="#returns_167" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_132">See Also<a class="headerlink" href="#see-also_132" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_143">Examples<a class="headerlink" href="#examples_143" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2ss</span> <span class="o">:</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zero-pole-gain representation to state-space representation</p>
<h2 id="parameters_171">Parameters<a class="headerlink" href="#parameters_171" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<h2 id="returns_168">Returns<a class="headerlink" href="#returns_168" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2tf</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return polynomial transfer function representation from zeros and poles</p>
<h2 id="parameters_172">Parameters<a class="headerlink" href="#parameters_172" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="returns_169">Returns<a class="headerlink" href="#returns_169" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Ltisys</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Bunch</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Bunch</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Bunch</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LinearTimeInvariant</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearTimeInvariant</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinearTimeInvariant</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>None</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">StateSpaceContinuous</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">StateSpaceContinuous</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">StateSpaceContinuous</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Continuous-time Linear Time Invariant system in state-space form.</p>
<p>Represents the system as the continuous-time, first order differential
equation :math:<code>\dot{x} = A x + B u</code>.
Continuous-time <code>StateSpace</code> systems inherit additional functionality
from the <code>lti</code> class.</p>
<h2 id="parameters_173">Parameters<a class="headerlink" href="#parameters_173" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>StateSpace</code> class can be instantiated with 1 or 3 arguments.
The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>4: array_like: (A, B, C, D)</li>
</ul>
<h2 id="see-also_133">See Also<a class="headerlink" href="#see-also_133" title="Permanent link">&para;</a></h2>
<p>TransferFunction, ZerosPolesGain, lti
ss2zpk, ss2tf, zpk2sos</p>
<h2 id="notes_114">Notes<a class="headerlink" href="#notes_114" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>StateSpace</code> system representation (such as <code>zeros</code> or <code>poles</code>) is very
inefficient and may lead to numerical inaccuracies.  It is better to
convert to the specific system representation first. For example, call
<code>sys = sys.to_zpk()</code> before accessing/changing the zeros, poles or gain.</p>
<h2 id="examples_144">Examples<a class="headerlink" href="#examples_144" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>a = np.array([[0, 1], [0, 0]])
b = np.array([[0], [1]])
c = np.array([[1, 0]])
d = np.array([[0]])</p>
<p>sys = signal.StateSpace(a, b, c, d)
print(sys)
StateSpaceContinuous(
array([[0, 1],
[0, 0]]),
array([[0],
[1]]),
array([[1, 0]]),
array([[0]]),
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>bode</code> for details.</p>
<h2 id="examples_145">Examples<a class="headerlink" href="#examples_145" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>freqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of a continuous-time system.
See <code>impulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of a continuous-time system to input <code>U</code>.
See <code>lsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of a continuous-time system.
See <code>step</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the discretized <code>StateSpace</code> system.</p>
<p>Parameters: See <code>cont2discrete</code> for details.</p>
<h2 id="returns_170">Returns<a class="headerlink" href="#returns_170" title="Permanent link">&para;</a></h2>
<p>sys: instance of <code>dlti</code> and <code>StateSpace</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>StateSpace</code> system.</p>
<h2 id="returns_171">Returns<a class="headerlink" href="#returns_171" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="parameters_174">Parameters<a class="headerlink" href="#parameters_174" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_172">Returns<a class="headerlink" href="#returns_172" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="parameters_175">Parameters<a class="headerlink" href="#parameters_175" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_173">Returns<a class="headerlink" href="#returns_173" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">StateSpaceDiscrete</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">StateSpaceDiscrete</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">StateSpaceDiscrete</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Discrete-time Linear Time Invariant system in state-space form.</p>
<p>Represents the system as the discrete-time difference equation
:math:<code>x[k+1] = A x[k] + B u[k]</code>.
<code>StateSpace</code> systems inherit additional functionality from the <code>dlti</code>
class.</p>
<h2 id="parameters_176">Parameters<a class="headerlink" href="#parameters_176" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>StateSpace</code> class can be instantiated with 1 or 3 arguments.
The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>4: array_like: (A, B, C, D)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>True</code>
(unspecified sampling time). Must be specified as a keyword argument,
for example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also_134">See Also<a class="headerlink" href="#see-also_134" title="Permanent link">&para;</a></h2>
<p>TransferFunction, ZerosPolesGain, dlti
ss2zpk, ss2tf, zpk2sos</p>
<h2 id="notes_115">Notes<a class="headerlink" href="#notes_115" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>StateSpace</code> system representation (such as <code>zeros</code> or <code>poles</code>) is very
inefficient and may lead to numerical inaccuracies.  It is better to
convert to the specific system representation first. For example, call
<code>sys = sys.to_zpk()</code> before accessing/changing the zeros, poles or gain.</p>
<h2 id="examples_146">Examples<a class="headerlink" href="#examples_146" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>a = np.array([[1, 0.1], [0, 1]])
b = np.array([[0.005], [0.1]])
c = np.array([[1, 0]])
d = np.array([[0]])</p>
<p>signal.StateSpace(a, b, c, d, dt=0.1)
StateSpaceDiscrete(
array([[ 1. ,  0.1],
[ 0. ,  1. ]]),
array([[ 0.005],
[ 0.1  ]]),
array([[1, 0]]),
array([[0]]),
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>dbode</code> for details.</p>
<h2 id="examples_147">Examples<a class="headerlink" href="#examples_147" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3) with sampling time 0.5s</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: signal.dbode(sys)</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>dfreqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of the discrete-time <code>dlti</code> system.
See <code>dimpulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of the discrete-time system to input <code>u</code>.
See <code>dlsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of the discrete-time <code>dlti</code> system.
See <code>dstep</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>StateSpace</code> system.</p>
<h2 id="returns_174">Returns<a class="headerlink" href="#returns_174" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="parameters_177">Parameters<a class="headerlink" href="#parameters_177" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_175">Returns<a class="headerlink" href="#returns_175" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="parameters_178">Parameters<a class="headerlink" href="#parameters_178" title="Permanent link">&para;</a></h2>
<p>kwargs : dict, optional
Additional keywords passed to <code>ss2zpk</code></p>
<h2 id="returns_176">Returns<a class="headerlink" href="#returns_176" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">TransferFunctionContinuous</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">TransferFunctionContinuous</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">TransferFunctionContinuous</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Continuous-time Linear Time Invariant system in transfer function form.</p>
<p>Represents the system as the transfer function
:math:<code>H(s)=\sum_{i=0}^N b[N-i] s^i / \sum_{j=0}^M a[M-j] s^j</code>, where
:math:<code>b</code> are elements of the numerator <code>num</code>, :math:<code>a</code> are elements of
the denominator <code>den</code>, and <code>N == len(b) - 1</code>, <code>M == len(a) - 1</code>.
Continuous-time <code>TransferFunction</code> systems inherit additional
functionality from the <code>lti</code> class.</p>
<h2 id="parameters_179">Parameters<a class="headerlink" href="#parameters_179" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>TransferFunction</code> class can be instantiated with 1 or 2
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>2: array_like: (numerator, denominator)</li>
</ul>
<h2 id="see-also_135">See Also<a class="headerlink" href="#see-also_135" title="Permanent link">&para;</a></h2>
<p>ZerosPolesGain, StateSpace, lti
tf2ss, tf2zpk, tf2sos</p>
<h2 id="notes_116">Notes<a class="headerlink" href="#notes_116" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>TransferFunction</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.  It is better to convert to the specific system
representation first. For example, call <code>sys = sys.to_ss()</code> before
accessing/changing the A, B, C, D system matrices.</p>
<p>If (numerator, denominator) is passed in for <code>*system</code>, coefficients
for both the numerator and denominator should be specified in descending
exponent order (e.g. <code>s^2 + 3s + 5</code> would be represented as
<code>[1, 3, 5]</code>)</p>
<h2 id="examples_148">Examples<a class="headerlink" href="#examples_148" title="Permanent link">&para;</a></h2>
<p>Construct the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
<p>signal.TransferFunction(num, den)
TransferFunctionContinuous(
array([ 1.,  3.,  3.]),
array([ 1.,  2.,  1.]),
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>bode</code> for details.</p>
<h2 id="examples_149">Examples<a class="headerlink" href="#examples_149" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>freqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of a continuous-time system.
See <code>impulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of a continuous-time system to input <code>U</code>.
See <code>lsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of a continuous-time system.
See <code>step</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the discretized <code>TransferFunction</code> system.</p>
<p>Parameters: See <code>cont2discrete</code> for details.</p>
<h2 id="returns_177">Returns<a class="headerlink" href="#returns_177" title="Permanent link">&para;</a></h2>
<p>sys: instance of <code>dlti</code> and <code>StateSpace</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_178">Returns<a class="headerlink" href="#returns_178" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>TransferFunction</code> system.</p>
<h2 id="returns_179">Returns<a class="headerlink" href="#returns_179" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="returns_180">Returns<a class="headerlink" href="#returns_180" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">TransferFunctionDiscrete</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">TransferFunctionDiscrete</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">TransferFunctionDiscrete</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Discrete-time Linear Time Invariant system in transfer function form.</p>
<p>Represents the system as the transfer function
:math:<code>H(z)=\sum_{i=0}^N b[N-i] z^i / \sum_{j=0}^M a[M-j] z^j</code>, where
:math:<code>b</code> are elements of the numerator <code>num</code>, :math:<code>a</code> are elements of
the denominator <code>den</code>, and <code>N == len(b) - 1</code>, <code>M == len(a) - 1</code>.
Discrete-time <code>TransferFunction</code> systems inherit additional functionality
from the <code>dlti</code> class.</p>
<h2 id="parameters_180">Parameters<a class="headerlink" href="#parameters_180" title="Permanent link">&para;</a></h2>
<p>*system: arguments
The <code>TransferFunction</code> class can be instantiated with 1 or 2
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>2: array_like: (numerator, denominator)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>True</code>
(unspecified sampling time). Must be specified as a keyword argument,
for example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also_136">See Also<a class="headerlink" href="#see-also_136" title="Permanent link">&para;</a></h2>
<p>ZerosPolesGain, StateSpace, dlti
tf2ss, tf2zpk, tf2sos</p>
<h2 id="notes_117">Notes<a class="headerlink" href="#notes_117" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>TransferFunction</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.</p>
<p>If (numerator, denominator) is passed in for <code>*system</code>, coefficients
for both the numerator and denominator should be specified in descending
exponent order (e.g., <code>z^2 + 3z + 5</code> would be represented as
<code>[1, 3, 5]</code>).</p>
<h2 id="examples_150">Examples<a class="headerlink" href="#examples_150" title="Permanent link">&para;</a></h2>
<p>Construct the transfer function with a sampling time of 0.5 seconds:</p>
<p>.. math:: H(z) = \frac{z^2 + 3z + 3}{z^2 + 2z + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
<p>signal.TransferFunction(num, den, 0.5)
TransferFunctionDiscrete(
array([ 1.,  3.,  3.]),
array([ 1.,  2.,  1.]),
dt: 0.5
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>dbode</code> for details.</p>
<h2 id="examples_151">Examples<a class="headerlink" href="#examples_151" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3) with sampling time 0.5s</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: signal.dbode(sys)</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>dfreqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of the discrete-time <code>dlti</code> system.
See <code>dimpulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of the discrete-time system to input <code>u</code>.
See <code>dlsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of the discrete-time <code>dlti</code> system.
See <code>dstep</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_181">Returns<a class="headerlink" href="#returns_181" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current <code>TransferFunction</code> system.</p>
<h2 id="returns_182">Returns<a class="headerlink" href="#returns_182" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
The current system (copy)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>ZerosPolesGain</code>.</p>
<h2 id="returns_183">Returns<a class="headerlink" href="#returns_183" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
Zeros, poles, gain representation of the current system</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ZerosPolesGainContinuous</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ZerosPolesGainContinuous</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ZerosPolesGainContinuous</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Continuous-time Linear Time Invariant system in zeros, poles, gain form.</p>
<p>Represents the system as the continuous time transfer function
:math:<code>H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])</code>, where :math:<code>k</code> is
the <code>gain</code>, :math:<code>z</code> are the <code>zeros</code> and :math:<code>p</code> are the <code>poles</code>.
Continuous-time <code>ZerosPolesGain</code> systems inherit additional functionality
from the <code>lti</code> class.</p>
<h2 id="parameters_181">Parameters<a class="headerlink" href="#parameters_181" title="Permanent link">&para;</a></h2>
<p>*system : arguments
The <code>ZerosPolesGain</code> class can be instantiated with 1 or 3
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>lti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>3: array_like: (zeros, poles, gain)</li>
</ul>
<h2 id="see-also_137">See Also<a class="headerlink" href="#see-also_137" title="Permanent link">&para;</a></h2>
<p>TransferFunction, StateSpace, lti
zpk2ss, zpk2tf, zpk2sos</p>
<h2 id="notes_118">Notes<a class="headerlink" href="#notes_118" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>ZerosPolesGain</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.  It is better to convert to the specific system
representation first. For example, call <code>sys = sys.to_ss()</code> before
accessing/changing the A, B, C, D system matrices.</p>
<h2 id="examples_152">Examples<a class="headerlink" href="#examples_152" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(s) = 5(s - 1)(s - 2) / (s - 3)(s - 4)</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.ZerosPolesGain([1, 2], [3, 4], 5)
ZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>bode</code> for details.</p>
<h2 id="examples_153">Examples<a class="headerlink" href="#examples_153" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>freqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of a continuous-time system.
See <code>impulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of a continuous-time system to input <code>U</code>.
See <code>lsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of a continuous-time system.
See <code>step</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the discretized <code>ZerosPolesGain</code> system.</p>
<p>Parameters: See <code>cont2discrete</code> for details.</p>
<h2 id="returns_184">Returns<a class="headerlink" href="#returns_184" title="Permanent link">&para;</a></h2>
<p>sys: instance of <code>dlti</code> and <code>ZerosPolesGain</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_185">Returns<a class="headerlink" href="#returns_185" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="returns_186">Returns<a class="headerlink" href="#returns_186" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current 'ZerosPolesGain' system.</p>
<h2 id="returns_187">Returns<a class="headerlink" href="#returns_187" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
The current system (copy)</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ZerosPolesGainDiscrete</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ZerosPolesGainDiscrete</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ZerosPolesGainDiscrete</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Discrete-time Linear Time Invariant system in zeros, poles, gain form.</p>
<p>Represents the system as the discrete-time transfer function
:math:<code>H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])</code>, where :math:<code>k</code> is
the <code>gain</code>, :math:<code>z</code> are the <code>zeros</code> and :math:<code>p</code> are the <code>poles</code>.
Discrete-time <code>ZerosPolesGain</code> systems inherit additional functionality
from the <code>dlti</code> class.</p>
<h2 id="parameters_182">Parameters<a class="headerlink" href="#parameters_182" title="Permanent link">&para;</a></h2>
<p>*system : arguments
The <code>ZerosPolesGain</code> class can be instantiated with 1 or 3
arguments. The following gives the number of input arguments and their
interpretation:</p>
<ul>
<li>1: <code>dlti</code> system: (<code>StateSpace</code>, <code>TransferFunction</code> or
<code>ZerosPolesGain</code>)</li>
<li>3: array_like: (zeros, poles, gain)
dt: float, optional
Sampling time [s] of the discrete-time systems. Defaults to <code>True</code>
(unspecified sampling time). Must be specified as a keyword argument,
for example, <code>dt=0.1</code>.</li>
</ul>
<h2 id="see-also_138">See Also<a class="headerlink" href="#see-also_138" title="Permanent link">&para;</a></h2>
<p>TransferFunction, StateSpace, dlti
zpk2ss, zpk2tf, zpk2sos</p>
<h2 id="notes_119">Notes<a class="headerlink" href="#notes_119" title="Permanent link">&para;</a></h2>
<p>Changing the value of properties that are not part of the
<code>ZerosPolesGain</code> system representation (such as the <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>
state-space matrices) is very inefficient and may lead to numerical
inaccuracies.  It is better to convert to the specific system
representation first. For example, call <code>sys = sys.to_ss()</code> before
accessing/changing the A, B, C, D system matrices.</p>
<h2 id="examples_154">Examples<a class="headerlink" href="#examples_154" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(s) = 5(s - 1)(s - 2) / (s - 3)(s - 4)</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.ZerosPolesGain([1, 2], [3, 4], 5)
ZerosPolesGainContinuous(
array([1, 2]),
array([3, 4]),
5,
dt: None
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 5(z - 1)(z - 2) / (z - 3)(z - 4)</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.ZerosPolesGain([1, 2], [3, 4], 5, dt=0.1)
ZerosPolesGainDiscrete(
array([1, 2]),
array([3, 4]),
5,
dt: 0.1
)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<p>Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude
[dB] and phase [deg]. See <code>dbode</code> for details.</p>
<h2 id="examples_155">Examples<a class="headerlink" href="#examples_155" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3) with sampling time 0.5s</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: signal.dbode(sys)</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = sys.bode()</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<p>Returns a 2-tuple containing arrays of frequencies [rad/s] and
complex magnitude.
See <code>dfreqresp</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the impulse response of the discrete-time <code>dlti</code> system.
See <code>dimpulse</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">output</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the response of the discrete-time system to input <code>u</code>.
See <code>dlsim</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the step response of the discrete-time <code>dlti</code> system.
See <code>dstep</code> for details.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_ss</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>StateSpace</code>.</p>
<h2 id="returns_188">Returns<a class="headerlink" href="#returns_188" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>StateSpace</code>
State space model of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert system representation to <code>TransferFunction</code>.</p>
<h2 id="returns_189">Returns<a class="headerlink" href="#returns_189" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>TransferFunction</code>
Transfer function of the current system</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_zpk</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a copy of the current 'ZerosPolesGain' system.</p>
<h2 id="returns_190">Returns<a class="headerlink" href="#returns_190" title="Permanent link">&para;</a></h2>
<p>sys : instance of <code>ZerosPolesGain</code>
The current system (copy)</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Six</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Iterator</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless
instance that has no instance attributes and cannot be given any.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">StringIO</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">StringIO</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">StringIO</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">initial_value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">newline</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Text I/O implementation using an in-memory buffer.</p>
<p>The initial_value argument sets the value of object.  The newline
argument is like the one of TextIOWrapper's constructor.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Close the IO object.</p>
<p>Attempting any further operation after the object is closed
will raise a ValueError.</p>
<p>This method has no effect if the file is already closed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fileno</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns underlying file descriptor if one exists.</p>
<p>OSError is raised if the IO object does not use a file descriptor.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flush</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Flush write buffers, if applicable.</p>
<p>This is not implemented for read-only and non-blocking streams.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">getvalue</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Retrieve the entire contents of the object.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isatty</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return whether this is an 'interactive' stream.</p>
<p>Return False if it can't be determined.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">read</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Read at most size characters, returned as a string.</p>
<p>If the argument is negative or omitted, read until EOF
is reached. Return an empty string at EOF.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">readable</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns True if the IO object can be read.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">readline</span> <span class="o">:</span> <span class="o">?</span><span class="n">size</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Read until newline or EOF.</p>
<p>Returns an empty string if EOF is hit immediately.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">readlines</span> <span class="o">:</span> <span class="o">?</span><span class="n">hint</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a list of lines from the stream.</p>
<p>hint can be specified to control the number of lines read: no more
lines will be read if the total size (in bytes/characters) of all
lines so far exceeds hint.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">seek</span> <span class="o">:</span> <span class="o">?</span><span class="n">whence</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pos</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Change stream position.</p>
<p>Seek to character offset pos relative to position indicated by whence:
0  Start of stream (the default).  pos should be &gt;= 0;
1  Current position - pos must be 0;
2  End of stream - pos must be 0.
Returns the new absolute position.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">seekable</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns True if the IO object can be seeked.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tell</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Tell the current file position.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">truncate</span> <span class="o">:</span> <span class="o">?</span><span class="n">pos</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Truncate size to pos.</p>
<p>The pos argument defaults to the current file position, as
returned by tell().  The current file position is unchanged.
Returns the new absolute position.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">writable</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns True if the IO object can be written.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">write</span> <span class="o">:</span> <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Write string to file.</p>
<p>Returns the number of characters written, which is always equal to
the length of the string.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">writelines</span> <span class="o">:</span> <span class="n">lines</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Write a list of lines to stream.</p>
<p>Line separators are not added, so it is usual for each of the
lines provided to have a line separator at the end.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">advance_iterator</span> <span class="o">:</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterator</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>next(iterator[, default])</p>
<p>Return the next item from the iterator. If default is given and the iterator
is exhausted, it is returned instead of raising StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">b</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Byte literal</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_unbound_function</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get the function out of a possibly unbound function</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iteritems</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the (key, value) pairs of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iterkeys</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the keys of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">itervalues</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an iterator over the values of a dictionary.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">next</span> <span class="o">:</span> <span class="o">?</span><span class="n">default</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iterator</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>next(iterator[, default])</p>
<p>Return the next item from the iterator. If default is given and the iterator
is exhausted, it is returned instead of raising StopIteration.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reduce</span> <span class="o">:</span> <span class="o">?</span><span class="n">initial</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">function_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sequence</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>reduce(function, sequence[, initial]) -&gt; value</p>
<p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reraise</span> <span class="o">:</span> <span class="o">?</span><span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reraise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">u</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Text literal</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_metaclass</span> <span class="o">:</span> <span class="o">?</span><span class="n">base</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">meta</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a base class with a metaclass.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">abcd_normalize</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">d</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check state-space matrices and ensure they are two-dimensional.</p>
<p>If enough information on the system is provided, that is, enough
properly-shaped arrays are passed to the function, the missing ones
are built from this information, ensuring the correct number of
rows and columns. Otherwise a ValueError is raised.</p>
<h2 id="parameters_183">Parameters<a class="headerlink" href="#parameters_183" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array_like, optional
State-space matrices. All of them are None (missing) by default.
See <code>ss2tf</code> for format.</p>
<h2 id="returns_191">Returns<a class="headerlink" href="#returns_191" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array
Properly shaped state-space matrices.</p>
<h2 id="raises_26">Raises<a class="headerlink" href="#raises_26" title="Permanent link">&para;</a></h2>
<p>ValueError
If not enough information on the system was provided.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_184">Parameters<a class="headerlink" href="#parameters_184" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_192">Returns<a class="headerlink" href="#returns_192" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_139">See Also<a class="headerlink" href="#see-also_139" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_156">Examples<a class="headerlink" href="#examples_156" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters_185">Parameters<a class="headerlink" href="#parameters_185" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns_193">Returns<a class="headerlink" href="#returns_193" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also_140">See Also<a class="headerlink" href="#see-also_140" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples_157">Examples<a class="headerlink" href="#examples_157" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h2 id="parameters_186">Parameters<a class="headerlink" href="#parameters_186" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
<h2 id="returns_194">Returns<a class="headerlink" href="#returns_194" title="Permanent link">&para;</a></h2>
<p>res, res2, ... : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
<h2 id="see-also_141">See Also<a class="headerlink" href="#see-also_141" title="Permanent link">&para;</a></h2>
<p>atleast_1d, atleast_3d</p>
<h2 id="examples_158">Examples<a class="headerlink" href="#examples_158" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_2d(3.0)
array([[3.]])</p>
<p>x = np.arange(3.0)
np.atleast_2d(x)
array([[0., 1., 2.]])
np.atleast_2d(x).base is x
True</p>
<p>np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<h2 id="parameters_187">Parameters<a class="headerlink" href="#parameters_187" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in rad/s). Magnitude and phase data is calculated
for every value in this array. If not given a reasonable set will be
calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_195">Returns<a class="headerlink" href="#returns_195" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/s]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]</p>
<h2 id="notes_120">Notes<a class="headerlink" href="#notes_120" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_159">Examples<a class="headerlink" href="#examples_159" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = signal.bode(sys)</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cont2discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform a continuous to a discrete state-space system.</p>
<h2 id="parameters_188">Parameters<a class="headerlink" href="#parameters_188" title="Permanent link">&para;</a></h2>
<p>system : a tuple describing the system or an instance of <code>lti</code>
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>dt : float
The discretization time step.
method : str, optional
Which method to use:</p>
<ul>
<li>gbt: generalized bilinear transformation</li>
<li>bilinear: Tustin's approximation ('gbt' with alpha=0.5)</li>
<li>euler: Euler (or forward differencing) method ('gbt' with alpha=0)</li>
<li>backward_diff: Backwards differencing ('gbt' with alpha=1.0)</li>
<li>zoh: zero-order hold (default)</li>
<li>foh: first-order hold ( <em>versionadded: 1.3.0</em> )</li>
<li>impulse: equivalent impulse response ( <em>versionadded: 1.3.0</em> )</li>
</ul>
<p>alpha : float within [0, 1], optional
The generalized bilinear transformation weighting parameter, which
should only be specified with method='gbt', and is ignored otherwise</p>
<h2 id="returns_196">Returns<a class="headerlink" href="#returns_196" title="Permanent link">&para;</a></h2>
<p>sysd : tuple containing the discrete system
Based on the input type, the output will be of the form</p>
<ul>
<li>(num, den, dt)   for transfer function input</li>
<li>(zeros, poles, gain, dt)   for zeros-poles-gain input</li>
<li>(A, B, C, D, dt) for state-space system input</li>
</ul>
<h2 id="notes_121">Notes<a class="headerlink" href="#notes_121" title="Permanent link">&para;</a></h2>
<p>By default, the routine uses a Zero-Order Hold (zoh) method to perform
the transformation.  Alternatively, a generalized bilinear transformation
may be used, which includes the common Tustin's bilinear approximation,
an Euler's method technique, or a backwards differencing technique.</p>
<p>The Zero-Order Hold (zoh) method is based on [1]<em>, the generalized bilinear
approximation is based on [2]</em> and [3]<em>, the First-Order Hold (foh) method
is based on [4]</em>.</p>
<h2 id="references_36">References<a class="headerlink" href="#references_36" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Discretization#Discretization_of_linear_state_space_models</p>
<p>.. [2] http://techteach.no/publications/discretetime_signals_systems/discrete.pdf</p>
<p>.. [3] G. Zhang, X. Chen, and T. Chen, Digital redesign via the generalized
bilinear transformation, Int. J. Control, vol. 82, no. 4, pp. 741-754,
2009.
(https://www.mypolyuweb.hk/~magzhang/Research/ZCC09_IJC.pdf)</p>
<p>.. [4] G. F. Franklin, J. D. Powell, and M. L. Workman, Digital control
of dynamic systems, 3rd ed. Menlo Park, Calif: Addison-Wesley,
pp. 204-206, 1998.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dbode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<h2 id="parameters_189">Parameters<a class="headerlink" href="#parameters_189" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>dlti</code>)</li>
<li>2 (num, den, dt)</li>
<li>3 (zeros, poles, gain, dt)</li>
<li>4 (A, B, C, D, dt)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_197">Returns<a class="headerlink" href="#returns_197" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/time_unit]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]</p>
<h2 id="notes_122">Notes<a class="headerlink" href="#notes_122" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>z^2 + 3z + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_160">Examples<a class="headerlink" href="#examples_160" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3)</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: sys.bode()</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = signal.dbode(sys)</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dfreqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<h2 id="parameters_190">Parameters<a class="headerlink" href="#parameters_190" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>dlti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>dlti</code>)</li>
<li>2 (numerator, denominator, dt)</li>
<li>3 (zeros, poles, gain, dt)</li>
<li>4 (A, B, C, D, dt)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.
whole : bool, optional
Normally, if 'w' is not given, frequencies are computed from 0 to the
Nyquist frequency, pi radians/sample (upper-half of unit-circle). If
<code>whole</code> is True, compute frequencies from 0 to 2*pi radians/sample.</p>
<h2 id="returns_198">Returns<a class="headerlink" href="#returns_198" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [radians/sample]
H : 1D ndarray
Array of complex magnitude values</p>
<h2 id="notes_123">Notes<a class="headerlink" href="#notes_123" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>z^2 + 3z + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_161">Examples<a class="headerlink" href="#examples_161" title="Permanent link">&para;</a></h2>
<p>Generating the Nyquist plot of a transfer function</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3)</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</p>
<p>w, H = signal.dfreqresp(sys)</p>
<p>plt.figure()
plt.plot(H.real, H.imag, 'b')
plt.plot(H.real, -H.imag, 'r')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dimpulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of discrete-time system.</p>
<h2 id="parameters_191">Parameters<a class="headerlink" href="#parameters_191" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like or instance of <code>dlti</code>
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>x0 : array_like, optional
Initial state-vector.  Defaults to zero.
t : array_like, optional
Time points.  Computed if not given.
n : int, optional
The number of time points to compute (if <code>t</code> is not given).</p>
<h2 id="returns_199">Returns<a class="headerlink" href="#returns_199" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Time values for the output, as a 1-D array.
yout : tuple of ndarray
Impulse response of system.  Each element of the tuple represents
the output of the system based on an impulse in each input.</p>
<h2 id="see-also_142">See Also<a class="headerlink" href="#see-also_142" title="Permanent link">&para;</a></h2>
<p>impulse, dstep, dlsim, cont2discrete</p>
<h2 id="examples_162">Examples<a class="headerlink" href="#examples_162" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>butter = signal.dlti( *signal.butter(3, 0.5))
t, y = signal.dimpulse(butter, n=25)
plt.step(t, np.squeeze(y))
plt.grid()
plt.xlabel('n [samples]')
plt.ylabel('Amplitude')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dlsim</span> <span class="o">:</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a discrete-time linear system.</p>
<h2 id="parameters_192">Parameters<a class="headerlink" href="#parameters_192" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like or instance of <code>dlti</code>
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>u : array_like
An input array describing the input at each time <code>t</code> (interpolation is
assumed between given times).  If there are multiple inputs, then each
column of the rank-2 array represents an input.
t : array_like, optional
The time steps at which the input is defined.  If <code>t</code> is given, it
must be the same length as <code>u</code>, and the final value in <code>t</code> determines
the number of steps returned in the output.
x0 : array_like, optional
The initial conditions on the state vector (zero by default).</p>
<h2 id="returns_200">Returns<a class="headerlink" href="#returns_200" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Time values for the output, as a 1-D array.
yout : ndarray
System response, as a 1-D array.
xout : ndarray, optional
Time-evolution of the state-vector.  Only generated if the input is a
<code>StateSpace</code> system.</p>
<h2 id="see-also_143">See Also<a class="headerlink" href="#see-also_143" title="Permanent link">&para;</a></h2>
<p>lsim, dstep, dimpulse, cont2discrete</p>
<h2 id="examples_163">Examples<a class="headerlink" href="#examples_163" title="Permanent link">&para;</a></h2>
<p>A simple integrator transfer function with a discrete time step of 1.0
could be implemented as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
tf = ([1.0,], [1.0, -1.0], 1.0)
t_in = [0.0, 1.0, 2.0, 3.0]
u = np.asarray([0.0, 0.0, 1.0, 1.0])
t_out, y = signal.dlsim(tf, u, t=t_in)
y.T
array([[ 0.,  0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_193">Parameters<a class="headerlink" href="#parameters_193" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_201">Returns<a class="headerlink" href="#returns_201" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_27">Raises<a class="headerlink" href="#raises_27" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_144">See Also<a class="headerlink" href="#see-also_144" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_164">Examples<a class="headerlink" href="#examples_164" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstep</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of discrete-time system.</p>
<h2 id="parameters_194">Parameters<a class="headerlink" href="#parameters_194" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>x0 : array_like, optional
Initial state-vector.  Defaults to zero.
t : array_like, optional
Time points.  Computed if not given.
n : int, optional
The number of time points to compute (if <code>t</code> is not given).</p>
<h2 id="returns_202">Returns<a class="headerlink" href="#returns_202" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Output time points, as a 1-D array.
yout : tuple of ndarray
Step response of system.  Each element of the tuple represents
the output of the system based on a step response to each input.</p>
<h2 id="see-also_145">See Also<a class="headerlink" href="#see-also_145" title="Permanent link">&para;</a></h2>
<p>step, dimpulse, dlsim, cont2discrete</p>
<h2 id="examples_165">Examples<a class="headerlink" href="#examples_165" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>butter = signal.dlti( *signal.butter(3, 0.5))
t, y = signal.dstep(butter, n=25)
plt.step(t, np.squeeze(y))
plt.grid()
plt.xlabel('n [samples]')
plt.ylabel('Amplitude')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<h2 id="parameters_195">Parameters<a class="headerlink" href="#parameters_195" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>lti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in rad/s). Magnitude and phase data is
calculated for every value in this array. If not given, a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_203">Returns<a class="headerlink" href="#returns_203" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/s]
H : 1D ndarray
Array of complex magnitude values</p>
<h2 id="notes_124">Notes<a class="headerlink" href="#notes_124" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_166">Examples<a class="headerlink" href="#examples_166" title="Permanent link">&para;</a></h2>
<p>Generating the Nyquist plot of a transfer function</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(s) = 5 / (s-1)^3</p>
<blockquote>
<blockquote>
<blockquote>
<p>s1 = signal.ZerosPolesGain([], [1, 1, 1], [5])</p>
<p>w, H = signal.freqresp(s1)</p>
<p>plt.figure()
plt.plot(H.real, H.imag, 'b')
plt.plot(H.real, -H.imag, 'r')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of an analog
filter, compute its frequency response::</p>
<p>b[0]<em>(jw)</em><em>M + b[1]</em>(jw)<strong>(M-1) + ... + b[M]
H(w) = ----------------------------------------------
a[0]*(jw)</strong>N + a[1]<em>(jw)</em>*(N-1) + ... + a[N]</p>
<h2 id="parameters_196">Parameters<a class="headerlink" href="#parameters_196" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.
a : array_like
Denominator of a linear filter.
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.
plot : callable, optional
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqs</code>.</p>
<h2 id="returns_204">Returns<a class="headerlink" href="#returns_204" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_146">See Also<a class="headerlink" href="#see-also_146" title="Permanent link">&para;</a></h2>
<p>freqz : Compute the frequency response of a digital filter.</p>
<h2 id="notes_125">Notes<a class="headerlink" href="#notes_125" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's 'plot' function as the callable for <code>plot</code> produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try <code>lambda w, h: plot(w, abs(h))</code>.</p>
<h2 id="examples_167">Examples<a class="headerlink" href="#examples_167" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs, iirfilter</p>
<p>b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')</p>
<p>w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code> of a filter, compute its
frequency response::</p>
<p>(jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1])
H(w) = k * ----------------------------------------
(jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1])</p>
<h2 id="parameters_197">Parameters<a class="headerlink" href="#parameters_197" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.</p>
<h2 id="returns_205">Returns<a class="headerlink" href="#returns_205" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_147">See Also<a class="headerlink" href="#see-also_147" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqz : Compute the frequency response of a digital filter in TF form
freqz_zpk : Compute the frequency response of a digital filter in ZPK form</p>
<h2 id="notes_126">Notes<a class="headerlink" href="#notes_126" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_168">Examples<a class="headerlink" href="#examples_168" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs_zpk, iirfilter</p>
<p>z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1',
...                     output='zpk')</p>
<p>w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of a digital
filter, compute its frequency response::</p>
<p>jw                 -jw              -jwM
jw    B(e  )    b[0] + b[1]e    + ... + b[M]e
H(e  ) = ------ = -----------------------------------
jw                 -jw              -jwN
A(e  )    a[0] + a[1]e    + ... + a[N]e</p>
<h2 id="parameters_198">Parameters<a class="headerlink" href="#parameters_198" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
a : array_like
Denominator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).  This is a convenient alternative to::</p>
<p>np.linspace(0, fs if whole else fs/2, N, endpoint=False)</p>
<p>Using a number that is fast for FFT computations can result in
faster computations (see Notes).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
plot : callable
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqz</code>.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_206">Returns<a class="headerlink" href="#returns_206" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_148">See Also<a class="headerlink" href="#see-also_148" title="Permanent link">&para;</a></h2>
<p>freqz_zpk
sosfreqz</p>
<h2 id="notes_127">Notes<a class="headerlink" href="#notes_127" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's :func:<code>matplotlib.pyplot.plot</code> function as the callable
for <code>plot</code> produces unexpected results, as this plots the real part of the
complex transfer function, not the magnitude.
Try <code>lambda w, h: plot(w, np.abs(h))</code>.</p>
<p>A direct computation via (R)FFT is used to compute the frequency response
when the following conditions are met:</p>
<ol>
<li>An integer value is given for <code>worN</code>.</li>
<li><code>worN</code> is fast to compute via FFT (i.e.,
<code>next_fast_len(worN) &lt;scipy.fft.next_fast_len&gt;</code> equals <code>worN</code>).</li>
<li>The denominator coefficients are a single value (<code>a.shape[0] == 1</code>).</li>
<li><code>worN</code> is at least as long as the numerator coefficients
(<code>worN &gt;= b.shape[0]</code>).</li>
<li>If <code>b.ndim &gt; 1</code>, then <code>b.shape[-1] == 1</code>.</li>
</ol>
<p>For long FIR filters, the FFT approach can have lower error and be much
faster than the equivalent direct polynomial calculation.</p>
<h2 id="examples_169">Examples<a class="headerlink" href="#examples_169" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
b = signal.firwin(80, 0.5, window=('kaiser', 8))
w, h = signal.freqz(b)</p>
<p>import matplotlib.pyplot as plt
fig, ax1 = plt.subplots()
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [rad/sample]')</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle (radians)', color='g')
ax2.grid()
ax2.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting Examples</p>
<p>Suppose we have two FIR filters whose coefficients are stored in the
rows of an array with shape (2, 25).  For this demonstration we'll
use random data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(42)
b = np.random.rand(2, 25)</p>
</blockquote>
</blockquote>
</blockquote>
<p>To compute the frequency response for these two filters with one call
to <code>freqz</code>, we must pass in <code>b.T</code>, because <code>freqz</code> expects the first
axis to hold the coefficients. We must then extend the shape with a
trivial dimension of length 1 to allow broadcasting with the array
of frequencies.  That is, we pass in <code>b.T[..., np.newaxis]</code>, which has
shape (25, 2, 1):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b.T[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now suppose we have two transfer functions, with the same numerator
coefficients <code>b = [0.5, 0.5]</code>. The coefficients for the two denominators
are stored in the first dimension of the two-dimensional array  <code>a</code>::</p>
<p>a = [   1      1  ]
[ -0.25, -0.5 ]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0.5, 0.5])
a = np.array([[1, 1], [-0.25, -0.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Only <code>a</code> is more than one-dimensional.  To make it compatible for
broadcasting with the frequencies, we extend it with a trivial dimension
in the call to <code>freqz</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b, a[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter in ZPK form.</p>
<p>Given the Zeros, Poles and Gain of a digital filter, compute its frequency
response:</p>
<p>:math:<code>H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])</code></p>
<p>where :math:<code>k</code> is the <code>gain</code>, :math:<code>Z</code> are the <code>zeros</code> and :math:<code>P</code> are
the <code>poles</code>.</p>
<h2 id="parameters_199">Parameters<a class="headerlink" href="#parameters_199" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_207">Returns<a class="headerlink" href="#returns_207" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_149">See Also<a class="headerlink" href="#see-also_149" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqs_zpk : Compute the frequency response of an analog filter in ZPK form
freqz : Compute the frequency response of a digital filter in TF form</p>
<h2 id="notes_128">Notes<a class="headerlink" href="#notes_128" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_170">Examples<a class="headerlink" href="#examples_170" title="Permanent link">&para;</a></h2>
<p>Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a
system with sample rate of 1000 Hz, and plot the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
z, p, k = signal.butter(4, 100, output='zpk', fs=1000)
w, h = signal.freqz_zpk(z, p, k, fs=1000)</p>
<p>import matplotlib.pyplot as plt
fig = plt.figure()
ax1 = fig.add_subplot(1, 1, 1)
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [Hz]')
ax1.grid()</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle [radians]', color='g')</p>
<p>plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of continuous-time system.</p>
<h2 id="parameters_200">Parameters<a class="headerlink" href="#parameters_200" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector.  Defaults to zero.
T : array_like, optional
Time points.  Computed if not given.
N : int, optional
The number of time points to compute (if <code>T</code> is not given).</p>
<h2 id="returns_208">Returns<a class="headerlink" href="#returns_208" title="Permanent link">&para;</a></h2>
<p>T : ndarray
A 1-D array of time points.
yout : ndarray
A 1-D array containing the impulse response of the system (except for
singularities at zero).</p>
<h2 id="notes_129">Notes<a class="headerlink" href="#notes_129" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_171">Examples<a class="headerlink" href="#examples_171" title="Permanent link">&para;</a></h2>
<p>Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = u(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = ([1.0], [1.0, 2.0, 1.0])
t, y = signal.impulse2(system)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse2</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of a single-input, continuous-time linear system.</p>
<h2 id="parameters_201">Parameters<a class="headerlink" href="#parameters_201" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : 1-D array_like, optional
The initial condition of the state vector.  Default: 0 (the
zero vector).
T : 1-D array_like, optional
The time steps at which the input is defined and at which the
output is desired.  If <code>T</code> is not given, the function will
generate a set of time samples automatically.
N : int, optional
Number of time points to compute.  Default: 100.
kwargs : various types
Additional keyword arguments are passed on to the function
<code>scipy.signal.lsim2</code>, which in turn passes them on to
<code>scipy.integrate.odeint</code>; see the latter's documentation for
information about these arguments.</p>
<h2 id="returns_209">Returns<a class="headerlink" href="#returns_209" title="Permanent link">&para;</a></h2>
<p>T : ndarray
The time values for the output.
yout : ndarray
The output response of the system.</p>
<h2 id="see-also_150">See Also<a class="headerlink" href="#see-also_150" title="Permanent link">&para;</a></h2>
<p>impulse, lsim2, scipy.integrate.odeint</p>
<h2 id="notes_130">Notes<a class="headerlink" href="#notes_130" title="Permanent link">&para;</a></h2>
<p>The solution is generated by calling <code>scipy.signal.lsim2</code>, which uses
the differential equation solver <code>scipy.integrate.odeint</code>.</p>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_172">Examples<a class="headerlink" href="#examples_172" title="Permanent link">&para;</a></h2>
<p>Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = u(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = ([1.0], [1.0, 2.0, 1.0])
t, y = signal.impulse2(system)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linspace</span> <span class="o">:</span> <span class="o">?</span><span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">endpoint</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retstep</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">start</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stop</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <code>num</code> evenly spaced samples, calculated over the
interval [<code>start</code>, <code>stop</code>].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<p>.. versionchanged:: 1.16.0
Non-scalar <code>start</code> and <code>stop</code> are now supported.</p>
<h2 id="parameters_202">Parameters<a class="headerlink" href="#parameters_202" title="Permanent link">&para;</a></h2>
<p>start : array_like
The starting value of the sequence.
stop : array_like
The end value of the sequence, unless <code>endpoint</code> is set to False.
In that case, the sequence consists of all but the last of <code>num + 1</code>
evenly spaced samples, so that <code>stop</code> is excluded.  Note that the step
size changes when <code>endpoint</code> is False.
num : int, optional
Number of samples to generate. Default is 50. Must be non-negative.
endpoint : bool, optional
If True, <code>stop</code> is the last sample. Otherwise, it is not included.
Default is True.
retstep : bool, optional
If True, return (<code>samples</code>, <code>step</code>), where <code>step</code> is the spacing
between samples.
dtype : dtype, optional
The type of the output array.  If <code>dtype</code> is not given, infer the data
type from the other input arguments.</p>
<p>.. versionadded:: 1.9.0</p>
<p>axis : int, optional
The axis in the result to store the samples.  Relevant only if start
or stop are array-like.  By default (0), the samples will be along a
new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<p>.. versionadded:: 1.16.0</p>
<h2 id="returns_210">Returns<a class="headerlink" href="#returns_210" title="Permanent link">&para;</a></h2>
<p>samples : ndarray
There are <code>num</code> equally spaced samples in the closed interval
<code>[start, stop]</code> or the half-open interval <code>[start, stop)</code>
(depending on whether <code>endpoint</code> is True or False).
step : float, optional
Only returned if <code>retstep</code> is True</p>
<p>Size of spacing between samples.</p>
<h2 id="see-also_151">See Also<a class="headerlink" href="#see-also_151" title="Permanent link">&para;</a></h2>
<p>arange : Similar to <code>linspace</code>, but uses a step size (instead of the
number of samples).
geomspace : Similar to <code>linspace</code>, but with numbers spaced evenly on a log
scale (a geometric progression).
logspace : Similar to <code>geomspace</code>, but with the end points specified as
logarithms.</p>
<h2 id="examples_173">Examples<a class="headerlink" href="#examples_173" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.linspace(2.0, 3.0, num=5)
array([2.  , 2.25, 2.5 , 2.75, 3.  ])
np.linspace(2.0, 3.0, num=5, endpoint=False)
array([2. ,  2.2,  2.4,  2.6,  2.8])
np.linspace(2.0, 3.0, num=5, retstep=True)
(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Graphical illustration:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
N = 8
y = np.zeros(N)
x1 = np.linspace(0, 10, N, endpoint=True)
x2 = np.linspace(0, 10, N, endpoint=False)
plt.plot(x1, y, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
plt.plot(x2, y + 0.5, 'o')
[<matplotlib.lines.Line2D object at 0x...>]
plt.ylim([-0.5, 1])
(-0.5, 1)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsim</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">interp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a continuous-time linear system.</p>
<h2 id="parameters_203">Parameters<a class="headerlink" href="#parameters_203" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>U : array_like
An input array describing the input at each time <code>T</code>
(interpolation is assumed between given times).  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U = 0 or None, a zero input is used.
T : array_like
The time steps at which the input is defined and at which the
output is desired.  Must be nonnegative, increasing, and equally spaced.
X0 : array_like, optional
The initial conditions on the state vector (zero by default).
interp : bool, optional
Whether to use linear (True, the default) or zero-order-hold (False)
interpolation for the input array.</p>
<h2 id="returns_211">Returns<a class="headerlink" href="#returns_211" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Time values for the output.
yout : 1D ndarray
System response.
xout : ndarray
Time evolution of the state vector.</p>
<h2 id="notes_131">Notes<a class="headerlink" href="#notes_131" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_174">Examples<a class="headerlink" href="#examples_174" title="Permanent link">&para;</a></h2>
<p>Simulate a double integrator y'' = u, with a constant input u = 1</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = signal.lti([[0., 1.], [0., 0.]], [[0.], [1.]], [[1., 0.]], 0.)
t = np.linspace(0, 5)
u = np.ones_like(t)
tout, y, x = signal.lsim(system, u, t)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsim2</span> <span class="o">:</span> <span class="o">?</span><span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a continuous-time linear system, by using
the ODE solver <code>scipy.integrate.odeint</code>.</p>
<h2 id="parameters_204">Parameters<a class="headerlink" href="#parameters_204" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>lti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>U : array_like (1D or 2D), optional
An input array describing the input at each time T.  Linear
interpolation is used between given times.  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U is not given, the input is assumed
to be zero.
T : array_like (1D or 2D), optional
The time steps at which the input is defined and at which the
output is desired.  The default is 101 evenly spaced points on
the interval [0,10.0].
X0 : array_like (1D), optional
The initial condition of the state vector.  If <code>X0</code> is not
given, the initial conditions are assumed to be 0.
kwargs : dict
Additional keyword arguments are passed on to the function
<code>odeint</code>.  See the notes below for more details.</p>
<h2 id="returns_212">Returns<a class="headerlink" href="#returns_212" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
The time values for the output.
yout : ndarray
The response of the system.
xout : ndarray
The time-evolution of the state-vector.</p>
<h2 id="notes_132">Notes<a class="headerlink" href="#notes_132" title="Permanent link">&para;</a></h2>
<p>This function uses <code>scipy.integrate.odeint</code> to solve the
system's differential equations.  Additional keyword arguments
given to <code>lsim2</code> are passed on to <code>odeint</code>.  See the documentation
for <code>scipy.integrate.odeint</code> for the full list of arguments.</p>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nan_to_num</span> <span class="o">:</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nan</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">posinf</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">neginf</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Replace NaN with zero and infinity with large finite numbers (default
behaviour) or with the numbers defined by the user using the <code>nan</code>,
<code>posinf</code> and/or <code>neginf</code> keywords.</p>
<p>If <code>x</code> is inexact, NaN is replaced by zero or by the user defined value in
<code>nan</code> keyword, infinity is replaced by the largest finite floating point
values representable by <code>x.dtype</code> or by the user defined value in
<code>posinf</code> keyword and -infinity is replaced by the most negative finite
floating point values representable by <code>x.dtype</code> or by the user defined
value in <code>neginf</code> keyword.</p>
<p>For complex dtypes, the above is applied to each of the real and
imaginary components of <code>x</code> separately.</p>
<p>If <code>x</code> is not inexact, then no replacements are made.</p>
<h2 id="parameters_205">Parameters<a class="headerlink" href="#parameters_205" title="Permanent link">&para;</a></h2>
<p>x : scalar or array_like
Input data.
copy : bool, optional
Whether to create a copy of <code>x</code> (True) or to replace values
in-place (False). The in-place operation only occurs if
casting to an array does not require a copy.
Default is True.</p>
<p>.. versionadded:: 1.13
nan : int, float, optional
Value to be used to fill NaN values. If no value is passed
then NaN values will be replaced with 0.0.</p>
<p>.. versionadded:: 1.17
posinf : int, float, optional
Value to be used to fill positive infinity values. If no value is
passed then positive infinity values will be replaced with a very
large number.</p>
<p>.. versionadded:: 1.17
neginf : int, float, optional
Value to be used to fill negative infinity values. If no value is
passed then negative infinity values will be replaced with a very
small (or negative) number.</p>
<p>.. versionadded:: 1.17</p>
<h2 id="returns_213">Returns<a class="headerlink" href="#returns_213" title="Permanent link">&para;</a></h2>
<p>out : ndarray
<code>x</code>, with the non-finite values replaced. If <code>copy</code> is False, this may
be <code>x</code> itself.</p>
<h2 id="see-also_152">See Also<a class="headerlink" href="#see-also_152" title="Permanent link">&para;</a></h2>
<p>isinf : Shows which elements are positive or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)</p>
<h2 id="notes_133">Notes<a class="headerlink" href="#notes_133" title="Permanent link">&para;</a></h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<h2 id="examples_175">Examples<a class="headerlink" href="#examples_175" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.nan_to_num(np.inf)
1.7976931348623157e+308
np.nan_to_num(-np.inf)
-1.7976931348623157e+308
np.nan_to_num(np.nan)
0.0
x = np.array([np.inf, -np.inf, np.nan, -128, 128])
np.nan_to_num(x)
array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
-1.28000000e+002,  1.28000000e+002])
np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,
-1.2800000e+02,  1.2800000e+02])
y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
-1.28000000e+002,   1.28000000e+002])
np.nan_to_num(y)
array([  1.79769313e+308 +0.00000000e+000j, # may vary
0.00000000e+000 +0.00000000e+000j,
0.00000000e+000 +1.79769313e+308j])
np.nan_to_num(y, nan=111111, posinf=222222)
array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">normalize</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Normalize numerator/denominator of a continuous-time transfer function.</p>
<p>If values of <code>b</code> are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.</p>
<h2 id="parameters_206">Parameters<a class="headerlink" href="#parameters_206" title="Permanent link">&para;</a></h2>
<p>b: array_like
Numerator of the transfer function. Can be a 2d array to normalize
multiple transfer functions.
a: array_like
Denominator of the transfer function. At most 1d.</p>
<h2 id="returns_214">Returns<a class="headerlink" href="#returns_214" title="Permanent link">&para;</a></h2>
<p>num: array
The numerator of the normalized transfer function. At least a 1d
array. A 2d-array if the input <code>num</code> is a 2d array.
den: 1d-array
The denominator of the normalized transfer function.</p>
<h2 id="notes_134">Notes<a class="headerlink" href="#notes_134" title="Permanent link">&para;</a></h2>
<p>Coefficients for both the numerator and denominator should be specified in
descending exponent order (e.g., <code>s^2 + 3s + 5</code> would be represented as
<code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ones</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a new array of given shape and type, filled with ones.</p>
<h2 id="parameters_207">Parameters<a class="headerlink" href="#parameters_207" title="Permanent link">&para;</a></h2>
<p>shape : int or sequence of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: C
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_215">Returns<a class="headerlink" href="#returns_215" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of ones with the given shape, dtype, and order.</p>
<h2 id="see-also_153">See Also<a class="headerlink" href="#see-also_153" title="Permanent link">&para;</a></h2>
<p>ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_176">Examples<a class="headerlink" href="#examples_176" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.ones(5)
array([1., 1., 1., 1., 1.])</p>
<p>np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])</p>
<p>np.ones((2, 1))
array([[1.],
[1.]])</p>
<p>s = (2,2)
np.ones(s)
array([[1.,  1.],
[1.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">place_poles</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">YT</span> <span class="o">|</span> <span class="o">`</span><span class="nc">KNV0</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">poles</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute K such that eigenvalues (A - dot(B, K))=poles.</p>
<p>K is the gain matrix such as the plant described by the linear system
<code>AX+BU</code> will have its closed-loop poles, i.e the eigenvalues <code>A - B*K</code>,
as close as possible to those asked for in poles.</p>
<p>SISO, MISO and MIMO systems are supported.</p>
<h2 id="parameters_208">Parameters<a class="headerlink" href="#parameters_208" title="Permanent link">&para;</a></h2>
<p>A, B : ndarray
State-space representation of linear system <code>AX + BU</code>.
poles : array_like
Desired real poles and/or complex conjugates poles.
Complex poles are only supported with <code>method='YT'</code> (default).
method: {'YT', 'KNV0'}, optional
Which method to choose to find the gain matrix K. One of:</p>
<ul>
<li>'YT': Yang Tits</li>
<li>'KNV0': Kautsky, Nichols, Van Dooren update method 0</li>
</ul>
<p>See References and Notes for details on the algorithms.
rtol: float, optional
After each iteration the determinant of the eigenvectors of
<code>A - B*K</code> is compared to its previous value, when the relative
error between these two values becomes lower than <code>rtol</code> the algorithm
stops.  Default is 1e-3.
maxiter: int, optional
Maximum number of iterations to compute the gain matrix.
Default is 30.</p>
<h2 id="returns_216">Returns<a class="headerlink" href="#returns_216" title="Permanent link">&para;</a></h2>
<p>full_state_feedback : Bunch object
full_state_feedback is composed of:
gain_matrix : 1-D ndarray
The closed loop matrix K such as the eigenvalues of <code>A-BK</code>
are as close as possible to the requested poles.
computed_poles : 1-D ndarray
The poles corresponding to <code>A-BK</code> sorted as first the real
poles in increasing order, then the complex congugates in
lexicographic order.
requested_poles : 1-D ndarray
The poles the algorithm was asked to place sorted as above,
they may differ from what was achieved.
X : 2-D ndarray
The transfer matrix such as <code>X * diag(poles) = (A - B*K)*X</code>
(see Notes)
rtol : float
The relative tolerance achieved on <code>det(X)</code> (see Notes).
<code>rtol</code> will be NaN if it is possible to solve the system
<code>diag(poles) = (A - B*K)</code>, or 0 when the optimization
algorithms can't do anything i.e when <code>B.shape[1] == 1</code>.
nb_iter : int
The number of iterations performed before converging.
<code>nb_iter</code> will be NaN if it is possible to solve the system
<code>diag(poles) = (A - B*K)</code>, or 0 when the optimization
algorithms can't do anything i.e when <code>B.shape[1] == 1</code>.</p>
<h2 id="notes_135">Notes<a class="headerlink" href="#notes_135" title="Permanent link">&para;</a></h2>
<p>The Tits and Yang (YT), [2]<em> paper is an update of the original Kautsky et
al. (KNV) paper [1]</em>.  KNV relies on rank-1 updates to find the transfer
matrix X such that <code>X * diag(poles) = (A - B*K)*X</code>, whereas YT uses
rank-2 updates. This yields on average more robust solutions (see [2]_
pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV
does not in its original version.  Only update method 0 proposed by KNV has
been implemented here, hence the name <code>'KNV0'</code>.</p>
<p>KNV extended to complex poles is used in Matlab's <code>place</code> function, YT is
distributed under a non-free licence by Slicot under the name <code>robpole</code>.
It is unclear and undocumented how KNV0 has been extended to complex poles
(Tits and Yang claim on page 14 of their paper that their method can not be
used to extend KNV to complex poles), therefore only YT supports them in
this implementation.</p>
<p>As the solution to the problem of pole placement is not unique for MIMO
systems, both methods start with a tentative transfer matrix which is
altered in various way to increase its determinant.  Both methods have been
proven to converge to a stable solution, however depending on the way the
initial transfer matrix is chosen they will converge to different
solutions and therefore there is absolutely no guarantee that using
<code>'KNV0'</code> will yield results similar to Matlab's or any other
implementation of these algorithms.</p>
<p>Using the default method <code>'YT'</code> should be fine in most cases; <code>'KNV0'</code>
is only provided because it is needed by <code>'YT'</code> in some specific cases.
Furthermore <code>'YT'</code> gives on average more robust results than <code>'KNV0'</code>
when <code>abs(det(X))</code> is used as a robustness indicator.</p>
<p>[2]_ is available as a technical report on the following URL:
https://hdl.handle.net/1903/5598</p>
<h2 id="references_37">References<a class="headerlink" href="#references_37" title="Permanent link">&para;</a></h2>
<p>.. [1] J. Kautsky, N.K. Nichols and P. van Dooren, 'Robust pole assignment
in linear state feedback', International Journal of Control, Vol. 41
pp. 1129-1155, 1985.
.. [2] A.L. Tits and Y. Yang, 'Globally convergent algorithms for robust
pole assignment by state feedback', IEEE Transactions on Automatic
Control, Vol. 41, pp. 1432-1452, 1996.</p>
<h2 id="examples_177">Examples<a class="headerlink" href="#examples_177" title="Permanent link">&para;</a></h2>
<p>A simple example demonstrating real pole placement using both KNV and YT
algorithms.  This is example number 1 from section 4 of the reference KNV
publication ([1]_):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],
...               [-0.5814, -4.290,   0,      0.6750 ],
...               [ 1.067,   4.273,  -6.654,  5.893  ],
...               [ 0.0480,  4.273,   1.343, -2.104  ]])
B = np.array([[ 0,      5.679 ],
...               [ 1.136,  1.136 ],
...               [ 0,      0,    ],
...               [-3.146,  0     ]])
P = np.array([-0.2, -0.5, -5.0566, -8.6659])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute K with KNV method 0, with the default YT method and with the YT
method while forcing 100 iterations of the algorithm and print some results
after each call.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fsf1 = signal.place_poles(A, B, P, method='KNV0')
fsf1.gain_matrix
array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],
[ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])</p>
<p>fsf2 = signal.place_poles(A, B, P)  # uses YT method
fsf2.computed_poles
array([-8.6659, -5.0566, -0.5   , -0.2   ])</p>
<p>fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)
fsf3.X
array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],
[-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],
[-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],
[ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The absolute value of the determinant of X is a good indicator to check the
robustness of the results, both <code>'KNV0'</code> and <code>'YT'</code> aim at maximizing
it.  Below a comparison of the robustness of the results above:</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))
True
abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now a simple example for complex poles:</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([[ 0,  7/3.,  0,   0   ],
...               [ 0,   0,    0,  7/9. ],
...               [ 0,   0,    0,   0   ],
...               [ 0,   0,    0,   0   ]])
B = np.array([[ 0,  0 ],
...               [ 0,  0 ],
...               [ 1,  0 ],
...               [ 0,  1 ]])
P = np.array([-3, -1, -2-1j, -2+1j]) / 3.
fsf = signal.place_poles(A, B, P, method='YT')</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can plot the desired and computed poles in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 2*np.pi, 401)
plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle
plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,
...          'wo', label='Desired')
plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx',
...          label='Placed')
plt.grid()
plt.axis('image')
plt.axis([-1.1, 1.1, -1.1, 1.1])
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">real</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the real part of the complex argument.</p>
<h2 id="parameters_209">Parameters<a class="headerlink" href="#parameters_209" title="Permanent link">&para;</a></h2>
<p>val : array_like
Input array.</p>
<h2 id="returns_217">Returns<a class="headerlink" href="#returns_217" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
The real component of the complex argument. If <code>val</code> is real, the type
of <code>val</code> is used for the output.  If <code>val</code> has complex elements, the
returned type is float.</p>
<h2 id="see-also_154">See Also<a class="headerlink" href="#see-also_154" title="Permanent link">&para;</a></h2>
<p>real_if_close, imag, angle</p>
<h2 id="examples_178">Examples<a class="headerlink" href="#examples_178" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1+2j, 3+4j, 5+6j])
a.real
array([1.,  3.,  5.])
a.real = 9
a
array([9.+2.j,  9.+4.j,  9.+6.j])
a.real = np.array([9, 8, 7])
a
array([9.+2.j,  8.+4.j,  7.+6.j])
np.real(1 + 1j)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">s_qr</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_210">Parameters<a class="headerlink" href="#parameters_210" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic', 'raw'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes). The final option 'raw'
(added in SciPy 0.11) makes the function return two matrices
(Q, TAU) in the internal format used by LAPACK.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition. If pivoting, compute the decomposition
<code>A P = Q R</code> as above, but where P is chosen such that the diagonal
of R is non-increasing.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_218">Returns<a class="headerlink" href="#returns_218" title="Permanent link">&para;</a></h2>
<p>Q : float or complex ndarray
Of shape (M, M), or (M, K) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.
R : float or complex ndarray
Of shape (M, N), or (K, N) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
P : int ndarray
Of shape (N,) for <code>pivoting=True</code>. Not returned if
<code>pivoting=False</code>.</p>
<h2 id="raises_28">Raises<a class="headerlink" href="#raises_28" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails</p>
<h2 id="notes_136">Notes<a class="headerlink" href="#notes_136" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_179">Examples<a class="headerlink" href="#examples_179" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)</p>
<p>q, r = linalg.qr(a)
np.allclose(a, np.dot(q, r))
True
q.shape, r.shape
((9, 9), (9, 6))</p>
<p>r2 = linalg.qr(a, mode='r')
np.allclose(r, r2)
True</p>
<p>q3, r3 = linalg.qr(a, mode='economic')
q3.shape, r3.shape
((9, 6), (6, 6))</p>
<p>q4, r4, p4 = linalg.qr(a, pivoting=True)
d = np.abs(np.diag(r4))
np.all(d[1:] &lt;= d[:-1])
True
np.allclose(a[:, p4], np.dot(q4, r4))
True
q4.shape, r4.shape, p4.shape
((9, 9), (9, 6), (6,))</p>
<p>q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)
q5.shape, r5.shape, p5.shape
((9, 6), (6, 6), (6,))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">squeeze</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove single-dimensional entries from the shape of an array.</p>
<h2 id="parameters_211">Parameters<a class="headerlink" href="#parameters_211" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
.. versionadded:: 1.7.0</p>
<p>Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
<h2 id="returns_219">Returns<a class="headerlink" href="#returns_219" title="Permanent link">&para;</a></h2>
<p>squeezed : ndarray
The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <code>a</code> itself
or a view into <code>a</code>.</p>
<h2 id="raises_29">Raises<a class="headerlink" href="#raises_29" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>axis</code> is not None, and an axis being squeezed is not of length 1</p>
<h2 id="see-also_155">See Also<a class="headerlink" href="#see-also_155" title="Permanent link">&para;</a></h2>
<p>expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<h2 id="examples_180">Examples<a class="headerlink" href="#examples_180" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[[0], [1], [2]]])
x.shape
(1, 3, 1)
np.squeeze(x).shape
(3,)
np.squeeze(x, axis=0).shape
(3, 1)
np.squeeze(x, axis=1).shape
Traceback (most recent call last):
...
ValueError: cannot select an axis to squeeze out which has size not equal to one
np.squeeze(x, axis=2).shape
(1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>State-space to transfer function.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_212">Parameters<a class="headerlink" href="#parameters_212" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_220">Returns<a class="headerlink" href="#returns_220" title="Permanent link">&para;</a></h2>
<p>num : 2-D ndarray
Numerator(s) of the resulting transfer function(s).  <code>num</code> has one row
for each of the system's outputs. Each row is a sequence representation
of the numerator polynomial.
den : 1-D ndarray
Denominator of the resulting transfer function(s).  <code>den</code> is a sequence
representation of the denominator polynomial.</p>
<h2 id="examples_181">Examples<a class="headerlink" href="#examples_181" title="Permanent link">&para;</a></h2>
<p>Convert the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = [[-2, -1], [1, 0]]
B = [[1], [0]]  # 2-dimensional column vector
C = [[1, 2]]    # 2-dimensional row vector
D = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import ss2tf
ss2tf(A, B, C, D)
(array([[1, 3, 3]]), array([ 1.,  2.,  1.]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>State-space representation to zero-pole-gain representation.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_213">Parameters<a class="headerlink" href="#parameters_213" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_221">Returns<a class="headerlink" href="#returns_221" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of continuous-time system.</p>
<h2 id="parameters_214">Parameters<a class="headerlink" href="#parameters_214" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector (default is zero).
T : array_like, optional
Time points (computed if not given).
N : int, optional
Number of time points to compute if <code>T</code> is not given.</p>
<h2 id="returns_222">Returns<a class="headerlink" href="#returns_222" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Output time points.
yout : 1D ndarray
Step response of system.</p>
<h2 id="see-also_156">See also<a class="headerlink" href="#see-also_156" title="Permanent link">&para;</a></h2>
<p>scipy.signal.step2</p>
<h2 id="notes_137">Notes<a class="headerlink" href="#notes_137" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_182">Examples<a class="headerlink" href="#examples_182" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
lti = signal.lti([1.0], [1.0, 1.0])
t, y = signal.step(lti)
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.title('Step response for 1. Order Lowpass')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step2</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of continuous-time system.</p>
<p>This function is functionally the same as <code>scipy.signal.step</code>, but
it uses the function <code>scipy.signal.lsim2</code> to compute the step
response.</p>
<h2 id="parameters_215">Parameters<a class="headerlink" href="#parameters_215" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector (default is zero).
T : array_like, optional
Time points (computed if not given).
N : int, optional
Number of time points to compute if <code>T</code> is not given.
kwargs : various types
Additional keyword arguments are passed on the function
<code>scipy.signal.lsim2</code>, which in turn passes them on to
<code>scipy.integrate.odeint</code>.  See the documentation for
<code>scipy.integrate.odeint</code> for information about these arguments.</p>
<h2 id="returns_223">Returns<a class="headerlink" href="#returns_223" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Output time points.
yout : 1D ndarray
Step response of system.</p>
<h2 id="see-also_157">See also<a class="headerlink" href="#see-also_157" title="Permanent link">&para;</a></h2>
<p>scipy.signal.step</p>
<h2 id="notes_138">Notes<a class="headerlink" href="#notes_138" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_183">Examples<a class="headerlink" href="#examples_183" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
lti = signal.lti([1.0], [1.0, 1.0])
t, y = signal.step2(lti)
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.title('Step response for 1. Order Lowpass')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2ss</span> <span class="o">:</span> <span class="n">num</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">den</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transfer function to state-space representation.</p>
<h2 id="parameters_216">Parameters<a class="headerlink" href="#parameters_216" title="Permanent link">&para;</a></h2>
<p>num, den : array_like
Sequences representing the coefficients of the numerator and
denominator polynomials, in order of descending degree. The
denominator needs to be at least as long as the numerator.</p>
<h2 id="returns_224">Returns<a class="headerlink" href="#returns_224" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<h2 id="examples_184">Examples<a class="headerlink" href="#examples_184" title="Permanent link">&para;</a></h2>
<p>Convert the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import tf2ss
A, B, C, D = tf2ss(num, den)
A
array([[-2., -1.],
[ 1.,  0.]])
B
array([[ 1.],
[ 0.]])
C
array([[ 1.,  2.]])
D
array([[ 1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2zpk</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.</p>
<h2 id="parameters_217">Parameters<a class="headerlink" href="#parameters_217" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.</p>
<h2 id="returns_225">Returns<a class="headerlink" href="#returns_225" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_139">Notes<a class="headerlink" href="#notes_139" title="Permanent link">&para;</a></h2>
<p>If some values of <code>b</code> are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.</p>
<p>The <code>b</code> and <code>a</code> arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable.  So the inputs
:math:<code>b = [b_0, b_1, ..., b_M]</code> and :math:<code>a =[a_0, a_1, ..., a_N]</code>
can represent an analog filter of the form:</p>
<p>.. math::</p>
<p>H(s) = \frac
{b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
{a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}</p>
<p>or a discrete-time filter of the form:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
{a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}</p>
<p>This 'positive powers' form is found more commonly in controls
engineering.  If <code>M</code> and <code>N</code> are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the 'negative powers' discrete-time form preferred in DSP:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}</p>
<p>Although this is true for common filters, remember that this is not true
in the general case.  If <code>M</code> and <code>N</code> are not equal, the discrete-time
transfer function coefficients must first be converted to the 'positive
powers' form before finding the poles and zeros.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Permute the dimensions of an array.</p>
<h2 id="parameters_218">Parameters<a class="headerlink" href="#parameters_218" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.
axes : list of ints, optional
By default, reverse the dimensions, otherwise permute the axes
according to the values given.</p>
<h2 id="returns_226">Returns<a class="headerlink" href="#returns_226" title="Permanent link">&para;</a></h2>
<p>p : ndarray
<code>a</code> with its axes permuted.  A view is returned whenever
possible.</p>
<h2 id="see-also_158">See Also<a class="headerlink" href="#see-also_158" title="Permanent link">&para;</a></h2>
<p>moveaxis
argsort</p>
<h2 id="notes_140">Notes<a class="headerlink" href="#notes_140" title="Permanent link">&para;</a></h2>
<p>Use <code>transpose(a, argsort(axes))</code> to invert the transposition of tensors
when using the <code>axes</code> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<h2 id="examples_185">Examples<a class="headerlink" href="#examples_185" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(4).reshape((2,2))
x
array([[0, 1],
[2, 3]])</p>
<p>np.transpose(x)
array([[0, 2],
[1, 3]])</p>
<p>x = np.ones((1, 2, 3))
np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_219">Parameters<a class="headerlink" href="#parameters_219" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_227">Returns<a class="headerlink" href="#returns_227" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_159">See Also<a class="headerlink" href="#see-also_159" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_186">Examples<a class="headerlink" href="#examples_186" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros_like</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Is</span> <span class="k">of</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an array of zeros with the same shape and type as a given array.</p>
<h2 id="parameters_220">Parameters<a class="headerlink" href="#parameters_220" title="Permanent link">&para;</a></h2>
<p>a : array_like
The shape and data-type of <code>a</code> define these same attributes of
the returned array.
dtype : data-type, optional
Overrides the data type of the result.</p>
<p>.. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
Overrides the memory layout of the result. 'C' means C-order,
'F' means F-order, 'A' means 'F' if <code>a</code> is Fortran contiguous,
'C' otherwise. 'K' means match the layout of <code>a</code> as closely
as possible.</p>
<p>.. versionadded:: 1.6.0
subok : bool, optional.
If True, then the newly created array will use the sub-class
type of 'a', otherwise it will be a base-class array. Defaults
to True.
shape : int or sequence of ints, optional.
Overrides the shape of the result. If order='K' and the number of
dimensions is unchanged, will try to keep order, otherwise,
order='C' is implied.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_228">Returns<a class="headerlink" href="#returns_228" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the same shape and type as <code>a</code>.</p>
<h2 id="see-also_160">See Also<a class="headerlink" href="#see-also_160" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.</p>
<h2 id="examples_187">Examples<a class="headerlink" href="#examples_187" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(6)
x = x.reshape((2, 3))
x
array([[0, 1, 2],
[3, 4, 5]])
np.zeros_like(x)
array([[0, 0, 0],
[0, 0, 0]])</p>
<p>y = np.arange(3, dtype=float)
y
array([0., 1., 2.])
np.zeros_like(y)
array([0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2ss</span> <span class="o">:</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zero-pole-gain representation to state-space representation</p>
<h2 id="parameters_221">Parameters<a class="headerlink" href="#parameters_221" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<h2 id="returns_229">Returns<a class="headerlink" href="#returns_229" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2tf</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return polynomial transfer function representation from zeros and poles</p>
<h2 id="parameters_222">Parameters<a class="headerlink" href="#parameters_222" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="returns_230">Returns<a class="headerlink" href="#returns_230" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Signaltools</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">CKDTree</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTree</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">leafsize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compact_nodes</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy_data</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">balanced_tree</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boxsize</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
balanced_tree=True, boxsize=None)</p>
<p>kd-tree for quick nearest-neighbor lookup</p>
<p>This class provides an index into a set of k-dimensional points
which can be used to rapidly look up the nearest neighbors of any
point.</p>
<p>The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary trie, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.</p>
<p>During construction, the axis and splitting point are chosen by the
'sliding midpoint' rule, which ensures that the cells do not all
become long and thin.</p>
<p>The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.</p>
<p>For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.</p>
<h2 id="parameters_223">Parameters<a class="headerlink" href="#parameters_223" title="Permanent link">&para;</a></h2>
<p>data : array_like, shape (n,m)
The n data points of dimension m to be indexed. This array is
not copied unless this is necessary to produce a contiguous
array of doubles, and so modifying this data will result in
bogus results. The data are also copied if the kd-tree is built
with copy_data=True.
leafsize : positive int, optional
The number of points at which the algorithm switches over to
brute-force. Default: 16.
compact_nodes : bool, optional
If True, the kd-tree is built to shrink the hyperrectangles to
the actual data range. This usually gives a more compact tree that
is robust against degenerated input data and gives faster queries
at the expense of longer build time. Default: True.
copy_data : bool, optional
If True the data is always copied to protect the kd-tree against
data corruption. Default: False.
balanced_tree : bool, optional
If True, the median is used to split the hyperrectangles instead of
the midpoint. This usually gives a more compact tree and
faster queries at the expense of longer build time. Default: True.
boxsize : array_like or scalar, optional
Apply a m-d toroidal topology to the KDTree.. The topology is generated
by :math:<code>x_i + n_i L_i</code> where :math:<code>n_i</code> are integers and :math:<code>L_i</code>
is the boxsize along i-th dimension. The input data shall be wrapped
into :math:<code>[0, L_i)</code>. A ValueError is raised if any of the data is
outside of this bound.</p>
<h2 id="attributes">Attributes<a class="headerlink" href="#attributes" title="Permanent link">&para;</a></h2>
<p>data : ndarray, shape (n,m)
The n data points of dimension m to be indexed. This array is
not copied unless this is necessary to produce a contiguous
array of doubles. The data are also copied if the kd-tree is built
with <code>copy_data=True</code>.
leafsize : positive int
The number of points at which the algorithm switches over to
brute-force.
m : int
The dimension of a single data-point.
n : int
The number of data points.
maxes : ndarray, shape (m,)
The maximum value in each dimension of the n data points.
mins : ndarray, shape (m,)
The minimum value in each dimension of the n data points.
tree : object, class cKDTreeNode
This class exposes a Python view of the root node in the cKDTree object.
size : int
The number of nodes in the tree.</p>
<h2 id="see-also_161">See Also<a class="headerlink" href="#see-also_161" title="Permanent link">&para;</a></h2>
<p>KDTree : Implementation of <code>cKDTree</code> in pure Python</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_neighbors</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">weights</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cumulative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>count_neighbors(self, other, r, p=2., weights=None, cumulative=True)</p>
<p>Count how many nearby pairs can be formed. (pair-counting)</p>
<p>Count the number of pairs (x1,x2) can be formed, with x1 drawn
from self and x2 drawn from <code>other</code>, and where
<code>distance(x1, x2, p) &lt;= r</code>.</p>
<p>Data points on self and other are optionally weighted by the <code>weights</code>
argument. (See below)</p>
<p>The algorithm we implement here is based on [1]_. See notes for further discussion.</p>
<h2 id="parameters_224">Parameters<a class="headerlink" href="#parameters_224" title="Permanent link">&para;</a></h2>
<p>other : cKDTree instance
The other tree to draw points from, can be the same tree as self.
r : float or one-dimensional array of floats
The radius to produce a count for. Multiple radii are searched with
a single tree traversal.
If the count is non-cumulative(<code>cumulative=False</code>), <code>r</code> defines
the edges of the bins, and must be non-decreasing.
p : float, optional
1&lt;=p&lt;=infinity.
Which Minkowski p-norm to use.
Default 2.0.
A finite large p may cause a ValueError if overflow can occur.
weights : tuple, array_like, or None, optional
If None, the pair-counting is unweighted.
If given as a tuple, weights[0] is the weights of points in <code>self</code>, and
weights[1] is the weights of points in <code>other</code>; either can be None to
indicate the points are unweighted.
If given as an array_like, weights is the weights of points in <code>self</code>
and <code>other</code>. For this to make sense, <code>self</code> and <code>other</code> must be the
same tree. If <code>self</code> and <code>other</code> are two different trees, a <code>ValueError</code>
is raised.
Default: None
cumulative : bool, optional
Whether the returned counts are cumulative. When cumulative is set to <code>False</code>
the algorithm is optimized to work with a large number of bins (&gt;10) specified
by <code>r</code>. When <code>cumulative</code> is set to True, the algorithm is optimized to work
with a small number of <code>r</code>. Default: True</p>
<h2 id="returns_231">Returns<a class="headerlink" href="#returns_231" title="Permanent link">&para;</a></h2>
<p>result : scalar or 1-D array
The number of pairs. For unweighted counts, the result is integer.
For weighted counts, the result is float.
If cumulative is False, <code>result[i]</code> contains the counts with
<code>(-inf if i == 0 else r[i-1]) &lt; R &lt;= r[i]</code></p>
<h2 id="notes_141">Notes<a class="headerlink" href="#notes_141" title="Permanent link">&para;</a></h2>
<p>Pair-counting is the basic operation used to calculate the two point
correlation functions from a data set composed of position of objects.</p>
<p>Two point correlation function measures the clustering of objects and
is widely used in cosmology to quantify the large scale structure
in our Universe, but it may be useful for data analysis in other fields
where self-similar assembly of objects also occur.</p>
<p>The Landy-Szalay estimator for the two point correlation function of
<code>D</code> measures the clustering signal in <code>D</code>. [2]_</p>
<p>For example, given the position of two sets of objects,</p>
<ul>
<li>
<p>objects <code>D</code> (data) contains the clustering signal, and</p>
</li>
<li>
<p>objects <code>R</code> (random) that contains no signal,</p>
</li>
</ul>
<p>.. math::</p>
<p>\xi(r) = \frac{<D, D> - 2 f <D, R> + f^2<R, R>}{f^2<R, R>},</p>
<p>where the brackets represents counting pairs between two data sets
in a finite bin around <code>r</code> (distance), corresponding to setting
<code>cumulative=False</code>, and <code>f = float(len(D)) / float(len(R))</code> is the
ratio between number of objects from data and random.</p>
<p>The algorithm implemented here is loosely based on the dual-tree
algorithm described in [1]<em>. We switch between two different
pair-cumulation scheme depending on the setting of <code>cumulative</code>.
The computing time of the method we use when for
<code>cumulative == False</code> does not scale with the total number of bins.
The algorithm for <code>cumulative == True</code> scales linearly with the
number of bins, though it is slightly faster when only
1 or 2 bins are used. [5]</em>.</p>
<p>As an extension to the naive pair-counting,
weighted pair-counting counts the product of weights instead
of number of pairs.
Weighted pair-counting is used to estimate marked correlation functions
([3]<em>, section 2.2),
or to properly calculate the average of data per distance bin
(e.g. [4]</em>, section 2.1 on redshift).</p>
<p>.. [1] Gray and Moore,
'N-body problems in statistical learning',
Mining the sky, 2000,
https://arxiv.org/abs/astro-ph/0012333</p>
<p>.. [2] Landy and Szalay,
'Bias and variance of angular correlation functions',
The Astrophysical Journal, 1993,
http://adsabs.harvard.edu/abs/1993ApJ...412...64L</p>
<p>.. [3] Sheth, Connolly and Skibba,
'Marked correlations in galaxy formation models',
Arxiv e-print, 2005,
https://arxiv.org/abs/astro-ph/0511773</p>
<p>.. [4] Hawkins, et al.,
'The 2dF Galaxy Redshift Survey: correlation functions,
peculiar velocities and the matter density of the Universe',
Monthly Notices of the Royal Astronomical Society, 2002,
http://adsabs.harvard.edu/abs/2003MNRAS.346...78H</p>
<p>.. [5] https://github.com/scipy/scipy/pull/5647#issuecomment-168474926</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Shape_tuple_self_m_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_ball_point(self, x, r, p=2., eps=0)</p>
<p>Find all points within distance r of point(s) x.</p>
<h2 id="parameters_225">Parameters<a class="headerlink" href="#parameters_225" title="Permanent link">&para;</a></h2>
<p>x : array_like, shape tuple + (self.m,)
The point or points to search for neighbors of.
r : array_like, float
The radius of points to return, shall broadcast to the length of x.
p : float, optional
Which Minkowski p-norm to use.  Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
eps : nonnegative float, optional
Approximate search. Branches of the tree are not explored if their
nearest points are further than <code>r / (1 + eps)</code>, and branches are
added in bulk if their furthest points are nearer than
<code>r * (1 + eps)</code>.
n_jobs : int, optional
Number of jobs to schedule for parallel processing. If -1 is given
all processors are used. Default: 1.
return_sorted : bool, optional
Sorts returned indicies if True and does not sort them if False. If
None, does not sort single point queries, but does sort
multi-point queries which was the behavior before this option
was added.</p>
<p>.. versionadded:: 1.2.0
return_length: bool, optional
Return the number of points inside the radius instead of a list
of the indices.
.. versionadded:: 1.3.0</p>
<h2 id="returns_232">Returns<a class="headerlink" href="#returns_232" title="Permanent link">&para;</a></h2>
<p>results : list or array of lists
If <code>x</code> is a single point, returns a list of the indices of the
neighbors of <code>x</code>. If <code>x</code> is an array of points, returns an object
array of shape tuple containing lists of neighbors.</p>
<h2 id="notes_142">Notes<a class="headerlink" href="#notes_142" title="Permanent link">&para;</a></h2>
<p>If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a cKDTree and using
query_ball_tree.</p>
<h2 id="examples_188">Examples<a class="headerlink" href="#examples_188" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import spatial
x, y = np.mgrid[0:4, 0:4]
points = np.c_[x.ravel(), y.ravel()]
tree = spatial.cKDTree(points)
tree.query_ball_point([2, 0], 1)
[4, 8, 9, 12]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_ball_tree(self, other, r, p=2., eps=0)</p>
<p>Find all pairs of points whose distance is at most r</p>
<h2 id="parameters_226">Parameters<a class="headerlink" href="#parameters_226" title="Permanent link">&para;</a></h2>
<p>other : cKDTree instance
The tree containing points to search against.
r : float
The maximum distance, has to be positive.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
A finite large p may cause a ValueError if overflow can occur.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.</p>
<h2 id="returns_233">Returns<a class="headerlink" href="#returns_233" title="Permanent link">&para;</a></h2>
<p>results : list of lists
For each element <code>self.data[i]</code> of this tree, <code>results[i]</code> is a
list of the indices of its neighbors in <code>other.data</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_pairs</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_pairs(self, r, p=2., eps=0)</p>
<p>Find all pairs of points whose distance is at most r.</p>
<h2 id="parameters_227">Parameters<a class="headerlink" href="#parameters_227" title="Permanent link">&para;</a></h2>
<p>r : positive float
The maximum distance.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
A finite large p may cause a ValueError if overflow can occur.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.
output_type : string, optional
Choose the output container, 'set' or 'ndarray'. Default: 'set'</p>
<h2 id="returns_234">Returns<a class="headerlink" href="#returns_234" title="Permanent link">&para;</a></h2>
<p>results : set or ndarray
Set of pairs <code>(i,j)</code>, with <code>i &lt; j</code>, for which the corresponding
positions are close. If output_type is 'ndarray', an ndarry is
returned instead of a set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sparse_distance_matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">max_distance</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sparse_distance_matrix(self, other, max_distance, p=2.)</p>
<p>Compute a sparse distance matrix</p>
<p>Computes a distance matrix between two cKDTrees, leaving as zero
any distance greater than max_distance.</p>
<h2 id="parameters_228">Parameters<a class="headerlink" href="#parameters_228" title="Permanent link">&para;</a></h2>
<p>other : cKDTree</p>
<p>max_distance : positive float</p>
<p>p : float, 1&lt;=p&lt;=infinity
Which Minkowski p-norm to use.
A finite large p may cause a ValueError if overflow can occur.</p>
<p>output_type : string, optional
Which container to use for output data. Options: 'dok_matrix',
'coo_matrix', 'dict', or 'ndarray'. Default: 'dok_matrix'.</p>
<h2 id="returns_235">Returns<a class="headerlink" href="#returns_235" title="Permanent link">&para;</a></h2>
<p>result : dok_matrix, coo_matrix, dict or ndarray
Sparse matrix representing the results in 'dictionary of keys'
format. If a dict is returned the keys are (i,j) tuples of indices.
If output_type is 'ndarray' a record array with fields 'i', 'j',
and 'v' is returned,</p>
<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute leafsize: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leafsize</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute leafsize: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leafsize_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute m: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">m</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute m: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">m_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute n: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute n: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute maxes: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxes</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute maxes: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxes_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute mins: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mins</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute mins: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mins_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute tree: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tree</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute tree: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tree_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute size: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">size</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute size: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">size_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Sp_fft</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_229">Parameters<a class="headerlink" href="#parameters_229" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_236">Returns<a class="headerlink" href="#returns_236" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_162">See Also<a class="headerlink" href="#see-also_162" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_143">Notes<a class="headerlink" href="#notes_143" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on <code>dct</code> and the <code>idct</code> is scaled by
<code>1/N</code> where <code>N</code> is the 'logical' size of the DCT. For <code>norm='ortho'</code>
both directions are scaled by the same factor <code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<h2 id="references_38">References<a class="headerlink" href="#references_38" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_189">Examples<a class="headerlink" href="#examples_189" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_230">Parameters<a class="headerlink" href="#parameters_230" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_237">Returns<a class="headerlink" href="#returns_237" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_163">See Also<a class="headerlink" href="#see-also_163" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_144">Notes<a class="headerlink" href="#notes_144" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_190">Examples<a class="headerlink" href="#examples_190" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_231">Parameters<a class="headerlink" href="#parameters_231" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_238">Returns<a class="headerlink" href="#returns_238" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_164">See Also<a class="headerlink" href="#see-also_164" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_145">Notes<a class="headerlink" href="#notes_145" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on the <code>dst</code> and the <code>idst</code> is
scaled by <code>1/N</code> where <code>N</code> is the 'logical' size of the DST. For
<code>norm='ortho'</code> both directions are scaled by the same factor
<code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<h2 id="references_39">References<a class="headerlink" href="#references_39" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_232">Parameters<a class="headerlink" href="#parameters_232" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding dimension
of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_239">Returns<a class="headerlink" href="#returns_239" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_165">See Also<a class="headerlink" href="#see-also_165" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_146">Notes<a class="headerlink" href="#notes_146" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_191">Examples<a class="headerlink" href="#examples_191" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [1]_.</p>
<h2 id="parameters_233">Parameters<a class="headerlink" href="#parameters_233" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT.  If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode. Default is None, meaning no normalization on the
forward transforms and scaling by <code>1/n</code> on the <code>ifft</code>.
For <code>norm='ortho'</code>, both directions are scaled by <code>1/sqrt(n)</code>.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See the notes below for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>. See below for more
details.</p>
<h2 id="returns_240">Returns<a class="headerlink" href="#returns_240" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_30">Raises<a class="headerlink" href="#raises_30" title="Permanent link">&para;</a></h2>
<p>IndexError
if <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_166">See Also<a class="headerlink" href="#see-also_166" title="Permanent link">&para;</a></h2>
<p>ifft : The inverse of <code>fft</code>.
fft2 : The two-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.
next_fast_len : Size to pad input to for most efficient transforms</p>
<h2 id="notes_147">Notes<a class="headerlink" href="#notes_147" title="Permanent link">&para;</a></h2>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform
(DFT) can be calculated efficiently, by using symmetries in the calculated
terms. The symmetry is highest when <code>n</code> is a power of 2, and the transform
is therefore most efficient for these sizes. For poorly factorizable sizes,
<code>scipy.fft</code> uses Bluestein's algorithm [2]_ and so is never worse than
O(<code>n</code> log <code>n</code>). Further performance improvements may be seen by zero-padding
the input using <code>next_fast_len</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>fft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(-2j * np.pi * k * np.arange(n)/n))</p>
<p>The frequency term <code>f=k/n</code> is found at <code>y[k]</code>. At <code>y[n/2]</code> we reach
the Nyquist frequency and wrap around to the negative-frequency terms. So,
for an 8-point transform, the frequencies of the result are
[0, 1, 2, 3, -4, -3, -2, -1]. To rearrange the fft output so that the
zero-frequency component is centered, like [-4, -3, -2, -1, 0, 1, 2, 3],
use <code>fftshift</code>.</p>
<p>Transforms can be done in single, double or extended precision (long
double) floating point. Half precision inputs will be converted to single
precision and non floating-point inputs will be converted to double
precision.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<p>When <code>overwrite_x=True</code> is specified, the memory referenced by <code>x</code> may
be used by the implementation in any way. This may include reusing the
memory for the result, but this is in no way guaranteed. You should not
rely on the contents of <code>x</code> after the transform as this may change in
future without warning.</p>
<p>The <code>workers</code> argument specifies the maximum number of parallel jobs to
split the FFT computation into. This will execute independent 1-dimensional
FFTs within <code>x</code>. So, <code>x</code> must be at least 2-dimensional and the
non-transformed axes must be large enough to split into chunks. If <code>x</code> is
too small, fewer jobs may be used than requested.</p>
<h2 id="references_40">References<a class="headerlink" href="#references_40" title="Permanent link">&para;</a></h2>
<p>.. [1] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
machine calculation of complex Fourier series,' <em>Math. Comput.</em>
19: 297-301.
.. [2] Bluestein, L., 1970, 'A linear filtering approach to the
computation of discrete Fourier transform'. <em>IEEE Transactions on
Audio and Electroacoustics.</em> 18 (4): 451-455.</p>
<h2 id="examples_192">Examples<a class="headerlink" href="#examples_192" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, fftfreq, fftshift
import matplotlib.pyplot as plt
t = np.arange(256)
sp = fftshift(fft(np.sin(t)))
freq = fftshift(fftfreq(t.shape[-1]))
plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional discrete Fourier Transform</p>
<p>This function computes the <em>n</em>-dimensional discrete Fourier Transform
over any axes in an <em>M</em>-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.</p>
<h2 id="parameters_234">Parameters<a class="headerlink" href="#parameters_234" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT. If not given, the last two axes are
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_241">Returns<a class="headerlink" href="#returns_241" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_31">Raises<a class="headerlink" href="#raises_31" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_167">See Also<a class="headerlink" href="#see-also_167" title="Permanent link">&para;</a></h2>
<p>ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
For two-dimensional input, swaps first and third quadrants, and second
and fourth quadrants.</p>
<h2 id="notes_148">Notes<a class="headerlink" href="#notes_148" title="Permanent link">&para;</a></h2>
<p><code>fft2</code> is just <code>fftn</code> with a different default for <code>axes</code>.</p>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.</p>
<p>See <code>fftn</code> for details and a plotting example, and <code>fft</code> for
definitions and conventions used.</p>
<h2 id="examples_193">Examples<a class="headerlink" href="#examples_193" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:5, :5][0]
scipy.fft.fft2(x)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
0.  +0.j        ,   0.  +0.j        ],
[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_235">Parameters<a class="headerlink" href="#parameters_235" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_242">Returns<a class="headerlink" href="#returns_242" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_194">Examples<a class="headerlink" href="#examples_194" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform.</p>
<p>This function computes the <em>N</em>-dimensional discrete Fourier Transform over
any number of axes in an <em>M</em>-dimensional array by means of the Fast Fourier
Transform (FFT).</p>
<h2 id="parameters_236">Parameters<a class="headerlink" href="#parameters_236" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_243">Returns<a class="headerlink" href="#returns_243" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_32">Raises<a class="headerlink" href="#raises_32" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_168">See Also<a class="headerlink" href="#see-also_168" title="Permanent link">&para;</a></h2>
<p>ifftn : The inverse of <code>fftn</code>, the inverse <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The <em>n</em>-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array</p>
<h2 id="notes_149">Notes<a class="headerlink" href="#notes_149" title="Permanent link">&para;</a></h2>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="examples_195">Examples<a class="headerlink" href="#examples_195" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:3, :3, :3][0]
scipy.fft.fftn(x, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[ 9.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[18.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]]])
scipy.fft.fftn(x, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
[ 0.+0.j,  0.+0.j,  0.+0.j]],
[[-2.+0.j, -2.+0.j, -2.+0.j],
[ 0.+0.j,  0.+0.j,  0.+0.j]]])</p>
<p>import matplotlib.pyplot as plt
[X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
FS = scipy.fft.fftn(S)
plt.imshow(np.log(np.abs(scipy.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_237">Parameters<a class="headerlink" href="#parameters_237" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_244">Returns<a class="headerlink" href="#returns_244" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_169">See Also<a class="headerlink" href="#see-also_169" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_196">Examples<a class="headerlink" href="#examples_196" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_workers</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the default number of workers within the current context</p>
<h2 id="examples_197">Examples<a class="headerlink" href="#examples_197" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft
fft.get_workers()
1
with fft.set_workers(4):
...     fft.get_workers()
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.</p>
<h2 id="parameters_238">Parameters<a class="headerlink" href="#parameters_238" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output. For <code>n</code> output
points, <code>n//2 + 1</code> input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros. If <code>n</code> is not given, it is taken to be <code>2*(m-1)</code>
where <code>m</code> is the length of the input along the axis specified by
<code>axis</code>.
axis : int, optional
Axis over which to compute the FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_245">Returns<a class="headerlink" href="#returns_245" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*m - 2</code> where <code>m</code> is the length of the transformed axis of
the input. To get an odd number of output points, <code>n</code> must be
specified, for instance as <code>2*m - 1</code> in the typical case,</p>
<h2 id="raises_33">Raises<a class="headerlink" href="#raises_33" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_170">See also<a class="headerlink" href="#see-also_170" title="Permanent link">&para;</a></h2>
<p>rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of <code>hfft</code>.
hfftn : Compute the n-dimensional FFT of a Hermitian signal.</p>
<h2 id="notes_150">Notes<a class="headerlink" href="#notes_150" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd.
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_198">Examples<a class="headerlink" href="#examples_198" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, hfft
a = 2 * np.pi * np.arange(10) / 10
signal = np.cos(a) + 3j * np.sin(3 * a)
fft(signal).round(10)
array([ -0.+0.j,   5.+0.j,  -0.+0.j,  15.-0.j,   0.+0.j,   0.+0.j,
-0.+0.j, -15.-0.j,   0.+0.j,   5.+0.j])
hfft(signal[:6]).round(10) # Input first half of signal
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])
hfft(signal, 10)  # Input entire signal and truncate
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a Hermitian complex array.</p>
<h2 id="parameters_239">Parameters<a class="headerlink" href="#parameters_239" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be Hermitian complex.
s : sequence of ints, optional
Shape of the real output.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_246">Returns<a class="headerlink" href="#returns_246" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The real result of the 2D Hermitian complex real FFT.</p>
<h2 id="see-also_171">See Also<a class="headerlink" href="#see-also_171" title="Permanent link">&para;</a></h2>
<p>hfftn : Compute the N-dimensional discrete Fourier Transform for Hermitian
complex input.</p>
<h2 id="notes_151">Notes<a class="headerlink" href="#notes_151" title="Permanent link">&para;</a></h2>
<p>This is really just <code>hfftn</code> with different default behavior.
For more details see <code>hfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional FFT of Hermitian symmetric complex input, i.e. a
signal with a real spectrum.</p>
<p>This function computes the N-dimensional discrete Fourier Transform for a
Hermitian symmetric complex input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT). In other
words, <code>ihfftn(hfftn(x, s)) == x</code> to within numerical accuracy. (<code>s</code>
here is <code>x.shape</code> with <code>s[-1] = x.shape[-1] * 2 - 1</code>, this is necessary
for the same reason <code>x.shape</code> would be necessary for <code>irfft</code>.)</p>
<h2 id="parameters_240">Parameters<a class="headerlink" href="#parameters_240" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_247">Returns<a class="headerlink" href="#returns_247" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_34">Raises<a class="headerlink" href="#raises_34" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_172">See Also<a class="headerlink" href="#see-also_172" title="Permanent link">&para;</a></h2>
<p>ihfftn : The inverse n-dimensional FFT with real spectrum. Inverse of <code>hfftn</code>.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : Forward FFT of real input</p>
<h2 id="notes_152">Notes<a class="headerlink" href="#notes_152" title="Permanent link">&para;</a></h2>
<p>For a 1 dimensional signal <code>x</code> to have a real spectrum, it must satisfy
the Hermitian property::</p>
<p>x[i] == np.conj(x[-i]) for all i</p>
<p>This generalizes into higher dimensions by reflecting over each axis in
turn::</p>
<p>x[i, j, k, ...] == np.conj(x[-i, -j, -k, ...]) for all i, j, k, ...</p>
<p>This should not be confused with a Hermitian matrix, for which the
transpose is it's own conjugate::</p>
<p>x[i, j] == np.conj(x[j, i]) for all i, j</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_199">Examples<a class="headerlink" href="#examples_199" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((3, 2, 2))
scipy.fft.hfftn(x)
array([[[12.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_241">Parameters<a class="headerlink" href="#parameters_241" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_248">Returns<a class="headerlink" href="#returns_248" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_173">See Also<a class="headerlink" href="#see-also_173" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_153">Notes<a class="headerlink" href="#notes_153" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT-II, which is the same as the normalized DCT-III.</p>
<p>The IDCT is equivalent to a normal DCT except for the normalization and
type. DCT type 1 and 4 are their own inverse and DCTs 2 and 3 are each
other's inverses.</p>
<h2 id="examples_200">Examples<a class="headerlink" href="#examples_200" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1)
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_242">Parameters<a class="headerlink" href="#parameters_242" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are
None, <code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is
not None, then <code>s</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_249">Returns<a class="headerlink" href="#returns_249" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_174">See Also<a class="headerlink" href="#see-also_174" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_154">Notes<a class="headerlink" href="#notes_154" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_201">Examples<a class="headerlink" href="#examples_201" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_243">Parameters<a class="headerlink" href="#parameters_243" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_250">Returns<a class="headerlink" href="#returns_250" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_175">See Also<a class="headerlink" href="#see-also_175" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_155">Notes<a class="headerlink" href="#notes_155" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST-II, which is the same as the normalized DST-III.</p>
<p>The IDST is equivalent to a normal DST except for the normalization and
type. DST type 1 and 4 are their own inverse and DSTs 2 and 3 are each
other's inverses.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_244">Parameters<a class="headerlink" href="#parameters_244" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_251">Returns<a class="headerlink" href="#returns_251" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_176">See Also<a class="headerlink" href="#see-also_176" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_156">Notes<a class="headerlink" href="#notes_156" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_202">Examples<a class="headerlink" href="#examples_202" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <code>fft</code>.  In other words,
<code>ifft(fft(x)) == x</code> to within numerical accuracy.</p>
<p>The input should be ordered in the same way as is returned by <code>fft</code>,
i.e.,</p>
<ul>
<li><code>x[0]</code> should contain the zero frequency term,</li>
<li><code>x[1:n//2]</code> should contain the positive-frequency terms,</li>
<li><code>x[n//2 + 1:]</code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</li>
</ul>
<p>For an even number of input points, <code>x[n//2]</code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <code>fft</code> for details.</p>
<h2 id="parameters_245">Parameters<a class="headerlink" href="#parameters_245" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
See notes about padding issues.
axis : int, optional
Axis over which to compute the inverse DFT.  If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_252">Returns<a class="headerlink" href="#returns_252" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_35">Raises<a class="headerlink" href="#raises_35" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_177">See Also<a class="headerlink" href="#see-also_177" title="Permanent link">&para;</a></h2>
<p>fft : The one-dimensional (forward) FFT, of which <code>ifft</code> is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.</p>
<h2 id="notes_157">Notes<a class="headerlink" href="#notes_157" title="Permanent link">&para;</a></h2>
<p>If the input parameter <code>n</code> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <code>ifft</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>ifft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(2j * np.pi * k * np.arange(n)/n)) / len(x)</p>
<p>As with <code>fft</code>, <code>ifft</code> has support for all floating point types and is
optimized for real input.</p>
<h2 id="examples_203">Examples<a class="headerlink" href="#examples_203" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot a band-limited signal with random phases:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(400)
n = np.zeros((400,), dtype=complex)
n[40:60] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20,)))
s = scipy.fft.ifft(n)
plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, <code>ifft2(fft2(x)) == x</code>
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fft2</code>, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_246">Parameters<a class="headerlink" href="#parameters_246" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each axis) of the output (<code>s[0]</code> refers to axis 0,
<code>s[1]</code> to axis 1, etc.).  This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last two
axes are used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_253">Returns<a class="headerlink" href="#returns_253" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_36">Raises<a class="headerlink" href="#raises_36" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_178">See Also<a class="headerlink" href="#see-also_178" title="Permanent link">&para;</a></h2>
<p>fft2 : The forward 2-dimensional FFT, of which <code>ifft2</code> is the inverse.
ifftn : The inverse of the <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.</p>
<h2 id="notes_158">Notes<a class="headerlink" href="#notes_158" title="Permanent link">&para;</a></h2>
<p><code>ifft2</code> is just <code>ifftn</code> with a different default for <code>axes</code>.</p>
<p>See <code>ifftn</code> for details and a plotting example, and <code>fft</code> for
definition and conventions used.</p>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifft2</code> is called.</p>
<h2 id="examples_204">Examples<a class="headerlink" href="#examples_204" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = 4 * np.eye(4)
scipy.fft.ifft2(x)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
<code>ifftn(fftn(x)) == x</code> to within numerical accuracy.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fftn</code>, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_247">Parameters<a class="headerlink" href="#parameters_247" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the IFFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_254">Returns<a class="headerlink" href="#returns_254" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_37">Raises<a class="headerlink" href="#raises_37" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_179">See Also<a class="headerlink" href="#see-also_179" title="Permanent link">&para;</a></h2>
<p>fftn : The forward <em>n</em>-dimensional FFT, of which <code>ifftn</code> is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes <code>fftshift</code>, shifts zero-frequency terms to beginning
of array.</p>
<h2 id="notes_159">Notes<a class="headerlink" href="#notes_159" title="Permanent link">&para;</a></h2>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifftn</code> is called.</p>
<h2 id="examples_205">Examples<a class="headerlink" href="#examples_205" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.eye(4)
scipy.fft.ifftn(scipy.fft.fftn(x, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot an image with band-limited frequency content:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
n = np.zeros((200,200), dtype=complex)
n[60:80, 20:40] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20, 20)))
im = scipy.fft.ifftn(n).real
plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_248">Parameters<a class="headerlink" href="#parameters_248" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_255">Returns<a class="headerlink" href="#returns_255" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_180">See Also<a class="headerlink" href="#see-also_180" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_206">Examples<a class="headerlink" href="#examples_206" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p>
<h2 id="parameters_249">Parameters<a class="headerlink" href="#parameters_249" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
n : int, optional
Length of the inverse FFT, the number of points along
transformation axis in the input to use.  If <code>n</code> is smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. If <code>n</code> is not given, the length of
the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_256">Returns<a class="headerlink" href="#returns_256" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n//2 + 1</code>.</p>
<h2 id="see-also_181">See also<a class="headerlink" href="#see-also_181" title="Permanent link">&para;</a></h2>
<p>hfft, irfft</p>
<h2 id="notes_160">Notes<a class="headerlink" href="#notes_160" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd:
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_207">Examples<a class="headerlink" href="#examples_207" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, ihfft
spectrum = np.array([ 15, -4, 0, -1, 0, -4])
ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real spectrum.</p>
<h2 id="parameters_250">Parameters<a class="headerlink" href="#parameters_250" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real input to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_257">Returns<a class="headerlink" href="#returns_257" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_182">See Also<a class="headerlink" href="#see-also_182" title="Permanent link">&para;</a></h2>
<p>ihfftn : Compute the inverse of the N-dimensional FFT of Hermitian input.</p>
<h2 id="notes_161">Notes<a class="headerlink" href="#notes_161" title="Permanent link">&para;</a></h2>
<p>This is really <code>ihfftn</code> with different defaults.
For more details see <code>ihfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform for a real
spectrum.</p>
<p>This function computes the N-dimensional inverse discrete Fourier Transform
over any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT). By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining transforms
are complex.</p>
<h2 id="parameters_251">Parameters<a class="headerlink" href="#parameters_251" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_258">Returns<a class="headerlink" href="#returns_258" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_38">Raises<a class="headerlink" href="#raises_38" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_183">See Also<a class="headerlink" href="#see-also_183" title="Permanent link">&para;</a></h2>
<p>hfftn : The forward n-dimensional FFT of Hermitian input.
hfft : The one-dimensional FFT of Hermitian input.
fft : The one-dimensional FFT, with definitions and conventions used.
fftn : The n-dimensional FFT.
hfft2 : The two-dimensional FFT of Hermitian input.</p>
<h2 id="notes_162">Notes<a class="headerlink" href="#notes_162" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>ihfft</code>, then the transform over the remaining axes is
performed as by <code>ifftn</code>. The order of the output is the positive part of
the Hermitian output signal, in the same format as <code>rfft</code>.</p>
<h2 id="examples_208">Examples<a class="headerlink" href="#examples_208" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.ihfftn(x)
array([[[1.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])
scipy.fft.ihfftn(x, axes=(2, 0))
array([[[1.+0.j,  0.+0.j], # may vary
[1.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <code>rfft</code>.
In other words, <code>irfft(rfft(x), len(x)) == x</code> to within numerical
accuracy. (See Notes below for why <code>len(a)</code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <code>rfft</code>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<h2 id="parameters_252">Parameters<a class="headerlink" href="#parameters_252" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output.
For <code>n</code> output points, <code>n//2+1</code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <code>n</code> is not given, it is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along the axis
specified by <code>axis</code>.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_259">Returns<a class="headerlink" href="#returns_259" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*(m-1)</code> where <code>m</code> is the length of the transformed axis of the
input. To get an odd number of output points, <code>n</code> must be specified.</p>
<h2 id="raises_39">Raises<a class="headerlink" href="#raises_39" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_184">See Also<a class="headerlink" href="#see-also_184" title="Permanent link">&para;</a></h2>
<p>rfft : The one-dimensional FFT of real input, of which <code>irfft</code> is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_163">Notes<a class="headerlink" href="#notes_163" title="Permanent link">&para;</a></h2>
<p>Returns the real valued <code>n</code>-point inverse discrete Fourier transform
of <code>x</code>, where <code>x</code> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <code>n</code> is the length of the result, not the
input.</p>
<p>If you specify an <code>n</code> such that <code>a</code> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <code>m</code> points via Fourier interpolation by:
<code>a_resamp = irfft(rfft(a), m)</code>.</p>
<p>The default value of <code>n</code> assumes an even output length. By the Hermitian
symmetry, the last imaginary component must be 0 and so is ignored. To
avoid losing information, the correct length of the real input <em>must</em> be
given.</p>
<h2 id="examples_209">Examples<a class="headerlink" href="#examples_209" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
scipy.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the last term in the input to the ordinary <code>ifft</code> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <code>irfft</code>, the negative frequencies are not
specified, and the output array is purely real.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real array.</p>
<h2 id="parameters_253">Parameters<a class="headerlink" href="#parameters_253" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real output to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_260">Returns<a class="headerlink" href="#returns_260" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_185">See Also<a class="headerlink" href="#see-also_185" title="Permanent link">&para;</a></h2>
<p>irfftn : Compute the inverse of the N-dimensional FFT of real input.</p>
<h2 id="notes_164">Notes<a class="headerlink" href="#notes_164" title="Permanent link">&para;</a></h2>
<p>This is really <code>irfftn</code> with different defaults.
For more details see <code>irfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the N-dimensional FFT of real input.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, <code>irfftn(rfftn(x), x.shape) == x</code> to within numerical
accuracy. (The <code>a.shape</code> is necessary like <code>len(a)</code> is for <code>irfft</code>,
and for the same reason.)</p>
<p>The input should be ordered in the same way as is returned by <code>rfftn</code>,
i.e. as for <code>irfft</code> for the final transformation axis, and as for <code>ifftn</code>
along all the other axes.</p>
<h2 id="parameters_254">Parameters<a class="headerlink" href="#parameters_254" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_261">Returns<a class="headerlink" href="#returns_261" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_40">Raises<a class="headerlink" href="#raises_40" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_186">See Also<a class="headerlink" href="#see-also_186" title="Permanent link">&para;</a></h2>
<p>rfftn : The forward n-dimensional FFT of real input,
of which <code>ifftn</code> is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.</p>
<h2 id="notes_165">Notes<a class="headerlink" href="#notes_165" title="Permanent link">&para;</a></h2>
<p>See <code>fft</code> for definitions and conventions used.</p>
<p>See <code>rfft</code> for definitions and conventions used for real input.</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_210">Examples<a class="headerlink" href="#examples_210" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.zeros((3, 2, 2))
x[0, 0, 0] = 3 * 2 * 2
scipy.fft.irfftn(x)
array([[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">register_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Register a backend for permanent use.</p>
<p>Registered backends have the lowest priority and will be tried after the
global backend.</p>
<h2 id="parameters_255">Parameters<a class="headerlink" href="#parameters_255" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_41">Raises<a class="headerlink" href="#raises_41" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).</p>
<h2 id="parameters_256">Parameters<a class="headerlink" href="#parameters_256" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array
n : int, optional
Number of points along transformation axis in the input to use.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT. If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_262">Returns<a class="headerlink" href="#returns_262" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
If <code>n</code> is even, the length of the transformed axis is <code>(n/2)+1</code>.
If <code>n</code> is odd, the length is <code>(n+1)/2</code>.</p>
<h2 id="raises_42">Raises<a class="headerlink" href="#raises_42" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_187">See Also<a class="headerlink" href="#see-also_187" title="Permanent link">&para;</a></h2>
<p>irfft : The inverse of <code>rfft</code>.
fft : The one-dimensional FFT of general (complex) input.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_166">Notes<a class="headerlink" href="#notes_166" title="Permanent link">&para;</a></h2>
<p>When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore <code>n//2 + 1</code>.</p>
<p>When <code>X = rfft(x)</code> and fs is the sampling frequency, <code>X[0]</code> contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</p>
<p>If <code>n</code> is even, <code>A[-1]</code> contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If <code>n</code> is odd, there is no term at fs/2; <code>A[-1]</code> contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.</p>
<p>If the input <code>a</code> contains an imaginary part, it is silently discarded.</p>
<h2 id="examples_211">Examples<a class="headerlink" href="#examples_211" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
scipy.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the final element of the <code>fft</code> output is the complex conjugate
of the second element, for real input. For <code>rfft</code>, this symmetry is
exploited to compute only the non-negative frequency terms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a real array.</p>
<h2 id="parameters_257">Parameters<a class="headerlink" href="#parameters_257" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be real.
s : sequence of ints, optional
Shape of the FFT.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_263">Returns<a class="headerlink" href="#returns_263" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the real 2-D FFT.</p>
<h2 id="see-also_188">See Also<a class="headerlink" href="#see-also_188" title="Permanent link">&para;</a></h2>
<p>rfftn : Compute the N-dimensional discrete Fourier Transform for real
input.</p>
<h2 id="notes_167">Notes<a class="headerlink" href="#notes_167" title="Permanent link">&para;</a></h2>
<p>This is really just <code>rfftn</code> with different default behavior.
For more details see <code>rfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,     n/2-1,     n/2] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d</em>n)   if n is odd</p>
<p>Unlike <code>fftfreq</code> (but like <code>scipy.fftpack.rfftfreq</code>)
the Nyquist frequency component is considered to be positive.</p>
<h2 id="parameters_258">Parameters<a class="headerlink" href="#parameters_258" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_264">Returns<a class="headerlink" href="#returns_264" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n//2 + 1</code> containing the sample frequencies.</p>
<h2 id="examples_212">Examples<a class="headerlink" href="#examples_212" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
fourier = np.fft.rfft(signal)
n = signal.size
sample_rate = 100
freq = np.fft.fftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
freq = np.fft.rfftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20.,  30.,  40.,  50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.</p>
<h2 id="parameters_259">Parameters<a class="headerlink" href="#parameters_259" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
The final element of <code>s</code> corresponds to <code>n</code> for <code>rfft(x, n)</code>, while
for the remaining axes, it corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_265">Returns<a class="headerlink" href="#returns_265" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_43">Raises<a class="headerlink" href="#raises_43" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_189">See Also<a class="headerlink" href="#see-also_189" title="Permanent link">&para;</a></h2>
<p>irfftn : The inverse of <code>rfftn</code>, i.e. the inverse of the n-dimensional FFT
of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.</p>
<h2 id="notes_168">Notes<a class="headerlink" href="#notes_168" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>rfft</code>, then the transform over the remaining axes is
performed as by <code>fftn</code>.  The order of the output is as for <code>rfft</code> for the
final transformation axis, and as for <code>fftn</code> for the remaining
transformation axes.</p>
<p>See <code>fft</code> for details, definitions and conventions used.</p>
<h2 id="examples_213">Examples<a class="headerlink" href="#examples_213" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.rfftn(x)
array([[[8.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
<p>scipy.fft.rfftn(x, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
[4.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_backend</span> <span class="o">:</span> <span class="o">?</span><span class="n">coerce</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">backend</span><span class="o">:[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to set the backend within a fixed scope.</p>
<p>Upon entering the <code>with</code> statement, the given backend will be added to
the list of available backends with the highest priority. Upon exit, the
backend is reset to the state before entering the scope.</p>
<h2 id="parameters_260">Parameters<a class="headerlink" href="#parameters_260" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.
coerce: bool, optional
Whether to allow expensive conversions for the <code>x</code> parameter. e.g.
copying a numpy array to the GPU for a CuPy backend. Implies <code>only</code>.
only: bool, optional
If only is <code>True</code> and this backend returns <code>NotImplemented</code> then a
BackendNotImplemented error will be raised immediately. Ignoring any
lower priority backends.</p>
<h2 id="examples_214">Examples<a class="headerlink" href="#examples_214" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
with fft.set_backend('scipy', only=True):
...     fft.fft([1])  # Always calls the scipy implementation
array([1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_global_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sets the global fft backend</p>
<p>The global backend has higher priority than registered backends, but lower
priority than context-specific backends set with <code>set_backend</code>.</p>
<h2 id="parameters_261">Parameters<a class="headerlink" href="#parameters_261" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_44">Raises<a class="headerlink" href="#raises_44" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<h2 id="notes_169">Notes<a class="headerlink" href="#notes_169" title="Permanent link">&para;</a></h2>
<p>This will overwrite the previously set global backend, which by default is
the SciPy implementation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_workers</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager for the default number of workers used in <code>scipy.fft</code></p>
<h2 id="parameters_262">Parameters<a class="headerlink" href="#parameters_262" title="Permanent link">&para;</a></h2>
<p>workers : int
The default number of workers to use</p>
<h2 id="examples_215">Examples<a class="headerlink" href="#examples_215" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft, signal
x = np.random.randn(128, 64)
with fft.set_workers(4):
...     y = signal.fftconvolve(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">skip_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to skip a backend within a fixed scope.</p>
<p>Within the context of a <code>with</code> statement, the given backend will not be
called. This covers backends registered both locally and globally. Upon
exit, the backend will again be considered.</p>
<h2 id="parameters_263">Parameters<a class="headerlink" href="#parameters_263" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to skip.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="examples_216">Examples<a class="headerlink" href="#examples_216" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
fft.fft([1])  # Calls default scipy backend
array([1.+0.j])
with fft.skip_backend('scipy'):  # We expicitly skip the scipy backend
...     fft.fft([1])                 # leaving no implementation available
Traceback (most recent call last):
...
BackendNotImplementedError: No selected backends had an implementation ...</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">axis_reverse</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverse the 1-d slices of <code>a</code> along axis <code>axis</code>.</p>
<p>Returns axis_slice(a, step=-1, axis=axis).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">axis_slice</span> <span class="o">:</span> <span class="o">?</span><span class="n">start</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stop</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">step</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Take a slice along axis 'axis' from 'a'.</p>
<h2 id="parameters_264">Parameters<a class="headerlink" href="#parameters_264" title="Permanent link">&para;</a></h2>
<p>a : numpy.ndarray
The array to be sliced.
start, stop, step : int or None
The slice parameters.
axis : int, optional
The axis of <code>a</code> to be sliced.</p>
<h2 id="examples_217">Examples<a class="headerlink" href="#examples_217" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
axis_slice(a, start=0, stop=1, axis=1)
array([[1],
[4],
[7]])
axis_slice(a, start=1, axis=0)
array([[4, 5, 6],
[7, 8, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_170">Notes<a class="headerlink" href="#notes_170" title="Permanent link">&para;</a></h2>
<p>The keyword arguments start, stop and step are used by calling
slice(start, stop, step).  This implies axis_slice() does not
handle its arguments the exactly the same as indexing.  To select
a single index k, for example, use
axis_slice(a, start=k, stop=k+1)
In this case, the length of the axis 'axis' in the result will
be 1; the trivial dimension is not removed. (Use numpy.squeeze()
to remove trivial axes.)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheby1</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev type I digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Chebyshev type I filter and
return the filter coefficients.</p>
<h2 id="parameters_265">Parameters<a class="headerlink" href="#parameters_265" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rp : float
The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For Type I filters, this is the point in the transition band at which
the gain first drops below -<code>rp</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_266">Returns<a class="headerlink" href="#returns_266" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_190">See Also<a class="headerlink" href="#see-also_190" title="Permanent link">&para;</a></h2>
<p>cheb1ord, cheb1ap</p>
<h2 id="notes_171">Notes<a class="headerlink" href="#notes_171" title="Permanent link">&para;</a></h2>
<p>The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.</p>
<p>Type I filters roll off faster than Type II (<code>cheby2</code>), but Type II
filters do not have any ripple in the passband.</p>
<p>The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_218">Examples<a class="headerlink" href="#examples_218" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Chebyshev Type I frequency response (rp=5)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-5, color='green') # rp
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.cheby1(10, 1, 15, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 15 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose_conv_method</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">measure</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find the fastest convolution/correlation method.</p>
<p>This primarily exists to be called during the <code>method='auto'</code> option in
<code>convolve</code> and <code>correlate</code>. It can also be used to determine the value of
<code>method</code> for many different convolutions of the same dtype/shape.
In addition, it supports timing the convolution to adapt the value of
<code>method</code> to a particular set of inputs and/or hardware.</p>
<h2 id="parameters_266">Parameters<a class="headerlink" href="#parameters_266" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
The first argument passed into the convolution function.
in2 : array_like
The second argument passed into the convolution function.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
measure : bool, optional
If True, run and time the convolution of <code>in1</code> and <code>in2</code> with both
methods and return the fastest. If False (default), predict the fastest
method using precomputed values.</p>
<h2 id="returns_267">Returns<a class="headerlink" href="#returns_267" title="Permanent link">&para;</a></h2>
<p>method : str
A string indicating which convolution method is fastest, either
'direct' or 'fft'
times : dict, optional
A dictionary containing the times (in seconds) needed for each method.
This value is only returned if <code>measure=True</code>.</p>
<h2 id="see-also_191">See Also<a class="headerlink" href="#see-also_191" title="Permanent link">&para;</a></h2>
<p>convolve
correlate</p>
<h2 id="notes_172">Notes<a class="headerlink" href="#notes_172" title="Permanent link">&para;</a></h2>
<p>Generally, this method is 99% accurate for 2D signals and 85% accurate
for 1D signals for randomly chosen input sizes. For precision, use
<code>measure=True</code> to find the fastest method by timing the convolution.
This can be used to avoid the minimal overhead of finding the fastest
<code>method</code> later, or to adapt the value of <code>method</code> to a particular set
of inputs.</p>
<p>Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this
function. These experiments measured the ratio between the time required
when using <code>method='auto'</code> and the time required for the fastest method
(i.e., <code>ratio = time_auto / min(time_fft, time_direct)</code>). In these
experiments, we found:</p>
<ul>
<li>There is a 95% chance of this ratio being less than 1.5 for 1D signals
and a 99% chance of being less than 2.5 for 2D signals.</li>
<li>The ratio was always less than 2.5/5 for 1D/2D signals respectively.</li>
<li>This function is most inaccurate for 1D convolutions that take between 1
and 10 milliseconds with <code>method='direct'</code>. A good proxy for this
(at least in our experiments) is <code>1e6 &lt;= in1.size * in2.size &lt;= 1e7</code>.</li>
</ul>
<p>The 2D results almost certainly generalize to 3D/4D/etc because the
implementation is the same (the 1D implementation is different).</p>
<p>All the numbers above are specific to the EC2 machine. However, we did find
that this function generalizes fairly decently across hardware. The speed
tests were of similar quality (and even slightly better) than the same
tests performed on the machine to tune this function's numbers (a mid-2014
15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).</p>
<p>There are cases when <code>fftconvolve</code> supports the inputs but this function
returns <code>direct</code> (e.g., to protect against floating point integer
precision).</p>
<p>.. versionadded:: 0.19</p>
<h2 id="examples_219">Examples<a class="headerlink" href="#examples_219" title="Permanent link">&para;</a></h2>
<p>Estimate the fastest method for a given input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
img = np.random.rand(32, 32)
filter = np.random.rand(8, 8)
method = signal.choose_conv_method(img, filter, mode='same')
method
'fft'</p>
</blockquote>
</blockquote>
</blockquote>
<p>This can then be applied to other arrays of the same dtype and shape:</p>
<blockquote>
<blockquote>
<blockquote>
<p>img2 = np.random.rand(32, 32)
filter2 = np.random.rand(8, 8)
corr2 = signal.correlate(img2, filter2, mode='same', method=method)
conv2 = signal.convolve(img2, filter2, mode='same', method=method)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The output of this function (<code>method</code>) works with <code>correlate</code> and
<code>convolve</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cmplx_sort</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Sort roots based on magnitude.</p>
<h2 id="parameters_267">Parameters<a class="headerlink" href="#parameters_267" title="Permanent link">&para;</a></h2>
<p>p : array_like
The roots to sort, as a 1-D array.</p>
<h2 id="returns_268">Returns<a class="headerlink" href="#returns_268" title="Permanent link">&para;</a></h2>
<p>p_sorted : ndarray
Sorted roots.
indx : ndarray
Array of indices needed to sort the input <code>p</code>.</p>
<h2 id="examples_220">Examples<a class="headerlink" href="#examples_220" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
vals = [1, 4, 1+1.j, 3]
p_sorted, indx = signal.cmplx_sort(vals)
p_sorted
array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])
indx
array([0, 2, 3, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">const_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Constant extension at the boundaries of an array</p>
<p>Generate a new ndarray that is a constant extension of <code>x</code> along an axis.</p>
<p>The extension repeats the values at the first and last element of
the axis.</p>
<h2 id="parameters_268">Parameters<a class="headerlink" href="#parameters_268" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_221">Examples<a class="headerlink" href="#examples_221" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import const_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
const_ext(a, 2)
array([[ 1,  1,  1,  2,  3,  4,  5,  5,  5],
[ 0,  0,  0,  1,  4,  9, 16, 16, 16]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constant extension continues with the same values as the endpoints of the
array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = const_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='constant extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fft</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays.</p>
<p>Convolve <code>in1</code> and <code>in2</code>, with the output size determined by the
<code>mode</code> argument.</p>
<h2 id="parameters_269">Parameters<a class="headerlink" href="#parameters_269" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the convolution.</p>
<p><code>direct</code>
The convolution is determined directly from sums, the definition of
convolution.
<code>fft</code>
The Fourier Transform is used to perform the convolution by calling
<code>fftconvolve</code>.
<code>auto</code>
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See Notes for more detail.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="returns_269">Returns<a class="headerlink" href="#returns_269" title="Permanent link">&para;</a></h2>
<p>convolve : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_192">See Also<a class="headerlink" href="#see-also_192" title="Permanent link">&para;</a></h2>
<p>numpy.polymul : performs polynomial multiplication (same operation, but
also accepts poly1d objects)
choose_conv_method : chooses the fastest appropriate convolution method
fftconvolve : Always uses the FFT method.
oaconvolve : Uses the overlap-add method to do convolution, which is
generally faster when the input arrays are large and
significantly different in size.</p>
<h2 id="notes_173">Notes<a class="headerlink" href="#notes_173" title="Permanent link">&para;</a></h2>
<p>By default, <code>convolve</code> and <code>correlate</code> use <code>method='auto'</code>, which calls
<code>choose_conv_method</code> to choose the fastest method using pre-computed
values (<code>choose_conv_method</code> can also measure real-world timing with a
keyword argument). Because <code>fftconvolve</code> relies on floating point numbers,
there are certain constraints that may force <code>method=direct</code> (more detail
in <code>choose_conv_method</code> docstring).</p>
<h2 id="examples_222">Examples<a class="headerlink" href="#examples_222" title="Permanent link">&para;</a></h2>
<p>Smooth a square pulse using a Hann window:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.repeat([0., 1., 0.], 100)
win = signal.hann(50)
filtered = signal.convolve(sig, win, mode='same') / sum(win)</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)
ax_orig.plot(sig)
ax_orig.set_title('Original pulse')
ax_orig.margins(0, 0.1)
ax_win.plot(win)
ax_win.set_title('Filter impulse response')
ax_win.margins(0, 0.1)
ax_filt.plot(filtered)
ax_filt.set_title('Filtered signal')
ax_filt.margins(0, 0.1)
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">Fill</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Symm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fillvalue</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two 2-dimensional arrays.</p>
<p>Convolve <code>in1</code> and <code>in2</code> with output size determined by <code>mode</code>, and
boundary conditions determined by <code>boundary</code> and <code>fillvalue</code>.</p>
<h2 id="parameters_270">Parameters<a class="headerlink" href="#parameters_270" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
A flag indicating how to handle boundaries:</p>
<p><code>fill</code>
pad input arrays with fillvalue. (default)
<code>wrap</code>
circular boundary conditions.
<code>symm</code>
symmetrical boundary conditions.</p>
<p>fillvalue : scalar, optional
Value to fill pad input arrays with. Default is 0.</p>
<h2 id="returns_270">Returns<a class="headerlink" href="#returns_270" title="Permanent link">&para;</a></h2>
<p>out : ndarray
A 2-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="examples_223">Examples<a class="headerlink" href="#examples_223" title="Permanent link">&para;</a></h2>
<p>Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy import misc
ascent = misc.ascent()
scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],
...                    [-10+0j, 0+ 0j, +10 +0j],
...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy
grad = signal.convolve2d(ascent, scharr, boundary='symm', mode='same')</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))
ax_orig.imshow(ascent, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_mag.imshow(np.absolute(grad), cmap='gray')
ax_mag.set_title('Gradient magnitude')
ax_mag.set_axis_off()
ax_ang.imshow(np.angle(grad), cmap='hsv') # hsv is cyclic, like angles
ax_ang.set_title('Gradient orientation')
ax_ang.set_axis_off()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fft</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cross-correlate two N-dimensional arrays.</p>
<p>Cross-correlate <code>in1</code> and <code>in2</code>, with the output size determined by the
<code>mode</code> argument.</p>
<h2 id="parameters_271">Parameters<a class="headerlink" href="#parameters_271" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear cross-correlation
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the correlation.</p>
<p><code>direct</code>
The correlation is determined directly from sums, the definition of
correlation.
<code>fft</code>
The Fast Fourier Transform is used to perform the correlation more
quickly (only available for numerical arrays.)
<code>auto</code>
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See <code>convolve</code> Notes for more detail.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="returns_271">Returns<a class="headerlink" href="#returns_271" title="Permanent link">&para;</a></h2>
<p>correlate : array
An N-dimensional array containing a subset of the discrete linear
cross-correlation of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_193">See Also<a class="headerlink" href="#see-also_193" title="Permanent link">&para;</a></h2>
<p>choose_conv_method : contains more documentation on <code>method</code>.</p>
<h2 id="notes_174">Notes<a class="headerlink" href="#notes_174" title="Permanent link">&para;</a></h2>
<p>The correlation z of two d-dimensional arrays x and y is defined as::</p>
<p>z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])</p>
<p>This way, if x and y are 1-D arrays and <code>z = correlate(x, y, 'full')</code>
then</p>
<p>.. math::</p>
<p>z[k] = (x * y)(k - N + 1)
= \sum_{l=0}^{ ||x||-1}x_l y_{l-k+N-1}^{*}</p>
<p>for :math:<code>k = 0, 1, ..., ||x|| + ||y|| - 2</code></p>
<p>where :math:<code>||x||</code> is the length of <code>x</code>, :math:<code>N = \max(||x||,||y||)</code>,
and :math:<code>y_m</code> is 0 when m is outside the range of y.</p>
<p><code>method='fft'</code> only works for numerical arrays as it relies on
<code>fftconvolve</code>. In certain cases (i.e., arrays of objects or when
rounding integers can lose precision), <code>method='direct'</code> is always used.</p>
<h2 id="examples_224">Examples<a class="headerlink" href="#examples_224" title="Permanent link">&para;</a></h2>
<p>Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)
sig_noise = sig + np.random.randn(len(sig))
corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128</p>
<p>import matplotlib.pyplot as plt
clock = np.arange(64, len(sig), 128)
fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)
ax_orig.plot(sig)
ax_orig.plot(clock, sig[clock], 'ro')
ax_orig.set_title('Original signal')
ax_noise.plot(sig_noise)
ax_noise.set_title('Signal with noise')
ax_corr.plot(corr)
ax_corr.plot(clock, corr[clock], 'ro')
ax_corr.axhline(0.5, ls=':')
ax_corr.set_title('Cross-correlated with rectangular pulse')
ax_orig.margins(0, 0.1)
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">Fill</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Symm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fillvalue</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cross-correlate two 2-dimensional arrays.</p>
<p>Cross correlate <code>in1</code> and <code>in2</code> with output size determined by <code>mode</code>, and
boundary conditions determined by <code>boundary</code> and <code>fillvalue</code>.</p>
<h2 id="parameters_272">Parameters<a class="headerlink" href="#parameters_272" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear cross-correlation
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
A flag indicating how to handle boundaries:</p>
<p><code>fill</code>
pad input arrays with fillvalue. (default)
<code>wrap</code>
circular boundary conditions.
<code>symm</code>
symmetrical boundary conditions.</p>
<p>fillvalue : scalar, optional
Value to fill pad input arrays with. Default is 0.</p>
<h2 id="returns_272">Returns<a class="headerlink" href="#returns_272" title="Permanent link">&para;</a></h2>
<p>correlate2d : ndarray
A 2-dimensional array containing a subset of the discrete linear
cross-correlation of <code>in1</code> with <code>in2</code>.</p>
<h2 id="examples_225">Examples<a class="headerlink" href="#examples_225" title="Permanent link">&para;</a></h2>
<p>Use 2D cross-correlation to find the location of a template in a noisy
image:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy import misc
face = misc.face(gray=True) - misc.face(gray=True).mean()
template = np.copy(face[300:365, 670:750])  # right eye
template -= template.mean()
face = face + np.random.randn( *face.shape) * 50  # add noise
corr = signal.correlate2d(face, template, boundary='symm', mode='same')
y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,
...                                                     figsize=(6, 15))
ax_orig.imshow(face, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_template.imshow(template, cmap='gray')
ax_template.set_title('Template')
ax_template.set_axis_off()
ax_corr.imshow(corr, cmap='gray')
ax_corr.set_title('Cross-correlation')
ax_corr.set_axis_off()
ax_orig.plot(x, y, 'ro')
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">decimate</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:[`</span><span class="nc">Fir</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iir</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_dlti_instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zero_phase</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Downsample the signal after applying an anti-aliasing filter.</p>
<p>By default, an order 8 Chebyshev type I filter is used. A 30 point FIR
filter with Hamming window is used if <code>ftype</code> is 'fir'.</p>
<h2 id="parameters_273">Parameters<a class="headerlink" href="#parameters_273" title="Permanent link">&para;</a></h2>
<p>x : array_like
The signal to be downsampled, as an N-dimensional array.
q : int
The downsampling factor. When using IIR downsampling, it is recommended
to call <code>decimate</code> multiple times for downsampling factors higher than
13.
n : int, optional
The order of the filter (1 less than the length for 'fir'). Defaults to
8 for 'iir' and 20 times the downsampling factor for 'fir'.
ftype : str {'iir', 'fir'} or <code>dlti</code> instance, optional
If 'iir' or 'fir', specifies the type of lowpass filter. If an instance
of an <code>dlti</code> object, uses that object to filter before downsampling.
axis : int, optional
The axis along which to decimate.
zero_phase : bool, optional
Prevent phase shift by filtering with <code>filtfilt</code> instead of <code>lfilter</code>
when using an IIR filter, and shifting the outputs back by the filter's
group delay when using an FIR filter. The default value of <code>True</code> is
recommended, since a phase shift is generally not desired.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_273">Returns<a class="headerlink" href="#returns_273" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The down-sampled signal.</p>
<h2 id="see-also_194">See Also<a class="headerlink" href="#see-also_194" title="Permanent link">&para;</a></h2>
<p>resample : Resample up or down using the FFT method.
resample_poly : Resample using polyphase filtering and an FIR filter.</p>
<h2 id="notes_175">Notes<a class="headerlink" href="#notes_175" title="Permanent link">&para;</a></h2>
<p>The <code>zero_phase</code> keyword was added in 0.18.0.
The possibility to use instances of <code>dlti</code> as <code>ftype</code> was added in
0.18.0.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deconvolve</span> <span class="o">:</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">divisor</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Deconvolves <code>divisor</code> out of <code>signal</code> using inverse filtering.</p>
<p>Returns the quotient and remainder such that
<code>signal = convolve(divisor, quotient) + remainder</code></p>
<h2 id="parameters_274">Parameters<a class="headerlink" href="#parameters_274" title="Permanent link">&para;</a></h2>
<p>signal : array_like
Signal data, typically a recorded signal
divisor : array_like
Divisor data, typically an impulse response or filter that was
applied to the original signal</p>
<h2 id="returns_274">Returns<a class="headerlink" href="#returns_274" title="Permanent link">&para;</a></h2>
<p>quotient : ndarray
Quotient, typically the recovered original signal
remainder : ndarray
Remainder</p>
<h2 id="examples_226">Examples<a class="headerlink" href="#examples_226" title="Permanent link">&para;</a></h2>
<p>Deconvolve a signal that's been filtered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
original = [0, 1, 0, 0, 1, 1, 0, 0]
impulse_response = [2, 1]
recorded = signal.convolve(impulse_response, original)
recorded
array([0, 2, 1, 0, 2, 3, 1, 0, 0])
recovered, remainder = signal.deconvolve(recorded, impulse_response)
recovered
array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_195">See Also<a class="headerlink" href="#see-also_195" title="Permanent link">&para;</a></h2>
<p>numpy.polydiv : performs polynomial division (same operation, but
also accepts poly1d objects)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">detrend</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Linear</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_data</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove linear trend along axis from data.</p>
<h2 id="parameters_275">Parameters<a class="headerlink" href="#parameters_275" title="Permanent link">&para;</a></h2>
<p>data : array_like
The input data.
axis : int, optional
The axis along which to detrend the data. By default this is the
last axis (-1).
type : {'linear', 'constant'}, optional
The type of detrending. If <code>type == 'linear'</code> (default),
the result of a linear least-squares fit to <code>data</code> is subtracted
from <code>data</code>.
If <code>type == 'constant'</code>, only the mean of <code>data</code> is subtracted.
bp : array_like of ints, optional
A sequence of break points. If given, an individual linear fit is
performed for each part of <code>data</code> between two break points.
Break points are specified as indices into <code>data</code>.
overwrite_data : bool, optional
If True, perform in place detrending and avoid a copy. Default is False</p>
<h2 id="returns_275">Returns<a class="headerlink" href="#returns_275" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
The detrended input data.</p>
<h2 id="examples_227">Examples<a class="headerlink" href="#examples_227" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
randgen = np.random.RandomState(9)
npoints = 1000
noise = randgen.randn(npoints)
x = 3 + 2*np.linspace(0, 1, npoints) + noise
(signal.detrend(x) - noise).max() &lt; 0.01
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">even_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Even extension at the boundaries of an array</p>
<p>Generate a new ndarray by making an even extension of <code>x</code> along an axis.</p>
<h2 id="parameters_276">Parameters<a class="headerlink" href="#parameters_276" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_228">Examples<a class="headerlink" href="#examples_228" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import even_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
even_ext(a, 2)
array([[ 3,  2,  1,  2,  3,  4,  5,  4,  3],
[ 4,  1,  0,  1,  4,  9, 16,  9,  4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even extension is a 'mirror image' at the boundaries of the original array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = even_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='even extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">factorial</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The factorial of a number or array of numbers.</p>
<p>The factorial of non-negative integer <code>n</code> is the product of all
positive integers less than or equal to <code>n</code>::</p>
<p>n! = n * (n - 1) * (n - 2) * ... * 1</p>
<h2 id="parameters_277">Parameters<a class="headerlink" href="#parameters_277" title="Permanent link">&para;</a></h2>
<p>n : int or array_like of ints
Input values.  If <code>n &lt; 0</code>, the return value is 0.
exact : bool, optional
If True, calculate the answer exactly using long integer arithmetic.
If False, result is approximated in floating point rapidly using the
<code>gamma</code> function.
Default is False.</p>
<h2 id="returns_276">Returns<a class="headerlink" href="#returns_276" title="Permanent link">&para;</a></h2>
<p>nf : float or int or ndarray
Factorial of <code>n</code>, as integer or float depending on <code>exact</code>.</p>
<h2 id="notes_176">Notes<a class="headerlink" href="#notes_176" title="Permanent link">&para;</a></h2>
<p>For arrays with <code>exact=True</code>, the factorial is computed only once, for
the largest input, with each other result computed in the process.
The output dtype is increased to <code>int64</code> or <code>object</code> if necessary.</p>
<p>With <code>exact=False</code> the factorial is approximated using the gamma
function:</p>
<p>.. math:: n! = \Gamma(n+1)</p>
<h2 id="examples_229">Examples<a class="headerlink" href="#examples_229" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import factorial
arr = np.array([3, 4, 5])
factorial(arr, exact=False)
array([   6.,   24.,  120.])
factorial(arr, exact=True)
array([  6,  24, 120])
factorial(5, exact=True)
120L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftconvolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays using FFT.</p>
<p>Convolve <code>in1</code> and <code>in2</code> using the fast Fourier transform method, with
the output size determined by the <code>mode</code> argument.</p>
<p>This is generally much faster than <code>convolve</code> for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<p>As of v0.19, <code>convolve</code> automatically chooses this method or the direct
method based on an estimation of which is faster.</p>
<h2 id="parameters_278">Parameters<a class="headerlink" href="#parameters_278" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
axes : int or array_like of ints or None, optional
Axes over which to compute the convolution.
The default is over all axes.</p>
<h2 id="returns_277">Returns<a class="headerlink" href="#returns_277" title="Permanent link">&para;</a></h2>
<p>out : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_196">See Also<a class="headerlink" href="#see-also_196" title="Permanent link">&para;</a></h2>
<p>convolve : Uses the direct convolution or FFT convolution algorithm
depending on which is faster.
oaconvolve : Uses the overlap-add method to do convolution, which is
generally faster when the input arrays are large and
significantly different in size.</p>
<h2 id="examples_230">Examples<a class="headerlink" href="#examples_230" title="Permanent link">&para;</a></h2>
<p>Autocorrelation of white noise is an impulse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.random.randn(1000)
autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
ax_orig.plot(sig)
ax_orig.set_title('White noise')
ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)
ax_mag.set_title('Autocorrelation')
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The <code>convolve2d</code> function allows for other types of image boundaries,
but is far slower.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import misc
face = misc.face(gray=True)
kernel = np.outer(signal.gaussian(70, 8), signal.gaussian(70, 8))
blurred = signal.fftconvolve(face, kernel, mode='same')</p>
<p>fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,
...                                                      figsize=(6, 15))
ax_orig.imshow(face, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_kernel.imshow(kernel, cmap='gray')
ax_kernel.set_title('Gaussian kernel')
ax_kernel.set_axis_off()
ax_blurred.imshow(blurred, cmap='gray')
ax_blurred.set_title('Blurred')
ax_blurred.set_axis_off()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">filtfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">irlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply a digital filter forward and backward to a signal.</p>
<p>This function applies a linear digital filter twice, once forward and
once backwards.  The combined filter has zero phase and a filter order
twice that of the original.</p>
<p>The function provides options for handling the edges of the signal.</p>
<p>The function <code>sosfiltfilt</code> (and filter design using <code>output='sos'</code>)
should be preferred over <code>filtfilt</code> for most filtering tasks, as
second-order sections have fewer numerical problems.</p>
<h2 id="parameters_279">Parameters<a class="headerlink" href="#parameters_279" title="Permanent link">&para;</a></h2>
<p>b : (N,) array_like
The numerator coefficient vector of the filter.
a : (N,) array_like
The denominator coefficient vector of the filter.  If <code>a[0]</code>
is not 1, then both <code>a</code> and <code>b</code> are normalized by <code>a[0]</code>.
x : array_like
The array of data to be filtered.
axis : int, optional
The axis of <code>x</code> to which the filter is applied.
Default is -1.
padtype : str or None, optional
Must be 'odd', 'even', 'constant', or None.  This determines the
type of extension to use for the padded signal to which the filter
is applied.  If <code>padtype</code> is None, no padding is used.  The default
is 'odd'.
padlen : int or None, optional
The number of elements by which to extend <code>x</code> at both ends of
<code>axis</code> before applying the filter.  This value must be less than
<code>x.shape[axis] - 1</code>.  <code>padlen=0</code> implies no padding.
The default value is <code>3 * max(len(a), len(b))</code>.
method : str, optional
Determines the method for handling the edges of the signal, either
'pad' or 'gust'.  When <code>method</code> is 'pad', the signal is padded; the
type of padding is determined by <code>padtype</code> and <code>padlen</code>, and <code>irlen</code>
is ignored.  When <code>method</code> is 'gust', Gustafsson's method is used,
and <code>padtype</code> and <code>padlen</code> are ignored.
irlen : int or None, optional
When <code>method</code> is 'gust', <code>irlen</code> specifies the length of the
impulse response of the filter.  If <code>irlen</code> is None, no part
of the impulse response is ignored.  For a long signal, specifying
<code>irlen</code> can significantly improve the performance of the filter.</p>
<h2 id="returns_278">Returns<a class="headerlink" href="#returns_278" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The filtered output with the same shape as <code>x</code>.</p>
<h2 id="see-also_197">See Also<a class="headerlink" href="#see-also_197" title="Permanent link">&para;</a></h2>
<p>sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt</p>
<h2 id="notes_177">Notes<a class="headerlink" href="#notes_177" title="Permanent link">&para;</a></h2>
<p>When <code>method</code> is 'pad', the function pads the data along the given axis
in one of three ways: odd, even or constant.  The odd and even extensions
have the corresponding symmetry about the end point of the data.  The
constant extension extends the data with the values at the end points. On
both the forward and backward passes, the initial condition of the
filter is found by using <code>lfilter_zi</code> and scaling it by the end point of
the extended data.</p>
<p>When <code>method</code> is 'gust', Gustafsson's method [1]_ is used.  Initial
conditions are chosen for the forward and backward passes so that the
forward-backward filter gives the same result as the backward-forward
filter.</p>
<p>The option to use Gustaffson's method was added in scipy version 0.16.0.</p>
<h2 id="references_41">References<a class="headerlink" href="#references_41" title="Permanent link">&para;</a></h2>
<p>.. [1] F. Gustaffson, 'Determining the initial states in forward-backward
filtering', Transactions on Signal Processing, Vol. 46, pp. 988-992,
1996.</p>
<h2 id="examples_231">Examples<a class="headerlink" href="#examples_231" title="Permanent link">&para;</a></h2>
<p>The examples will use several functions from <code>scipy.signal</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we create a one second signal that is the sum of two pure sine
waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.0, 2001)
xlow = np.sin(2 * np.pi * 5 * t)
xhigh = np.sin(2 * np.pi * 250 * t)
x = xlow + xhigh</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now create a lowpass Butterworth filter with a cutoff of 0.125 times
the Nyquist frequency, or 125 Hz, and apply it to <code>x</code> with <code>filtfilt</code>.
The result should be approximately <code>xlow</code>, with no phase shift.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.butter(8, 0.125)
y = signal.filtfilt(b, a, x, padlen=150)
np.abs(y - xlow).max()
9.1086182074789912e-06</p>
</blockquote>
</blockquote>
</blockquote>
<p>We get a fairly clean result for this artificial example because
the odd extension is exact, and with the moderately long padding,
the filter's transients have dissipated by the time the actual data
is reached.  In general, transient effects at the edges are
unavoidable.</p>
<p>The following example demonstrates the option <code>method='gust'</code>.</p>
<p>First, create a filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.
np.random.seed(123456)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>sig</code> is a random input signal to be filtered.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 60
sig = np.random.randn(n)*<em>3 + 3</em>np.random.randn(n).cumsum()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply <code>filtfilt</code> to <code>sig</code>, once using the Gustafsson method, and
once using padding, and plot the results for comparison.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fgust = signal.filtfilt(b, a, sig, method='gust')
fpad = signal.filtfilt(b, a, sig, padlen=50)
plt.plot(sig, 'k-', label='input')
plt.plot(fgust, 'b-', linewidth=4, label='gust')
plt.plot(fpad, 'c-', linewidth=1.5, label='pad')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>irlen</code> argument can be used to improve the performance
of Gustafsson's method.</p>
<p>Estimate the impulse response length of the filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z, p, k = signal.tf2zpk(b, a)
eps = 1e-9
r = np.max(np.abs(p))
approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))
approx_impulse_len
137</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter to a longer signal, with and without the <code>irlen</code>
argument.  The difference between <code>y1</code> and <code>y2</code> is small.  For long
signals, using <code>irlen</code> gives a significant performance improvement.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.random.randn(5000)
y1 = signal.filtfilt(b, a, x, method='gust')
y2 = signal.filtfilt(b, a, x, method='gust', irlen=approx_impulse_len)
print(np.max(np.abs(y1 - y2)))
1.80056858312e-10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple_of_string_and_parameter_values</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pass_zero</span><span class="o">:[`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">cutoff</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T1D_array_like</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using the window method.</p>
<p>This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
<code>numtaps</code> is odd and Type II if <code>numtaps</code> is even.</p>
<p>Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with <code>numtaps</code> even and
having a passband whose right end is at the Nyquist frequency.</p>
<h2 id="parameters_280">Parameters<a class="headerlink" href="#parameters_280" title="Permanent link">&para;</a></h2>
<p>numtaps : int
Length of the filter (number of coefficients, i.e. the filter
order + 1).  <code>numtaps</code> must be odd if a passband includes the
Nyquist frequency.
cutoff : float or 1D array_like
Cutoff frequency of filter (expressed in the same units as <code>fs</code>)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in <code>cutoff</code> should be positive and
monotonically increasing between 0 and <code>fs/2</code>.  The values 0 and
<code>fs/2</code> must not be included in <code>cutoff</code>.
width : float or None, optional
If <code>width</code> is not None, then assume it is the approximate width
of the transition region (expressed in the same units as <code>fs</code>)
for use in Kaiser FIR filter design.  In this case, the <code>window</code>
argument is ignored.
window : string or tuple of string and parameter values, optional
Desired window to use. See <code>scipy.signal.get_window</code> for a list
of windows and required parameters.
pass_zero : {True, False, 'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
If True, the gain at the frequency 0 (i.e. the 'DC gain') is 1.
If False, the DC gain is 0. Can also be a string argument for the
desired filter type (equivalent to <code>btype</code> in IIR design functions).</p>
<p>.. versionadded:: 1.3.0
Support for string arguments.
scale : bool, optional
Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:</p>
<ul>
<li>0 (DC) if the first passband starts at 0 (i.e. pass_zero
is True)</li>
<li><code>fs/2</code> (the Nyquist frequency) if the first passband ends at
<code>fs/2</code> (i.e the filter is a single band highpass filter);
center of first passband otherwise</li>
</ul>
<p>nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>  This is the Nyquist frequency.
Each frequency in <code>cutoff</code> must be between 0 and <code>nyq</code>. Default
is 1.
fs : float, optional
The sampling frequency of the signal.  Each frequency in <code>cutoff</code>
must be between 0 and <code>fs/2</code>.  Default is 2.</p>
<h2 id="returns_279">Returns<a class="headerlink" href="#returns_279" title="Permanent link">&para;</a></h2>
<p>h : (numtaps,) ndarray
Coefficients of length <code>numtaps</code> FIR filter.</p>
<h2 id="raises_45">Raises<a class="headerlink" href="#raises_45" title="Permanent link">&para;</a></h2>
<p>ValueError
If any value in <code>cutoff</code> is less than or equal to 0 or greater
than or equal to <code>fs/2</code>, if the values in <code>cutoff</code> are not strictly
monotonically increasing, or if <code>numtaps</code> is even but a passband
includes the Nyquist frequency.</p>
<h2 id="see-also_198">See Also<a class="headerlink" href="#see-also_198" title="Permanent link">&para;</a></h2>
<p>firwin2
firls
minimum_phase
remez</p>
<h2 id="examples_232">Examples<a class="headerlink" href="#examples_232" title="Permanent link">&para;</a></h2>
<p>Low-pass from 0 to f:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
numtaps = 3
f = 0.1
signal.firwin(numtaps, f)
array([ 0.06799017,  0.86401967,  0.06799017])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use a specific window function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, window='nuttall')
array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</p>
</blockquote>
</blockquote>
</blockquote>
<p>High-pass ('stop' from 0 to f):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, pass_zero=False)
array([-0.00859313,  0.98281375, -0.00859313])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-pass:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f1, f2 = 0.1, 0.2
signal.firwin(numtaps, [f1, f2], pass_zero=False)
array([ 0.06301614,  0.88770441,  0.06301614])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-stop:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2])
array([-0.00801395,  1.0160279 , -0.00801395])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>f3, f4 = 0.3, 0.4
signal.firwin(numtaps, [f1, f2, f3, f4])
array([-0.01376344,  1.02752689, -0.01376344])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [f1, f2] and [f3,f4]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)
array([ 0.04890915,  0.91284326,  0.04890915])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gcd</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>greatest common divisor of x and y</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_window</span> <span class="o">:</span> <span class="o">?</span><span class="n">fftbins</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window of a given length and type.</p>
<h2 id="parameters_281">Parameters<a class="headerlink" href="#parameters_281" title="Permanent link">&para;</a></h2>
<p>window : string, float, or tuple
The type of window to create. See below for more details.
Nx : int
The number of samples in the window.
fftbins : bool, optional
If True (default), create a 'periodic' window, ready to use with
<code>ifftshift</code> and be multiplied by the result of an FFT (see also
:func:<code>~scipy.fft.fftfreq</code>).
If False, create a 'symmetric' window, for use in filter design.</p>
<h2 id="returns_280">Returns<a class="headerlink" href="#returns_280" title="Permanent link">&para;</a></h2>
<p>get_window : ndarray
Returns a window of length <code>Nx</code> and type <code>window</code></p>
<h2 id="notes_178">Notes<a class="headerlink" href="#notes_178" title="Permanent link">&para;</a></h2>
<p>Window types:</p>
<ul>
<li><code>~scipy.signal.windows.boxcar</code></li>
<li><code>~scipy.signal.windows.triang</code></li>
<li><code>~scipy.signal.windows.blackman</code></li>
<li><code>~scipy.signal.windows.hamming</code></li>
<li><code>~scipy.signal.windows.hann</code></li>
<li><code>~scipy.signal.windows.bartlett</code></li>
<li><code>~scipy.signal.windows.flattop</code></li>
<li><code>~scipy.signal.windows.parzen</code></li>
<li><code>~scipy.signal.windows.bohman</code></li>
<li><code>~scipy.signal.windows.blackmanharris</code></li>
<li><code>~scipy.signal.windows.nuttall</code></li>
<li><code>~scipy.signal.windows.barthann</code></li>
<li><code>~scipy.signal.windows.kaiser</code> (needs beta)</li>
<li><code>~scipy.signal.windows.gaussian</code> (needs standard deviation)</li>
<li><code>~scipy.signal.windows.general_gaussian</code> (needs power, width)</li>
<li><code>~scipy.signal.windows.slepian</code> (needs width)</li>
<li><code>~scipy.signal.windows.dpss</code> (needs normalized half-bandwidth)</li>
<li><code>~scipy.signal.windows.chebwin</code> (needs attenuation)</li>
<li><code>~scipy.signal.windows.exponential</code> (needs decay scale)</li>
<li><code>~scipy.signal.windows.tukey</code> (needs taper fraction)</li>
</ul>
<p>If the window requires no parameters, then <code>window</code> can be a string.</p>
<p>If the window requires parameters, then <code>window</code> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <code>window</code> is a floating point number, it is interpreted as the beta
parameter of the <code>~scipy.signal.windows.kaiser</code> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<h2 id="examples_233">Examples<a class="headerlink" href="#examples_233" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.get_window('triang', 7)
array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])
signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])
signal.get_window(4.0, 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the analytic signal, using the Hilbert transform.</p>
<p>The transformation is done along the last axis by default.</p>
<h2 id="parameters_282">Parameters<a class="headerlink" href="#parameters_282" title="Permanent link">&para;</a></h2>
<p>x : array_like
Signal data.  Must be real.
N : int, optional
Number of Fourier components.  Default: <code>x.shape[axis]</code>
axis : int, optional
Axis along which to do the transformation.  Default: -1.</p>
<h2 id="returns_281">Returns<a class="headerlink" href="#returns_281" title="Permanent link">&para;</a></h2>
<p>xa : ndarray
Analytic signal of <code>x</code>, of each 1-D array along <code>axis</code></p>
<h2 id="notes_179">Notes<a class="headerlink" href="#notes_179" title="Permanent link">&para;</a></h2>
<p>The analytic signal <code>x_a(t)</code> of signal <code>x(t)</code> is:</p>
<p>.. math:: x_a = F^{-1}(F(x) 2U) = x + i y</p>
<p>where <code>F</code> is the Fourier transform, <code>U</code> the unit step function,
and <code>y</code> the Hilbert transform of <code>x</code>. [1]_</p>
<p>In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from <code>np.imag(hilbert(x))</code>, and the
original signal from <code>np.real(hilbert(x))</code>.</p>
<h2 id="examples_234">Examples<a class="headerlink" href="#examples_234" title="Permanent link">&para;</a></h2>
<p>In this example we use the Hilbert transform to determine the amplitude
envelope and instantaneous frequency of an amplitude-modulated signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import hilbert, chirp</p>
<p>duration = 1.0
fs = 400.0
samples = int(fs*duration)
t = np.arange(samples) / fs</p>
</blockquote>
</blockquote>
</blockquote>
<p>We create a chirp of which the frequency increases from 20 Hz to 100 Hz and
apply an amplitude modulation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal = chirp(t, 20.0, t[-1], 100.0)
signal <em>= (1.0 + 0.5 * np.sin(2.0</em>np.pi<em>3.0</em>t) )</p>
</blockquote>
</blockquote>
</blockquote>
<p>The amplitude envelope is given by magnitude of the analytic signal. The
instantaneous frequency can be obtained by differentiating the
instantaneous phase in respect to time. The instantaneous phase corresponds
to the phase angle of the analytic signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>analytic_signal = hilbert(signal)
amplitude_envelope = np.abs(analytic_signal)
instantaneous_phase = np.unwrap(np.angle(analytic_signal))
instantaneous_frequency = (np.diff(instantaneous_phase) /
...                            (2.0*np.pi) * fs)</p>
<p>fig = plt.figure()
ax0 = fig.add_subplot(211)
ax0.plot(t, signal, label='signal')
ax0.plot(t, amplitude_envelope, label='envelope')
ax0.set_xlabel('time in seconds')
ax0.legend()
ax1 = fig.add_subplot(212)
ax1.plot(t[1:], instantaneous_frequency)
ax1.set_xlabel('time in seconds')
ax1.set_ylim(0.0, 120.0)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_42">References<a class="headerlink" href="#references_42" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Analytic signal'.
https://en.wikipedia.org/wiki/Analytic_signal
.. [2] Leon Cohen, 'Time-Frequency Analysis', 1995. Chapter 2.
.. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal
Processing, Third Edition, 2009. Chapter 12.
ISBN 13: 978-1292-02572-8</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert2</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:[`</span><span class="nc">Tuple_of_two_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the '2-D' analytic signal of <code>x</code></p>
<h2 id="parameters_283">Parameters<a class="headerlink" href="#parameters_283" title="Permanent link">&para;</a></h2>
<p>x : array_like
2-D signal data.
N : int or tuple of two ints, optional
Number of Fourier components. Default is <code>x.shape</code></p>
<h2 id="returns_282">Returns<a class="headerlink" href="#returns_282" title="Permanent link">&para;</a></h2>
<p>xa : ndarray
Analytic signal of <code>x</code> taken along axes (0,1).</p>
<h2 id="references_43">References<a class="headerlink" href="#references_43" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Analytic signal',
https://en.wikipedia.org/wiki/Analytic_signal</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invres</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute b(s) and a(s) from partial fraction expansion.</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(s)     b[0] s<strong>(M) + b[1] s</strong>(M-1) + ... + b[M]
H(s) = ------ = ------------------------------------------
a(s)     a[0] s<strong>(N) + a[1] s</strong>(N-1) + ... + a[N]</p>
<p>then the partial-fraction expansion H(s) is defined as::</p>
<p>r[0]       r[1]             r[-1]
= -------- + -------- + ... + --------- + k(s)
(s-p[0])   (s-p[1])         (s-p[-1])</p>
<p>If there are any repeated roots (closer together than <code>tol</code>), then H(s)
has terms like::</p>
<p>r[i]      r[i+1]              r[i+n-1]
-------- + ----------- + ... + -----------
(s-p[i])  (s-p[i])<strong>2          (s-p[i])</strong>n</p>
<p>This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use <code>invresz</code>.</p>
<h2 id="parameters_284">Parameters<a class="headerlink" href="#parameters_284" title="Permanent link">&para;</a></h2>
<p>r : array_like
Residues corresponding to the poles. For repeated poles, the residues
must be ordered to correspond to ascending by power fractions.
p : array_like
Poles. Equal poles must be adjacent.
k : array_like
Coefficients of the direct polynomial term.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_283">Returns<a class="headerlink" href="#returns_283" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="see-also_199">See Also<a class="headerlink" href="#see-also_199" title="Permanent link">&para;</a></h2>
<p>residue, invresz, unique_roots</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invresz</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute b(z) and a(z) from partial fraction expansion.</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(z)     b[0] + b[1] z<strong>(-1) + ... + b[M] z</strong>(-M)
H(z) = ------ = ------------------------------------------
a(z)     a[0] + a[1] z<strong>(-1) + ... + a[N] z</strong>(-N)</p>
<p>then the partial-fraction expansion H(z) is defined as::</p>
<p>r[0]                   r[-1]
= --------------- + ... + ---------------- + k[0] + k[1]z<strong>(-1) ...
(1-p[0]z</strong>(-1))         (1-p[-1]z**(-1))</p>
<p>If there are any repeated roots (closer than <code>tol</code>), then the partial
fraction expansion has terms like::</p>
<p>r[i]              r[i+1]                    r[i+n-1]
-------------- + ------------------ + ... + ------------------
(1-p[i]z<strong>(-1))  (1-p[i]z</strong>(-1))<strong>2         (1-p[i]z</strong>(-1))**n</p>
<p>This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use <code>invres</code>.</p>
<h2 id="parameters_285">Parameters<a class="headerlink" href="#parameters_285" title="Permanent link">&para;</a></h2>
<p>r : array_like
Residues corresponding to the poles. For repeated poles, the residues
must be ordered to correspond to ascending by power fractions.
p : array_like
Poles. Equal poles must be adjacent.
k : array_like
Coefficients of the direct polynomial term.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_284">Returns<a class="headerlink" href="#returns_284" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="see-also_200">See Also<a class="headerlink" href="#see-also_200" title="Permanent link">&para;</a></h2>
<p>residuez, unique_roots, invres</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lambertw</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lambertw(z, k=0, tol=1e-8)</p>
<p>Lambert W function.</p>
<p>The Lambert W function <code>W(z)</code> is defined as the inverse function
of <code>w * exp(w)</code>. In other words, the value of <code>W(z)</code> is
such that <code>z = W(z) * exp(W(z))</code> for any complex number
<code>z</code>.</p>
<p>The Lambert W function is a multivalued function with infinitely
many branches. Each branch gives a separate solution of the
equation <code>z = w exp(w)</code>. Here, the branches are indexed by the
integer <code>k</code>.</p>
<h2 id="parameters_286">Parameters<a class="headerlink" href="#parameters_286" title="Permanent link">&para;</a></h2>
<p>z : array_like
Input argument.
k : int, optional
Branch index.
tol : float, optional
Evaluation tolerance.</p>
<h2 id="returns_285">Returns<a class="headerlink" href="#returns_285" title="Permanent link">&para;</a></h2>
<p>w : array
<code>w</code> will have the same shape as <code>z</code>.</p>
<h2 id="notes_180">Notes<a class="headerlink" href="#notes_180" title="Permanent link">&para;</a></h2>
<p>All branches are supported by <code>lambertw</code>:</p>
<ul>
<li><code>lambertw(z)</code> gives the principal solution (branch 0)</li>
<li><code>lambertw(z, k)</code> gives the solution on branch <code>k</code></li>
</ul>
<p>The Lambert W function has two partially real branches: the
principal branch (<code>k = 0</code>) is real for real <code>z &gt; -1/e</code>, and the
<code>k = -1</code> branch is real for <code>-1/e &lt; z &lt; 0</code>. All branches except
<code>k = 0</code> have a logarithmic singularity at <code>z = 0</code>.</p>
<p><strong>Possible issues</strong></p>
<p>The evaluation can become inaccurate very close to the branch point
at <code>-1/e</code>. In some corner cases, <code>lambertw</code> might currently
fail to converge, or can end up on the wrong branch.</p>
<p><strong>Algorithm</strong></p>
<p>Halley's iteration is used to invert <code>w * exp(w)</code>, using a first-order
asymptotic approximation (O(log(w)) or <code>O(w)</code>) as the initial estimate.</p>
<p>The definition, implementation and choice of branches is based on [2]_.</p>
<h2 id="see-also_201">See Also<a class="headerlink" href="#see-also_201" title="Permanent link">&para;</a></h2>
<p>wrightomega : the Wright Omega function</p>
<h2 id="references_44">References<a class="headerlink" href="#references_44" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Lambert_W_function
.. [2] Corless et al, 'On the Lambert W function', Adv. Comp. Math. 5
(1996) 329-359.
http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf</p>
<h2 id="examples_235">Examples<a class="headerlink" href="#examples_235" title="Permanent link">&para;</a></h2>
<p>The Lambert W function is the inverse of <code>w exp(w)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import lambertw
w = lambertw(1)
w
(0.56714329040978384+0j)
w * np.exp(w)
(1.0+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Any branch gives a valid inverse:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = lambertw(1, k=3)
w
(-2.8535817554090377+17.113535539412148j)
w*np.exp(w)
(1.0000000000000002+1.609823385706477e-15j)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Applications to equation-solving</strong></p>
<p>The Lambert W function may be used to solve various kinds of
equations, such as finding the value of the infinite power
tower :math:<code>z^{z^{z^{\ldots}}}</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def tower(z, n):
...     if n == 0:
...         return z
...     return z ** tower(z, n-1)
...
tower(0.5, 100)
0.641185744504986
-lambertw(-np.log(0.5)) / np.log(0.5)
(0.64118574450498589+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfilter</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zi</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Filter data along one-dimension with an IIR or FIR filter.</p>
<p>Filter a data sequence, <code>x</code>, using a digital filter.  This works for many
fundamental data types (including Object type).  The filter is a direct
form II transposed implementation of the standard difference equation
(see Notes).</p>
<p>The function <code>sosfilt</code> (and filter design using <code>output='sos'</code>) should be
preferred over <code>lfilter</code> for most filtering tasks, as second-order sections
have fewer numerical problems.</p>
<h2 id="parameters_287">Parameters<a class="headerlink" href="#parameters_287" title="Permanent link">&para;</a></h2>
<p>b : array_like
The numerator coefficient vector in a 1-D sequence.
a : array_like
The denominator coefficient vector in a 1-D sequence.  If <code>a[0]</code>
is not 1, then both <code>a</code> and <code>b</code> are normalized by <code>a[0]</code>.
x : array_like
An N-dimensional input array.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.
zi : array_like, optional
Initial conditions for the filter delays.  It is a vector
(or array of vectors for an N-dimensional input) of length
<code>max(len(a), len(b)) - 1</code>.  If <code>zi</code> is None or is not given then
initial rest is assumed.  See <code>lfiltic</code> for more information.</p>
<h2 id="returns_286">Returns<a class="headerlink" href="#returns_286" title="Permanent link">&para;</a></h2>
<p>y : array
The output of the digital filter.
zf : array, optional
If <code>zi</code> is None, this is not returned, otherwise, <code>zf</code> holds the
final filter delay values.</p>
<h2 id="see-also_202">See Also<a class="headerlink" href="#see-also_202" title="Permanent link">&para;</a></h2>
<p>lfiltic : Construct initial conditions for <code>lfilter</code>.
lfilter_zi : Compute initial state (steady state of step response) for
<code>lfilter</code>.
filtfilt : A forward-backward filter, to obtain a filter with linear phase.
savgol_filter : A Savitzky-Golay filter.
sosfilt: Filter data using cascaded second-order sections.
sosfiltfilt: A forward-backward filter using second-order sections.</p>
<h2 id="notes_181">Notes<a class="headerlink" href="#notes_181" title="Permanent link">&para;</a></h2>
<p>The filter function is implemented as a direct II transposed structure.
This means that the filter implements::</p>
<p>a[0]<em>y[n] = b[0]</em>x[n] + b[1]<em>x[n-1] + ... + b[M]</em>x[n-M]
- a[1]<em>y[n-1] - ... - a[N]</em>y[n-N]</p>
<p>where <code>M</code> is the degree of the numerator, <code>N</code> is the degree of the
denominator, and <code>n</code> is the sample number.  It is implemented using
the following difference equations (assuming M = N)::</p>
<p>a[0]<em>y[n] = b[0] * x[n]               + d[0][n-1]
d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]
d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]
...
d[N-2][n] = b[N-1]</em>x[n] - a[N-1]*y[n] + d[N-1][n-1]
d[N-1][n] = b[N] * x[n] - a[N] * y[n]</p>
<p>where <code>d</code> are the state variables.</p>
<p>The rational transfer function describing this filter in the
z-transform domain is::</p>
<p>-1              -M
b[0] + b[1]z  + ... + b[M] z
Y(z) = -------------------------------- X(z)
-1              -N
a[0] + a[1]z  + ... + a[N] z</p>
<h2 id="examples_236">Examples<a class="headerlink" href="#examples_236" title="Permanent link">&para;</a></h2>
<p>Generate a noisy signal to be filtered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 201)
x = (np.sin(2<em>np.pi</em>0.75<em>t</em>(1-t) + 2.1) +
...      0.1<em>np.sin(2</em>np.pi<em>1.25</em>t + 1) +
...      0.18<em>np.cos(2</em>np.pi<em>3.85</em>t))
xn = x + np.random.randn(len(t)) * 0.08</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create an order 3 lowpass butterworth filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.butter(3, 0.05)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter to xn.  Use lfilter_zi to choose the initial condition of
the filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zi = signal.lfilter_zi(b, a)
z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter again, to have a result filtered at an order the same as
filtfilt:</p>
<blockquote>
<blockquote>
<blockquote>
<p>z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use filtfilt to apply the filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = signal.filtfilt(b, a, xn)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the original signal and the various filtered versions:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure
plt.plot(t, xn, 'b', alpha=0.75)
plt.plot(t, z, 'r--', t, z2, 'r', t, y, 'k')
plt.legend(('noisy signal', 'lfilter, once', 'lfilter, twice',
...             'filtfilt'), loc='best')
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfilter_zi</span> <span class="o">:</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for lfilter for step response steady-state.</p>
<p>Compute an initial state <code>zi</code> for the <code>lfilter</code> function that corresponds
to the steady state of the step response.</p>
<p>A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.</p>
<h2 id="parameters_288">Parameters<a class="headerlink" href="#parameters_288" title="Permanent link">&para;</a></h2>
<p>b, a : array_like (1-D)
The IIR filter coefficients. See <code>lfilter</code> for more
information.</p>
<h2 id="returns_287">Returns<a class="headerlink" href="#returns_287" title="Permanent link">&para;</a></h2>
<p>zi : 1-D ndarray
The initial state for the filter.</p>
<h2 id="see-also_203">See Also<a class="headerlink" href="#see-also_203" title="Permanent link">&para;</a></h2>
<p>lfilter, lfiltic, filtfilt</p>
<h2 id="notes_182">Notes<a class="headerlink" href="#notes_182" title="Permanent link">&para;</a></h2>
<p>A linear filter with order m has a state space representation (A, B, C, D),
for which the output y of the filter can be expressed as::</p>
<p>z(n+1) = A<em>z(n) + B</em>x(n)
y(n)   = C<em>z(n) + D</em>x(n)</p>
<p>where z(n) is a vector of length m, A has shape (m, m), B has shape
(m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is
a scalar).  lfilter_zi solves::</p>
<p>zi = A*zi + B</p>
<p>In other words, it finds the initial condition for which the response
to an input of all ones is a constant.</p>
<p>Given the filter coefficients <code>a</code> and <code>b</code>, the state space matrices
for the transposed direct form II implementation of the linear filter,
which is the implementation used by scipy.signal.lfilter, are::</p>
<p>A = scipy.linalg.companion(a).T
B = b[1:] - a[1:]*b[0]</p>
<p>assuming <code>a[0]</code> is 1.0; if <code>a[0]</code> is not 1, <code>a</code> and <code>b</code> are first
divided by a[0].</p>
<h2 id="examples_237">Examples<a class="headerlink" href="#examples_237" title="Permanent link">&para;</a></h2>
<p>The following code creates a lowpass Butterworth filter. Then it
applies that filter to an array whose values are all 1.0; the
output is also all 1.0, as expected for a lowpass filter.  If the
<code>zi</code> argument of <code>lfilter</code> had not been given, the output would have
shown the transient signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array, ones
from scipy.signal import lfilter, lfilter_zi, butter
b, a = butter(5, 0.25)
zi = lfilter_zi(b, a)
y, zo = lfilter(b, a, ones(10), zi=zi)
y
array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Another example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])
y, zf = lfilter(b, a, x, zi=zi*x[0])
y
array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
0.44399389,  0.35505241])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the <code>zi</code> argument to <code>lfilter</code> was computed using
<code>lfilter_zi</code> and scaled by <code>x[0]</code>.  Then the output <code>y</code> has no
transient until the input drops from 0.5 to 0.0.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfiltic</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for lfilter given input and output vectors.</p>
<p>Given a linear filter (b, a) and initial conditions on the output <code>y</code>
and the input <code>x</code>, return the initial conditions on the state vector zi
which is used by <code>lfilter</code> to generate the output given the input.</p>
<h2 id="parameters_289">Parameters<a class="headerlink" href="#parameters_289" title="Permanent link">&para;</a></h2>
<p>b : array_like
Linear filter term.
a : array_like
Linear filter term.
y : array_like
Initial conditions.</p>
<p>If <code>N = len(a) - 1</code>, then <code>y = {y[-1], y[-2], ..., y[-N]}</code>.</p>
<p>If <code>y</code> is too short, it is padded with zeros.
x : array_like, optional
Initial conditions.</p>
<p>If <code>M = len(b) - 1</code>, then <code>x = {x[-1], x[-2], ..., x[-M]}</code>.</p>
<p>If <code>x</code> is not given, its initial conditions are assumed zero.</p>
<p>If <code>x</code> is too short, it is padded with zeros.</p>
<h2 id="returns_288">Returns<a class="headerlink" href="#returns_288" title="Permanent link">&para;</a></h2>
<p>zi : ndarray
The state vector <code>zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}</code>,
where <code>K = max(M, N)</code>.</p>
<h2 id="see-also_204">See Also<a class="headerlink" href="#see-also_204" title="Permanent link">&para;</a></h2>
<p>lfilter, lfilter_zi</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">medfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">kernel_size</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">volume</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform a median filter on an N-dimensional array.</p>
<p>Apply a median filter to the input array using a local window-size
given by <code>kernel_size</code>. The array will automatically be zero-padded.</p>
<h2 id="parameters_290">Parameters<a class="headerlink" href="#parameters_290" title="Permanent link">&para;</a></h2>
<p>volume : array_like
An N-dimensional input array.
kernel_size : array_like, optional
A scalar or an N-length list giving the size of the median filter
window in each dimension.  Elements of <code>kernel_size</code> should be odd.
If <code>kernel_size</code> is a scalar, then this scalar is used as the size in
each dimension. Default size is 3 for each dimension.</p>
<h2 id="returns_289">Returns<a class="headerlink" href="#returns_289" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array the same size as input containing the median filtered
result.</p>
<h2 id="see-also_205">See also<a class="headerlink" href="#see-also_205" title="Permanent link">&para;</a></h2>
<p>scipy.ndimage.median_filter</p>
<h2 id="notes_183">Notes<a class="headerlink" href="#notes_183" title="Permanent link">&para;</a></h2>
<p>The more general function <code>scipy.ndimage.median_filter</code> has a more
efficient implementation of a median filter and therefore runs much faster.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">medfilt2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">kernel_size</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Median filter a 2-dimensional array.</p>
<p>Apply a median filter to the <code>input</code> array using a local window-size
given by <code>kernel_size</code> (must be odd). The array is zero-padded
automatically.</p>
<h2 id="parameters_291">Parameters<a class="headerlink" href="#parameters_291" title="Permanent link">&para;</a></h2>
<p>input : array_like
A 2-dimensional input array.
kernel_size : array_like, optional
A scalar or a list of length 2, giving the size of the
median filter window in each dimension.  Elements of
<code>kernel_size</code> should be odd.  If <code>kernel_size</code> is a scalar,
then this scalar is used as the size in each dimension.
Default is a kernel of size (3, 3).</p>
<h2 id="returns_290">Returns<a class="headerlink" href="#returns_290" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array the same size as input containing the median filtered
result.</p>
<h2 id="see-also_206">See also<a class="headerlink" href="#see-also_206" title="Permanent link">&para;</a></h2>
<p>scipy.ndimage.median_filter</p>
<h2 id="notes_184">Notes<a class="headerlink" href="#notes_184" title="Permanent link">&para;</a></h2>
<p>The more general function <code>scipy.ndimage.median_filter</code> has a more
efficient implementation of a median filter and therefore runs much faster.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">oaconvolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays using the overlap-add method.</p>
<p>Convolve <code>in1</code> and <code>in2</code> using the overlap-add method, with
the output size determined by the <code>mode</code> argument.</p>
<p>This is generally much faster than <code>convolve</code> for large arrays (n &gt; ~500),
and generally much faster than <code>fftconvolve</code> when one array is much
larger than the other, but can be slower when only a few output values are
needed or when the arrays are very similar in shape, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<h2 id="parameters_292">Parameters<a class="headerlink" href="#parameters_292" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
axes : int or array_like of ints or None, optional
Axes over which to compute the convolution.
The default is over all axes.</p>
<h2 id="returns_291">Returns<a class="headerlink" href="#returns_291" title="Permanent link">&para;</a></h2>
<p>out : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_207">See Also<a class="headerlink" href="#see-also_207" title="Permanent link">&para;</a></h2>
<p>convolve : Uses the direct convolution or FFT convolution algorithm
depending on which is faster.
fftconvolve : An implementation of convolution using FFT.</p>
<h2 id="notes_185">Notes<a class="headerlink" href="#notes_185" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<h2 id="examples_238">Examples<a class="headerlink" href="#examples_238" title="Permanent link">&para;</a></h2>
<p>Convolve a 100,000 sample signal with a 512-sample filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.random.randn(100000)
filt = signal.firwin(512, 0.01)
fsig = signal.oaconvolve(sig, filt)</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
ax_orig.plot(sig)
ax_orig.set_title('White noise')
ax_mag.plot(fsig)
ax_mag.set_title('Filtered noise')
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_45">References<a class="headerlink" href="#references_45" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Overlap-add_method'.
https://en.wikipedia.org/wiki/Overlap-add_method
.. [2] Richard G. Lyons. Understanding Digital Signal Processing,
Third Edition, 2011. Chapter 13.10.
ISBN 13: 978-0137-02741-5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">odd_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Odd extension at the boundaries of an array</p>
<p>Generate a new ndarray by making an odd extension of <code>x</code> along an axis.</p>
<h2 id="parameters_293">Parameters<a class="headerlink" href="#parameters_293" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_239">Examples<a class="headerlink" href="#examples_239" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import odd_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
odd_ext(a, 2)
array([[-1,  0,  1,  2,  3,  4,  5,  6,  7],
[-4, -1,  0,  1,  4,  9, 16, 23, 28]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Odd extension is a '180 degree rotation' at the endpoints of the original
array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = odd_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='odd extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">order_filter</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">domain</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform an order filter on an N-dimensional array.</p>
<p>Perform an order filter on the array in.  The domain argument acts as a
mask centered over each pixel.  The non-zero elements of domain are
used to select elements surrounding each input pixel which are placed
in a list.   The list is sorted, and the output for that pixel is the
element corresponding to rank in the sorted list.</p>
<h2 id="parameters_294">Parameters<a class="headerlink" href="#parameters_294" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The N-dimensional input array.
domain : array_like
A mask array with the same number of dimensions as <code>a</code>.
Each dimension should have an odd number of elements.
rank : int
A non-negative integer which selects the element from the
sorted list (0 corresponds to the smallest element, 1 is the
next smallest element, etc.).</p>
<h2 id="returns_292">Returns<a class="headerlink" href="#returns_292" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results of the order filter in an array with the same
shape as <code>a</code>.</p>
<h2 id="examples_240">Examples<a class="headerlink" href="#examples_240" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
x = np.arange(25).reshape(5, 5)
domain = np.identity(3)
x
array([[ 0,  1,  2,  3,  4],
[ 5,  6,  7,  8,  9],
[10, 11, 12, 13, 14],
[15, 16, 17, 18, 19],
[20, 21, 22, 23, 24]])
signal.order_filter(x, domain, 0)
array([[  0.,   0.,   0.,   0.,   0.],
[  0.,   0.,   1.,   2.,   0.],
[  0.,   5.,   6.,   7.,   0.],
[  0.,  10.,  11.,  12.,   0.],
[  0.,   0.,   0.,   0.,   0.]])
signal.order_filter(x, domain, 2)
array([[  6.,   7.,   8.,   9.,   4.],
[ 11.,  12.,  13.,  14.,   9.],
[ 16.,  17.,  18.,  19.,  14.],
[ 21.,  22.,  23.,  24.,  19.],
[ 20.,  21.,  22.,  23.,  24.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resample</span> <span class="o">:</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resample <code>x</code> to <code>num</code> samples using Fourier method along the given axis.</p>
<p>The resampled signal starts at the same value as <code>x</code> but is sampled
with a spacing of <code>len(x) / num * (spacing of x)</code>.  Because a
Fourier method is used, the signal is assumed to be periodic.</p>
<h2 id="parameters_295">Parameters<a class="headerlink" href="#parameters_295" title="Permanent link">&para;</a></h2>
<p>x : array_like
The data to be resampled.
num : int
The number of samples in the resampled signal.
t : array_like, optional
If <code>t</code> is given, it is assumed to be the equally spaced sample
positions associated with the signal data in <code>x</code>.
axis : int, optional
The axis of <code>x</code> that is resampled.  Default is 0.
window : array_like, callable, string, float, or tuple, optional
Specifies the window applied to the signal in the Fourier
domain.  See below for details.</p>
<h2 id="returns_293">Returns<a class="headerlink" href="#returns_293" title="Permanent link">&para;</a></h2>
<p>resampled_x or (resampled_x, resampled_t)
Either the resampled array, or, if <code>t</code> was given, a tuple
containing the resampled array and the corresponding resampled
positions.</p>
<h2 id="see-also_208">See Also<a class="headerlink" href="#see-also_208" title="Permanent link">&para;</a></h2>
<p>decimate : Downsample the signal after applying an FIR or IIR filter.
resample_poly : Resample using polyphase filtering and an FIR filter.</p>
<h2 id="notes_186">Notes<a class="headerlink" href="#notes_186" title="Permanent link">&para;</a></h2>
<p>The argument <code>window</code> controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn't intend to be
interpreted as band-limited.</p>
<p>If <code>window</code> is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</p>
<p>If <code>window</code> is an array of the same length as <code>x.shape[axis]</code> it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).</p>
<p>For any other type of <code>window</code>, the function <code>scipy.signal.get_window</code>
is called to generate the window.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from <code>dx</code> to <code>dx * len(x) / num</code>.</p>
<p>If <code>t</code> is not None, then it is used solely to calculate the resampled
positions <code>resampled_t</code></p>
<p>As noted, <code>resample</code> uses FFT transformations, which can be very
slow if the number of input or output samples is large and prime;
see <code>scipy.fft.fft</code>.</p>
<h2 id="examples_241">Examples<a class="headerlink" href="#examples_241" title="Permanent link">&para;</a></h2>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>x = np.linspace(0, 10, 20, endpoint=False)
y = np.cos(-x**2/6.0)
f = signal.resample(y, 100)
xnew = np.linspace(0, 10, 100, endpoint=False)</p>
<p>import matplotlib.pyplot as plt
plt.plot(x, y, 'go-', xnew, f, '.-', 10, y[0], 'ro')
plt.legend(['data', 'resampled'], loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resample_poly</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resample <code>x</code> along the given axis using polyphase filtering.</p>
<p>The signal <code>x</code> is upsampled by the factor <code>up</code>, a zero-phase low-pass
FIR filter is applied, and then it is downsampled by the factor <code>down</code>.
The resulting sample rate is <code>up / down</code> times the original sample
rate. By default, values beyond the boundary of the signal are assumed
to be zero during the filtering step.</p>
<h2 id="parameters_296">Parameters<a class="headerlink" href="#parameters_296" title="Permanent link">&para;</a></h2>
<p>x : array_like
The data to be resampled.
up : int
The upsampling factor.
down : int
The downsampling factor.
axis : int, optional
The axis of <code>x</code> that is resampled. Default is 0.
window : string, tuple, or array_like, optional
Desired window to use to design the low-pass filter, or the FIR filter
coefficients to employ. See below for details.
padtype : string, optional
<code>constant</code>, <code>line</code>, <code>mean</code>, <code>median</code>, <code>maximum</code>, <code>minimum</code> or any of
the other signal extension modes supported by <code>scipy.signal.upfirdn</code>.
Changes assumptions on values beyond the boundary. If <code>constant</code>,
assumed to be <code>cval</code> (default zero). If <code>line</code> assumed to continue a
linear trend defined by the first and last points. <code>mean</code>, <code>median</code>,
<code>maximum</code> and <code>minimum</code> work as in <code>np.pad</code> and assume that the values
beyond the boundary are the mean, median, maximum or minimum
respectively of the array along the axis.</p>
<p>.. versionadded:: 1.4.0
cval : float, optional
Value to use if <code>padtype='constant'</code>. Default is zero.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_294">Returns<a class="headerlink" href="#returns_294" title="Permanent link">&para;</a></h2>
<p>resampled_x : array
The resampled array.</p>
<h2 id="see-also_209">See Also<a class="headerlink" href="#see-also_209" title="Permanent link">&para;</a></h2>
<p>decimate : Downsample the signal after applying an FIR or IIR filter.
resample : Resample up or down using the FFT method.</p>
<h2 id="notes_187">Notes<a class="headerlink" href="#notes_187" title="Permanent link">&para;</a></h2>
<p>This polyphase method will likely be faster than the Fourier method
in <code>scipy.signal.resample</code> when the number of samples is large and
prime, or when the number of samples is large and <code>up</code> and <code>down</code>
share a large greatest common denominator. The length of the FIR
filter used will depend on <code>max(up, down) // gcd(up, down)</code>, and
the number of operations during polyphase filtering will depend on
the filter length and <code>down</code> (see <code>scipy.signal.upfirdn</code> for details).</p>
<p>The argument <code>window</code> specifies the FIR low-pass filter design.</p>
<p>If <code>window</code> is an array_like it is assumed to be the FIR filter
coefficients. Note that the FIR filter is applied after the upsampling
step, so it should be designed to operate on a signal at a sampling
frequency higher than the original by a factor of <code>up//gcd(up, down)</code>.
This function's output will be centered with respect to this array, so it
is best to pass a symmetric filter with an odd number of samples if, as
is usually the case, a zero-phase filter is desired.</p>
<p>For any other type of <code>window</code>, the functions <code>scipy.signal.get_window</code>
and <code>scipy.signal.firwin</code> are called to generate the appropriate filter
coefficients.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector. The spacing between samples is changed
from <code>dx</code> to <code>dx * down / float(up)</code>.</p>
<h2 id="examples_242">Examples<a class="headerlink" href="#examples_242" title="Permanent link">&para;</a></h2>
<p>By default, the end of the resampled data rises to meet the first
sample of the next cycle for the FFT method, and gets closer to zero
for the polyphase method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>x = np.linspace(0, 10, 20, endpoint=False)
y = np.cos(-x**2/6.0)
f_fft = signal.resample(y, 100)
f_poly = signal.resample_poly(y, 100, 20)
xnew = np.linspace(0, 10, 100, endpoint=False)</p>
<p>import matplotlib.pyplot as plt
plt.plot(xnew, f_fft, 'b.-', xnew, f_poly, 'r.-')
plt.plot(x, y, 'ko-')
plt.plot(10, y[0], 'bo', 10, 0., 'ro')  # boundaries
plt.legend(['resample', 'resamp_poly', 'data'], loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This default behaviour can be changed by using the padtype option:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy import signal</p>
<p>N = 5
x = np.linspace(0, 1, N, endpoint=False)
y = 2 + x<strong>2 - 1.7<em>np.sin(x) + .2</em>np.cos(11*x)
y2 = 1 + x</strong>3 + 0.1<em>np.sin(x) + .1</em>np.cos(11<em>x)
Y = np.stack([y, y2], axis=-1)
up = 4
xr = np.linspace(0, 1, N</em>up, endpoint=False)</p>
<p>y2 = signal.resample_poly(Y, up, 1, padtype='constant')
y3 = signal.resample_poly(Y, up, 1, padtype='mean')
y4 = signal.resample_poly(Y, up, 1, padtype='line')</p>
<p>import matplotlib.pyplot as plt
for i in [0,1]:
...     plt.figure()
...     plt.plot(xr, y4[:,i], 'g.', label='line')
...     plt.plot(xr, y3[:,i], 'y.', label='mean')
...     plt.plot(xr, y2[:,i], 'r.', label='constant')
...     plt.plot(x, Y[:,i], 'k-')
...     plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">residue</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute partial-fraction expansion of b(s) / a(s).</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(s)     b[0] s<strong>(M) + b[1] s</strong>(M-1) + ... + b[M]
H(s) = ------ = ------------------------------------------
a(s)     a[0] s<strong>(N) + a[1] s</strong>(N-1) + ... + a[N]</p>
<p>then the partial-fraction expansion H(s) is defined as::</p>
<p>r[0]       r[1]             r[-1]
= -------- + -------- + ... + --------- + k(s)
(s-p[0])   (s-p[1])         (s-p[-1])</p>
<p>If there are any repeated roots (closer together than <code>tol</code>), then H(s)
has terms like::</p>
<p>r[i]      r[i+1]              r[i+n-1]
-------- + ----------- + ... + -----------
(s-p[i])  (s-p[i])<strong>2          (s-p[i])</strong>n</p>
<p>This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use <code>residuez</code>.</p>
<p>See Notes for details about the algorithm.</p>
<h2 id="parameters_297">Parameters<a class="headerlink" href="#parameters_297" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_295">Returns<a class="headerlink" href="#returns_295" title="Permanent link">&para;</a></h2>
<p>r : ndarray
Residues corresponding to the poles. For repeated poles, the residues
are ordered to correspond to ascending by power fractions.
p : ndarray
Poles ordered by magnitude in ascending order.
k : ndarray
Coefficients of the direct polynomial term.</p>
<h2 id="see-also_210">See Also<a class="headerlink" href="#see-also_210" title="Permanent link">&para;</a></h2>
<p>invres, residuez, numpy.poly, unique_roots</p>
<h2 id="notes_188">Notes<a class="headerlink" href="#notes_188" title="Permanent link">&para;</a></h2>
<p>The 'deflation through subtraction' algorithm is used for
computations --- method 6 in [1]_.</p>
<p>The form of partial fraction expansion depends on poles multiplicity in
the exact mathematical sense. However there is no way to exactly
determine multiplicity of roots of a polynomial in numerical computing.
Thus you should think of the result of <code>residue</code> with given <code>tol</code> as
partial fraction expansion computed for the denominator composed of the
computed poles with empirically determined multiplicity. The choice of
<code>tol</code> can drastically change the result if there are close poles.</p>
<h2 id="references_46">References<a class="headerlink" href="#references_46" title="Permanent link">&para;</a></h2>
<p>.. [1] J. F. Mahoney, B. D. Sivazlian, 'Partial fractions expansion: a
review of computational methodology and efficiency', Journal of
Computational and Applied Mathematics, Vol. 9, 1983.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">residuez</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute partial-fraction expansion of b(z) / a(z).</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(z)     b[0] + b[1] z<strong>(-1) + ... + b[M] z</strong>(-M)
H(z) = ------ = ------------------------------------------
a(z)     a[0] + a[1] z<strong>(-1) + ... + a[N] z</strong>(-N)</p>
<p>then the partial-fraction expansion H(z) is defined as::</p>
<p>r[0]                   r[-1]
= --------------- + ... + ---------------- + k[0] + k[1]z<strong>(-1) ...
(1-p[0]z</strong>(-1))         (1-p[-1]z**(-1))</p>
<p>If there are any repeated roots (closer than <code>tol</code>), then the partial
fraction expansion has terms like::</p>
<p>r[i]              r[i+1]                    r[i+n-1]
-------------- + ------------------ + ... + ------------------
(1-p[i]z<strong>(-1))  (1-p[i]z</strong>(-1))<strong>2         (1-p[i]z</strong>(-1))**n</p>
<p>This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use <code>residue</code>.</p>
<p>See Notes of <code>residue</code> for details about the algorithm.</p>
<h2 id="parameters_298">Parameters<a class="headerlink" href="#parameters_298" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_296">Returns<a class="headerlink" href="#returns_296" title="Permanent link">&para;</a></h2>
<p>r : ndarray
Residues corresponding to the poles. For repeated poles, the residues
are ordered to correspond to ascending by power fractions.
p : ndarray
Poles ordered by magnitude in ascending order.
k : ndarray
Coefficients of the direct polynomial term.</p>
<h2 id="see-also_211">See Also<a class="headerlink" href="#see-also_211" title="Permanent link">&para;</a></h2>
<p>invresz, residue, unique_roots</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zi</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Filter data along one dimension using cascaded second-order sections.</p>
<p>Filter a data sequence, <code>x</code>, using a digital IIR filter defined by
<code>sos</code>.</p>
<h2 id="parameters_299">Parameters<a class="headerlink" href="#parameters_299" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
x : array_like
An N-dimensional input array.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.
zi : array_like, optional
Initial conditions for the cascaded filter delays.  It is a (at
least 2D) vector of shape <code>(n_sections, ..., 2, ...)</code>, where
<code>..., 2, ...</code> denotes the shape of <code>x</code>, but with <code>x.shape[axis]</code>
replaced by 2.  If <code>zi</code> is None or is not given then initial rest
(i.e. all zeros) is assumed.
Note that these initial conditions are <em>not</em> the same as the initial
conditions given by <code>lfiltic</code> or <code>lfilter_zi</code>.</p>
<h2 id="returns_297">Returns<a class="headerlink" href="#returns_297" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The output of the digital filter.
zf : ndarray, optional
If <code>zi</code> is None, this is not returned, otherwise, <code>zf</code> holds the
final filter delay values.</p>
<h2 id="see-also_212">See Also<a class="headerlink" href="#see-also_212" title="Permanent link">&para;</a></h2>
<p>zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz</p>
<h2 id="notes_189">Notes<a class="headerlink" href="#notes_189" title="Permanent link">&para;</a></h2>
<p>The filter function is implemented as a series of second-order filters
with direct-form II transposed structure. It is designed to minimize
numerical precision errors for high-order filters.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_243">Examples<a class="headerlink" href="#examples_243" title="Permanent link">&para;</a></h2>
<p>Plot a 13th-order filter's impulse response using both <code>lfilter</code> and
<code>sosfilt</code>, showing the instability that results from trying to do a
13th-order filter in a single stage (the numerical error pushes some poles
outside of the unit circle):</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy import signal
b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba')
sos = signal.ellip(13, 0.009, 80, 0.05, output='sos')
x = signal.unit_impulse(700)
y_tf = signal.lfilter(b, a, x)
y_sos = signal.sosfilt(sos, x)
plt.plot(y_tf, 'r', label='TF')
plt.plot(y_sos, 'k', label='SOS')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfilt_zi</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for sosfilt for step response steady-state.</p>
<p>Compute an initial state <code>zi</code> for the <code>sosfilt</code> function that corresponds
to the steady state of the step response.</p>
<p>A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.</p>
<h2 id="parameters_300">Parameters<a class="headerlink" href="#parameters_300" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_298">Returns<a class="headerlink" href="#returns_298" title="Permanent link">&para;</a></h2>
<p>zi : ndarray
Initial conditions suitable for use with <code>sosfilt</code>, shape
<code>(n_sections, 2)</code>.</p>
<h2 id="see-also_213">See Also<a class="headerlink" href="#see-also_213" title="Permanent link">&para;</a></h2>
<p>sosfilt, zpk2sos</p>
<h2 id="notes_190">Notes<a class="headerlink" href="#notes_190" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_244">Examples<a class="headerlink" href="#examples_244" title="Permanent link">&para;</a></h2>
<p>Filter a rectangular pulse that begins at time 0, with and without
the use of the <code>zi</code> argument of <code>scipy.signal.sosfilt</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sos = signal.butter(9, 0.125, output='sos')
zi = signal.sosfilt_zi(sos)
x = (np.arange(250) &lt; 100).astype(int)
f1 = signal.sosfilt(sos, x)
f2, zo = signal.sosfilt(sos, x, zi=zi)</p>
<p>plt.plot(x, 'k--', label='x')
plt.plot(f1, 'b', alpha=0.5, linewidth=2, label='filtered')
plt.plot(f2, 'g', alpha=0.25, linewidth=4, label='filtered with zi')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfiltfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A forward-backward digital filter using cascaded second-order sections.</p>
<p>See <code>filtfilt</code> for more complete information about this method.</p>
<h2 id="parameters_301">Parameters<a class="headerlink" href="#parameters_301" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
x : array_like
The array of data to be filtered.
axis : int, optional
The axis of <code>x</code> to which the filter is applied.
Default is -1.
padtype : str or None, optional
Must be 'odd', 'even', 'constant', or None.  This determines the
type of extension to use for the padded signal to which the filter
is applied.  If <code>padtype</code> is None, no padding is used.  The default
is 'odd'.
padlen : int or None, optional
The number of elements by which to extend <code>x</code> at both ends of
<code>axis</code> before applying the filter.  This value must be less than
<code>x.shape[axis] - 1</code>.  <code>padlen=0</code> implies no padding.
The default value is::</p>
<p>3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),
(sos[:, 5] == 0).sum()))</p>
<p>The extra subtraction at the end attempts to compensate for poles
and zeros at the origin (e.g. for odd-order filters) to yield
equivalent estimates of <code>padlen</code> to those of <code>filtfilt</code> for
second-order section filters built with <code>scipy.signal</code> functions.</p>
<h2 id="returns_299">Returns<a class="headerlink" href="#returns_299" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The filtered output with the same shape as <code>x</code>.</p>
<h2 id="see-also_214">See Also<a class="headerlink" href="#see-also_214" title="Permanent link">&para;</a></h2>
<p>filtfilt, sosfilt, sosfilt_zi, sosfreqz</p>
<h2 id="notes_191">Notes<a class="headerlink" href="#notes_191" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_245">Examples<a class="headerlink" href="#examples_245" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sosfiltfilt, butter
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create an interesting signal to filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 201
t = np.linspace(0, 1, n)
np.random.seed(123)
x = 1 + (t &lt; 0.5) - 0.25<em>t</em><em>2 + 0.05</em>np.random.randn(n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a lowpass Butterworth filter, and use it to filter <code>x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = butter(4, 0.125, output='sos')
y = sosfiltfilt(sos, x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For comparison, apply an 8th order filter using <code>sosfilt</code>.  The filter
is initialized using the mean of the first four values of <code>x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sosfilt, sosfilt_zi
sos8 = butter(8, 0.125, output='sos')
zi = x[:4].mean() * sosfilt_zi(sos8)
y2, zo = sosfilt(sos8, x, zi=zi)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the results.  Note that the phase of <code>y</code> matches the input, while
<code>y2</code> has a significant phase delay.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(t, x, alpha=0.5, label='x(t)')
plt.plot(t, y, label='y(t)')
plt.plot(t, y2, label='y2(t)')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.xlabel('t')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sp_fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>==============================================
Discrete Fourier transforms (:mod:<code>scipy.fft</code>)
==============================================</p>
<p>.. currentmodule:: scipy.fft</p>
<h1 id="fast-fourier-transforms-ffts_1">Fast Fourier Transforms (FFTs)<a class="headerlink" href="#fast-fourier-transforms-ffts_1" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fft - Fast (discrete) Fourier Transform (FFT)
ifft - Inverse FFT
fft2 - Two dimensional FFT
ifft2 - Two dimensional inverse FFT
fftn - n-dimensional FFT
ifftn - n-dimensional inverse FFT
rfft - FFT of strictly real-valued sequence
irfft - Inverse of rfft
rfft2 - Two dimensional FFT of real sequence
irfft2 - Inverse of rfft2
rfftn - n-dimensional FFT of real sequence
irfftn - Inverse of rfftn
hfft - FFT of a Hermitian sequence (real spectrum)
ihfft - Inverse of hfft
hfft2 - Two dimensional FFT of a Hermitian sequence
ihfft2 - Inverse of hfft2
hfftn - n-dimensional FFT of a Hermitian sequence
ihfftn - Inverse of hfftn</p>
<h1 id="discrete-sin-and-cosine-transforms-dst-and-dct_1">Discrete Sin and Cosine Transforms (DST and DCT)<a class="headerlink" href="#discrete-sin-and-cosine-transforms-dst-and-dct_1" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>dct - Discrete cosine transform
idct - Inverse discrete cosine transform
dctn - n-dimensional Discrete cosine transform
idctn - n-dimensional Inverse discrete cosine transform
dst - Discrete sine transform
idst - Inverse discrete sine transform
dstn - n-dimensional Discrete sine transform
idstn - n-dimensional Inverse discrete sine transform</p>
<h1 id="helper-functions_1">Helper functions<a class="headerlink" href="#helper-functions_1" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fftshift - Shift the zero-frequency component to the center of the spectrum
ifftshift - The inverse of <code>fftshift</code>
fftfreq - Return the Discrete Fourier Transform sample frequencies
rfftfreq - DFT sample frequencies (for usage with rfft, irfft)
next_fast_len - Find the optimal length to zero-pad an FFT for speed
set_workers - Context manager to set default number of workers
get_workers - Get the current default number of workers</p>
<h1 id="backend-control_1">Backend control<a class="headerlink" href="#backend-control_1" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>set_backend - Context manager to set the backend within a fixed scope
skip_backend - Context manager to skip a backend within a fixed scope
set_global_backend - Sets the global fft backend
register_backend - Register a backend for permanent use</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">unique_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Max</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Maximum</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Minimum</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mean</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Determine unique roots and their multiplicities from a list of roots.</p>
<h2 id="parameters_302">Parameters<a class="headerlink" href="#parameters_302" title="Permanent link">&para;</a></h2>
<p>p : array_like
The list of roots.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. Refer to Notes about
the details on roots grouping.
rtype : {'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}, optional
How to determine the returned root if multiple roots are within
<code>tol</code> of each other.</p>
<ul>
<li>'max', 'maximum': pick the maximum of those roots</li>
<li>'min', 'minimum': pick the minimum of those roots</li>
<li>'avg', 'mean': take the average of those roots</li>
</ul>
<p>When finding minimum or maximum among complex roots they are compared
first by the real part and then by the imaginary part.</p>
<h2 id="returns_300">Returns<a class="headerlink" href="#returns_300" title="Permanent link">&para;</a></h2>
<p>unique : ndarray
The list of unique roots.
multiplicity : ndarray
The multiplicity of each root.</p>
<h2 id="notes_192">Notes<a class="headerlink" href="#notes_192" title="Permanent link">&para;</a></h2>
<p>If we have 3 roots <code>a</code>, <code>b</code> and <code>c</code>, such that <code>a</code> is close to
<code>b</code> and <code>b</code> is close to <code>c</code> (distance is less than <code>tol</code>), then it
doesn't necessarily mean that <code>a</code> is close to <code>c</code>. It means that roots
grouping is not unique. In this function we use 'greedy' grouping going
through the roots in the order they are given in the input <code>p</code>.</p>
<p>This utility function is not specific to roots but can be used for any
sequence of values for which uniqueness and multiplicity has to be
determined. For a more general routine, see <code>numpy.unique</code>.</p>
<h2 id="examples_246">Examples<a class="headerlink" href="#examples_246" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]
uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check which roots have multiplicity larger than 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>uniq[mult &gt; 1]
array([ 1.305])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upfirdn</span> <span class="o">:</span> <span class="o">?</span><span class="n">up</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">down</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upsample, FIR filter, and downsample</p>
<h2 id="parameters_303">Parameters<a class="headerlink" href="#parameters_303" title="Permanent link">&para;</a></h2>
<p>h : array_like
1-dimensional FIR (finite-impulse response) filter coefficients.
x : array_like
Input signal array.
up : int, optional
Upsampling rate. Default is 1.
down : int, optional
Downsampling rate. Default is 1.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis. Default is -1.
mode : str, optional
The signal extension mode to use. The set
<code>{'constant', 'symmetric', 'reflect', 'edge', 'wrap'}</code> correspond to
modes provided by <code>numpy.pad</code>. <code>'smooth'</code> implements a smooth
extension by extending based on the slope of the last 2 points at each
end of the array. <code>'antireflect'</code> and <code>'antisymmetric'</code> are
anti-symmetric versions of <code>'reflect'</code> and <code>'symmetric'</code>. The mode
<code>'line'</code> extends the signal based on a linear trend defined by the
first and last points along the <code>axis</code>.</p>
<p>.. versionadded:: 1.4.0
cval : float, optional
The constant value to use when <code>mode == 'constant'</code>.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_301">Returns<a class="headerlink" href="#returns_301" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The output signal array. Dimensions will be the same as <code>x</code> except
for along <code>axis</code>, which will change size according to the <code>h</code>,
<code>up</code>,  and <code>down</code> parameters.</p>
<h2 id="notes_193">Notes<a class="headerlink" href="#notes_193" title="Permanent link">&para;</a></h2>
<p>The algorithm is an implementation of the block diagram shown on page 129
of the Vaidyanathan text [1]_ (Figure 4.3-8d).</p>
<p>.. [1] P. P. Vaidyanathan, Multirate Systems and Filter Banks,
Prentice Hall, 1993.</p>
<p>The direct approach of upsampling by factor of P with zero insertion,
FIR filtering of length <code>N</code>, and downsampling by factor of Q is
O(N*Q) per output sample. The polyphase implementation used here is
O(N/P).</p>
<p>.. versionadded:: 0.18</p>
<h2 id="examples_247">Examples<a class="headerlink" href="#examples_247" title="Permanent link">&para;</a></h2>
<p>Simple operations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import upfirdn
upfirdn([1, 1, 1], [1, 1, 1])   # FIR filter
array([ 1.,  2.,  3.,  2.,  1.])
upfirdn([1], [1, 2, 3], 3)  # upsampling with zeros insertion
array([ 1.,  0.,  0.,  2.,  0.,  0.,  3.,  0.,  0.])
upfirdn([1, 1, 1], [1, 2, 3], 3)  # upsampling with sample-and-hold
array([ 1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])
upfirdn([.5, 1, .5], [1, 1, 1], 2)  # linear interpolation
array([ 0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  0.5,  0. ])
upfirdn([1], np.arange(10), 1, 3)  # decimation by 3
array([ 0.,  3.,  6.,  9.])
upfirdn([.5, 1, .5], np.arange(10), 2, 3)  # linear interp, rate 2/3
array([ 0. ,  1. ,  2.5,  4. ,  5.5,  7. ,  8.5,  0. ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply a single filter to multiple signals:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.reshape(np.arange(8), (4, 2))
x
array([[0, 1],
[2, 3],
[4, 5],
[6, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply along the last dimension of <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>h = [1, 1]
upfirdn(h, x, 2)
array([[ 0.,  0.,  1.,  1.],
[ 2.,  2.,  3.,  3.],
[ 4.,  4.,  5.,  5.],
[ 6.,  6.,  7.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply along the 0th dimension of <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>upfirdn(h, x, 2, axis=0)
array([[ 0.,  1.],
[ 0.,  1.],
[ 2.,  3.],
[ 2.,  3.],
[ 4.,  5.],
[ 4.,  5.],
[ 6.,  7.],
[ 6.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vectorstrength</span> <span class="o">:</span> <span class="n">events</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">period</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Determine the vector strength of the events corresponding to the given
period.</p>
<p>The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.</p>
<p>If multiple periods are used, calculate the vector strength of each.
This is called the 'resonating vector strength'.</p>
<h2 id="parameters_304">Parameters<a class="headerlink" href="#parameters_304" title="Permanent link">&para;</a></h2>
<p>events : 1D array_like
An array of time points containing the timing of the events.
period : float or array_like
The period of the signal that the events should synchronize to.
The period is in the same units as <code>events</code>.  It can also be an array
of periods, in which case the outputs are arrays of the same length.</p>
<h2 id="returns_302">Returns<a class="headerlink" href="#returns_302" title="Permanent link">&para;</a></h2>
<p>strength : float or 1D array
The strength of the synchronization.  1.0 is perfect synchronization
and 0.0 is no synchronization.  If <code>period</code> is an array, this is also
an array with each element containing the vector strength at the
corresponding period.
phase : float or array
The phase that the events are most strongly synchronized to in radians.
If <code>period</code> is an array, this is also an array with each element
containing the phase for the corresponding period.</p>
<h2 id="references_47">References<a class="headerlink" href="#references_47" title="Permanent link">&para;</a></h2>
<p>van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector
strength: Auditory system, electric fish, and noise.
Chaos 21, 047508 (2011);
:doi:<code>10.1063/1.3670512</code>.
van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:
biological and mathematical perspectives.  Biol Cybern.
2013 Aug;107(4):385-96. :doi:<code>10.1007/s00422-013-0561-7</code>.
van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens
when we vary the 'probing' frequency while keeping the spike times
fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
:doi:<code>10.1007/s00422-013-0560-8</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wiener</span> <span class="o">:</span> <span class="o">?</span><span class="n">mysize</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noise</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">im</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform a Wiener filter on an N-dimensional array.</p>
<p>Apply a Wiener filter to the N-dimensional array <code>im</code>.</p>
<h2 id="parameters_305">Parameters<a class="headerlink" href="#parameters_305" title="Permanent link">&para;</a></h2>
<p>im : ndarray
An N-dimensional array.
mysize : int or array_like, optional
A scalar or an N-length list giving the size of the Wiener filter
window in each dimension.  Elements of mysize should be odd.
If mysize is a scalar, then this scalar is used as the size
in each dimension.
noise : float, optional
The noise-power to use. If None, then noise is estimated as the
average of the local variance of the input.</p>
<h2 id="returns_303">Returns<a class="headerlink" href="#returns_303" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Wiener filtered result with the same shape as <code>im</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Sigtools</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Spectral</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Sp_fft</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_306">Parameters<a class="headerlink" href="#parameters_306" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_304">Returns<a class="headerlink" href="#returns_304" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_215">See Also<a class="headerlink" href="#see-also_215" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_194">Notes<a class="headerlink" href="#notes_194" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on <code>dct</code> and the <code>idct</code> is scaled by
<code>1/N</code> where <code>N</code> is the 'logical' size of the DCT. For <code>norm='ortho'</code>
both directions are scaled by the same factor <code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<h2 id="references_48">References<a class="headerlink" href="#references_48" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_248">Examples<a class="headerlink" href="#examples_248" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_307">Parameters<a class="headerlink" href="#parameters_307" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_305">Returns<a class="headerlink" href="#returns_305" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_216">See Also<a class="headerlink" href="#see-also_216" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_195">Notes<a class="headerlink" href="#notes_195" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_249">Examples<a class="headerlink" href="#examples_249" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_308">Parameters<a class="headerlink" href="#parameters_308" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_306">Returns<a class="headerlink" href="#returns_306" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_217">See Also<a class="headerlink" href="#see-also_217" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_196">Notes<a class="headerlink" href="#notes_196" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on the <code>dst</code> and the <code>idst</code> is
scaled by <code>1/N</code> where <code>N</code> is the 'logical' size of the DST. For
<code>norm='ortho'</code> both directions are scaled by the same factor
<code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<h2 id="references_49">References<a class="headerlink" href="#references_49" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_309">Parameters<a class="headerlink" href="#parameters_309" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding dimension
of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_307">Returns<a class="headerlink" href="#returns_307" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_218">See Also<a class="headerlink" href="#see-also_218" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_197">Notes<a class="headerlink" href="#notes_197" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_250">Examples<a class="headerlink" href="#examples_250" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [1]_.</p>
<h2 id="parameters_310">Parameters<a class="headerlink" href="#parameters_310" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT.  If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode. Default is None, meaning no normalization on the
forward transforms and scaling by <code>1/n</code> on the <code>ifft</code>.
For <code>norm='ortho'</code>, both directions are scaled by <code>1/sqrt(n)</code>.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See the notes below for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>. See below for more
details.</p>
<h2 id="returns_308">Returns<a class="headerlink" href="#returns_308" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_46">Raises<a class="headerlink" href="#raises_46" title="Permanent link">&para;</a></h2>
<p>IndexError
if <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_219">See Also<a class="headerlink" href="#see-also_219" title="Permanent link">&para;</a></h2>
<p>ifft : The inverse of <code>fft</code>.
fft2 : The two-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.
next_fast_len : Size to pad input to for most efficient transforms</p>
<h2 id="notes_198">Notes<a class="headerlink" href="#notes_198" title="Permanent link">&para;</a></h2>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform
(DFT) can be calculated efficiently, by using symmetries in the calculated
terms. The symmetry is highest when <code>n</code> is a power of 2, and the transform
is therefore most efficient for these sizes. For poorly factorizable sizes,
<code>scipy.fft</code> uses Bluestein's algorithm [2]_ and so is never worse than
O(<code>n</code> log <code>n</code>). Further performance improvements may be seen by zero-padding
the input using <code>next_fast_len</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>fft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(-2j * np.pi * k * np.arange(n)/n))</p>
<p>The frequency term <code>f=k/n</code> is found at <code>y[k]</code>. At <code>y[n/2]</code> we reach
the Nyquist frequency and wrap around to the negative-frequency terms. So,
for an 8-point transform, the frequencies of the result are
[0, 1, 2, 3, -4, -3, -2, -1]. To rearrange the fft output so that the
zero-frequency component is centered, like [-4, -3, -2, -1, 0, 1, 2, 3],
use <code>fftshift</code>.</p>
<p>Transforms can be done in single, double or extended precision (long
double) floating point. Half precision inputs will be converted to single
precision and non floating-point inputs will be converted to double
precision.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<p>When <code>overwrite_x=True</code> is specified, the memory referenced by <code>x</code> may
be used by the implementation in any way. This may include reusing the
memory for the result, but this is in no way guaranteed. You should not
rely on the contents of <code>x</code> after the transform as this may change in
future without warning.</p>
<p>The <code>workers</code> argument specifies the maximum number of parallel jobs to
split the FFT computation into. This will execute independent 1-dimensional
FFTs within <code>x</code>. So, <code>x</code> must be at least 2-dimensional and the
non-transformed axes must be large enough to split into chunks. If <code>x</code> is
too small, fewer jobs may be used than requested.</p>
<h2 id="references_50">References<a class="headerlink" href="#references_50" title="Permanent link">&para;</a></h2>
<p>.. [1] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
machine calculation of complex Fourier series,' <em>Math. Comput.</em>
19: 297-301.
.. [2] Bluestein, L., 1970, 'A linear filtering approach to the
computation of discrete Fourier transform'. <em>IEEE Transactions on
Audio and Electroacoustics.</em> 18 (4): 451-455.</p>
<h2 id="examples_251">Examples<a class="headerlink" href="#examples_251" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, fftfreq, fftshift
import matplotlib.pyplot as plt
t = np.arange(256)
sp = fftshift(fft(np.sin(t)))
freq = fftshift(fftfreq(t.shape[-1]))
plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional discrete Fourier Transform</p>
<p>This function computes the <em>n</em>-dimensional discrete Fourier Transform
over any axes in an <em>M</em>-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.</p>
<h2 id="parameters_311">Parameters<a class="headerlink" href="#parameters_311" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT. If not given, the last two axes are
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_309">Returns<a class="headerlink" href="#returns_309" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_47">Raises<a class="headerlink" href="#raises_47" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_220">See Also<a class="headerlink" href="#see-also_220" title="Permanent link">&para;</a></h2>
<p>ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
For two-dimensional input, swaps first and third quadrants, and second
and fourth quadrants.</p>
<h2 id="notes_199">Notes<a class="headerlink" href="#notes_199" title="Permanent link">&para;</a></h2>
<p><code>fft2</code> is just <code>fftn</code> with a different default for <code>axes</code>.</p>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.</p>
<p>See <code>fftn</code> for details and a plotting example, and <code>fft</code> for
definitions and conventions used.</p>
<h2 id="examples_252">Examples<a class="headerlink" href="#examples_252" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:5, :5][0]
scipy.fft.fft2(x)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
0.  +0.j        ,   0.  +0.j        ],
[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_312">Parameters<a class="headerlink" href="#parameters_312" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_310">Returns<a class="headerlink" href="#returns_310" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_253">Examples<a class="headerlink" href="#examples_253" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform.</p>
<p>This function computes the <em>N</em>-dimensional discrete Fourier Transform over
any number of axes in an <em>M</em>-dimensional array by means of the Fast Fourier
Transform (FFT).</p>
<h2 id="parameters_313">Parameters<a class="headerlink" href="#parameters_313" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_311">Returns<a class="headerlink" href="#returns_311" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_48">Raises<a class="headerlink" href="#raises_48" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_221">See Also<a class="headerlink" href="#see-also_221" title="Permanent link">&para;</a></h2>
<p>ifftn : The inverse of <code>fftn</code>, the inverse <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The <em>n</em>-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array</p>
<h2 id="notes_200">Notes<a class="headerlink" href="#notes_200" title="Permanent link">&para;</a></h2>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="examples_254">Examples<a class="headerlink" href="#examples_254" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:3, :3, :3][0]
scipy.fft.fftn(x, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[ 9.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[18.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]]])
scipy.fft.fftn(x, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
[ 0.+0.j,  0.+0.j,  0.+0.j]],
[[-2.+0.j, -2.+0.j, -2.+0.j],
[ 0.+0.j,  0.+0.j,  0.+0.j]]])</p>
<p>import matplotlib.pyplot as plt
[X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
FS = scipy.fft.fftn(S)
plt.imshow(np.log(np.abs(scipy.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_314">Parameters<a class="headerlink" href="#parameters_314" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_312">Returns<a class="headerlink" href="#returns_312" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_222">See Also<a class="headerlink" href="#see-also_222" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_255">Examples<a class="headerlink" href="#examples_255" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_workers</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the default number of workers within the current context</p>
<h2 id="examples_256">Examples<a class="headerlink" href="#examples_256" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft
fft.get_workers()
1
with fft.set_workers(4):
...     fft.get_workers()
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.</p>
<h2 id="parameters_315">Parameters<a class="headerlink" href="#parameters_315" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output. For <code>n</code> output
points, <code>n//2 + 1</code> input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros. If <code>n</code> is not given, it is taken to be <code>2*(m-1)</code>
where <code>m</code> is the length of the input along the axis specified by
<code>axis</code>.
axis : int, optional
Axis over which to compute the FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_313">Returns<a class="headerlink" href="#returns_313" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*m - 2</code> where <code>m</code> is the length of the transformed axis of
the input. To get an odd number of output points, <code>n</code> must be
specified, for instance as <code>2*m - 1</code> in the typical case,</p>
<h2 id="raises_49">Raises<a class="headerlink" href="#raises_49" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_223">See also<a class="headerlink" href="#see-also_223" title="Permanent link">&para;</a></h2>
<p>rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of <code>hfft</code>.
hfftn : Compute the n-dimensional FFT of a Hermitian signal.</p>
<h2 id="notes_201">Notes<a class="headerlink" href="#notes_201" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd.
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_257">Examples<a class="headerlink" href="#examples_257" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, hfft
a = 2 * np.pi * np.arange(10) / 10
signal = np.cos(a) + 3j * np.sin(3 * a)
fft(signal).round(10)
array([ -0.+0.j,   5.+0.j,  -0.+0.j,  15.-0.j,   0.+0.j,   0.+0.j,
-0.+0.j, -15.-0.j,   0.+0.j,   5.+0.j])
hfft(signal[:6]).round(10) # Input first half of signal
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])
hfft(signal, 10)  # Input entire signal and truncate
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a Hermitian complex array.</p>
<h2 id="parameters_316">Parameters<a class="headerlink" href="#parameters_316" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be Hermitian complex.
s : sequence of ints, optional
Shape of the real output.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_314">Returns<a class="headerlink" href="#returns_314" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The real result of the 2D Hermitian complex real FFT.</p>
<h2 id="see-also_224">See Also<a class="headerlink" href="#see-also_224" title="Permanent link">&para;</a></h2>
<p>hfftn : Compute the N-dimensional discrete Fourier Transform for Hermitian
complex input.</p>
<h2 id="notes_202">Notes<a class="headerlink" href="#notes_202" title="Permanent link">&para;</a></h2>
<p>This is really just <code>hfftn</code> with different default behavior.
For more details see <code>hfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional FFT of Hermitian symmetric complex input, i.e. a
signal with a real spectrum.</p>
<p>This function computes the N-dimensional discrete Fourier Transform for a
Hermitian symmetric complex input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT). In other
words, <code>ihfftn(hfftn(x, s)) == x</code> to within numerical accuracy. (<code>s</code>
here is <code>x.shape</code> with <code>s[-1] = x.shape[-1] * 2 - 1</code>, this is necessary
for the same reason <code>x.shape</code> would be necessary for <code>irfft</code>.)</p>
<h2 id="parameters_317">Parameters<a class="headerlink" href="#parameters_317" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_315">Returns<a class="headerlink" href="#returns_315" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_50">Raises<a class="headerlink" href="#raises_50" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_225">See Also<a class="headerlink" href="#see-also_225" title="Permanent link">&para;</a></h2>
<p>ihfftn : The inverse n-dimensional FFT with real spectrum. Inverse of <code>hfftn</code>.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : Forward FFT of real input</p>
<h2 id="notes_203">Notes<a class="headerlink" href="#notes_203" title="Permanent link">&para;</a></h2>
<p>For a 1 dimensional signal <code>x</code> to have a real spectrum, it must satisfy
the Hermitian property::</p>
<p>x[i] == np.conj(x[-i]) for all i</p>
<p>This generalizes into higher dimensions by reflecting over each axis in
turn::</p>
<p>x[i, j, k, ...] == np.conj(x[-i, -j, -k, ...]) for all i, j, k, ...</p>
<p>This should not be confused with a Hermitian matrix, for which the
transpose is it's own conjugate::</p>
<p>x[i, j] == np.conj(x[j, i]) for all i, j</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_258">Examples<a class="headerlink" href="#examples_258" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((3, 2, 2))
scipy.fft.hfftn(x)
array([[[12.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_318">Parameters<a class="headerlink" href="#parameters_318" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_316">Returns<a class="headerlink" href="#returns_316" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_226">See Also<a class="headerlink" href="#see-also_226" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_204">Notes<a class="headerlink" href="#notes_204" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT-II, which is the same as the normalized DCT-III.</p>
<p>The IDCT is equivalent to a normal DCT except for the normalization and
type. DCT type 1 and 4 are their own inverse and DCTs 2 and 3 are each
other's inverses.</p>
<h2 id="examples_259">Examples<a class="headerlink" href="#examples_259" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1)
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_319">Parameters<a class="headerlink" href="#parameters_319" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are
None, <code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is
not None, then <code>s</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_317">Returns<a class="headerlink" href="#returns_317" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_227">See Also<a class="headerlink" href="#see-also_227" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_205">Notes<a class="headerlink" href="#notes_205" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_260">Examples<a class="headerlink" href="#examples_260" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_320">Parameters<a class="headerlink" href="#parameters_320" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_318">Returns<a class="headerlink" href="#returns_318" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_228">See Also<a class="headerlink" href="#see-also_228" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_206">Notes<a class="headerlink" href="#notes_206" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST-II, which is the same as the normalized DST-III.</p>
<p>The IDST is equivalent to a normal DST except for the normalization and
type. DST type 1 and 4 are their own inverse and DSTs 2 and 3 are each
other's inverses.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_321">Parameters<a class="headerlink" href="#parameters_321" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_319">Returns<a class="headerlink" href="#returns_319" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_229">See Also<a class="headerlink" href="#see-also_229" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_207">Notes<a class="headerlink" href="#notes_207" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_261">Examples<a class="headerlink" href="#examples_261" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <code>fft</code>.  In other words,
<code>ifft(fft(x)) == x</code> to within numerical accuracy.</p>
<p>The input should be ordered in the same way as is returned by <code>fft</code>,
i.e.,</p>
<ul>
<li><code>x[0]</code> should contain the zero frequency term,</li>
<li><code>x[1:n//2]</code> should contain the positive-frequency terms,</li>
<li><code>x[n//2 + 1:]</code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</li>
</ul>
<p>For an even number of input points, <code>x[n//2]</code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <code>fft</code> for details.</p>
<h2 id="parameters_322">Parameters<a class="headerlink" href="#parameters_322" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
See notes about padding issues.
axis : int, optional
Axis over which to compute the inverse DFT.  If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_320">Returns<a class="headerlink" href="#returns_320" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_51">Raises<a class="headerlink" href="#raises_51" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_230">See Also<a class="headerlink" href="#see-also_230" title="Permanent link">&para;</a></h2>
<p>fft : The one-dimensional (forward) FFT, of which <code>ifft</code> is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.</p>
<h2 id="notes_208">Notes<a class="headerlink" href="#notes_208" title="Permanent link">&para;</a></h2>
<p>If the input parameter <code>n</code> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <code>ifft</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>ifft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(2j * np.pi * k * np.arange(n)/n)) / len(x)</p>
<p>As with <code>fft</code>, <code>ifft</code> has support for all floating point types and is
optimized for real input.</p>
<h2 id="examples_262">Examples<a class="headerlink" href="#examples_262" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot a band-limited signal with random phases:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(400)
n = np.zeros((400,), dtype=complex)
n[40:60] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20,)))
s = scipy.fft.ifft(n)
plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, <code>ifft2(fft2(x)) == x</code>
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fft2</code>, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_323">Parameters<a class="headerlink" href="#parameters_323" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each axis) of the output (<code>s[0]</code> refers to axis 0,
<code>s[1]</code> to axis 1, etc.).  This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last two
axes are used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_321">Returns<a class="headerlink" href="#returns_321" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_52">Raises<a class="headerlink" href="#raises_52" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_231">See Also<a class="headerlink" href="#see-also_231" title="Permanent link">&para;</a></h2>
<p>fft2 : The forward 2-dimensional FFT, of which <code>ifft2</code> is the inverse.
ifftn : The inverse of the <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.</p>
<h2 id="notes_209">Notes<a class="headerlink" href="#notes_209" title="Permanent link">&para;</a></h2>
<p><code>ifft2</code> is just <code>ifftn</code> with a different default for <code>axes</code>.</p>
<p>See <code>ifftn</code> for details and a plotting example, and <code>fft</code> for
definition and conventions used.</p>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifft2</code> is called.</p>
<h2 id="examples_263">Examples<a class="headerlink" href="#examples_263" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = 4 * np.eye(4)
scipy.fft.ifft2(x)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
<code>ifftn(fftn(x)) == x</code> to within numerical accuracy.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fftn</code>, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_324">Parameters<a class="headerlink" href="#parameters_324" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the IFFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_322">Returns<a class="headerlink" href="#returns_322" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_53">Raises<a class="headerlink" href="#raises_53" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_232">See Also<a class="headerlink" href="#see-also_232" title="Permanent link">&para;</a></h2>
<p>fftn : The forward <em>n</em>-dimensional FFT, of which <code>ifftn</code> is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes <code>fftshift</code>, shifts zero-frequency terms to beginning
of array.</p>
<h2 id="notes_210">Notes<a class="headerlink" href="#notes_210" title="Permanent link">&para;</a></h2>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifftn</code> is called.</p>
<h2 id="examples_264">Examples<a class="headerlink" href="#examples_264" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.eye(4)
scipy.fft.ifftn(scipy.fft.fftn(x, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot an image with band-limited frequency content:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
n = np.zeros((200,200), dtype=complex)
n[60:80, 20:40] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20, 20)))
im = scipy.fft.ifftn(n).real
plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_325">Parameters<a class="headerlink" href="#parameters_325" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_323">Returns<a class="headerlink" href="#returns_323" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_233">See Also<a class="headerlink" href="#see-also_233" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_265">Examples<a class="headerlink" href="#examples_265" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p>
<h2 id="parameters_326">Parameters<a class="headerlink" href="#parameters_326" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
n : int, optional
Length of the inverse FFT, the number of points along
transformation axis in the input to use.  If <code>n</code> is smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. If <code>n</code> is not given, the length of
the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_324">Returns<a class="headerlink" href="#returns_324" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n//2 + 1</code>.</p>
<h2 id="see-also_234">See also<a class="headerlink" href="#see-also_234" title="Permanent link">&para;</a></h2>
<p>hfft, irfft</p>
<h2 id="notes_211">Notes<a class="headerlink" href="#notes_211" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd:
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_266">Examples<a class="headerlink" href="#examples_266" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, ihfft
spectrum = np.array([ 15, -4, 0, -1, 0, -4])
ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real spectrum.</p>
<h2 id="parameters_327">Parameters<a class="headerlink" href="#parameters_327" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real input to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_325">Returns<a class="headerlink" href="#returns_325" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_235">See Also<a class="headerlink" href="#see-also_235" title="Permanent link">&para;</a></h2>
<p>ihfftn : Compute the inverse of the N-dimensional FFT of Hermitian input.</p>
<h2 id="notes_212">Notes<a class="headerlink" href="#notes_212" title="Permanent link">&para;</a></h2>
<p>This is really <code>ihfftn</code> with different defaults.
For more details see <code>ihfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform for a real
spectrum.</p>
<p>This function computes the N-dimensional inverse discrete Fourier Transform
over any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT). By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining transforms
are complex.</p>
<h2 id="parameters_328">Parameters<a class="headerlink" href="#parameters_328" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_326">Returns<a class="headerlink" href="#returns_326" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_54">Raises<a class="headerlink" href="#raises_54" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_236">See Also<a class="headerlink" href="#see-also_236" title="Permanent link">&para;</a></h2>
<p>hfftn : The forward n-dimensional FFT of Hermitian input.
hfft : The one-dimensional FFT of Hermitian input.
fft : The one-dimensional FFT, with definitions and conventions used.
fftn : The n-dimensional FFT.
hfft2 : The two-dimensional FFT of Hermitian input.</p>
<h2 id="notes_213">Notes<a class="headerlink" href="#notes_213" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>ihfft</code>, then the transform over the remaining axes is
performed as by <code>ifftn</code>. The order of the output is the positive part of
the Hermitian output signal, in the same format as <code>rfft</code>.</p>
<h2 id="examples_267">Examples<a class="headerlink" href="#examples_267" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.ihfftn(x)
array([[[1.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])
scipy.fft.ihfftn(x, axes=(2, 0))
array([[[1.+0.j,  0.+0.j], # may vary
[1.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <code>rfft</code>.
In other words, <code>irfft(rfft(x), len(x)) == x</code> to within numerical
accuracy. (See Notes below for why <code>len(a)</code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <code>rfft</code>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<h2 id="parameters_329">Parameters<a class="headerlink" href="#parameters_329" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output.
For <code>n</code> output points, <code>n//2+1</code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <code>n</code> is not given, it is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along the axis
specified by <code>axis</code>.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_327">Returns<a class="headerlink" href="#returns_327" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*(m-1)</code> where <code>m</code> is the length of the transformed axis of the
input. To get an odd number of output points, <code>n</code> must be specified.</p>
<h2 id="raises_55">Raises<a class="headerlink" href="#raises_55" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_237">See Also<a class="headerlink" href="#see-also_237" title="Permanent link">&para;</a></h2>
<p>rfft : The one-dimensional FFT of real input, of which <code>irfft</code> is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_214">Notes<a class="headerlink" href="#notes_214" title="Permanent link">&para;</a></h2>
<p>Returns the real valued <code>n</code>-point inverse discrete Fourier transform
of <code>x</code>, where <code>x</code> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <code>n</code> is the length of the result, not the
input.</p>
<p>If you specify an <code>n</code> such that <code>a</code> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <code>m</code> points via Fourier interpolation by:
<code>a_resamp = irfft(rfft(a), m)</code>.</p>
<p>The default value of <code>n</code> assumes an even output length. By the Hermitian
symmetry, the last imaginary component must be 0 and so is ignored. To
avoid losing information, the correct length of the real input <em>must</em> be
given.</p>
<h2 id="examples_268">Examples<a class="headerlink" href="#examples_268" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
scipy.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the last term in the input to the ordinary <code>ifft</code> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <code>irfft</code>, the negative frequencies are not
specified, and the output array is purely real.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real array.</p>
<h2 id="parameters_330">Parameters<a class="headerlink" href="#parameters_330" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real output to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_328">Returns<a class="headerlink" href="#returns_328" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_238">See Also<a class="headerlink" href="#see-also_238" title="Permanent link">&para;</a></h2>
<p>irfftn : Compute the inverse of the N-dimensional FFT of real input.</p>
<h2 id="notes_215">Notes<a class="headerlink" href="#notes_215" title="Permanent link">&para;</a></h2>
<p>This is really <code>irfftn</code> with different defaults.
For more details see <code>irfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the N-dimensional FFT of real input.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, <code>irfftn(rfftn(x), x.shape) == x</code> to within numerical
accuracy. (The <code>a.shape</code> is necessary like <code>len(a)</code> is for <code>irfft</code>,
and for the same reason.)</p>
<p>The input should be ordered in the same way as is returned by <code>rfftn</code>,
i.e. as for <code>irfft</code> for the final transformation axis, and as for <code>ifftn</code>
along all the other axes.</p>
<h2 id="parameters_331">Parameters<a class="headerlink" href="#parameters_331" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_329">Returns<a class="headerlink" href="#returns_329" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_56">Raises<a class="headerlink" href="#raises_56" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_239">See Also<a class="headerlink" href="#see-also_239" title="Permanent link">&para;</a></h2>
<p>rfftn : The forward n-dimensional FFT of real input,
of which <code>ifftn</code> is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.</p>
<h2 id="notes_216">Notes<a class="headerlink" href="#notes_216" title="Permanent link">&para;</a></h2>
<p>See <code>fft</code> for definitions and conventions used.</p>
<p>See <code>rfft</code> for definitions and conventions used for real input.</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_269">Examples<a class="headerlink" href="#examples_269" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.zeros((3, 2, 2))
x[0, 0, 0] = 3 * 2 * 2
scipy.fft.irfftn(x)
array([[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">register_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Register a backend for permanent use.</p>
<p>Registered backends have the lowest priority and will be tried after the
global backend.</p>
<h2 id="parameters_332">Parameters<a class="headerlink" href="#parameters_332" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_57">Raises<a class="headerlink" href="#raises_57" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).</p>
<h2 id="parameters_333">Parameters<a class="headerlink" href="#parameters_333" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array
n : int, optional
Number of points along transformation axis in the input to use.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT. If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_330">Returns<a class="headerlink" href="#returns_330" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
If <code>n</code> is even, the length of the transformed axis is <code>(n/2)+1</code>.
If <code>n</code> is odd, the length is <code>(n+1)/2</code>.</p>
<h2 id="raises_58">Raises<a class="headerlink" href="#raises_58" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_240">See Also<a class="headerlink" href="#see-also_240" title="Permanent link">&para;</a></h2>
<p>irfft : The inverse of <code>rfft</code>.
fft : The one-dimensional FFT of general (complex) input.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_217">Notes<a class="headerlink" href="#notes_217" title="Permanent link">&para;</a></h2>
<p>When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore <code>n//2 + 1</code>.</p>
<p>When <code>X = rfft(x)</code> and fs is the sampling frequency, <code>X[0]</code> contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</p>
<p>If <code>n</code> is even, <code>A[-1]</code> contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If <code>n</code> is odd, there is no term at fs/2; <code>A[-1]</code> contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.</p>
<p>If the input <code>a</code> contains an imaginary part, it is silently discarded.</p>
<h2 id="examples_270">Examples<a class="headerlink" href="#examples_270" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
scipy.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the final element of the <code>fft</code> output is the complex conjugate
of the second element, for real input. For <code>rfft</code>, this symmetry is
exploited to compute only the non-negative frequency terms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a real array.</p>
<h2 id="parameters_334">Parameters<a class="headerlink" href="#parameters_334" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be real.
s : sequence of ints, optional
Shape of the FFT.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_331">Returns<a class="headerlink" href="#returns_331" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the real 2-D FFT.</p>
<h2 id="see-also_241">See Also<a class="headerlink" href="#see-also_241" title="Permanent link">&para;</a></h2>
<p>rfftn : Compute the N-dimensional discrete Fourier Transform for real
input.</p>
<h2 id="notes_218">Notes<a class="headerlink" href="#notes_218" title="Permanent link">&para;</a></h2>
<p>This is really just <code>rfftn</code> with different default behavior.
For more details see <code>rfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,     n/2-1,     n/2] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d</em>n)   if n is odd</p>
<p>Unlike <code>fftfreq</code> (but like <code>scipy.fftpack.rfftfreq</code>)
the Nyquist frequency component is considered to be positive.</p>
<h2 id="parameters_335">Parameters<a class="headerlink" href="#parameters_335" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_332">Returns<a class="headerlink" href="#returns_332" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n//2 + 1</code> containing the sample frequencies.</p>
<h2 id="examples_271">Examples<a class="headerlink" href="#examples_271" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
fourier = np.fft.rfft(signal)
n = signal.size
sample_rate = 100
freq = np.fft.fftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
freq = np.fft.rfftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20.,  30.,  40.,  50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.</p>
<h2 id="parameters_336">Parameters<a class="headerlink" href="#parameters_336" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
The final element of <code>s</code> corresponds to <code>n</code> for <code>rfft(x, n)</code>, while
for the remaining axes, it corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_333">Returns<a class="headerlink" href="#returns_333" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_59">Raises<a class="headerlink" href="#raises_59" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_242">See Also<a class="headerlink" href="#see-also_242" title="Permanent link">&para;</a></h2>
<p>irfftn : The inverse of <code>rfftn</code>, i.e. the inverse of the n-dimensional FFT
of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.</p>
<h2 id="notes_219">Notes<a class="headerlink" href="#notes_219" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>rfft</code>, then the transform over the remaining axes is
performed as by <code>fftn</code>.  The order of the output is as for <code>rfft</code> for the
final transformation axis, and as for <code>fftn</code> for the remaining
transformation axes.</p>
<p>See <code>fft</code> for details, definitions and conventions used.</p>
<h2 id="examples_272">Examples<a class="headerlink" href="#examples_272" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.rfftn(x)
array([[[8.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
<p>scipy.fft.rfftn(x, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
[4.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_backend</span> <span class="o">:</span> <span class="o">?</span><span class="n">coerce</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">backend</span><span class="o">:[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to set the backend within a fixed scope.</p>
<p>Upon entering the <code>with</code> statement, the given backend will be added to
the list of available backends with the highest priority. Upon exit, the
backend is reset to the state before entering the scope.</p>
<h2 id="parameters_337">Parameters<a class="headerlink" href="#parameters_337" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.
coerce: bool, optional
Whether to allow expensive conversions for the <code>x</code> parameter. e.g.
copying a numpy array to the GPU for a CuPy backend. Implies <code>only</code>.
only: bool, optional
If only is <code>True</code> and this backend returns <code>NotImplemented</code> then a
BackendNotImplemented error will be raised immediately. Ignoring any
lower priority backends.</p>
<h2 id="examples_273">Examples<a class="headerlink" href="#examples_273" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
with fft.set_backend('scipy', only=True):
...     fft.fft([1])  # Always calls the scipy implementation
array([1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_global_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sets the global fft backend</p>
<p>The global backend has higher priority than registered backends, but lower
priority than context-specific backends set with <code>set_backend</code>.</p>
<h2 id="parameters_338">Parameters<a class="headerlink" href="#parameters_338" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_60">Raises<a class="headerlink" href="#raises_60" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<h2 id="notes_220">Notes<a class="headerlink" href="#notes_220" title="Permanent link">&para;</a></h2>
<p>This will overwrite the previously set global backend, which by default is
the SciPy implementation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_workers</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager for the default number of workers used in <code>scipy.fft</code></p>
<h2 id="parameters_339">Parameters<a class="headerlink" href="#parameters_339" title="Permanent link">&para;</a></h2>
<p>workers : int
The default number of workers to use</p>
<h2 id="examples_274">Examples<a class="headerlink" href="#examples_274" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft, signal
x = np.random.randn(128, 64)
with fft.set_workers(4):
...     y = signal.fftconvolve(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">skip_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to skip a backend within a fixed scope.</p>
<p>Within the context of a <code>with</code> statement, the given backend will not be
called. This covers backends registered both locally and globally. Upon
exit, the backend will again be considered.</p>
<h2 id="parameters_340">Parameters<a class="headerlink" href="#parameters_340" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to skip.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="examples_275">Examples<a class="headerlink" href="#examples_275" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
fft.fft([1])  # Calls default scipy backend
array([1.+0.j])
with fft.skip_backend('scipy'):  # We expicitly skip the scipy backend
...     fft.fft([1])                 # leaving no implementation available
Traceback (most recent call last):
...
BackendNotImplementedError: No selected backends had an implementation ...</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_COLA</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check whether the Constant OverLap Add (COLA) constraint is met</p>
<h2 id="parameters_341">Parameters<a class="headerlink" href="#parameters_341" title="Permanent link">&para;</a></h2>
<p>window : str or tuple or array_like
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.</p>
<h2 id="returns_334">Returns<a class="headerlink" href="#returns_334" title="Permanent link">&para;</a></h2>
<p>verdict : bool
<code>True</code> if chosen combination satisfies COLA within <code>tol</code>,
<code>False</code> otherwise</p>
<h2 id="see-also_243">See Also<a class="headerlink" href="#see-also_243" title="Permanent link">&para;</a></h2>
<p>check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform</p>
<h2 id="notes_221">Notes<a class="headerlink" href="#notes_221" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, it is sufficient that the signal windowing obeys the constraint of
'Constant OverLap Add' (COLA). This ensures that every point in the input
data is equally weighted, thereby avoiding aliasing and allowing full
reconstruction.</p>
<p>Some examples of windows that satisfy COLA:
- Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...
- Bartlett window at overlap of 1/2, 3/4, 5/6, ...
- Hann window at 1/2, 2/3, 3/4, ...
- Any Blackman family window at 2/3 overlap
- Any window with <code>noverlap = nperseg-1</code></p>
<p>A very comprehensive list of other windows may be found in [2]_,
wherein the COLA condition is satisfied when the 'Amplitude
Flatness' is unity.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_51">References<a class="headerlink" href="#references_51" title="Permanent link">&para;</a></h2>
<p>.. [1] Julius O. Smith III, 'Spectral Audio Signal Processing', W3K
Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, 'Spectrum and
spectral density estimation by the Discrete Fourier transform
(DFT), including a comprehensive list of window functions and
some new at-top windows', 2002,
http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</p>
<h2 id="examples_276">Examples<a class="headerlink" href="#examples_276" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Confirm COLA condition for rectangular window of 75% (3/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.boxcar(100), 100, 75)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>COLA is not true for 25% (1/4) overlap, though:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.boxcar(100), 100, 25)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Symmetrical' Hann window (for filter design) is not COLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.hann(120, sym=True), 120, 60)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Periodic' or 'DFT-even' Hann window (for FFT analysis) is COLA for
overlap of 1/2, 2/3, 3/4, etc.:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 60)
True</p>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 80)
True</p>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 90)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_NOLA</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check whether the Nonzero Overlap Add (NOLA) constraint is met</p>
<h2 id="parameters_342">Parameters<a class="headerlink" href="#parameters_342" title="Permanent link">&para;</a></h2>
<p>window : str or tuple or array_like
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.</p>
<h2 id="returns_335">Returns<a class="headerlink" href="#returns_335" title="Permanent link">&para;</a></h2>
<p>verdict : bool
<code>True</code> if chosen combination satisfies the NOLA constraint within
<code>tol</code>, <code>False</code> otherwise</p>
<h2 id="see-also_244">See Also<a class="headerlink" href="#see-also_244" title="Permanent link">&para;</a></h2>
<p>check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform</p>
<h2 id="notes_222">Notes<a class="headerlink" href="#notes_222" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, the signal windowing must obey the constraint of 'nonzero
overlap add' (NOLA):</p>
<p>.. math:: \sum_{t}w^{2}[n-tH] \ne 0</p>
<p>for all :math:<code>n</code>, where :math:<code>w</code> is the window function, :math:<code>t</code> is the
frame index, and :math:<code>H</code> is the hop size (:math:<code>H</code> = <code>nperseg</code> -
<code>noverlap</code>).</p>
<p>This ensures that the normalization factors in the denominator of the
overlap-add inversion equation are not zero. Only very pathological windows
will fail the NOLA constraint.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="references_52">References<a class="headerlink" href="#references_52" title="Permanent link">&para;</a></h2>
<p>.. [1] Julius O. Smith III, 'Spectral Audio Signal Processing', W3K
Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, 'Spectrum and
spectral density estimation by the Discrete Fourier transform
(DFT), including a comprehensive list of window functions and
some new at-top windows', 2002,
http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</p>
<h2 id="examples_277">Examples<a class="headerlink" href="#examples_277" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Confirm NOLA condition for rectangular window of 75% (3/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.boxcar(100), 100, 75)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>NOLA is also true for 25% (1/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.boxcar(100), 100, 25)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Symmetrical' Hann window (for filter design) is also NOLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.hann(120, sym=True), 120, 60)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>As long as there is overlap, it takes quite a pathological window to fail
NOLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = np.ones(64, dtype='float')
w[::2] = 0
signal.check_NOLA(w, 64, 32)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is not enough overlap, a window with zeros at the ends will not
work:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.hann(64), 64, 0)
False
signal.check_NOLA(signal.hann(64), 64, 1)
False
signal.check_NOLA(signal.hann(64), 64, 2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coherence</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate the magnitude squared coherence estimate, Cxy, of
discrete-time signals X and Y using Welch's method.</p>
<p><code>Cxy = abs(Pxy)**2/(Pxx*Pyy)</code>, where <code>Pxx</code> and <code>Pyy</code> are power
spectral density estimates of X and Y, and <code>Pxy</code> is the cross
spectral density estimate of X and Y.</p>
<h2 id="parameters_343">Parameters<a class="headerlink" href="#parameters_343" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
y : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> and <code>y</code> time series. Defaults
to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap: int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
axis : int, optional
Axis along which the coherence is computed for both inputs; the
default is over the last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_336">Returns<a class="headerlink" href="#returns_336" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Cxy : ndarray
Magnitude squared coherence of x and y.</p>
<h2 id="see-also_245">See Also<a class="headerlink" href="#see-also_245" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.</p>
<h2 id="notes_223">Notes<a class="headerlink" href="#notes_223" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_53">References<a class="headerlink" href="#references_53" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Stoica, Petre, and Randolph Moses, 'Spectral Analysis of
Signals' Prentice Hall, 2005</p>
<h2 id="examples_278">Examples<a class="headerlink" href="#examples_278" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate two test signals with some common features.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 20
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
b, a = signal.butter(2, 0.25, 'low')
x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
y = signal.lfilter(b, a, x)
x += amp<em>np.sin(2</em>np.pi<em>freq</em>time)
y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the coherence.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Cxy = signal.coherence(x, y, fs, nperseg=1024)
plt.semilogy(f, Cxy)
plt.xlabel('frequency [Hz]')
plt.ylabel('Coherence')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">const_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Constant extension at the boundaries of an array</p>
<p>Generate a new ndarray that is a constant extension of <code>x</code> along an axis.</p>
<p>The extension repeats the values at the first and last element of
the axis.</p>
<h2 id="parameters_344">Parameters<a class="headerlink" href="#parameters_344" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_279">Examples<a class="headerlink" href="#examples_279" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import const_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
const_ext(a, 2)
array([[ 1,  1,  1,  2,  3,  4,  5,  5,  5],
[ 0,  0,  0,  1,  4,  9, 16, 16, 16]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constant extension continues with the same values as the endpoints of the
array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = const_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='constant extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csd</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">average</span><span class="o">:[`</span><span class="nc">Mean</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Median</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate the cross power spectral density, Pxy, using Welch's
method.</p>
<h2 id="parameters_345">Parameters<a class="headerlink" href="#parameters_345" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
y : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> and <code>y</code> time series. Defaults
to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap: int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the cross spectral density ('density')
where <code>Pxy</code> has units of V<strong>2/Hz and computing the cross spectrum
('spectrum') where <code>Pxy</code> has units of V</strong>2, if <code>x</code> and <code>y</code> are
measured in V and <code>fs</code> is measured in Hz. Defaults to 'density'
axis : int, optional
Axis along which the CSD is computed for both inputs; the
default is over the last axis (i.e. <code>axis=-1</code>).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. Defaults to 'mean'.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_337">Returns<a class="headerlink" href="#returns_337" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxy : ndarray
Cross spectral density or cross power spectrum of x,y.</p>
<h2 id="see-also_246">See Also<a class="headerlink" href="#see-also_246" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method. [Equivalent to
csd(x,x)]
coherence: Magnitude squared coherence by Welch's method.</p>
<h2 id="notes_224">Notes<a class="headerlink" href="#notes_224" title="Permanent link">&para;</a></h2>
<p>By convention, Pxy is computed with the conjugate FFT of X
multiplied by the FFT of Y.</p>
<p>If the input series differ in length, the shorter series will be
zero-padded to match.</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_54">References<a class="headerlink" href="#references_54" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Rabiner, Lawrence R., and B. Gold. 'Theory and Application of
Digital Signal Processing' Prentice-Hall, pp. 414-419, 1975</p>
<h2 id="examples_280">Examples<a class="headerlink" href="#examples_280" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate two test signals with some common features.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 20
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
b, a = signal.butter(2, 0.25, 'low')
x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
y = signal.lfilter(b, a, x)
x += amp<em>np.sin(2</em>np.pi<em>freq</em>time)
y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the magnitude of the cross spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxy = signal.csd(x, y, fs, nperseg=1024)
plt.semilogy(f, np.abs(Pxy))
plt.xlabel('frequency [Hz]')
plt.ylabel('CSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">even_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Even extension at the boundaries of an array</p>
<p>Generate a new ndarray by making an even extension of <code>x</code> along an axis.</p>
<h2 id="parameters_346">Parameters<a class="headerlink" href="#parameters_346" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_281">Examples<a class="headerlink" href="#examples_281" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import even_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
even_ext(a, 2)
array([[ 3,  2,  1,  2,  3,  4,  5,  4,  3],
[ 4,  1,  0,  1,  4,  9, 16,  9,  4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even extension is a 'mirror image' at the boundaries of the original array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = even_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='even extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_window</span> <span class="o">:</span> <span class="o">?</span><span class="n">fftbins</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window of a given length and type.</p>
<h2 id="parameters_347">Parameters<a class="headerlink" href="#parameters_347" title="Permanent link">&para;</a></h2>
<p>window : string, float, or tuple
The type of window to create. See below for more details.
Nx : int
The number of samples in the window.
fftbins : bool, optional
If True (default), create a 'periodic' window, ready to use with
<code>ifftshift</code> and be multiplied by the result of an FFT (see also
:func:<code>~scipy.fft.fftfreq</code>).
If False, create a 'symmetric' window, for use in filter design.</p>
<h2 id="returns_338">Returns<a class="headerlink" href="#returns_338" title="Permanent link">&para;</a></h2>
<p>get_window : ndarray
Returns a window of length <code>Nx</code> and type <code>window</code></p>
<h2 id="notes_225">Notes<a class="headerlink" href="#notes_225" title="Permanent link">&para;</a></h2>
<p>Window types:</p>
<ul>
<li><code>~scipy.signal.windows.boxcar</code></li>
<li><code>~scipy.signal.windows.triang</code></li>
<li><code>~scipy.signal.windows.blackman</code></li>
<li><code>~scipy.signal.windows.hamming</code></li>
<li><code>~scipy.signal.windows.hann</code></li>
<li><code>~scipy.signal.windows.bartlett</code></li>
<li><code>~scipy.signal.windows.flattop</code></li>
<li><code>~scipy.signal.windows.parzen</code></li>
<li><code>~scipy.signal.windows.bohman</code></li>
<li><code>~scipy.signal.windows.blackmanharris</code></li>
<li><code>~scipy.signal.windows.nuttall</code></li>
<li><code>~scipy.signal.windows.barthann</code></li>
<li><code>~scipy.signal.windows.kaiser</code> (needs beta)</li>
<li><code>~scipy.signal.windows.gaussian</code> (needs standard deviation)</li>
<li><code>~scipy.signal.windows.general_gaussian</code> (needs power, width)</li>
<li><code>~scipy.signal.windows.slepian</code> (needs width)</li>
<li><code>~scipy.signal.windows.dpss</code> (needs normalized half-bandwidth)</li>
<li><code>~scipy.signal.windows.chebwin</code> (needs attenuation)</li>
<li><code>~scipy.signal.windows.exponential</code> (needs decay scale)</li>
<li><code>~scipy.signal.windows.tukey</code> (needs taper fraction)</li>
</ul>
<p>If the window requires no parameters, then <code>window</code> can be a string.</p>
<p>If the window requires parameters, then <code>window</code> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <code>window</code> is a floating point number, it is interpreted as the beta
parameter of the <code>~scipy.signal.windows.kaiser</code> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<h2 id="examples_282">Examples<a class="headerlink" href="#examples_282" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.get_window('triang', 7)
array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])
signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])
signal.get_window(4.0, 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">istft</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">input_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">time_axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">freq_axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">zxx</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Perform the inverse Short Time Fourier transform (iSTFT).</p>
<h2 id="parameters_348">Parameters<a class="headerlink" href="#parameters_348" title="Permanent link">&para;</a></h2>
<p>Zxx : array_like
STFT of the signal to be reconstructed. If a purely real array
is passed, it will be cast to a complex data type.
fs : float, optional
Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window. Must match the window used to generate the
STFT for faithful inversion.
nperseg : int, optional
Number of data points corresponding to each STFT segment. This
parameter must be specified if the number of data points per
segment is odd, or if the STFT was padded via <code>nfft &gt;
nperseg</code>. If <code>None</code>, the value depends on the shape of
<code>Zxx</code> and <code>input_onesided</code>. If <code>input_onesided</code> is <code>True</code>,
<code>nperseg=2*(Zxx.shape[freq_axis] - 1)</code>. Otherwise,
<code>nperseg=Zxx.shape[freq_axis]</code>. Defaults to <code>None</code>.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>, half
of the segment length. Defaults to <code>None</code>. When specified, the
COLA constraint must be met (see Notes below), and should match
the parameter used to generate the STFT. Defaults to <code>None</code>.
nfft : int, optional
Number of FFT points corresponding to each STFT segment. This
parameter must be specified if the STFT was padded via <code>nfft &gt;
nperseg</code>. If <code>None</code>, the default values are the same as for
<code>nperseg</code>, detailed above, with one exception: if
<code>input_onesided</code> is True and
<code>nperseg==2*Zxx.shape[freq_axis] - 1</code>, <code>nfft</code> also takes on
that value. This case allows the proper inversion of an
odd-length unpadded STFT using <code>nfft=None</code>. Defaults to
<code>None</code>.
input_onesided : bool, optional
If <code>True</code>, interpret the input array as one-sided FFTs, such
as is returned by <code>stft</code> with <code>return_onesided=True</code> and
<code>numpy.fft.rfft</code>. If <code>False</code>, interpret the input as a a
two-sided FFT. Defaults to <code>True</code>.
boundary : bool, optional
Specifies whether the input signal was extended at its
boundaries by supplying a non-<code>None</code> <code>boundary</code> argument to
<code>stft</code>. Defaults to <code>True</code>.
time_axis : int, optional
Where the time segments of the STFT is located; the default is
the last axis (i.e. <code>axis=-1</code>).
freq_axis : int, optional
Where the frequency axis of the STFT is located; the default is
the penultimate axis (i.e. <code>axis=-2</code>).</p>
<h2 id="returns_339">Returns<a class="headerlink" href="#returns_339" title="Permanent link">&para;</a></h2>
<p>t : ndarray
Array of output data times.
x : ndarray
iSTFT of <code>Zxx</code>.</p>
<h2 id="see-also_247">See Also<a class="headerlink" href="#see-also_247" title="Permanent link">&para;</a></h2>
<p>stft: Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met</p>
<h2 id="notes_226">Notes<a class="headerlink" href="#notes_226" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT with
<code>istft</code>, the signal windowing must obey the constraint of 'nonzero
overlap add' (NOLA):</p>
<p>.. math:: \sum_{t}w^{2}[n-tH] \ne 0</p>
<p>This ensures that the normalization factors that appear in the denominator
of the overlap-add reconstruction equation</p>
<p>.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</p>
<p>are not zero. The NOLA constraint can be checked with the <code>check_NOLA</code>
function.</p>
<p>An STFT which has been modified (via masking or otherwise) is not
guaranteed to correspond to a exactly realizible signal. This
function implements the iSTFT via the least-squares estimation
algorithm detailed in [2]_, which produces a signal that minimizes
the mean squared error between the STFT of the returned signal and
the modified STFT.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_55">References<a class="headerlink" href="#references_55" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim 'Signal Estimation from
Modified Short-Time Fourier Transform', IEEE 1984,
10.1109/TASSP.1984.1164317</p>
<h2 id="examples_283">Examples<a class="headerlink" href="#examples_283" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by
0.001 V**2/Hz of white noise sampled at 1024 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 1024
N = 10<em>fs
nperseg = 512
amp = 2 * np.sqrt(2)
noise_power = 0.001 * fs / 2
time = np.arange(N) / float(fs)
carrier = amp * np.sin(2</em>np.pi<em>50</em>time)
noise = np.random.normal(scale=np.sqrt(noise_power),
...                          size=time.shape)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the STFT, and plot its magnitude</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)
plt.figure()
plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp)
plt.ylim([f[1], f[-1]])
plt.title('STFT Magnitude')
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.yscale('log')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Zero the components that are 10% or less of the carrier magnitude,
then convert back to a time series via inverse STFT</p>
<blockquote>
<blockquote>
<blockquote>
<p>Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0)
_, xrec = signal.istft(Zxx, fs)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare the cleaned signal with the original and true carrier signals.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.plot(time, x, time, xrec, time, carrier)
plt.xlim([2, 2.1])
plt.xlabel('Time [sec]')
plt.ylabel('Signal')
plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the cleaned signal does not start as abruptly as the original,
since some of the coefficients of the transient were also removed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.plot(time, x, time, xrec, time, carrier)
plt.xlim([0, 0.1])
plt.xlabel('Time [sec]')
plt.ylabel('Signal')
plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lombscargle</span> <span class="o">:</span> <span class="o">?</span><span class="n">precenter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">normalize</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">freqs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lombscargle(x, y, freqs)</p>
<p>Computes the Lomb-Scargle periodogram.</p>
<p>The Lomb-Scargle periodogram was developed by Lomb [1]<em> and further
extended by Scargle [2]</em> to find, and test the significance of weak
periodic signals with uneven temporal sampling.</p>
<p>When <em>normalize</em> is False (default) the computed periodogram
is unnormalized, it takes the value <code>(A**2) * N/4</code> for a harmonic
signal with amplitude A for sufficiently large N.</p>
<p>When <em>normalize</em> is True the computed periodogram is normalized by
the residuals of the data around a constant reference model (at zero).</p>
<p>Input arrays should be one-dimensional and will be cast to float64.</p>
<h2 id="parameters_349">Parameters<a class="headerlink" href="#parameters_349" title="Permanent link">&para;</a></h2>
<p>x : array_like
Sample times.
y : array_like
Measurement values.
freqs : array_like
Angular frequencies for output periodogram.
precenter : bool, optional
Pre-center amplitudes by subtracting the mean.
normalize : bool, optional
Compute normalized periodogram.</p>
<h2 id="returns_340">Returns<a class="headerlink" href="#returns_340" title="Permanent link">&para;</a></h2>
<p>pgram : array_like
Lomb-Scargle periodogram.</p>
<h2 id="raises_61">Raises<a class="headerlink" href="#raises_61" title="Permanent link">&para;</a></h2>
<p>ValueError
If the input arrays <code>x</code> and <code>y</code> do not have the same shape.</p>
<h2 id="notes_227">Notes<a class="headerlink" href="#notes_227" title="Permanent link">&para;</a></h2>
<p>This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend [3]_ which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.</p>
<p>The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.</p>
<h2 id="references_56">References<a class="headerlink" href="#references_56" title="Permanent link">&para;</a></h2>
<p>.. [1] N.R. Lomb 'Least-squares frequency analysis of unequally spaced
data', Astrophysics and Space Science, vol 39, pp. 447-462, 1976</p>
<p>.. [2] J.D. Scargle 'Studies in astronomical time series analysis. II -
Statistical aspects of spectral analysis of unevenly spaced data',
The Astrophysical Journal, vol 263, pp. 835-853, 1982</p>
<p>.. [3] R.H.D. Townsend, 'Fast calculation of the Lomb-Scargle
periodogram using graphics processing units.', The Astrophysical
Journal Supplement Series, vol 191, pp. 247-253, 2010</p>
<h2 id="see-also_248">See Also<a class="headerlink" href="#see-also_248" title="Permanent link">&para;</a></h2>
<p>istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
welch: Power spectral density by Welch's method
spectrogram: Spectrogram by Welch's method
csd: Cross spectral density by Welch's method</p>
<h2 id="examples_284">Examples<a class="headerlink" href="#examples_284" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>First define some input parameters for the signal:</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = 2.
w = 1.
phi = 0.5 * np.pi
nin = 1000
nout = 100000
frac_points = 0.9 # Fraction of points to select</p>
</blockquote>
</blockquote>
</blockquote>
<p>Randomly select a fraction of an array with timesteps:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = np.random.rand(nin)
x = np.linspace(0.01, 10*np.pi, nin)
x = x[r &gt;= frac_points]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot a sine wave for the selected times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = A * np.sin(w*x+phi)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the array of frequencies for which to compute the periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = np.linspace(0.01, 10, nout)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate Lomb-Scargle periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.signal as signal
pgram = signal.lombscargle(x, y, f, normalize=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now make a plot of the input data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.subplot(2, 1, 1)
plt.plot(x, y, 'b+')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then plot the normalized periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.subplot(2, 1, 2)
plt.plot(f, pgram)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">odd_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Odd extension at the boundaries of an array</p>
<p>Generate a new ndarray by making an odd extension of <code>x</code> along an axis.</p>
<h2 id="parameters_350">Parameters<a class="headerlink" href="#parameters_350" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_285">Examples<a class="headerlink" href="#examples_285" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import odd_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
odd_ext(a, 2)
array([[-1,  0,  1,  2,  3,  4,  5,  6,  7],
[-4, -1,  0,  1,  4,  9, 16, 23, 28]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Odd extension is a '180 degree rotation' at the endpoints of the original
array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.5, 100)
a = 0.9 * np.sin(2 * np.pi * t**2)
b = odd_ext(a, 40)
import matplotlib.pyplot as plt
plt.plot(arange(-40, 140), b, 'b', lw=1, label='odd extension')
plt.plot(arange(100), a, 'r', lw=2, label='original')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">periodogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate power spectral density using a periodogram.</p>
<h2 id="parameters_351">Parameters<a class="headerlink" href="#parameters_351" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to 'boxcar'.
nfft : int, optional
Length of the FFT used. If <code>None</code> the length of <code>x</code> will be
used.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Pxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Pxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'
axis : int, optional
Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_341">Returns<a class="headerlink" href="#returns_341" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxx : ndarray
Power spectral density or power spectrum of <code>x</code>.</p>
<h2 id="notes_228">Notes<a class="headerlink" href="#notes_228" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="see-also_249">See Also<a class="headerlink" href="#see-also_249" title="Permanent link">&para;</a></h2>
<p>welch: Estimate power spectral density using Welch's method
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="examples_286">Examples<a class="headerlink" href="#examples_286" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
np.random.seed(1234)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2<em>np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp</em>np.sin(2<em>np.pi</em>freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the power spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_den = signal.periodogram(x, fs)
plt.semilogy(f, Pxx_den)
plt.ylim([1e-7, 1e2])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.mean(Pxx_den[25000:])
0.00099728892368242854</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute and plot the power spectrum.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')
plt.figure()
plt.semilogy(f, np.sqrt(Pxx_spec))
plt.ylim([1e-4, 1e1])
plt.xlabel('frequency [Hz]')
plt.ylabel('Linear spectrum [V RMS]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt(Pxx_spec.max())
2.0077340678640727</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sp_fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>==============================================
Discrete Fourier transforms (:mod:<code>scipy.fft</code>)
==============================================</p>
<p>.. currentmodule:: scipy.fft</p>
<h1 id="fast-fourier-transforms-ffts_2">Fast Fourier Transforms (FFTs)<a class="headerlink" href="#fast-fourier-transforms-ffts_2" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fft - Fast (discrete) Fourier Transform (FFT)
ifft - Inverse FFT
fft2 - Two dimensional FFT
ifft2 - Two dimensional inverse FFT
fftn - n-dimensional FFT
ifftn - n-dimensional inverse FFT
rfft - FFT of strictly real-valued sequence
irfft - Inverse of rfft
rfft2 - Two dimensional FFT of real sequence
irfft2 - Inverse of rfft2
rfftn - n-dimensional FFT of real sequence
irfftn - Inverse of rfftn
hfft - FFT of a Hermitian sequence (real spectrum)
ihfft - Inverse of hfft
hfft2 - Two dimensional FFT of a Hermitian sequence
ihfft2 - Inverse of hfft2
hfftn - n-dimensional FFT of a Hermitian sequence
ihfftn - Inverse of hfftn</p>
<h1 id="discrete-sin-and-cosine-transforms-dst-and-dct_2">Discrete Sin and Cosine Transforms (DST and DCT)<a class="headerlink" href="#discrete-sin-and-cosine-transforms-dst-and-dct_2" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>dct - Discrete cosine transform
idct - Inverse discrete cosine transform
dctn - n-dimensional Discrete cosine transform
idctn - n-dimensional Inverse discrete cosine transform
dst - Discrete sine transform
idst - Inverse discrete sine transform
dstn - n-dimensional Discrete sine transform
idstn - n-dimensional Inverse discrete sine transform</p>
<h1 id="helper-functions_2">Helper functions<a class="headerlink" href="#helper-functions_2" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fftshift - Shift the zero-frequency component to the center of the spectrum
ifftshift - The inverse of <code>fftshift</code>
fftfreq - Return the Discrete Fourier Transform sample frequencies
rfftfreq - DFT sample frequencies (for usage with rfft, irfft)
next_fast_len - Find the optimal length to zero-pad an FFT for speed
set_workers - Context manager to set default number of workers
get_workers - Get the current default number of workers</p>
<h1 id="backend-control_2">Backend control<a class="headerlink" href="#backend-control_2" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>set_backend - Context manager to set the backend within a fixed scope
skip_backend - Context manager to skip a backend within a fixed scope
set_global_backend - Sets the global fft backend
register_backend - Register a backend for permanent use</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spectrogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a spectrogram with consecutive Fourier transforms.</p>
<p>Spectrograms can be used as a way of visualizing the change of a
nonstationary signal's frequency content over time.</p>
<h2 id="parameters_352">Parameters<a class="headerlink" href="#parameters_352" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
Defaults to a Tukey window with shape parameter of 0.25.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 8</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Sxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Sxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'.
axis : int, optional
Axis along which the spectrogram is computed; the default is over
the last axis (i.e. <code>axis=-1</code>).
mode : str, optional
Defines what kind of return values are expected. Options are
['psd', 'complex', 'magnitude', 'angle', 'phase']. 'complex' is
equivalent to the output of <code>stft</code> with no padding or boundary
extension. 'magnitude' returns the absolute magnitude of the
STFT. 'angle' and 'phase' return the complex angle of the STFT,
with and without unwrapping, respectively.</p>
<h2 id="returns_342">Returns<a class="headerlink" href="#returns_342" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Sxx : ndarray
Spectrogram of x. By default, the last axis of Sxx corresponds
to the segment times.</p>
<h2 id="see-also_250">See Also<a class="headerlink" href="#see-also_250" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.</p>
<h2 id="notes_229">Notes<a class="headerlink" href="#notes_229" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch's method, where the
entire data stream is averaged over, one may wish to use a smaller
overlap (or perhaps none at all) when computing a spectrogram, to
maintain some statistical independence between individual segments.
It is for this reason that the default window is a Tukey window with
1/8th of a window's length overlap at each end.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_57">References<a class="headerlink" href="#references_57" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.</p>
<h2 id="examples_287">Examples<a class="headerlink" href="#examples_287" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fftshift
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2 * np.sqrt(2)
noise_power = 0.01 * fs / 2
time = np.arange(N) / float(fs)
mod = 500<em>np.cos(2</em>np.pi<em>0.25</em>time)
carrier = amp * np.sin(2<em>np.pi</em>3e3<em>time + mod)
noise = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
noise </em>= np.exp(-time/5)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the spectrogram.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Sxx = signal.spectrogram(x, fs)
plt.pcolormesh(t, f, Sxx)
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note, if using output that is not one sided, then use the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False)
plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0))
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stft</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padded</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Short Time Fourier Transform (STFT).</p>
<p>STFTs can be used as a way of quantifying the change of a
nonstationary signal's frequency and phase content over time.</p>
<h2 id="parameters_353">Parameters<a class="headerlink" href="#parameters_353" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to 256.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>. When
specified, the COLA constraint must be met (see Notes below).
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to <code>False</code>.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
boundary : str or None, optional
Specifies whether the input signal is extended at both ends, and
how to generate the new values, in order to center the first
windowed segment on the first input point. This has the benefit
of enabling reconstruction of the first input point when the
employed window function starts at zero. Valid options are
<code>['even', 'odd', 'constant', 'zeros', None]</code>. Defaults to
'zeros', for zero padding extension. I.e. <code>[1, 2, 3, 4]</code> is
extended to <code>[0, 1, 2, 3, 4, 0]</code> for <code>nperseg=3</code>.
padded : bool, optional
Specifies whether the input signal is zero-padded at the end to
make the signal fit exactly into an integer number of window
segments, so that all of the signal is included in the output.
Defaults to <code>True</code>. Padding occurs after boundary extension, if
<code>boundary</code> is not <code>None</code>, and <code>padded</code> is <code>True</code>, as is the
default.
axis : int, optional
Axis along which the STFT is computed; the default is over the
last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_343">Returns<a class="headerlink" href="#returns_343" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Zxx : ndarray
STFT of <code>x</code>. By default, the last axis of <code>Zxx</code> corresponds
to the segment times.</p>
<h2 id="see-also_251">See Also<a class="headerlink" href="#see-also_251" title="Permanent link">&para;</a></h2>
<p>istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
welch: Power spectral density by Welch's method.
spectrogram: Spectrogram by Welch's method.
csd: Cross spectral density by Welch's method.
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="notes_230">Notes<a class="headerlink" href="#notes_230" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, the signal windowing must obey the constraint of 'Nonzero
OverLap Add' (NOLA), and the input signal must have complete
windowing coverage (i.e. <code>(x.shape[axis] - nperseg) %
(nperseg-noverlap) == 0</code>). The <code>padded</code> argument may be used to
accomplish this.</p>
<p>Given a time-domain signal :math:<code>x[n]</code>, a window :math:<code>w[n]</code>, and a hop
size :math:<code>H</code> = <code>nperseg - noverlap</code>, the windowed frame at time index
:math:<code>t</code> is given by</p>
<p>.. math:: x_{t}[n]=x[n]w[n-tH]</p>
<p>The overlap-add (OLA) reconstruction equation is given by</p>
<p>.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</p>
<p>The NOLA constraint ensures that every normalization term that appears
in the denomimator of the OLA reconstruction equation is nonzero. Whether a
choice of <code>window</code>, <code>nperseg</code>, and <code>noverlap</code> satisfy this constraint can
be tested with <code>check_NOLA</code>.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_58">References<a class="headerlink" href="#references_58" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim 'Signal Estimation from
Modified Short-Time Fourier Transform', IEEE 1984,
10.1109/TASSP.1984.1164317</p>
<h2 id="examples_288">Examples<a class="headerlink" href="#examples_288" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2 * np.sqrt(2)
noise_power = 0.01 * fs / 2
time = np.arange(N) / float(fs)
mod = 500<em>np.cos(2</em>np.pi<em>0.25</em>time)
carrier = amp * np.sin(2<em>np.pi</em>3e3<em>time + mod)
noise = np.random.normal(scale=np.sqrt(noise_power),
...                          size=time.shape)
noise </em>= np.exp(-time/5)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the STFT's magnitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Zxx = signal.stft(x, fs, nperseg=1000)
plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp)
plt.title('STFT Magnitude')
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">welch</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">average</span><span class="o">:[`</span><span class="nc">Mean</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Median</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate power spectral density using Welch's method.</p>
<p>Welch's method [1]_ computes an estimate of the power spectral
density by dividing the data into overlapping segments, computing a
modified periodogram for each segment and averaging the
periodograms.</p>
<h2 id="parameters_354">Parameters<a class="headerlink" href="#parameters_354" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Pxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Pxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'
axis : int, optional
Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code>axis=-1</code>).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. Defaults to 'mean'.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_344">Returns<a class="headerlink" href="#returns_344" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxx : ndarray
Power spectral density or power spectrum of x.</p>
<h2 id="see-also_252">See Also<a class="headerlink" href="#see-also_252" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="notes_231">Notes<a class="headerlink" href="#notes_231" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>If <code>noverlap</code> is 0, this method is equivalent to Bartlett's method
[2]_.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_59">References<a class="headerlink" href="#references_59" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
Biometrika, vol. 37, pp. 1-16, 1950.</p>
<h2 id="examples_289">Examples<a class="headerlink" href="#examples_289" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
np.random.seed(1234)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2<em>np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp</em>np.sin(2<em>np.pi</em>freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the power spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_den = signal.welch(x, fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.mean(Pxx_den[256:])
0.0009924865443739191</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute and plot the power spectrum.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum')
plt.figure()
plt.semilogy(f, np.sqrt(Pxx_spec))
plt.xlabel('frequency [Hz]')
plt.ylabel('Linear spectrum [V RMS]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt(Pxx_spec.max())
2.0077340678640727</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we now introduce a discontinuity in the signal, by increasing the
amplitude of a small portion of the signal by 50, we can see the
corruption of the mean average power spectral density, but using a
median average better estimates the normal behaviour.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x[int(N//2):int(N//2)+10] <em>= 50.
f, Pxx_den = signal.welch(x, fs, nperseg=1024)
f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average='median')
plt.semilogy(f, Pxx_den, label='mean')
plt.semilogy(f_med, Pxx_den_med, label='median')
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V</em>*2/Hz]')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zero_ext</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zero padding at the boundaries of an array</p>
<p>Generate a new ndarray that is a zero padded extension of <code>x</code> along
an axis.</p>
<h2 id="parameters_355">Parameters<a class="headerlink" href="#parameters_355" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The array to be extended.
n : int
The number of elements by which to extend <code>x</code> at each end of the
axis.
axis : int, optional
The axis along which to extend <code>x</code>.  Default is -1.</p>
<h2 id="examples_290">Examples<a class="headerlink" href="#examples_290" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal._arraytools import zero_ext
a = np.array([[1, 2, 3, 4, 5], [0, 1, 4, 9, 16]])
zero_ext(a, 2)
array([[ 0,  0,  1,  2,  3,  4,  5,  0,  0],
[ 0,  0,  0,  1,  4,  9, 16,  0,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Spline</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">sepfir2d</span> <span class="o">:</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hrow</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hcol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sepfir2d(input, hrow, hcol) -&gt; output</p>
<p>Description:</p>
<p>Convolve the rank-2 input array with the separable filter defined by the
rank-1 arrays hrow, and hcol. Mirror symmetric boundary conditions are
assumed.  This function can be used to find an image given its B-spline
representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Waveforms</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_356">Parameters<a class="headerlink" href="#parameters_356" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_345">Returns<a class="headerlink" href="#returns_345" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_253">See Also<a class="headerlink" href="#see-also_253" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_291">Examples<a class="headerlink" href="#examples_291" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chirp</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Linear</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Quadratic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Logarithmic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Hyperbolic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">phi</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">vertex_zero</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">t1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">f1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Frequency-swept cosine generator.</p>
<p>In the following, 'Hz' should be interpreted as 'cycles per unit';
there is no requirement here that the unit is one second.  The
important distinction is that the units of rotation are cycles, not
radians. Likewise, <code>t</code> could be a measurement of space instead of time.</p>
<h2 id="parameters_357">Parameters<a class="headerlink" href="#parameters_357" title="Permanent link">&para;</a></h2>
<p>t : array_like
Times at which to evaluate the waveform.
f0 : float
Frequency (e.g. Hz) at time t=0.
t1 : float
Time at which <code>f1</code> is specified.
f1 : float
Frequency (e.g. Hz) of the waveform at time <code>t1</code>.
method : {'linear', 'quadratic', 'logarithmic', 'hyperbolic'}, optional
Kind of frequency sweep.  If not given, <code>linear</code> is assumed.  See
Notes below for more details.
phi : float, optional
Phase offset, in degrees. Default is 0.
vertex_zero : bool, optional
This parameter is only used when <code>method</code> is 'quadratic'.
It determines whether the vertex of the parabola that is the graph
of the frequency is at t=0 or t=t1.</p>
<h2 id="returns_346">Returns<a class="headerlink" href="#returns_346" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A numpy array containing the signal evaluated at <code>t</code> with the
requested time-varying frequency.  More precisely, the function
returns <code>cos(phase + (pi/180)*phi)</code> where <code>phase</code> is the integral
(from 0 to <code>t</code>) of <code>2*pi*f(t)</code>. <code>f(t)</code> is defined below.</p>
<h2 id="see-also_254">See Also<a class="headerlink" href="#see-also_254" title="Permanent link">&para;</a></h2>
<p>sweep_poly</p>
<h2 id="notes_232">Notes<a class="headerlink" href="#notes_232" title="Permanent link">&para;</a></h2>
<p>There are four options for the <code>method</code>.  The following formulas give
the instantaneous frequency (in Hz) of the signal generated by
<code>chirp()</code>.  For convenience, the shorter names shown below may also be
used.</p>
<p>linear, lin, li:</p>
<p><code>f(t) = f0 + (f1 - f0) * t / t1</code></p>
<p>quadratic, quad, q:</p>
<p>The graph of the frequency f(t) is a parabola through (0, f0) and
(t1, f1).  By default, the vertex of the parabola is at (0, f0).
If <code>vertex_zero</code> is False, then the vertex is at (t1, f1).  The
formula is:</p>
<p>if vertex_zero is True:</p>
<p><code>f(t) = f0 + (f1 - f0) * t**2 / t1**2</code></p>
<p>else:</p>
<p><code>f(t) = f1 - (f1 - f0) * (t1 - t)**2 / t1**2</code></p>
<p>To use a more general quadratic function, or an arbitrary
polynomial, use the function <code>scipy.signal.sweep_poly</code>.</p>
<p>logarithmic, log, lo:</p>
<p><code>f(t) = f0 * (f1/f0)**(t/t1)</code></p>
<p>f0 and f1 must be nonzero and have the same sign.</p>
<p>This signal is also known as a geometric or exponential chirp.</p>
<p>hyperbolic, hyp:</p>
<p><code>f(t) = f0*f1*t1 / ((f0 - f1)*t + f1*t1)</code></p>
<p>f0 and f1 must be nonzero.</p>
<h2 id="examples_292">Examples<a class="headerlink" href="#examples_292" title="Permanent link">&para;</a></h2>
<p>The following will be used in the examples:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import chirp, spectrogram
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>For the first example, we'll plot the waveform for a linear chirp
from 6 Hz to 1 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 10, 5001)
w = chirp(t, f0=6, f1=1, t1=10, method='linear')
plt.plot(t, w)
plt.title('Linear Chirp, f(0)=6, f(10)=1')
plt.xlabel('t (sec)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>For the remaining examples, we'll use higher frequency ranges,
and demonstrate the result using <code>scipy.signal.spectrogram</code>.
We'll use a 10 second interval sampled at 8000 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 8000
T = 10
t = np.linspace(0, T, T*fs, endpoint=False)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Quadratic chirp from 1500 Hz to 250 Hz over 10 seconds
(vertex of the parabolic curve of the frequency is at t=0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='quadratic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Quadratic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Quadratic chirp from 1500 Hz to 250 Hz over 10 seconds
(vertex of the parabolic curve of the frequency is at t=10):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='quadratic',
...           vertex_zero=False)
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Quadratic Chirp, f(0)=1500, f(10)=250\n' +
...           '(vertex_zero=False)')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Logarithmic chirp from 1500 Hz to 250 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='logarithmic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Logarithmic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Hyperbolic chirp from 1500 Hz to 250 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='hyperbolic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Hyperbolic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Cosine element-wise.</p>
<h2 id="parameters_358">Parameters<a class="headerlink" href="#parameters_358" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array in radians.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_347">Returns<a class="headerlink" href="#returns_347" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The corresponding cosine values.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_233">Notes<a class="headerlink" href="#notes_233" title="Permanent link">&para;</a></h2>
<p>If <code>out</code> is provided, the function writes the result into it,
and returns a reference to <code>out</code>.  (See Examples)</p>
<h2 id="references_60">References<a class="headerlink" href="#references_60" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<h2 id="examples_293">Examples<a class="headerlink" href="#examples_293" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.cos(np.array([0, np.pi/2, np.pi]))
array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</p>
<h1 id="example-of-providing-the-optional-output-parameter_2">Example of providing the optional output parameter<a class="headerlink" href="#example-of-providing-the-optional-output-parameter_2" title="Permanent link">&para;</a></h1>
<p>out1 = np.array([0], dtype='d')
out2 = np.cos([0.1], out1)
out2 is out1
True</p>
<h1 id="example-of-valueerror-due-to-provision-of-shape-mis-matched-out_4">Example of ValueError due to provision of shape mis-matched <code>out</code><a class="headerlink" href="#example-of-valueerror-due-to-provision-of-shape-mis-matched-out_4" title="Permanent link">&para;</a></h1>
<p>np.cos(np.zeros((3,3)),np.zeros((2,2)))
Traceback (most recent call last):
File '<stdin>', line 1, in <module>
ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exp</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2 id="parameters_359">Parameters<a class="headerlink" href="#parameters_359" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_348">Returns<a class="headerlink" href="#returns_348" title="Permanent link">&para;</a></h2>
<p>out : ndarray or scalar
Output array, element-wise exponential of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_255">See Also<a class="headerlink" href="#see-also_255" title="Permanent link">&para;</a></h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array.
exp2  : Calculate <code>2**x</code> for all elements in the array.</p>
<h2 id="notes_234">Notes<a class="headerlink" href="#notes_234" title="Permanent link">&para;</a></h2>
<p>The irrational number <code>e</code> is also known as Euler's number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>,
then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write
:math:<code>e^x = e^a e^{ib}</code>.  The first term, :math:<code>e^a</code>, is already
known (it is the real argument, described above).  The second term,
:math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with
magnitude 1 and a periodic phase.</p>
<h2 id="references_61">References<a class="headerlink" href="#references_61" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Exponential function',
https://en.wikipedia.org/wiki/Exponential_function
.. [2] M. Abramovitz and I. A. Stegun, 'Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,' Dover, 1964, p. 69,
http://www.math.sfu.ca/~cbm/aands/page_69.htm</p>
<h2 id="examples_294">Examples<a class="headerlink" href="#examples_294" title="Permanent link">&para;</a></h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(-2<em>np.pi, 2</em>np.pi, 100)
xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane
out = np.exp(xx)</p>
<p>plt.subplot(121)
plt.imshow(np.abs(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='gray')
plt.title('Magnitude of exp(x)')</p>
<p>plt.subplot(122)
plt.imshow(np.angle(out),
...            extent=[-2<em>np.pi, 2</em>np.pi, -2<em>np.pi, 2</em>np.pi], cmap='hsv')
plt.title('Phase (angle) of exp(x)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">extract</span> <span class="o">:</span> <span class="n">condition</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">arr</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the elements of an array that satisfy some condition.</p>
<p>This is equivalent to <code>np.compress(ravel(condition), ravel(arr))</code>.  If
<code>condition</code> is boolean <code>np.extract</code> is equivalent to <code>arr[condition]</code>.</p>
<p>Note that <code>place</code> does the exact opposite of <code>extract</code>.</p>
<h2 id="parameters_360">Parameters<a class="headerlink" href="#parameters_360" title="Permanent link">&para;</a></h2>
<p>condition : array_like
An array whose nonzero or True entries indicate the elements of <code>arr</code>
to extract.
arr : array_like
Input array of the same size as <code>condition</code>.</p>
<h2 id="returns_349">Returns<a class="headerlink" href="#returns_349" title="Permanent link">&para;</a></h2>
<p>extract : ndarray
Rank 1 array of values from <code>arr</code> where <code>condition</code> is True.</p>
<h2 id="see-also_256">See Also<a class="headerlink" href="#see-also_256" title="Permanent link">&para;</a></h2>
<p>take, put, copyto, compress, place</p>
<h2 id="examples_295">Examples<a class="headerlink" href="#examples_295" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>arr = np.arange(12).reshape((3, 4))
arr
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])
condition = np.mod(arr, 3)==0
condition
array([[ True, False, False,  True],
[False, False,  True, False],
[False,  True, False, False]])
np.extract(condition, arr)
array([0, 3, 6, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>condition</code> is boolean:</p>
<blockquote>
<blockquote>
<blockquote>
<p>arr[condition]
array([0, 3, 6, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gausspulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">fc</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bwr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tpr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retquad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retenv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">The_string_cutoff_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a Gaussian modulated sinusoid:</p>
<p><code>exp(-a t^2) exp(1j*2*pi*fc*t).</code></p>
<p>If <code>retquad</code> is True, then return the real and imaginary parts
(in-phase and quadrature).
If <code>retenv</code> is True, then return the envelope (unmodulated signal).
Otherwise, return the real part of the modulated sinusoid.</p>
<h2 id="parameters_361">Parameters<a class="headerlink" href="#parameters_361" title="Permanent link">&para;</a></h2>
<p>t : ndarray or the string 'cutoff'
Input array.
fc : int, optional
Center frequency (e.g. Hz).  Default is 1000.
bw : float, optional
Fractional bandwidth in frequency domain of pulse (e.g. Hz).
Default is 0.5.
bwr : float, optional
Reference level at which fractional bandwidth is calculated (dB).
Default is -6.
tpr : float, optional
If <code>t</code> is 'cutoff', then the function returns the cutoff
time for when the pulse amplitude falls below <code>tpr</code> (in dB).
Default is -60.
retquad : bool, optional
If True, return the quadrature (imaginary) as well as the real part
of the signal.  Default is False.
retenv : bool, optional
If True, return the envelope of the signal.  Default is False.</p>
<h2 id="returns_350">Returns<a class="headerlink" href="#returns_350" title="Permanent link">&para;</a></h2>
<p>yI : ndarray
Real part of signal.  Always returned.
yQ : ndarray
Imaginary part of signal.  Only returned if <code>retquad</code> is True.
yenv : ndarray
Envelope of signal.  Only returned if <code>retenv</code> is True.</p>
<h2 id="see-also_257">See Also<a class="headerlink" href="#see-also_257" title="Permanent link">&para;</a></h2>
<p>scipy.signal.morlet</p>
<h2 id="examples_296">Examples<a class="headerlink" href="#examples_296" title="Permanent link">&para;</a></h2>
<p>Plot real component, imaginary component, and envelope for a 5 Hz pulse,
sampled at 100 Hz for 2 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 2 * 100, endpoint=False)
i, q, e = signal.gausspulse(t, fc=5, retquad=True, retenv=True)
plt.plot(t, i, t, q, t, e, '--')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">log</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Natural logarithm, element-wise.</p>
<p>The natural logarithm <code>log</code> is the inverse of the exponential function,
so that <code>log(exp(x)) = x</code>. The natural logarithm is logarithm in base
<code>e</code>.</p>
<h2 id="parameters_362">Parameters<a class="headerlink" href="#parameters_362" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input value.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_351">Returns<a class="headerlink" href="#returns_351" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The natural logarithm of <code>x</code>, element-wise.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_258">See Also<a class="headerlink" href="#see-also_258" title="Permanent link">&para;</a></h2>
<p>log10, log2, log1p, emath.log</p>
<h2 id="notes_235">Notes<a class="headerlink" href="#notes_235" title="Permanent link">&para;</a></h2>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite
number of <code>z</code> such that <code>exp(z) = x</code>. The convention is to return the
<code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log</code> always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log</code> is a complex analytical function that
has a branch cut <code>[-inf, 0]</code> and is continuous from above on it. <code>log</code>
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.</p>
<h2 id="references_62">References<a class="headerlink" href="#references_62" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, 'Logarithm'. https://en.wikipedia.org/wiki/Logarithm</p>
<h2 id="examples_297">Examples<a class="headerlink" href="#examples_297" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.log([1, np.e, np.e**2, 0])
array([  0.,   1.,   2., -Inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mod_</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return element-wise remainder of division.</p>
<p>Computes the remainder complementary to the <code>floor_divide</code> function.  It is
equivalent to the Python modulus operator<code>x1 % x2</code> and has the same sign
as the divisor <code>x2</code>. The MATLAB function equivalent to <code>np.remainder</code>
is <code>mod</code>.</p>
<p>.. warning::</p>
<p>This should not be confused with:</p>
<ul>
<li>Python 3.7's <code>math.remainder</code> and C's <code>remainder</code>, which
computes the IEEE remainder, which are the complement to
<code>round(x1 / x2)</code>.</li>
<li>The MATLAB <code>rem</code> function and or the C <code>%</code> operator which is the
complement to <code>int(x1 / x2)</code>.</li>
</ul>
<h2 id="parameters_363">Parameters<a class="headerlink" href="#parameters_363" title="Permanent link">&para;</a></h2>
<p>x1 : array_like
Dividend array.
x2 : array_like
Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_352">Returns<a class="headerlink" href="#returns_352" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The element-wise remainder of the quotient <code>floor_divide(x1, x2)</code>.
This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2 id="see-also_259">See Also<a class="headerlink" href="#see-also_259" title="Permanent link">&para;</a></h2>
<p>floor_divide : Equivalent of Python <code>//</code> operator.
divmod : Simultaneous floor division and remainder.
fmod : Equivalent of the MATLAB <code>rem</code> function.
divide, floor</p>
<h2 id="notes_236">Notes<a class="headerlink" href="#notes_236" title="Permanent link">&para;</a></h2>
<p>Returns 0 when <code>x2</code> is 0 and both <code>x1</code> and <code>x2</code> are (arrays of)
integers.
<code>mod</code> is an alias of <code>remainder</code>.</p>
<h2 id="examples_298">Examples<a class="headerlink" href="#examples_298" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.remainder([4, 7], [2, 3])
array([0, 1])
np.remainder(np.arange(7), 5)
array([0, 1, 2, 3, 4, 0, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">place</span> <span class="o">:</span> <span class="n">arr</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mask</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Change elements of an array based on conditional and input values.</p>
<p>Similar to <code>np.copyto(arr, vals, where=mask)</code>, the difference is that
<code>place</code> uses the first N elements of <code>vals</code>, where N is the number of
True values in <code>mask</code>, while <code>copyto</code> uses the elements where <code>mask</code>
is True.</p>
<p>Note that <code>extract</code> does the exact opposite of <code>place</code>.</p>
<h2 id="parameters_364">Parameters<a class="headerlink" href="#parameters_364" title="Permanent link">&para;</a></h2>
<p>arr : ndarray
Array to put data into.
mask : array_like
Boolean mask array. Must have the same size as <code>a</code>.
vals : 1-D sequence
Values to put into <code>a</code>. Only the first N elements are used, where
N is the number of True values in <code>mask</code>. If <code>vals</code> is smaller
than N, it will be repeated, and if elements of <code>a</code> are to be masked,
this sequence must be non-empty.</p>
<h2 id="see-also_260">See Also<a class="headerlink" href="#see-also_260" title="Permanent link">&para;</a></h2>
<p>copyto, put, take, extract</p>
<h2 id="examples_299">Examples<a class="headerlink" href="#examples_299" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>arr = np.arange(6).reshape(2, 3)
np.place(arr, arr&gt;2, [44, 55])
arr
array([[ 0,  1,  2],
[44, 55, 44]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polyint</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">List_of_m_scalars</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Poly1d</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an antiderivative (indefinite integral) of a polynomial.</p>
<p>The returned order <code>m</code> antiderivative <code>P</code> of polynomial <code>p</code> satisfies
:math:<code>\frac{d^m}{dx^m}P(x) = p(x)</code> and is defined up to <code>m - 1</code>
integration constants <code>k</code>. The constants determine the low-order
polynomial part</p>
<p>.. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}</p>
<p>of <code>P</code> so that :math:<code>P^{(j)}(0) = k_{m-j-1}</code>.</p>
<h2 id="parameters_365">Parameters<a class="headerlink" href="#parameters_365" title="Permanent link">&para;</a></h2>
<p>p : array_like or poly1d
Polynomial to integrate.
A sequence is interpreted as polynomial coefficients, see <code>poly1d</code>.
m : int, optional
Order of the antiderivative. (Default: 1)
k : list of <code>m</code> scalars or scalar, optional
Integration constants. They are given in the order of integration:
those corresponding to highest-order terms come first.</p>
<p>If <code>None</code> (default), all constants are assumed to be zero.
If <code>m = 1</code>, a single scalar can be given instead of a list.</p>
<h2 id="see-also_261">See Also<a class="headerlink" href="#see-also_261" title="Permanent link">&para;</a></h2>
<p>polyder : derivative of a polynomial
poly1d.integ : equivalent method</p>
<h2 id="examples_300">Examples<a class="headerlink" href="#examples_300" title="Permanent link">&para;</a></h2>
<p>The defining property of the antiderivative:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = np.poly1d([1,1,1])
P = np.polyint(p)
P
poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary
np.polyder(P) == p
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>The integration constants default to zero, but can be specified:</p>
<blockquote>
<blockquote>
<blockquote>
<p>P = np.polyint(p, 3)
P(0)
0.0
np.polyder(P)(0)
0.0
np.polyder(P, 2)(0)
0.0
P = np.polyint(p, 3, k=[6,5,3])
P
poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that 3 = 6 / 2!, and that the constants are given in the order of
integrations. Constant of the highest-order polynomial term comes first:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.polyder(P, 2)(0)
6.0
np.polyder(P, 1)(0)
5.0
P(0)
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polyval</span> <span class="o">:</span> <span class="n">p</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Poly1d_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Poly1d_object</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a polynomial at specific values.</p>
<p>If <code>p</code> is of length N, this function returns the value:</p>
<p><code>p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]</code></p>
<p>If <code>x</code> is a sequence, then <code>p(x)</code> is returned for each element of <code>x</code>.
If <code>x</code> is another polynomial then the composite polynomial <code>p(x(t))</code>
is returned.</p>
<h2 id="parameters_366">Parameters<a class="headerlink" href="#parameters_366" title="Permanent link">&para;</a></h2>
<p>p : array_like or poly1d object
1D array of polynomial coefficients (including coefficients equal
to zero) from highest degree to the constant term, or an
instance of poly1d.
x : array_like or poly1d object
A number, an array of numbers, or an instance of poly1d, at
which to evaluate <code>p</code>.</p>
<h2 id="returns_353">Returns<a class="headerlink" href="#returns_353" title="Permanent link">&para;</a></h2>
<p>values : ndarray or poly1d
If <code>x</code> is a poly1d instance, the result is the composition of the two
polynomials, i.e., <code>x</code> is 'substituted' in <code>p</code> and the simplified
result is returned. In addition, the type of <code>x</code> - array_like or
poly1d - governs the type of the output: <code>x</code> array_like =&gt; <code>values</code>
array_like, <code>x</code> a poly1d object =&gt; <code>values</code> is also.</p>
<h2 id="see-also_262">See Also<a class="headerlink" href="#see-also_262" title="Permanent link">&para;</a></h2>
<p>poly1d: A polynomial class.</p>
<h2 id="notes_237">Notes<a class="headerlink" href="#notes_237" title="Permanent link">&para;</a></h2>
<p>Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.</p>
<p>If <code>x</code> is a subtype of <code>ndarray</code> the return value will be of the same type.</p>
<h2 id="references_63">References<a class="headerlink" href="#references_63" title="Permanent link">&para;</a></h2>
<p>.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand
Reinhold Co., 1985, pg. 720.</p>
<h2 id="examples_301">Examples<a class="headerlink" href="#examples_301" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.polyval([3,0,1], 5)  # 3 * 5<strong>2 + 0 * 5</strong>1 + 1
76
np.polyval([3,0,1], np.poly1d(5))
poly1d([76.])
np.polyval(np.poly1d([3,0,1]), 5)
76
np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
poly1d([76.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sawtooth</span> <span class="o">:</span> <span class="o">?</span><span class="n">width</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a periodic sawtooth or triangle waveform.</p>
<p>The sawtooth waveform has a period <code>2*pi</code>, rises from -1 to 1 on the
interval 0 to <code>width*2*pi</code>, then drops from 1 to -1 on the interval
<code>width*2*pi</code> to <code>2*pi</code>. <code>width</code> must be in the interval [0, 1].</p>
<p>Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.</p>
<h2 id="parameters_367">Parameters<a class="headerlink" href="#parameters_367" title="Permanent link">&para;</a></h2>
<p>t : array_like
Time.
width : array_like, optional
Width of the rising ramp as a proportion of the total cycle.
Default is 1, producing a rising ramp, while 0 produces a falling
ramp.  <code>width</code> = 0.5 produces a triangle wave.
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
<h2 id="returns_354">Returns<a class="headerlink" href="#returns_354" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing the sawtooth waveform.</p>
<h2 id="examples_302">Examples<a class="headerlink" href="#examples_302" title="Permanent link">&para;</a></h2>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(0, 1, 500)
plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2 id="parameters_368">Parameters<a class="headerlink" href="#parameters_368" title="Permanent link">&para;</a></h2>
<p>x : array_like
Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees).
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_355">Returns<a class="headerlink" href="#returns_355" title="Permanent link">&para;</a></h2>
<p>y : array_like
The sine of each element of x.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_263">See Also<a class="headerlink" href="#see-also_263" title="Permanent link">&para;</a></h2>
<p>arcsin, sinh, cos</p>
<h2 id="notes_238">Notes<a class="headerlink" href="#notes_238" title="Permanent link">&para;</a></h2>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the :math:<code>+x</code> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The :math:<code>y</code> coordinate of the outgoing
ray's intersection with the unit circle is the sine of that angle.  It
ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code>  The
function has zeroes where the angle is a multiple of :math:<code>\pi</code>.
Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<h2 id="examples_303">Examples<a class="headerlink" href="#examples_303" title="Permanent link">&para;</a></h2>
<p>Print sine of one angle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.pi/2.)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrt</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2 id="parameters_369">Parameters<a class="headerlink" href="#parameters_369" title="Permanent link">&para;</a></h2>
<p>x : array_like
The values whose square-roots are required.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_356">Returns<a class="headerlink" href="#returns_356" title="Permanent link">&para;</a></h2>
<p>y : ndarray
An array of the same shape as <code>x</code>, containing the positive
square-root of each element in <code>x</code>.  If any element in <code>x</code> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <code>x</code>
are real, so is <code>y</code>, with negative elements returning <code>nan</code>.
If <code>out</code> was provided, <code>y</code> is a reference to it.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_264">See Also<a class="headerlink" href="#see-also_264" title="Permanent link">&para;</a></h2>
<p>lib.scimath.sqrt
A version which returns complex numbers when given negative reals.</p>
<h2 id="notes_239">Notes<a class="headerlink" href="#notes_239" title="Permanent link">&para;</a></h2>
<p><em>sqrt</em> has--consistent with common convention--as its branch cut the
real 'interval' [<code>-inf</code>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<h2 id="examples_304">Examples<a class="headerlink" href="#examples_304" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt([1,4,9])
array([ 1.,  2.,  3.])</p>
<p>np.sqrt([4, -1, -3+4J])
array([ 2.+0.j,  0.+1.j,  1.+2.j])</p>
<p>np.sqrt([4, -1, np.inf])
array([ 2., nan, inf])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">square</span> <span class="o">:</span> <span class="o">?</span><span class="n">duty</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a periodic square-wave waveform.</p>
<p>The square wave has a period <code>2*pi</code>, has value +1 from 0 to
<code>2*pi*duty</code> and -1 from <code>2*pi*duty</code> to <code>2*pi</code>. <code>duty</code> must be in
the interval [0,1].</p>
<p>Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.</p>
<h2 id="parameters_370">Parameters<a class="headerlink" href="#parameters_370" title="Permanent link">&para;</a></h2>
<p>t : array_like
The input time array.
duty : array_like, optional
Duty cycle.  Default is 0.5 (50% duty cycle).
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
<h2 id="returns_357">Returns<a class="headerlink" href="#returns_357" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing the square waveform.</p>
<h2 id="examples_305">Examples<a class="headerlink" href="#examples_305" title="Permanent link">&para;</a></h2>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(0, 1, 500, endpoint=False)
plt.plot(t, signal.square(2 * np.pi * 5 * t))
plt.ylim(-2, 2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>A pulse-width modulated sine wave:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
sig = np.sin(2 * np.pi * t)
pwm = signal.square(2 * np.pi * 30 * t, duty=(sig + 1)/2)
plt.subplot(2, 1, 1)
plt.plot(t, sig)
plt.subplot(2, 1, 2)
plt.plot(t, pwm)
plt.ylim(-1.5, 1.5)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sweep_poly</span> <span class="o">:</span> <span class="o">?</span><span class="n">phi</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">poly</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Frequency-swept cosine generator, with a time-dependent frequency.</p>
<p>This function generates a sinusoidal function whose instantaneous
frequency varies with time.  The frequency at time <code>t</code> is given by
the polynomial <code>poly</code>.</p>
<h2 id="parameters_371">Parameters<a class="headerlink" href="#parameters_371" title="Permanent link">&para;</a></h2>
<p>t : ndarray
Times at which to evaluate the waveform.
poly : 1-D array_like or instance of numpy.poly1d
The desired frequency expressed as a polynomial.  If <code>poly</code> is
a list or ndarray of length n, then the elements of <code>poly</code> are
the coefficients of the polynomial, and the instantaneous
frequency is</p>
<p><code>f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]</code></p>
<p>If <code>poly</code> is an instance of numpy.poly1d, then the
instantaneous frequency is</p>
<p><code>f(t) = poly(t)</code></p>
<p>phi : float, optional
Phase offset, in degrees, Default: 0.</p>
<h2 id="returns_358">Returns<a class="headerlink" href="#returns_358" title="Permanent link">&para;</a></h2>
<p>sweep_poly : ndarray
A numpy array containing the signal evaluated at <code>t</code> with the
requested time-varying frequency.  More precisely, the function
returns <code>cos(phase + (pi/180)*phi)</code>, where <code>phase</code> is the integral
(from 0 to t) of <code>2 * pi * f(t)</code>; <code>f(t)</code> is defined above.</p>
<h2 id="see-also_265">See Also<a class="headerlink" href="#see-also_265" title="Permanent link">&para;</a></h2>
<p>chirp</p>
<h2 id="notes_240">Notes<a class="headerlink" href="#notes_240" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<p>If <code>poly</code> is a list or ndarray of length <code>n</code>, then the elements of
<code>poly</code> are the coefficients of the polynomial, and the instantaneous
frequency is:</p>
<p><code>f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]</code></p>
<p>If <code>poly</code> is an instance of <code>numpy.poly1d</code>, then the instantaneous
frequency is:</p>
<p><code>f(t) = poly(t)</code></p>
<p>Finally, the output <code>s</code> is:</p>
<p><code>cos(phase + (pi/180)*phi)</code></p>
<p>where <code>phase</code> is the integral from 0 to <code>t</code> of <code>2 * pi * f(t)</code>,
<code>f(t)</code> as defined above.</p>
<h2 id="examples_306">Examples<a class="headerlink" href="#examples_306" title="Permanent link">&para;</a></h2>
<p>Compute the waveform with instantaneous frequency::</p>
<p>f(t) = 0.025<em>t</em><em>3 - 0.36</em>t*<em>2 + 1.25</em>t + 2</p>
<p>over the interval 0 &lt;= t &lt;= 10.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sweep_poly
p = np.poly1d([0.025, -0.36, 1.25, 2.0])
t = np.linspace(0, 10, 5001)
w = sweep_poly(t, p)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.subplot(2, 1, 1)
plt.plot(t, w)
plt.title('Sweep Poly\nwith frequency ' +
...           '<span><span class="MathJax_Preview">f(t) = 0.025t^3 - 0.36t^2 + 1.25t + 2</span><script type="math/tex">f(t) = 0.025t^3 - 0.36t^2 + 1.25t + 2</script></span>')
plt.subplot(2, 1, 2)
plt.plot(t, p(t), 'r', label='f(t)')
plt.legend()
plt.xlabel('t')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">unit_impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">idx</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mid</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unit impulse signal (discrete delta function) or unit basis vector.</p>
<h2 id="parameters_372">Parameters<a class="headerlink" href="#parameters_372" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of int
Number of samples in the output (1-D), or a tuple that represents the
shape of the output (N-D).
idx : None or int or tuple of int or 'mid', optional
Index at which the value is 1.  If None, defaults to the 0th element.
If <code>idx='mid'</code>, the impulse will be centered at <code>shape // 2</code> in
all dimensions.  If an int, the impulse will be at <code>idx</code> in all
dimensions.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.</p>
<h2 id="returns_359">Returns<a class="headerlink" href="#returns_359" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing an impulse signal.</p>
<h2 id="notes_241">Notes<a class="headerlink" href="#notes_241" title="Permanent link">&para;</a></h2>
<p>The 1D case is also known as the Kronecker delta.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_307">Examples<a class="headerlink" href="#examples_307" title="Permanent link">&para;</a></h2>
<p>An impulse at the 0th element (:math:<code>\delta[n]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.unit_impulse(8)
array([ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Impulse offset by 2 samples (:math:<code>\delta[n-2]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse(7, 2)
array([ 0.,  0.,  1.,  0.,  0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>2-dimensional impulse, centered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse((3, 3), 'mid')
array([[ 0.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Impulse at (2, 2), using broadcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse((4, 4), 2)
array([[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the impulse response of a 4th-order Butterworth lowpass filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>imp = signal.unit_impulse(100, 'mid')
b, a = signal.butter(4, 0.2)
response = signal.lfilter(b, a, imp)</p>
<p>import matplotlib.pyplot as plt
plt.plot(np.arange(-50, 50), imp)
plt.plot(np.arange(-50, 50), response)
plt.margins(0.1, 0.1)
plt.xlabel('Time [samples]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_373">Parameters<a class="headerlink" href="#parameters_373" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_360">Returns<a class="headerlink" href="#returns_360" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_266">See Also<a class="headerlink" href="#see-also_266" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_308">Examples<a class="headerlink" href="#examples_308" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Wavelets</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">cascade</span> <span class="o">:</span> <span class="o">?</span><span class="n">j</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">hk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return (x, phi, psi) at dyadic points <code>K/2**J</code> from filter coefficients.</p>
<h2 id="parameters_374">Parameters<a class="headerlink" href="#parameters_374" title="Permanent link">&para;</a></h2>
<p>hk : array_like
Coefficients of low-pass filter.
J : int, optional
Values will be computed at grid points <code>K/2**J</code>. Default is 7.</p>
<h2 id="returns_361">Returns<a class="headerlink" href="#returns_361" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The dyadic points <code>K/2**J</code> for <code>K=0...N * (2**J)-1</code> where
<code>len(hk) = len(gk) = N+1</code>.
phi : ndarray
The scaling function <code>phi(x)</code> at <code>x</code>:
<code>phi(x) = sum(hk * phi(2x-k))</code>, where k is from 0 to N.
psi : ndarray, optional
The wavelet function <code>psi(x)</code> at <code>x</code>:
<code>phi(x) = sum(gk * phi(2x-k))</code>, where k is from 0 to N.
<code>psi</code> is only returned if <code>gk</code> is not None.</p>
<h2 id="notes_242">Notes<a class="headerlink" href="#notes_242" title="Permanent link">&para;</a></h2>
<p>The algorithm uses the vector cascade algorithm described by Strang and
Nguyen in 'Wavelets and Filter Banks'.  It builds a dictionary of values
and slices for quick reuse.  Then inserts vectors into final vector at the
end.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">comb</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">repetition</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The number of combinations of N things taken k at a time.</p>
<p>This is often expressed as 'N choose k'.</p>
<h2 id="parameters_375">Parameters<a class="headerlink" href="#parameters_375" title="Permanent link">&para;</a></h2>
<p>N : int, ndarray
Number of things.
k : int, ndarray
Number of elements taken.
exact : bool, optional
If <code>exact</code> is False, then floating point precision is used, otherwise
exact long integer is computed.
repetition : bool, optional
If <code>repetition</code> is True, then the number of combinations with
repetition is computed.</p>
<h2 id="returns_362">Returns<a class="headerlink" href="#returns_362" title="Permanent link">&para;</a></h2>
<p>val : int, float, ndarray
The total number of combinations.</p>
<h2 id="see-also_267">See Also<a class="headerlink" href="#see-also_267" title="Permanent link">&para;</a></h2>
<p>binom : Binomial coefficient ufunc</p>
<h2 id="notes_243">Notes<a class="headerlink" href="#notes_243" title="Permanent link">&para;</a></h2>
<ul>
<li>Array arguments accepted only for exact=False case.</li>
<li>If N &lt; 0, or k &lt; 0, then 0 is returned.</li>
<li>If k &gt; N and repetition=False, then 0 is returned.</li>
</ul>
<h2 id="examples_309">Examples<a class="headerlink" href="#examples_309" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.special import comb
k = np.array([3, 4])
n = np.array([10, 10])
comb(n, k, exact=False)
array([ 120.,  210.])
comb(10, 3, exact=True)
120L
comb(10, 3, exact=True, repetition=True)
220L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fft</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays.</p>
<p>Convolve <code>in1</code> and <code>in2</code>, with the output size determined by the
<code>mode</code> argument.</p>
<h2 id="parameters_376">Parameters<a class="headerlink" href="#parameters_376" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the convolution.</p>
<p><code>direct</code>
The convolution is determined directly from sums, the definition of
convolution.
<code>fft</code>
The Fourier Transform is used to perform the convolution by calling
<code>fftconvolve</code>.
<code>auto</code>
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See Notes for more detail.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="returns_363">Returns<a class="headerlink" href="#returns_363" title="Permanent link">&para;</a></h2>
<p>convolve : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_268">See Also<a class="headerlink" href="#see-also_268" title="Permanent link">&para;</a></h2>
<p>numpy.polymul : performs polynomial multiplication (same operation, but
also accepts poly1d objects)
choose_conv_method : chooses the fastest appropriate convolution method
fftconvolve : Always uses the FFT method.
oaconvolve : Uses the overlap-add method to do convolution, which is
generally faster when the input arrays are large and
significantly different in size.</p>
<h2 id="notes_244">Notes<a class="headerlink" href="#notes_244" title="Permanent link">&para;</a></h2>
<p>By default, <code>convolve</code> and <code>correlate</code> use <code>method='auto'</code>, which calls
<code>choose_conv_method</code> to choose the fastest method using pre-computed
values (<code>choose_conv_method</code> can also measure real-world timing with a
keyword argument). Because <code>fftconvolve</code> relies on floating point numbers,
there are certain constraints that may force <code>method=direct</code> (more detail
in <code>choose_conv_method</code> docstring).</p>
<h2 id="examples_310">Examples<a class="headerlink" href="#examples_310" title="Permanent link">&para;</a></h2>
<p>Smooth a square pulse using a Hann window:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.repeat([0., 1., 0.], 100)
win = signal.hann(50)
filtered = signal.convolve(sig, win, mode='same') / sum(win)</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)
ax_orig.plot(sig)
ax_orig.set_title('Original pulse')
ax_orig.margins(0, 0.1)
ax_win.plot(win)
ax_win.set_title('Filter impulse response')
ax_win.margins(0, 0.1)
ax_filt.plot(filtered)
ax_filt.set_title('Filtered signal')
ax_filt.margins(0, 0.1)
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cwt</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">wavelet</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">widths</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Continuous wavelet transform.</p>
<p>Performs a continuous wavelet transform on <code>data</code>,
using the <code>wavelet</code> function. A CWT performs a convolution
with <code>data</code> using the <code>wavelet</code> function, which is characterized
by a width parameter and length parameter. The <code>wavelet</code> function
is allowed to be complex.</p>
<h2 id="parameters_377">Parameters<a class="headerlink" href="#parameters_377" title="Permanent link">&para;</a></h2>
<p>data : (N,) ndarray
data on which to perform the transform.
wavelet : function
Wavelet function, which should take 2 arguments.
The first argument is the number of points that the returned vector
will have (len(wavelet(length,width)) == length).
The second is a width parameter, defining the size of the wavelet
(e.g. standard deviation of a gaussian). See <code>ricker</code>, which
satisfies these requirements.
widths : (M,) sequence
Widths to use for transform.
dtype : data-type, optional
The desired data type of output. Defaults to <code>float64</code> if the
output of <code>wavelet</code> is real and <code>complex128</code> if it is complex.</p>
<p>.. versionadded:: 1.4.0</p>
<p>kwargs
Keyword arguments passed to wavelet function.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_364">Returns<a class="headerlink" href="#returns_364" title="Permanent link">&para;</a></h2>
<p>cwt: (M, N) ndarray
Will have shape of (len(widths), len(data)).</p>
<h2 id="notes_245">Notes<a class="headerlink" href="#notes_245" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<p>For non-symmetric, complex-valued wavelets, the input signal is convolved
with the time-reversed complex-conjugate of the wavelet data [1].</p>
<p>::</p>
<p>length = min(10 * width[ii], len(data))
cwt[ii,:] = signal.convolve(data, np.conj(wavelet(length, width[ii],
**kwargs))[::-1], mode='same')</p>
<h2 id="references_64">References<a class="headerlink" href="#references_64" title="Permanent link">&para;</a></h2>
<p>.. [1] S. Mallat, 'A Wavelet Tour of Signal Processing (3rd Edition)',
Academic Press, 2009.</p>
<h2 id="examples_311">Examples<a class="headerlink" href="#examples_311" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 200, endpoint=False)
sig  = np.cos(2 * np.pi * 7 * t) + signal.gausspulse(t - 0.4, fc=2)
widths = np.arange(1, 31)
cwtmatr = signal.cwt(sig, signal.ricker, widths)
plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',
...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">daub</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The coefficients for the FIR low-pass filter producing Daubechies wavelets.</p>
<p>p&gt;=1 gives the order of the zero at f=1/2.
There are 2p filter coefficients.</p>
<h2 id="parameters_378">Parameters<a class="headerlink" href="#parameters_378" title="Permanent link">&para;</a></h2>
<p>p : int
Order of the zero at f=1/2, can have values from 1 to 34.</p>
<h2 id="returns_365">Returns<a class="headerlink" href="#returns_365" title="Permanent link">&para;</a></h2>
<p>daub : ndarray
Return</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]</p>
<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h2 id="parameters_379">Parameters<a class="headerlink" href="#parameters_379" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.
left : bool, optional
Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.  Default is False.
overwrite_b : bool, optional
Whether to overwrite <code>b</code>; may improve performance.  Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_366">Returns<a class="headerlink" href="#returns_366" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its
multiplicity. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.
vl : (M, M) double or complex ndarray
The normalized left eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.
vr : (M, M) double or complex ndarray
The normalized right eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
<h2 id="raises_62">Raises<a class="headerlink" href="#raises_62" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_269">See Also<a class="headerlink" href="#see-also_269" title="Permanent link">&para;</a></h2>
<p>eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_312">Examples<a class="headerlink" href="#examples_312" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
<p>a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
[-0.        +0.70710678j, -0.        -0.70710678j]])
linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
[0.        -0.70710678j, 0.        +0.70710678j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morlet</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">complete</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complex Morlet wavelet.</p>
<h2 id="parameters_380">Parameters<a class="headerlink" href="#parameters_380" title="Permanent link">&para;</a></h2>
<p>M : int
Length of the wavelet.
w : float, optional
Omega0. Default is 5
s : float, optional
Scaling factor, windowed from <code>-s*2*pi</code> to <code>+s*2*pi</code>. Default is 1.
complete : bool, optional
Whether to use the complete or the standard version.</p>
<h2 id="returns_367">Returns<a class="headerlink" href="#returns_367" title="Permanent link">&para;</a></h2>
<p>morlet : (M,) ndarray</p>
<h2 id="see-also_270">See Also<a class="headerlink" href="#see-also_270" title="Permanent link">&para;</a></h2>
<p>morlet2 : Implementation of Morlet wavelet, compatible with <code>cwt</code>.
scipy.signal.gausspulse</p>
<h2 id="notes_246">Notes<a class="headerlink" href="#notes_246" title="Permanent link">&para;</a></h2>
<p>The standard version::</p>
<p>pi<strong>-0.25 * exp(1j<em>w</em>x) * exp(-0.5*(x</strong>2))</p>
<p>This commonly used wavelet is often referred to simply as the
Morlet wavelet.  Note that this simplified version can cause
admissibility problems at low values of <code>w</code>.</p>
<p>The complete version::</p>
<p>pi<strong>-0.25 * (exp(1j<em>w</em>x) - exp(-0.5*(w</strong>2))) * exp(-0.5<em>(x</em>*2))</p>
<p>This version has a correction
term to improve admissibility. For <code>w</code> greater than 5, the
correction term is negligible.</p>
<p>Note that the energy of the return wavelet is not normalised
according to <code>s</code>.</p>
<p>The fundamental frequency of this wavelet in Hz is given
by <code>f = 2*s*w*r / M</code> where <code>r</code> is the sampling rate.</p>
<p>Note: This function was created before <code>cwt</code> and is not compatible
with it.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morlet2</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complex Morlet wavelet, designed to work with <code>cwt</code>.</p>
<p>Returns the complete version of morlet wavelet, normalised
according to <code>s</code>::</p>
<p>exp(1j<em>w</em>x/s) * exp(-0.5<em>(x/s)</em><em>2) * pi</em>*(-0.25) * sqrt(1/s)</p>
<h2 id="parameters_381">Parameters<a class="headerlink" href="#parameters_381" title="Permanent link">&para;</a></h2>
<p>M : int
Length of the wavelet.
s : float
Width parameter of the wavelet.
w : float, optional
Omega0. Default is 5</p>
<h2 id="returns_368">Returns<a class="headerlink" href="#returns_368" title="Permanent link">&para;</a></h2>
<p>morlet : (M,) ndarray</p>
<h2 id="see-also_271">See Also<a class="headerlink" href="#see-also_271" title="Permanent link">&para;</a></h2>
<p>morlet : Implementation of Morlet wavelet, incompatible with <code>cwt</code></p>
<h2 id="notes_247">Notes<a class="headerlink" href="#notes_247" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<p>This function was designed to work with <code>cwt</code>. Because <code>morlet2</code>
returns an array of complex numbers, the <code>dtype</code> argument of <code>cwt</code>
should be set to <code>complex128</code> for best results.</p>
<p>Note the difference in implementation with <code>morlet</code>.
The fundamental frequency of this wavelet in Hz is given by::</p>
<p>f = w<em>fs / (2</em>s*np.pi)</p>
<p>where <code>fs</code> is the sampling rate and <code>s</code> is the wavelet width parameter.
Similarly we can get the wavelet width parameter at <code>f</code>::</p>
<p>s = w<em>fs / (2</em>f*np.pi)</p>
<h2 id="examples_313">Examples<a class="headerlink" href="#examples_313" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>M = 100
s = 4.0
w = 2.0
wavelet = signal.morlet2(M, s, w)
plt.plot(abs(wavelet))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows basic use of <code>morlet2</code> with <code>cwt</code> in time-frequency
analysis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t, dt = np.linspace(0, 1, 200, retstep=True)
fs = 1/dt
w = 6.
sig = np.cos(2<em>np.pi</em>(50 + 10<em>t)</em>t) + np.sin(40<em>np.pi</em>t)
freq = np.linspace(1, fs/2, 100)
widths = w<em>fs / (2</em>freq*np.pi)
cwtm = signal.cwt(sig, signal.morlet2, widths, w=w)
plt.pcolormesh(t, freq, np.abs(cwtm), cmap='viridis')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmf</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return high-pass qmf filter from low-pass</p>
<h2 id="parameters_382">Parameters<a class="headerlink" href="#parameters_382" title="Permanent link">&para;</a></h2>
<p>hk : array_like
Coefficients of high-pass filter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ricker</span> <span class="o">:</span> <span class="n">points</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Ricker wavelet, also known as the 'Mexican hat wavelet'.</p>
<p>It models the function:</p>
<p><code>A * (1 - (x/a)**2) * exp(-0.5*(x/a)**2)</code>,</p>
<p>where <code>A = 2/(sqrt(3*a)*(pi**0.25))</code>.</p>
<h2 id="parameters_383">Parameters<a class="headerlink" href="#parameters_383" title="Permanent link">&para;</a></h2>
<p>points : int
Number of points in <code>vector</code>.
Will be centered around 0.
a : scalar
Width parameter of the wavelet.</p>
<h2 id="returns_369">Returns<a class="headerlink" href="#returns_369" title="Permanent link">&para;</a></h2>
<p>vector : (N,) ndarray
Array of length <code>points</code> in shape of ricker curve.</p>
<h2 id="examples_314">Examples<a class="headerlink" href="#examples_314" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>points = 100
a = 4.0
vec2 = signal.ricker(points, a)
print(len(vec2))
100
plt.plot(vec2)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Windows</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Windows</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Sp_fft</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">dct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Cosine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_384">Parameters<a class="headerlink" href="#parameters_384" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_370">Returns<a class="headerlink" href="#returns_370" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_272">See Also<a class="headerlink" href="#see-also_272" title="Permanent link">&para;</a></h2>
<p>idct : Inverse DCT</p>
<h2 id="notes_248">Notes<a class="headerlink" href="#notes_248" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>dct(x, norm='ortho')</code> is equal to
MATLAB <code>dct(x)</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on <code>dct</code> and the <code>idct</code> is scaled by
<code>1/N</code> where <code>N</code> is the 'logical' size of the DCT. For <code>norm='ortho'</code>
both directions are scaled by the same factor <code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DCT, only the first 4 types are
implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
Inverse DCT generally refers to DCT type 3.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DCT-I; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
\frac{\pi k n}{N-1} \right)</p>
<p>If <code>norm='ortho'</code>, <code>x[0]</code> and <code>x[N-1]</code> are multiplied by a scaling
factor of :math:<code>\sqrt{2}</code>, and <code>y[k]</code> is multiplied by a scaling factor
<code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\frac{1}{2}\sqrt{\frac{1}{N-1}} &amp; \text{if }k=0\text{ or }N-1, \
\frac{1}{2}\sqrt{\frac{2}{N-1}} &amp; \text{otherwise} \end{cases}</p>
<p>.. note::
The DCT-I is only supported for input size &gt; 1.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DCT-II; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::
f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k=0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p>Which makes the corresponding matrix of coefficients orthonormal
(<code>O @ O.T = np.eye(N)</code>).</p>
<p><strong>Type III</strong></p>
<p>There are several definitions, we use the following (for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>or, for <code>norm='ortho'</code></p>
<p>.. math::</p>
<p>y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
\cos\left(\frac{\pi(2k+1)n}{2N}\right)</p>
<p>The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
to a factor <code>2N</code>. The orthonormalized DCT-III is exactly the inverse of
the orthonormalized DCT-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DCT-IV; we use the following
(for <code>norm=None</code>)</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)</p>
<p>If <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \frac{1}{\sqrt{2N}}</p>
<h2 id="references_65">References<a class="headerlink" href="#references_65" title="Permanent link">&para;</a></h2>
<p>.. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
Makhoul, <code>IEEE Transactions on acoustics, speech and signal
processing</code> vol. 28(1), pp. 27-34,
:doi:<code>10.1109/TASSP.1980.1163351</code> (1980).
.. [2] Wikipedia, 'Discrete cosine transform',
https://en.wikipedia.org/wiki/Discrete_cosine_transform</p>
<h2 id="examples_315">Examples<a class="headerlink" href="#examples_315" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the FFT (though faster) for real,
even-symmetrical inputs.  The output is also real and even-symmetrical.
Half of the FFT input is used to generate half of the FFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, dct
fft(np.array([4., 3., 5., 10., 5., 3.])).real
array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
dct(np.array([4., 3., 5., 10.]), 1)
array([ 30.,  -8.,   6.,  -2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_385">Parameters<a class="headerlink" href="#parameters_385" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_371">Returns<a class="headerlink" href="#returns_371" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_273">See Also<a class="headerlink" href="#see-also_273" title="Permanent link">&para;</a></h2>
<p>idctn : Inverse multidimensional DCT</p>
<h2 id="notes_249">Notes<a class="headerlink" href="#notes_249" title="Permanent link">&para;</a></h2>
<p>For full details of the DCT types and normalization modes, as well as
references, see <code>dct</code>.</p>
<h2 id="examples_316">Examples<a class="headerlink" href="#examples_316" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Sine Transform of arbitrary type sequence x.</p>
<h2 id="parameters_386">Parameters<a class="headerlink" href="#parameters_386" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the dst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_372">Returns<a class="headerlink" href="#returns_372" title="Permanent link">&para;</a></h2>
<p>dst : ndarray of reals
The transformed input array.</p>
<h2 id="see-also_274">See Also<a class="headerlink" href="#see-also_274" title="Permanent link">&para;</a></h2>
<p>idst : Inverse DST</p>
<h2 id="notes_250">Notes<a class="headerlink" href="#notes_250" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>.</p>
<p>For <code>norm=None</code>, there is no scaling on the <code>dst</code> and the <code>idst</code> is
scaled by <code>1/N</code> where <code>N</code> is the 'logical' size of the DST. For
<code>norm='ortho'</code> both directions are scaled by the same factor
<code>1/sqrt(N)</code>.</p>
<p>There are theoretically 8 types of the DST for different combinations of
even/odd boundary conditions and boundary off sets [1]_, only the first
4 types are implemented in scipy.</p>
<p><strong>Type I</strong></p>
<p>There are several definitions of the DST-I; we use the following
for <code>norm=None</code>. DST-I assumes the input is odd around <code>n=-1</code> and <code>n=N</code>.</p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)</p>
<p>Note that the DST-I is only supported for input size &gt; 1.
The (unnormalized) DST-I is its own inverse, up to a factor <code>2(N+1)</code>.
The orthonormalized DST-I is exactly its own inverse.</p>
<p><strong>Type II</strong></p>
<p>There are several definitions of the DST-II; we use the following for
<code>norm=None</code>. DST-II assumes the input is odd around <code>n=-1/2</code> and
<code>n=N-1/2</code>; the output is odd around :math:<code>k=-1</code> and even around <code>k=N-1</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)</p>
<p>if <code>norm='ortho'</code>, <code>y[k]</code> is multiplied by a scaling factor <code>f</code></p>
<p>.. math::</p>
<p>f = \begin{cases}
\sqrt{\frac{1}{4N}} &amp; \text{if }k = 0, \
\sqrt{\frac{1}{2N}} &amp; \text{otherwise} \end{cases}</p>
<p><strong>Type III</strong></p>
<p>There are several definitions of the DST-III, we use the following (for
<code>norm=None</code>). DST-III assumes the input is odd around <code>n=-1</code> and even
around <code>n=N-1</code></p>
<p>.. math::</p>
<p>y_k = (-1)^k x_{N-1} + 2 \sum_{n=0}^{N-2} x_n \sin\left(
\frac{\pi(2k+1)(n+1)}{2N}\right)</p>
<p>The (unnormalized) DST-III is the inverse of the (unnormalized) DST-II, up
to a factor <code>2N</code>. The orthonormalized DST-III is exactly the inverse of the
orthonormalized DST-II.</p>
<p><strong>Type IV</strong></p>
<p>There are several definitions of the DST-IV, we use the following (for
<code>norm=None</code>). DST-IV assumes the input is odd around <code>n=-0.5</code> and even
around <code>n=N-0.5</code></p>
<p>.. math::</p>
<p>y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(2k+1)(2n+1)}{4N}\right)</p>
<p>The (unnormalized) DST-IV is its own inverse, up to a factor <code>2N</code>. The
orthonormalized DST-IV is exactly its own inverse.</p>
<h2 id="references_66">References<a class="headerlink" href="#references_66" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Discrete sine transform',
https://en.wikipedia.org/wiki/Discrete_sine_transform</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_387">Parameters<a class="headerlink" href="#parameters_387" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>shape</code> is -1, the size of the corresponding dimension
of <code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the DST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_373">Returns<a class="headerlink" href="#returns_373" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_275">See Also<a class="headerlink" href="#see-also_275" title="Permanent link">&para;</a></h2>
<p>idstn : Inverse multidimensional DST</p>
<h2 id="notes_251">Notes<a class="headerlink" href="#notes_251" title="Permanent link">&para;</a></h2>
<p>For full details of the DST types and normalization modes, as well as
references, see <code>dst</code>.</p>
<h2 id="examples_317">Examples<a class="headerlink" href="#examples_317" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [1]_.</p>
<h2 id="parameters_388">Parameters<a class="headerlink" href="#parameters_388" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT.  If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode. Default is None, meaning no normalization on the
forward transforms and scaling by <code>1/n</code> on the <code>ifft</code>.
For <code>norm='ortho'</code>, both directions are scaled by <code>1/sqrt(n)</code>.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See the notes below for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>. See below for more
details.</p>
<h2 id="returns_374">Returns<a class="headerlink" href="#returns_374" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_63">Raises<a class="headerlink" href="#raises_63" title="Permanent link">&para;</a></h2>
<p>IndexError
if <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_276">See Also<a class="headerlink" href="#see-also_276" title="Permanent link">&para;</a></h2>
<p>ifft : The inverse of <code>fft</code>.
fft2 : The two-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.
fftfreq : Frequency bins for given FFT parameters.
next_fast_len : Size to pad input to for most efficient transforms</p>
<h2 id="notes_252">Notes<a class="headerlink" href="#notes_252" title="Permanent link">&para;</a></h2>
<p>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform
(DFT) can be calculated efficiently, by using symmetries in the calculated
terms. The symmetry is highest when <code>n</code> is a power of 2, and the transform
is therefore most efficient for these sizes. For poorly factorizable sizes,
<code>scipy.fft</code> uses Bluestein's algorithm [2]_ and so is never worse than
O(<code>n</code> log <code>n</code>). Further performance improvements may be seen by zero-padding
the input using <code>next_fast_len</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>fft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(-2j * np.pi * k * np.arange(n)/n))</p>
<p>The frequency term <code>f=k/n</code> is found at <code>y[k]</code>. At <code>y[n/2]</code> we reach
the Nyquist frequency and wrap around to the negative-frequency terms. So,
for an 8-point transform, the frequencies of the result are
[0, 1, 2, 3, -4, -3, -2, -1]. To rearrange the fft output so that the
zero-frequency component is centered, like [-4, -3, -2, -1, 0, 1, 2, 3],
use <code>fftshift</code>.</p>
<p>Transforms can be done in single, double or extended precision (long
double) floating point. Half precision inputs will be converted to single
precision and non floating-point inputs will be converted to double
precision.</p>
<p>If the data type of <code>x</code> is real, a 'real FFT' algorithm is automatically
used, which roughly halves the computation time.  To increase efficiency
a little further, use <code>rfft</code>, which does the same calculation, but only
outputs half of the symmetrical spectrum.  If the data is both real and
symmetrical, the <code>dct</code> can again double the efficiency, by generating
half of the spectrum from half of the signal.</p>
<p>When <code>overwrite_x=True</code> is specified, the memory referenced by <code>x</code> may
be used by the implementation in any way. This may include reusing the
memory for the result, but this is in no way guaranteed. You should not
rely on the contents of <code>x</code> after the transform as this may change in
future without warning.</p>
<p>The <code>workers</code> argument specifies the maximum number of parallel jobs to
split the FFT computation into. This will execute independent 1-dimensional
FFTs within <code>x</code>. So, <code>x</code> must be at least 2-dimensional and the
non-transformed axes must be large enough to split into chunks. If <code>x</code> is
too small, fewer jobs may be used than requested.</p>
<h2 id="references_67">References<a class="headerlink" href="#references_67" title="Permanent link">&para;</a></h2>
<p>.. [1] Cooley, James W., and John W. Tukey, 1965, 'An algorithm for the
machine calculation of complex Fourier series,' <em>Math. Comput.</em>
19: 297-301.
.. [2] Bluestein, L., 1970, 'A linear filtering approach to the
computation of discrete Fourier transform'. <em>IEEE Transactions on
Audio and Electroacoustics.</em> 18 (4): 451-455.</p>
<h2 id="examples_318">Examples<a class="headerlink" href="#examples_318" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, fftfreq, fftshift
import matplotlib.pyplot as plt
t = np.arange(256)
sp = fftshift(fft(np.sin(t)))
freq = fftshift(fftfreq(t.shape[-1]))
plt.plot(freq, sp.real, freq, sp.imag)
[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional discrete Fourier Transform</p>
<p>This function computes the <em>n</em>-dimensional discrete Fourier Transform
over any axes in an <em>M</em>-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.</p>
<h2 id="parameters_389">Parameters<a class="headerlink" href="#parameters_389" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT. If not given, the last two axes are
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_375">Returns<a class="headerlink" href="#returns_375" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_64">Raises<a class="headerlink" href="#raises_64" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_277">See Also<a class="headerlink" href="#see-also_277" title="Permanent link">&para;</a></h2>
<p>ifft2 : The inverse two-dimensional FFT.
fft : The one-dimensional FFT.
fftn : The <em>n</em>-dimensional FFT.
fftshift : Shifts zero-frequency terms to the center of the array.
For two-dimensional input, swaps first and third quadrants, and second
and fourth quadrants.</p>
<h2 id="notes_253">Notes<a class="headerlink" href="#notes_253" title="Permanent link">&para;</a></h2>
<p><code>fft2</code> is just <code>fftn</code> with a different default for <code>axes</code>.</p>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.</p>
<p>See <code>fftn</code> for details and a plotting example, and <code>fft</code> for
definitions and conventions used.</p>
<h2 id="examples_319">Examples<a class="headerlink" href="#examples_319" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:5, :5][0]
scipy.fft.fft2(x)
array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
0.  +0.j        ,   0.  +0.j        ],
[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ],
[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
0.  +0.j        ,   0.  +0.j        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies.</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d</em>n)   if n is odd</p>
<h2 id="parameters_390">Parameters<a class="headerlink" href="#parameters_390" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_376">Returns<a class="headerlink" href="#returns_376" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n</code> containing the sample frequencies.</p>
<h2 id="examples_320">Examples<a class="headerlink" href="#examples_320" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
fourier = np.fft.fft(signal)
n = signal.size
timestep = 0.1
freq = np.fft.fftfreq(n, d=timestep)
freq
array([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform.</p>
<p>This function computes the <em>N</em>-dimensional discrete Fourier Transform over
any number of axes in an <em>M</em>-dimensional array by means of the Fast Fourier
Transform (FFT).</p>
<h2 id="parameters_391">Parameters<a class="headerlink" href="#parameters_391" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_377">Returns<a class="headerlink" href="#returns_377" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_65">Raises<a class="headerlink" href="#raises_65" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_278">See Also<a class="headerlink" href="#see-also_278" title="Permanent link">&para;</a></h2>
<p>ifftn : The inverse of <code>fftn</code>, the inverse <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT, with definitions and conventions used.
rfftn : The <em>n</em>-dimensional FFT of real input.
fft2 : The two-dimensional FFT.
fftshift : Shifts zero-frequency terms to centre of array</p>
<h2 id="notes_254">Notes<a class="headerlink" href="#notes_254" title="Permanent link">&para;</a></h2>
<p>The output, analogously to <code>fft</code>, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="examples_321">Examples<a class="headerlink" href="#examples_321" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.mgrid[:3, :3, :3][0]
scipy.fft.fftn(x, axes=(1, 2))
array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[ 9.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]],
[[18.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j],
[ 0.+0.j,   0.+0.j,   0.+0.j]]])
scipy.fft.fftn(x, (2, 2), axes=(0, 1))
array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
[ 0.+0.j,  0.+0.j,  0.+0.j]],
[[-2.+0.j, -2.+0.j, -2.+0.j],
[ 0.+0.j,  0.+0.j,  0.+0.j]]])</p>
<p>import matplotlib.pyplot as plt
[X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
...                      2 * np.pi * np.arange(200) / 34)
S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
FS = scipy.fft.fftn(S)
plt.imshow(np.log(np.abs(scipy.fft.fftshift(FS))**2))
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Shift the zero-frequency component to the center of the spectrum.</p>
<p>This function swaps half-spaces for all axes listed (defaults to all).
Note that <code>y[0]</code> is the Nyquist component only if <code>len(x)</code> is even.</p>
<h2 id="parameters_392">Parameters<a class="headerlink" href="#parameters_392" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to shift.  Default is None, which shifts all axes.</p>
<h2 id="returns_378">Returns<a class="headerlink" href="#returns_378" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_279">See Also<a class="headerlink" href="#see-also_279" title="Permanent link">&para;</a></h2>
<p>ifftshift : The inverse of <code>fftshift</code>.</p>
<h2 id="examples_322">Examples<a class="headerlink" href="#examples_322" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(10, 0.1)
freqs
array([ 0.,  1.,  2., ..., -3., -2., -1.])
np.fft.fftshift(freqs)
array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Shift the zero-frequency component only along the second axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.fftshift(freqs, axes=(1,))
array([[ 2.,  0.,  1.],
[-4.,  3.,  4.],
[-1., -3., -2.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_workers</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the default number of workers within the current context</p>
<h2 id="examples_323">Examples<a class="headerlink" href="#examples_323" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft
fft.get_workers()
1
with fft.set_workers(4):
...     fft.get_workers()
4</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.</p>
<h2 id="parameters_393">Parameters<a class="headerlink" href="#parameters_393" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output. For <code>n</code> output
points, <code>n//2 + 1</code> input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros. If <code>n</code> is not given, it is taken to be <code>2*(m-1)</code>
where <code>m</code> is the length of the input along the axis specified by
<code>axis</code>.
axis : int, optional
Axis over which to compute the FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_379">Returns<a class="headerlink" href="#returns_379" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*m - 2</code> where <code>m</code> is the length of the transformed axis of
the input. To get an odd number of output points, <code>n</code> must be
specified, for instance as <code>2*m - 1</code> in the typical case,</p>
<h2 id="raises_66">Raises<a class="headerlink" href="#raises_66" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_280">See also<a class="headerlink" href="#see-also_280" title="Permanent link">&para;</a></h2>
<p>rfft : Compute the one-dimensional FFT for real input.
ihfft : The inverse of <code>hfft</code>.
hfftn : Compute the n-dimensional FFT of a Hermitian signal.</p>
<h2 id="notes_255">Notes<a class="headerlink" href="#notes_255" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd.
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_324">Examples<a class="headerlink" href="#examples_324" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft, hfft
a = 2 * np.pi * np.arange(10) / 10
signal = np.cos(a) + 3j * np.sin(3 * a)
fft(signal).round(10)
array([ -0.+0.j,   5.+0.j,  -0.+0.j,  15.-0.j,   0.+0.j,   0.+0.j,
-0.+0.j, -15.-0.j,   0.+0.j,   5.+0.j])
hfft(signal[:6]).round(10) # Input first half of signal
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])
hfft(signal, 10)  # Input entire signal and truncate
array([  0.,   5.,   0.,  15.,  -0.,   0.,   0., -15.,  -0.,   5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a Hermitian complex array.</p>
<h2 id="parameters_394">Parameters<a class="headerlink" href="#parameters_394" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be Hermitian complex.
s : sequence of ints, optional
Shape of the real output.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_380">Returns<a class="headerlink" href="#returns_380" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The real result of the 2D Hermitian complex real FFT.</p>
<h2 id="see-also_281">See Also<a class="headerlink" href="#see-also_281" title="Permanent link">&para;</a></h2>
<p>hfftn : Compute the N-dimensional discrete Fourier Transform for Hermitian
complex input.</p>
<h2 id="notes_256">Notes<a class="headerlink" href="#notes_256" title="Permanent link">&para;</a></h2>
<p>This is really just <code>hfftn</code> with different default behavior.
For more details see <code>hfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional FFT of Hermitian symmetric complex input, i.e. a
signal with a real spectrum.</p>
<p>This function computes the N-dimensional discrete Fourier Transform for a
Hermitian symmetric complex input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT). In other
words, <code>ihfftn(hfftn(x, s)) == x</code> to within numerical accuracy. (<code>s</code>
here is <code>x.shape</code> with <code>s[-1] = x.shape[-1] * 2 - 1</code>, this is necessary
for the same reason <code>x.shape</code> would be necessary for <code>irfft</code>.)</p>
<h2 id="parameters_395">Parameters<a class="headerlink" href="#parameters_395" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_381">Returns<a class="headerlink" href="#returns_381" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_67">Raises<a class="headerlink" href="#raises_67" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_282">See Also<a class="headerlink" href="#see-also_282" title="Permanent link">&para;</a></h2>
<p>ihfftn : The inverse n-dimensional FFT with real spectrum. Inverse of <code>hfftn</code>.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : Forward FFT of real input</p>
<h2 id="notes_257">Notes<a class="headerlink" href="#notes_257" title="Permanent link">&para;</a></h2>
<p>For a 1 dimensional signal <code>x</code> to have a real spectrum, it must satisfy
the Hermitian property::</p>
<p>x[i] == np.conj(x[-i]) for all i</p>
<p>This generalizes into higher dimensions by reflecting over each axis in
turn::</p>
<p>x[i, j, k, ...] == np.conj(x[-i, -j, -k, ...]) for all i, j, k, ...</p>
<p>This should not be confused with a Hermitian matrix, for which the
transpose is it's own conjugate::</p>
<p>x[i, j] == np.conj(x[j, i]) for all i, j</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_325">Examples<a class="headerlink" href="#examples_325" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((3, 2, 2))
scipy.fft.hfftn(x)
array([[[12.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]],
[[ 0.,  0.],
[ 0.,  0.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idct</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_396">Parameters<a class="headerlink" href="#parameters_396" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idct is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_382">Returns<a class="headerlink" href="#returns_382" title="Permanent link">&para;</a></h2>
<p>idct : ndarray of real
The transformed input array.</p>
<h2 id="see-also_283">See Also<a class="headerlink" href="#see-also_283" title="Permanent link">&para;</a></h2>
<p>dct : Forward DCT</p>
<h2 id="notes_258">Notes<a class="headerlink" href="#notes_258" title="Permanent link">&para;</a></h2>
<p>For a single dimension array <code>x</code>, <code>idct(x, norm='ortho')</code> is equal to
MATLAB <code>idct(x)</code>.</p>
<p>'The' IDCT is the IDCT-II, which is the same as the normalized DCT-III.</p>
<p>The IDCT is equivalent to a normal DCT except for the normalization and
type. DCT type 1 and 4 are their own inverse and DCTs 2 and 3 are each
other's inverses.</p>
<h2 id="examples_326">Examples<a class="headerlink" href="#examples_326" title="Permanent link">&para;</a></h2>
<p>The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
inputs.  The output is also real and even-symmetrical.  Half of the IFFT
input is used to generate half of the IFFT output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, idct
ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
array([  4.,   3.,   5.,  10.,   5.,   3.])
idct(np.array([ 30.,  -8.,   6.,  -2.]), 1)
array([  4.,   3.,   5.,  10.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idctn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Cosine Transform along the specified axes.</p>
<h2 id="parameters_397">Parameters<a class="headerlink" href="#parameters_397" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DCT (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are
None, <code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is
not None, then <code>s</code> is <code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDCT is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_383">Returns<a class="headerlink" href="#returns_383" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_284">See Also<a class="headerlink" href="#see-also_284" title="Permanent link">&para;</a></h2>
<p>dctn : multidimensional DCT</p>
<h2 id="notes_259">Notes<a class="headerlink" href="#notes_259" title="Permanent link">&para;</a></h2>
<p>For full details of the IDCT types and normalization modes, as well as
references, see <code>idct</code>.</p>
<h2 id="examples_327">Examples<a class="headerlink" href="#examples_327" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dctn, idctn
y = np.random.randn(16, 16)
np.allclose(y, idctn(dctn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idst</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Inverse Discrete Sine Transform of an arbitrary type sequence.</p>
<h2 id="parameters_398">Parameters<a class="headerlink" href="#parameters_398" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
n : int, optional
Length of the transform.  If <code>n &lt; x.shape[axis]</code>, <code>x</code> is
truncated.  If <code>n &gt; x.shape[axis]</code>, <code>x</code> is zero-padded. The
default results in <code>n = x.shape[axis]</code>.
axis : int, optional
Axis along which the idst is computed; the default is over the
last axis (i.e., <code>axis=-1</code>).
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_384">Returns<a class="headerlink" href="#returns_384" title="Permanent link">&para;</a></h2>
<p>idst : ndarray of real
The transformed input array.</p>
<h2 id="see-also_285">See Also<a class="headerlink" href="#see-also_285" title="Permanent link">&para;</a></h2>
<p>dst : Forward DST</p>
<h2 id="notes_260">Notes<a class="headerlink" href="#notes_260" title="Permanent link">&para;</a></h2>
<p>'The' IDST is the IDST-II, which is the same as the normalized DST-III.</p>
<p>The IDST is equivalent to a normal DST except for the normalization and
type. DST type 1 and 4 are their own inverse and DSTs 2 and 3 are each
other's inverses.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">idstn</span> <span class="o">:</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Three</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Four</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return multidimensional Discrete Sine Transform along the specified axes.</p>
<h2 id="parameters_399">Parameters<a class="headerlink" href="#parameters_399" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
type : {1, 2, 3, 4}, optional
Type of the DST (see Notes). Default type is 2.
s : int or array_like of ints or None, optional
The shape of the result.  If both <code>s</code> and <code>axes</code> (see below) are None,
<code>s</code> is <code>x.shape</code>; if <code>s</code> is None but <code>axes</code> is not None, then <code>s</code> is
<code>scipy.take(x.shape, axes, axis=0)</code>.
If <code>s[i] &gt; x.shape[i]</code>, the i-th dimension is padded with zeros.
If <code>s[i] &lt; x.shape[i]</code>, the i-th dimension is truncated to length
<code>s[i]</code>.
If any element of <code>s</code> is -1, the size of the corresponding dimension of
<code>x</code> is used.
axes : int or array_like of ints or None, optional
Axes over which the IDST is computed.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see Notes). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_385">Returns<a class="headerlink" href="#returns_385" title="Permanent link">&para;</a></h2>
<p>y : ndarray of real
The transformed input array.</p>
<h2 id="see-also_286">See Also<a class="headerlink" href="#see-also_286" title="Permanent link">&para;</a></h2>
<p>dstn : multidimensional DST</p>
<h2 id="notes_261">Notes<a class="headerlink" href="#notes_261" title="Permanent link">&para;</a></h2>
<p>For full details of the IDST types and normalization modes, as well as
references, see <code>idst</code>.</p>
<h2 id="examples_328">Examples<a class="headerlink" href="#examples_328" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import dstn, idstn
y = np.random.randn(16, 16)
np.allclose(y, idstn(dstn(y)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier transform computed by <code>fft</code>.  In other words,
<code>ifft(fft(x)) == x</code> to within numerical accuracy.</p>
<p>The input should be ordered in the same way as is returned by <code>fft</code>,
i.e.,</p>
<ul>
<li><code>x[0]</code> should contain the zero frequency term,</li>
<li><code>x[1:n//2]</code> should contain the positive-frequency terms,</li>
<li><code>x[n//2 + 1:]</code> should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.</li>
</ul>
<p>For an even number of input points, <code>x[n//2]</code> represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. See <code>fft</code> for details.</p>
<h2 id="parameters_400">Parameters<a class="headerlink" href="#parameters_400" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
n : int, optional
Length of the transformed axis of the output.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
See notes about padding issues.
axis : int, optional
Axis over which to compute the inverse DFT.  If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_386">Returns<a class="headerlink" href="#returns_386" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.</p>
<h2 id="raises_68">Raises<a class="headerlink" href="#raises_68" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axes</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_287">See Also<a class="headerlink" href="#see-also_287" title="Permanent link">&para;</a></h2>
<p>fft : The one-dimensional (forward) FFT, of which <code>ifft</code> is the inverse
ifft2 : The two-dimensional inverse FFT.
ifftn : The n-dimensional inverse FFT.</p>
<h2 id="notes_262">Notes<a class="headerlink" href="#notes_262" title="Permanent link">&para;</a></h2>
<p>If the input parameter <code>n</code> is larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before calling <code>ifft</code>.</p>
<p>If <code>x</code> is a 1d array, then the <code>ifft</code> is equivalent to ::</p>
<p>y[k] = np.sum(x * np.exp(2j * np.pi * k * np.arange(n)/n)) / len(x)</p>
<p>As with <code>fft</code>, <code>ifft</code> has support for all floating point types and is
optimized for real input.</p>
<h2 id="examples_329">Examples<a class="headerlink" href="#examples_329" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([0, 4, 0, 0])
array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot a band-limited signal with random phases:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
t = np.arange(400)
n = np.zeros((400,), dtype=complex)
n[40:60] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20,)))
s = scipy.fft.ifft(n)
plt.plot(t, s.real, 'b-', t, s.imag, 'r--')
[<matplotlib.lines.Line2D object at ...>, <matplotlib.lines.Line2D object at ...>]
plt.legend(('real', 'imaginary'))
<matplotlib.legend.Legend object at ...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words, <code>ifft2(fft2(x)) == x</code>
to within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fft2</code>, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_401">Parameters<a class="headerlink" href="#parameters_401" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each axis) of the output (<code>s[0]</code> refers to axis 0,
<code>s[1]</code> to axis 1, etc.).  This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last two
axes are used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_387">Returns<a class="headerlink" href="#returns_387" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or the last two axes if <code>axes</code> is not given.</p>
<h2 id="raises_69">Raises<a class="headerlink" href="#raises_69" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length, or <code>axes</code> not given and
<code>len(s) != 2</code>.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_288">See Also<a class="headerlink" href="#see-also_288" title="Permanent link">&para;</a></h2>
<p>fft2 : The forward 2-dimensional FFT, of which <code>ifft2</code> is the inverse.
ifftn : The inverse of the <em>n</em>-dimensional FFT.
fft : The one-dimensional FFT.
ifft : The one-dimensional inverse FFT.</p>
<h2 id="notes_263">Notes<a class="headerlink" href="#notes_263" title="Permanent link">&para;</a></h2>
<p><code>ifft2</code> is just <code>ifftn</code> with a different default for <code>axes</code>.</p>
<p>See <code>ifftn</code> for details and a plotting example, and <code>fft</code> for
definition and conventions used.</p>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifft2</code> is called.</p>
<h2 id="examples_330">Examples<a class="headerlink" href="#examples_330" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = 4 * np.eye(4)
scipy.fft.ifft2(x)
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,
<code>ifftn(fftn(x)) == x</code> to within numerical accuracy.</p>
<p>The input, analogously to <code>ifft</code>, should be ordered in the same way as is
returned by <code>fftn</code>, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.</p>
<h2 id="parameters_402">Parameters<a class="headerlink" href="#parameters_402" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, can be complex.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
This corresponds to <code>n</code> for <code>ifft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.  See notes for issue on <code>ifft</code> zero padding.
axes : sequence of ints, optional
Axes over which to compute the IFFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_388">Returns<a class="headerlink" href="#returns_388" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.</p>
<h2 id="raises_70">Raises<a class="headerlink" href="#raises_70" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_289">See Also<a class="headerlink" href="#see-also_289" title="Permanent link">&para;</a></h2>
<p>fftn : The forward <em>n</em>-dimensional FFT, of which <code>ifftn</code> is the inverse.
ifft : The one-dimensional inverse FFT.
ifft2 : The two-dimensional inverse FFT.
ifftshift : Undoes <code>fftshift</code>, shifts zero-frequency terms to beginning
of array.</p>
<h2 id="notes_264">Notes<a class="headerlink" href="#notes_264" title="Permanent link">&para;</a></h2>
<p>Zero-padding, analogously with <code>ifft</code>, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed before <code>ifftn</code> is called.</p>
<h2 id="examples_331">Examples<a class="headerlink" href="#examples_331" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.eye(4)
scipy.fft.ifftn(scipy.fft.fftn(x, axes=(0,)), axes=(1,))
array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create and plot an image with band-limited frequency content:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
n = np.zeros((200,200), dtype=complex)
n[60:80, 20:40] = np.exp(1j<em>np.random.uniform(0, 2</em>np.pi, (20, 20)))
im = scipy.fft.ifftn(n).real
plt.imshow(im)
<matplotlib.image.AxesImage object at 0x...>
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ifftshift</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">Shape_tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The inverse of <code>fftshift</code>. Although identical for even-length <code>x</code>, the
functions differ by one sample for odd-length <code>x</code>.</p>
<h2 id="parameters_403">Parameters<a class="headerlink" href="#parameters_403" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
axes : int or shape tuple, optional
Axes over which to calculate.  Defaults to None, which shifts all axes.</p>
<h2 id="returns_389">Returns<a class="headerlink" href="#returns_389" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The shifted array.</p>
<h2 id="see-also_290">See Also<a class="headerlink" href="#see-also_290" title="Permanent link">&para;</a></h2>
<p>fftshift : Shift zero-frequency component to the center of the spectrum.</p>
<h2 id="examples_332">Examples<a class="headerlink" href="#examples_332" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
freqs
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])
np.fft.ifftshift(np.fft.fftshift(freqs))
array([[ 0.,  1.,  2.],
[ 3.,  4., -4.],
[-3., -2., -1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse FFT of a signal that has Hermitian symmetry.</p>
<h2 id="parameters_404">Parameters<a class="headerlink" href="#parameters_404" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
n : int, optional
Length of the inverse FFT, the number of points along
transformation axis in the input to use.  If <code>n</code> is smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. If <code>n</code> is not given, the length of
the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See <code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_390">Returns<a class="headerlink" href="#returns_390" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n//2 + 1</code>.</p>
<h2 id="see-also_291">See also<a class="headerlink" href="#see-also_291" title="Permanent link">&para;</a></h2>
<p>hfft, irfft</p>
<h2 id="notes_265">Notes<a class="headerlink" href="#notes_265" title="Permanent link">&para;</a></h2>
<p><code>hfft</code>/<code>ihfft</code> are a pair analogous to <code>rfft</code>/<code>irfft</code>, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here it's <code>hfft</code> for
which you must supply the length of the result if it is to be odd:
* even: <code>ihfft(hfft(a, 2*len(a) - 2) == a</code>, within roundoff error,
* odd: <code>ihfft(hfft(a, 2*len(a) - 1) == a</code>, within roundoff error.</p>
<h2 id="examples_333">Examples<a class="headerlink" href="#examples_333" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import ifft, ihfft
spectrum = np.array([ 15, -4, 0, -1, 0, -4])
ifft(spectrum)
array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
ihfft(spectrum)
array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real spectrum.</p>
<h2 id="parameters_405">Parameters<a class="headerlink" href="#parameters_405" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real input to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_391">Returns<a class="headerlink" href="#returns_391" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_292">See Also<a class="headerlink" href="#see-also_292" title="Permanent link">&para;</a></h2>
<p>ihfftn : Compute the inverse of the N-dimensional FFT of Hermitian input.</p>
<h2 id="notes_266">Notes<a class="headerlink" href="#notes_266" title="Permanent link">&para;</a></h2>
<p>This is really <code>ihfftn</code> with different defaults.
For more details see <code>ihfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ihfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional inverse discrete Fourier Transform for a real
spectrum.</p>
<p>This function computes the N-dimensional inverse discrete Fourier Transform
over any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT). By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining transforms
are complex.</p>
<h2 id="parameters_406">Parameters<a class="headerlink" href="#parameters_406" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_392">Returns<a class="headerlink" href="#returns_392" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_71">Raises<a class="headerlink" href="#raises_71" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_293">See Also<a class="headerlink" href="#see-also_293" title="Permanent link">&para;</a></h2>
<p>hfftn : The forward n-dimensional FFT of Hermitian input.
hfft : The one-dimensional FFT of Hermitian input.
fft : The one-dimensional FFT, with definitions and conventions used.
fftn : The n-dimensional FFT.
hfft2 : The two-dimensional FFT of Hermitian input.</p>
<h2 id="notes_267">Notes<a class="headerlink" href="#notes_267" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>ihfft</code>, then the transform over the remaining axes is
performed as by <code>ifftn</code>. The order of the output is the positive part of
the Hermitian output signal, in the same format as <code>rfft</code>.</p>
<h2 id="examples_334">Examples<a class="headerlink" href="#examples_334" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.ihfftn(x)
array([[[1.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])
scipy.fft.ihfftn(x, axes=(2, 0))
array([[[1.+0.j,  0.+0.j], # may vary
[1.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the n-point DFT for real input.</p>
<p>This function computes the inverse of the one-dimensional <em>n</em>-point
discrete Fourier Transform of real input computed by <code>rfft</code>.
In other words, <code>irfft(rfft(x), len(x)) == x</code> to within numerical
accuracy. (See Notes below for why <code>len(a)</code> is necessary here.)</p>
<p>The input is expected to be in the form returned by <code>rfft</code>, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.</p>
<h2 id="parameters_407">Parameters<a class="headerlink" href="#parameters_407" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array.
n : int, optional
Length of the transformed axis of the output.
For <code>n</code> output points, <code>n//2+1</code> input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  If <code>n</code> is not given, it is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along the axis
specified by <code>axis</code>.
axis : int, optional
Axis over which to compute the inverse FFT. If not given, the last
axis is used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_393">Returns<a class="headerlink" href="#returns_393" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
The length of the transformed axis is <code>n</code>, or, if <code>n</code> is not given,
<code>2*(m-1)</code> where <code>m</code> is the length of the transformed axis of the
input. To get an odd number of output points, <code>n</code> must be specified.</p>
<h2 id="raises_72">Raises<a class="headerlink" href="#raises_72" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>x</code>.</p>
<h2 id="see-also_294">See Also<a class="headerlink" href="#see-also_294" title="Permanent link">&para;</a></h2>
<p>rfft : The one-dimensional FFT of real input, of which <code>irfft</code> is inverse.
fft : The one-dimensional FFT.
irfft2 : The inverse of the two-dimensional FFT of real input.
irfftn : The inverse of the <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_268">Notes<a class="headerlink" href="#notes_268" title="Permanent link">&para;</a></h2>
<p>Returns the real valued <code>n</code>-point inverse discrete Fourier transform
of <code>x</code>, where <code>x</code> contains the non-negative frequency terms of a
Hermitian-symmetric sequence. <code>n</code> is the length of the result, not the
input.</p>
<p>If you specify an <code>n</code> such that <code>a</code> must be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series to <code>m</code> points via Fourier interpolation by:
<code>a_resamp = irfft(rfft(a), m)</code>.</p>
<p>The default value of <code>n</code> assumes an even output length. By the Hermitian
symmetry, the last imaginary component must be 0 and so is ignored. To
avoid losing information, the correct length of the real input <em>must</em> be
given.</p>
<h2 id="examples_335">Examples<a class="headerlink" href="#examples_335" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
scipy.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the last term in the input to the ordinary <code>ifft</code> is the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When calling <code>irfft</code>, the negative frequencies are not
specified, and the output array is purely real.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional inverse FFT of a real array.</p>
<h2 id="parameters_408">Parameters<a class="headerlink" href="#parameters_408" title="Permanent link">&para;</a></h2>
<p>x : array_like
The input array
s : sequence of ints, optional
Shape of the real output to the inverse FFT.
axes : sequence of ints, optional
The axes over which to compute the inverse fft.
Default is the last two axes.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_394">Returns<a class="headerlink" href="#returns_394" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the inverse real 2-D FFT.</p>
<h2 id="see-also_295">See Also<a class="headerlink" href="#see-also_295" title="Permanent link">&para;</a></h2>
<p>irfftn : Compute the inverse of the N-dimensional FFT of real input.</p>
<h2 id="notes_269">Notes<a class="headerlink" href="#notes_269" title="Permanent link">&para;</a></h2>
<p>This is really <code>irfftn</code> with different defaults.
For more details see <code>irfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">irfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the N-dimensional FFT of real input.</p>
<p>This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words, <code>irfftn(rfftn(x), x.shape) == x</code> to within numerical
accuracy. (The <code>a.shape</code> is necessary like <code>len(a)</code> is for <code>irfft</code>,
and for the same reason.)</p>
<p>The input should be ordered in the same way as is returned by <code>rfftn</code>,
i.e. as for <code>irfft</code> for the final transformation axis, and as for <code>ifftn</code>
along all the other axes.</p>
<h2 id="parameters_409">Parameters<a class="headerlink" href="#parameters_409" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
s : sequence of ints, optional
Shape (length of each transformed axis) of the output
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.). <code>s</code> is also the
number of input points used along this axis, except for the last axis,
where <code>s[-1]//2+1</code> points of the input are used.
Along any axis, if the shape indicated by <code>s</code> is smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. If <code>s</code> is not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to be
<code>2*(m-1)</code> where <code>m</code> is the length of the input along that axis.
axes : sequence of ints, optional
Axes over which to compute the inverse FFT. If not given, the last
<code>len(s)</code> axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_395">Returns<a class="headerlink" href="#returns_395" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> or <code>x</code>,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element of <code>s</code>, or the length of the input in every axis except for the
last one if <code>s</code> is not given.  In the final transformed axis the length
of the output when <code>s</code> is not given is <code>2*(m-1)</code> where <code>m</code> is the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis, <code>s</code> must be specified.</p>
<h2 id="raises_73">Raises<a class="headerlink" href="#raises_73" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_296">See Also<a class="headerlink" href="#see-also_296" title="Permanent link">&para;</a></h2>
<p>rfftn : The forward n-dimensional FFT of real input,
of which <code>ifftn</code> is the inverse.
fft : The one-dimensional FFT, with definitions and conventions used.
irfft : The inverse of the one-dimensional FFT of real input.
irfft2 : The inverse of the two-dimensional FFT of real input.</p>
<h2 id="notes_270">Notes<a class="headerlink" href="#notes_270" title="Permanent link">&para;</a></h2>
<p>See <code>fft</code> for definitions and conventions used.</p>
<p>See <code>rfft</code> for definitions and conventions used for real input.</p>
<p>The default value of <code>s</code> assumes an even output length in the final
transformation axis. When performing the final complex to real
transformation, the Hermitian symmetry requires that the last imaginary
component along that axis must be 0 and so it is ignored. To avoid losing
information, the correct length of the real input <em>must</em> be given.</p>
<h2 id="examples_336">Examples<a class="headerlink" href="#examples_336" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.zeros((3, 2, 2))
x[0, 0, 0] = 3 * 2 * 2
scipy.fft.irfftn(x)
array([[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]],
[[1.,  1.],
[1.,  1.]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">register_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Register a backend for permanent use.</p>
<p>Registered backends have the lowest priority and will be tried after the
global backend.</p>
<h2 id="parameters_410">Parameters<a class="headerlink" href="#parameters_410" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_74">Raises<a class="headerlink" href="#raises_74" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the one-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the one-dimensional <em>n</em>-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).</p>
<h2 id="parameters_411">Parameters<a class="headerlink" href="#parameters_411" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array
n : int, optional
Number of points along transformation axis in the input to use.
If <code>n</code> is smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. If <code>n</code> is not given,
the length of the input along the axis specified by <code>axis</code> is used.
axis : int, optional
Axis over which to compute the FFT. If not given, the last axis is
used.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_396">Returns<a class="headerlink" href="#returns_396" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axis
indicated by <code>axis</code>, or the last one if <code>axis</code> is not specified.
If <code>n</code> is even, the length of the transformed axis is <code>(n/2)+1</code>.
If <code>n</code> is odd, the length is <code>(n+1)/2</code>.</p>
<h2 id="raises_75">Raises<a class="headerlink" href="#raises_75" title="Permanent link">&para;</a></h2>
<p>IndexError
If <code>axis</code> is larger than the last axis of <code>a</code>.</p>
<h2 id="see-also_297">See Also<a class="headerlink" href="#see-also_297" title="Permanent link">&para;</a></h2>
<p>irfft : The inverse of <code>rfft</code>.
fft : The one-dimensional FFT of general (complex) input.
fftn : The <em>n</em>-dimensional FFT.
rfftn : The <em>n</em>-dimensional FFT of real input.</p>
<h2 id="notes_271">Notes<a class="headerlink" href="#notes_271" title="Permanent link">&para;</a></h2>
<p>When the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is therefore <code>n//2 + 1</code>.</p>
<p>When <code>X = rfft(x)</code> and fs is the sampling frequency, <code>X[0]</code> contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</p>
<p>If <code>n</code> is even, <code>A[-1]</code> contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. If <code>n</code> is odd, there is no term at fs/2; <code>A[-1]</code> contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.</p>
<p>If the input <code>a</code> contains an imaginary part, it is silently discarded.</p>
<h2 id="examples_337">Examples<a class="headerlink" href="#examples_337" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
scipy.fft.fft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
scipy.fft.rfft([0, 1, 0, 0])
array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice how the final element of the <code>fft</code> output is the complex conjugate
of the second element, for real input. For <code>rfft</code>, this symmetry is
exploited to compute only the non-negative frequency terms.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfft2</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the 2-dimensional FFT of a real array.</p>
<h2 id="parameters_412">Parameters<a class="headerlink" href="#parameters_412" title="Permanent link">&para;</a></h2>
<p>x : array
Input array, taken to be real.
s : sequence of ints, optional
Shape of the FFT.
axes : sequence of ints, optional
Axes over which to compute the FFT.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_397">Returns<a class="headerlink" href="#returns_397" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The result of the real 2-D FFT.</p>
<h2 id="see-also_298">See Also<a class="headerlink" href="#see-also_298" title="Permanent link">&para;</a></h2>
<p>rfftn : Compute the N-dimensional discrete Fourier Transform for real
input.</p>
<h2 id="notes_272">Notes<a class="headerlink" href="#notes_272" title="Permanent link">&para;</a></h2>
<p>This is really just <code>rfftn</code> with different default behavior.
For more details see <code>rfftn</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftfreq</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).</p>
<p>The returned float array <code>f</code> contains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.</p>
<p>Given a window length <code>n</code> and a sample spacing <code>d</code>::</p>
<p>f = [0, 1, ...,     n/2-1,     n/2] / (d<em>n)   if n is even
f = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d</em>n)   if n is odd</p>
<p>Unlike <code>fftfreq</code> (but like <code>scipy.fftpack.rfftfreq</code>)
the Nyquist frequency component is considered to be positive.</p>
<h2 id="parameters_413">Parameters<a class="headerlink" href="#parameters_413" title="Permanent link">&para;</a></h2>
<p>n : int
Window length.
d : scalar, optional
Sample spacing (inverse of the sampling rate). Defaults to 1.</p>
<h2 id="returns_398">Returns<a class="headerlink" href="#returns_398" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of length <code>n//2 + 1</code> containing the sample frequencies.</p>
<h2 id="examples_338">Examples<a class="headerlink" href="#examples_338" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)
fourier = np.fft.rfft(signal)
n = signal.size
sample_rate = 100
freq = np.fft.fftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20., ..., -30., -20., -10.])
freq = np.fft.rfftfreq(n, d=1./sample_rate)
freq
array([  0.,  10.,  20.,  30.,  40.,  50.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rfftn</span> <span class="o">:</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_x</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">workers</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the N-dimensional discrete Fourier Transform for real input.</p>
<p>This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.</p>
<h2 id="parameters_414">Parameters<a class="headerlink" href="#parameters_414" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array, taken to be real.
s : sequence of ints, optional
Shape (length along each transformed axis) to use from the input.
(<code>s[0]</code> refers to axis 0, <code>s[1]</code> to axis 1, etc.).
The final element of <code>s</code> corresponds to <code>n</code> for <code>rfft(x, n)</code>, while
for the remaining axes, it corresponds to <code>n</code> for <code>fft(x, n)</code>.
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
if <code>s</code> is not given, the shape of the input along the axes specified
by <code>axes</code> is used.
axes : sequence of ints, optional
Axes over which to compute the FFT.  If not given, the last <code>len(s)</code>
axes are used, or all axes if <code>s</code> is also not specified.
norm : {None, 'ortho'}, optional
Normalization mode (see <code>fft</code>). Default is None.
overwrite_x : bool, optional
If True, the contents of <code>x</code> can be destroyed; the default is False.
See :func:<code>fft</code> for more details.
workers : int, optional
Maximum number of workers to use for parallel computation. If negative,
the value wraps around from <code>os.cpu_count()</code>.
See :func:<code>~scipy.fft.fft</code> for more details.</p>
<h2 id="returns_399">Returns<a class="headerlink" href="#returns_399" title="Permanent link">&para;</a></h2>
<p>out : complex ndarray
The truncated or zero-padded input, transformed along the axes
indicated by <code>axes</code>, or by a combination of <code>s</code> and <code>x</code>,
as explained in the parameters section above.
The length of the last axis transformed will be <code>s[-1]//2+1</code>,
while the remaining transformed axes will have lengths according to
<code>s</code>, or unchanged from the input.</p>
<h2 id="raises_76">Raises<a class="headerlink" href="#raises_76" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>s</code> and <code>axes</code> have different length.
IndexError
If an element of <code>axes</code> is larger than than the number of axes of <code>x</code>.</p>
<h2 id="see-also_299">See Also<a class="headerlink" href="#see-also_299" title="Permanent link">&para;</a></h2>
<p>irfftn : The inverse of <code>rfftn</code>, i.e. the inverse of the n-dimensional FFT
of real input.
fft : The one-dimensional FFT, with definitions and conventions used.
rfft : The one-dimensional FFT of real input.
fftn : The n-dimensional FFT.
rfft2 : The two-dimensional FFT of real input.</p>
<h2 id="notes_273">Notes<a class="headerlink" href="#notes_273" title="Permanent link">&para;</a></h2>
<p>The transform for real input is performed over the last transformation
axis, as by <code>rfft</code>, then the transform over the remaining axes is
performed as by <code>fftn</code>.  The order of the output is as for <code>rfft</code> for the
final transformation axis, and as for <code>fftn</code> for the remaining
transformation axes.</p>
<p>See <code>fft</code> for details, definitions and conventions used.</p>
<h2 id="examples_339">Examples<a class="headerlink" href="#examples_339" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft
x = np.ones((2, 2, 2))
scipy.fft.rfftn(x)
array([[[8.+0.j,  0.+0.j], # may vary
[0.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
<p>scipy.fft.rfftn(x, axes=(2, 0))
array([[[4.+0.j,  0.+0.j], # may vary
[4.+0.j,  0.+0.j]],
[[0.+0.j,  0.+0.j],
[0.+0.j,  0.+0.j]]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_backend</span> <span class="o">:</span> <span class="o">?</span><span class="n">coerce</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">backend</span><span class="o">:[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to set the backend within a fixed scope.</p>
<p>Upon entering the <code>with</code> statement, the given backend will be added to
the list of available backends with the highest priority. Upon exit, the
backend is reset to the state before entering the scope.</p>
<h2 id="parameters_415">Parameters<a class="headerlink" href="#parameters_415" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.
coerce: bool, optional
Whether to allow expensive conversions for the <code>x</code> parameter. e.g.
copying a numpy array to the GPU for a CuPy backend. Implies <code>only</code>.
only: bool, optional
If only is <code>True</code> and this backend returns <code>NotImplemented</code> then a
BackendNotImplemented error will be raised immediately. Ignoring any
lower priority backends.</p>
<h2 id="examples_340">Examples<a class="headerlink" href="#examples_340" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
with fft.set_backend('scipy', only=True):
...     fft.fft([1])  # Always calls the scipy implementation
array([1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_global_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sets the global fft backend</p>
<p>The global backend has higher priority than registered backends, but lower
priority than context-specific backends set with <code>set_backend</code>.</p>
<h2 id="parameters_416">Parameters<a class="headerlink" href="#parameters_416" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to use.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="raises_77">Raises<a class="headerlink" href="#raises_77" title="Permanent link">&para;</a></h2>
<p>ValueError: If the backend does not implement <code>numpy.scipy.fft</code></p>
<h2 id="notes_274">Notes<a class="headerlink" href="#notes_274" title="Permanent link">&para;</a></h2>
<p>This will overwrite the previously set global backend, which by default is
the SciPy implementation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_workers</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager for the default number of workers used in <code>scipy.fft</code></p>
<h2 id="parameters_417">Parameters<a class="headerlink" href="#parameters_417" title="Permanent link">&para;</a></h2>
<p>workers : int
The default number of workers to use</p>
<h2 id="examples_341">Examples<a class="headerlink" href="#examples_341" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import fft, signal
x = np.random.randn(128, 64)
with fft.set_workers(4):
...     y = signal.fftconvolve(x, x)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">skip_backend</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">Scipy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Context manager to skip a backend within a fixed scope.</p>
<p>Within the context of a <code>with</code> statement, the given backend will not be
called. This covers backends registered both locally and globally. Upon
exit, the backend will again be considered.</p>
<h2 id="parameters_418">Parameters<a class="headerlink" href="#parameters_418" title="Permanent link">&para;</a></h2>
<p>backend: {object, 'scipy'}
The backend to skip.
Can either be a <code>str</code> containing the name of a known backend
{'scipy'}, or an object that implements the uarray protocol.</p>
<h2 id="examples_342">Examples<a class="headerlink" href="#examples_342" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.fft as fft
fft.fft([1])  # Calls default scipy backend
array([1.+0.j])
with fft.skip_backend('scipy'):  # We expicitly skip the scipy backend
...     fft.fft([1])                 # leaving no implementation available
Traceback (most recent call last):
...
BackendNotImplementedError: No selected backends had an implementation ...</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">barthann</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a modified Bartlett-Hann window.</p>
<h2 id="parameters_419">Parameters<a class="headerlink" href="#parameters_419" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_400">Returns<a class="headerlink" href="#returns_400" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_343">Examples<a class="headerlink" href="#examples_343" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.barthann(51)
plt.plot(window)
plt.title('Bartlett-Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett-Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bartlett</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<h2 id="parameters_420">Parameters<a class="headerlink" href="#parameters_420" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_401">Returns<a class="headerlink" href="#returns_401" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The triangular window, with the first and last samples equal to zero
and the maximum value normalized to 1 (though the value 1 does not
appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_300">See Also<a class="headerlink" href="#see-also_300" title="Permanent link">&para;</a></h2>
<p>triang : A triangular window that does not touch zero at the ends</p>
<h2 id="notes_275">Notes<a class="headerlink" href="#notes_275" title="Permanent link">&para;</a></h2>
<p>The Bartlett window is defined as</p>
<p>.. math:: w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)</p>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means'removing the foot', i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The Fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich. [2]_</p>
<h2 id="references_68">References<a class="headerlink" href="#references_68" title="Permanent link">&para;</a></h2>
<p>.. [1] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, 'Discrete-Time Signal
Processing', Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 429.</p>
<h2 id="examples_344">Examples<a class="headerlink" href="#examples_344" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bartlett(51)
plt.plot(window)
plt.title('Bartlett window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackman</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three terms of
a summation of cosines. It was designed to have close to the minimal
leakage possible.  It is close to optimal, only slightly worse than a
Kaiser window.</p>
<h2 id="parameters_421">Parameters<a class="headerlink" href="#parameters_421" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_402">Returns<a class="headerlink" href="#returns_402" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_276">Notes<a class="headerlink" href="#notes_276" title="Permanent link">&para;</a></h2>
<p>The Blackman window is defined as</p>
<p>.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)</p>
<p>The 'exact Blackman' window was designed to null out the third and fourth
sidelobes, but has discontinuities at the boundaries, resulting in a
6 dB/oct fall-off.  This window is an approximation of the 'exact' window,
which does not null the sidelobes as well, but is smooth at the edges,
improving the fall-off rate to 18 dB/oct. [3]_</p>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
'near optimal' tapering function, almost as good (by some measures)
as the Kaiser window.</p>
<h2 id="references_69">References<a class="headerlink" href="#references_69" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
.. [3] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_345">Examples<a class="headerlink" href="#examples_345" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackman(51)
plt.plot(window)
plt.title('Blackman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackmanharris</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window.</p>
<h2 id="parameters_422">Parameters<a class="headerlink" href="#parameters_422" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_403">Returns<a class="headerlink" href="#returns_403" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_346">Examples<a class="headerlink" href="#examples_346" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackmanharris(51)
plt.plot(window)
plt.title('Blackman-Harris window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman-Harris window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bohman</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bohman window.</p>
<h2 id="parameters_423">Parameters<a class="headerlink" href="#parameters_423" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_404">Returns<a class="headerlink" href="#returns_404" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_347">Examples<a class="headerlink" href="#examples_347" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bohman(51)
plt.plot(window)
plt.title('Bohman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bohman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcar</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a boxcar or rectangular window.</p>
<p>Also known as a rectangular window or Dirichlet window, this is equivalent
to no window at all.</p>
<h2 id="parameters_424">Parameters<a class="headerlink" href="#parameters_424" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
Whether the window is symmetric. (Has no effect for boxcar.)</p>
<h2 id="returns_405">Returns<a class="headerlink" href="#returns_405" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1.</p>
<h2 id="examples_348">Examples<a class="headerlink" href="#examples_348" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.boxcar(51)
plt.plot(window)
plt.title('Boxcar window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the boxcar window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">at</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Dolph-Chebyshev window.</p>
<h2 id="parameters_425">Parameters<a class="headerlink" href="#parameters_425" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
at : float
Attenuation (in dB).
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_406">Returns<a class="headerlink" href="#returns_406" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="notes_277">Notes<a class="headerlink" href="#notes_277" title="Permanent link">&para;</a></h2>
<p>This window optimizes for the narrowest main lobe width for a given order
<code>M</code> and sidelobe equiripple attenuation <code>at</code>, using Chebyshev
polynomials.  It was originally developed by Dolph to optimize the
directionality of radio antenna arrays.</p>
<p>Unlike most windows, the Dolph-Chebyshev is defined in terms of its
frequency response:</p>
<p>.. math:: W(k) = \frac
{\cos{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]}}
{\cosh[M \cosh^{-1}(\beta)]}</p>
<p>where</p>
<p>.. math:: \beta = \cosh \left [\frac{1}{M}
\cosh^{-1}(10^\frac{A}{20}) \right ]</p>
<p>and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (<code>at</code>).</p>
<p>The time domain window is then generated using the IFFT, so
power-of-two <code>M</code> are the fastest to generate, and prime number <code>M</code> are
the slowest.</p>
<p>The equiripple condition in the frequency domain creates impulses in the
time domain, which appear at the ends of the window.</p>
<h2 id="references_70">References<a class="headerlink" href="#references_70" title="Permanent link">&para;</a></h2>
<p>.. [1] C. Dolph, 'A current distribution for broadside arrays which
optimizes the relationship between beam width and side-lobe level',
Proceedings of the IEEE, Vol. 34, Issue 6
.. [2] Peter Lynch, 'The Dolph-Chebyshev Window: A Simple Optimal Filter',
American Meteorological Society (April 1997)
http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf
.. [3] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transforms', Proceedings of the IEEE, Vol. 66,
No. 1, January 1978</p>
<h2 id="examples_349">Examples<a class="headerlink" href="#examples_349" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.chebwin(51, at=100)
plt.plot(window)
plt.title('Dolph-Chebyshev window (100 dB)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Dolph-Chebyshev window (100 dB)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a simple cosine shape.</p>
<h2 id="parameters_426">Parameters<a class="headerlink" href="#parameters_426" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_407">Returns<a class="headerlink" href="#returns_407" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_278">Notes<a class="headerlink" href="#notes_278" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<h2 id="examples_350">Examples<a class="headerlink" href="#examples_350" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.cosine(51)
plt.plot(window)
plt.title('Cosine window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the cosine window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dpss</span> <span class="o">:</span> <span class="o">?</span><span class="n">kmax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">T_2</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Optional</span> <span class="k">of</span> <span class="o">[`</span><span class="nc">T_subsample_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Approximate</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_ratios</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Discrete Prolate Spheroidal Sequences (DPSS).</p>
<p>DPSS (or Slepian sequences) are often used in multitaper power spectral
density estimation (see [1]_). The first window in the sequence can be
used to maximize the energy concentration in the main lobe, and is also
called the Slepian window.</p>
<h2 id="parameters_427">Parameters<a class="headerlink" href="#parameters_427" title="Permanent link">&para;</a></h2>
<p>M : int
Window length.
NW : float
Standardized half bandwidth corresponding to <code>2*NW = BW/f0 = BW*N*dt</code>
where <code>dt</code> is taken as 1.
Kmax : int | None, optional
Number of DPSS windows to return (orders <code>0</code> through <code>Kmax-1</code>).
If None (default), return only a single window of shape <code>(M,)</code>
instead of an array of windows of shape <code>(Kmax, M)</code>.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.
norm : {2, 'approximate', 'subsample'} | None, optional
If 'approximate' or 'subsample', then the windows are normalized by the
maximum, and a correction scale-factor for even-length windows
is applied either using <code>M**2/(M**2+NW)</code> ('approximate') or
a FFT-based subsample shift ('subsample'), see Notes for details.
If None, then 'approximate' is used when <code>Kmax=None</code> and 2 otherwise
(which uses the l2 norm).
return_ratios : bool, optional
If True, also return the concentration ratios in addition to the
windows.</p>
<h2 id="returns_408">Returns<a class="headerlink" href="#returns_408" title="Permanent link">&para;</a></h2>
<p>v : ndarray, shape (Kmax, N) or (N,)
The DPSS windows. Will be 1D if <code>Kmax</code> is None.
r : ndarray, shape (Kmax,) or float, optional
The concentration ratios for the windows. Only returned if
<code>return_ratios</code> evaluates to True. Will be 0D if <code>Kmax</code> is None.</p>
<h2 id="notes_279">Notes<a class="headerlink" href="#notes_279" title="Permanent link">&para;</a></h2>
<p>This computation uses the tridiagonal eigenvector formulation given
in [2]_.</p>
<p>The default normalization for <code>Kmax=None</code>, i.e. window-generation mode,
simply using the l-infinity norm would create a window with two unity
values, which creates slight normalization differences between even and odd
orders. The approximate correction of <code>M**2/float(M**2+NW)</code> for even
sample numbers is used to counteract this effect (see Examples below).</p>
<p>For very long signals (e.g., 1e6 elements), it can be useful to compute
windows orders of magnitude shorter and use interpolation (e.g.,
<code>scipy.interpolate.interp1d</code>) to obtain tapers of length <code>M</code>,
but this in general will not preserve orthogonality between the tapers.</p>
<p>.. versionadded:: 1.1</p>
<h2 id="references_71">References<a class="headerlink" href="#references_71" title="Permanent link">&para;</a></h2>
<p>.. [1] Percival DB, Walden WT. Spectral Analysis for Physical Applications:
Multitaper and Conventional Univariate Techniques.
Cambridge University Press; 1993.
.. [2] Slepian, D. Prolate spheroidal wave functions, Fourier analysis, and
uncertainty V: The discrete case. Bell System Technical Journal,
Volume 57 (1978), 1371430.
.. [3] Kaiser, JF, Schafer RW. On the Use of the I0-Sinh Window for
Spectrum Analysis. IEEE Transactions on Acoustics, Speech and
Signal Processing. ASSP-28 (1): 105-107; 1980.</p>
<h2 id="examples_351">Examples<a class="headerlink" href="#examples_351" title="Permanent link">&para;</a></h2>
<p>We can compare the window to <code>kaiser</code>, which was invented as an alternative
that was easier to calculate [3]<em> (example adapted from
<code>here &lt;https://ccrma.stanford.edu/~jos/sasp/Kaiser_DPSS_Windows_Compared.html&gt;</code></em>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import windows, freqz
N = 51
fig, axes = plt.subplots(3, 2, figsize=(5, 7))
for ai, alpha in enumerate((1, 3, 5)):
...     win_dpss = windows.dpss(N, alpha)
...     beta = alpha*np.pi
...     win_kaiser = windows.kaiser(N, beta)
...     for win, c in ((win_dpss, 'k'), (win_kaiser, 'r')):
...         win /= win.sum()
...         axes[ai, 0].plot(win, color=c, lw=1.)
...         axes[ai, 0].set(xlim=[0, N-1], title=r'<span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> = %s' % alpha,
...                         ylabel='Amplitude')
...         w, h = freqz(win)
...         axes[ai, 1].plot(w, 20 * np.log10(np.abs(h)), color=c, lw=1.)
...         axes[ai, 1].set(xlim=[0, np.pi],
...                         title=r'<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> = %0.2f' % beta,
...                         ylabel='Magnitude (dB)')
for ax in axes.ravel():
...     ax.grid(True)
axes[2, 1].legend(['DPSS', 'Kaiser'])
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>And here are examples of the first four windows, along with their
concentration ratios:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = 512
NW = 2.5
win, eigvals = windows.dpss(M, NW, 4, return_ratios=True)
fig, ax = plt.subplots(1)
ax.plot(win.T, linewidth=1.)
ax.set(xlim=[0, M-1], ylim=[-0.1, 0.1], xlabel='Samples',
...        title='DPSS, M=%d, NW=%0.1f' % (M, NW))
ax.legend(['win[%d] (%0.4f)' % (ii, ratio)
...            for ii, ratio in enumerate(eigvals)])
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using a standard :math:<code>l_{\infty}</code> norm would produce two unity values
for even <code>M</code>, but only one unity value for odd <code>M</code>. This produces uneven
window power that can be counteracted by the approximate correction
<code>M**2/float(M**2+NW)</code>, which can be selected by using
<code>norm='approximate'</code> (which is the same as <code>norm=None</code> when
<code>Kmax=None</code>, as is the case here). Alternatively, the slower
<code>norm='subsample'</code> can be used, which uses subsample shifting in the
frequency domain (FFT) to compute the correction:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Ms = np.arange(1, 41)
factors = (50, 20, 10, 5, 2.0001)
energy = np.empty((3, len(Ms), len(factors)))
for mi, M in enumerate(Ms):
...     for fi, factor in enumerate(factors):
...         NW = M / float(factor)
...         # Corrected using empirical approximation (default)
...         win = windows.dpss(M, NW)
...         energy[0, mi, fi] = np.sum(win <strong> 2) / np.sqrt(M)
...         # Corrected using subsample shifting
...         win = windows.dpss(M, NW, norm='subsample')
...         energy[1, mi, fi] = np.sum(win </strong> 2) / np.sqrt(M)
...         # Uncorrected (using l-infinity norm)
...         win /= win.max()
...         energy[2, mi, fi] = np.sum(win ** 2) / np.sqrt(M)
fig, ax = plt.subplots(1)
hs = ax.plot(Ms, energy[2], '-o', markersize=4,
...              markeredgecolor='none')
leg = [hs[-1]]
for hi, hh in enumerate(hs):
...     h1 = ax.plot(Ms, energy[0, :, hi], '-o', markersize=4,
...                  color=hh.get_color(), markeredgecolor='none',
...                  alpha=0.66)
...     h2 = ax.plot(Ms, energy[1, :, hi], '-o', markersize=4,
...                  color=hh.get_color(), markeredgecolor='none',
...                  alpha=0.33)
...     if hi == len(hs) - 1:
...         leg.insert(0, h1[0])
...         leg.insert(0, h2[0])
ax.set(xlabel='M (samples)', ylabel=r'Power / <span><span class="MathJax_Preview">\sqrt{M}</span><script type="math/tex">\sqrt{M}</script></span>')
ax.legend(leg, ['Uncorrected', r'Corrected: <span><span class="MathJax_Preview">\frac{M^2}{M^2+NW}</span><script type="math/tex">\frac{M^2}{M^2+NW}</script></span>',
...                 'Corrected (subsample)'])
fig.tight_layout()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exponential</span> <span class="o">:</span> <span class="o">?</span><span class="n">center</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tau</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an exponential (or Poisson) window.</p>
<h2 id="parameters_428">Parameters<a class="headerlink" href="#parameters_428" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
center : float, optional
Parameter defining the center location of the window function.
The default value if not given is <code>center = (M-1) / 2</code>.  This
parameter must take its default value for symmetric windows.
tau : float, optional
Parameter defining the decay.  For <code>center = 0</code> use
<code>tau = -(M-1) / ln(x)</code> if <code>x</code> is the fraction of the window
remaining at the end.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_409">Returns<a class="headerlink" href="#returns_409" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_280">Notes<a class="headerlink" href="#notes_280" title="Permanent link">&para;</a></h2>
<p>The Exponential window is defined as</p>
<p>.. math::  w(n) = e^{-|n-center| / \tau}</p>
<h2 id="references_72">References<a class="headerlink" href="#references_72" title="Permanent link">&para;</a></h2>
<p>S. Gade and H. Herlufsen, 'Windows to FFT analysis (Part I)',
Technical Review 3, Bruel &amp; Kjaer, 1987.</p>
<h2 id="examples_352">Examples<a class="headerlink" href="#examples_352" title="Permanent link">&para;</a></h2>
<p>Plot the symmetric window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>M = 51
tau = 3.0
window = signal.exponential(M, tau=tau)
plt.plot(window)
plt.title('Exponential Window (tau=3.0)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -35, 0])
plt.title('Frequency response of the Exponential window (tau=3.0)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function can also generate non-symmetric windows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>tau2 = -(M-1) / np.log(0.01)
window2 = signal.exponential(M, 0, tau2, False)
plt.figure()
plt.plot(window2)
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flattop</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flat top window.</p>
<h2 id="parameters_429">Parameters<a class="headerlink" href="#parameters_429" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_410">Returns<a class="headerlink" href="#returns_410" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_281">Notes<a class="headerlink" href="#notes_281" title="Permanent link">&para;</a></h2>
<p>Flat top windows are used for taking accurate measurements of signal
amplitude in the frequency domain, with minimal scalloping error from the
center of a frequency bin to its edges, compared to others.  This is a
5th-order cosine window, with the 5 terms optimized to make the main lobe
maximally flat. [1]_</p>
<h2 id="references_73">References<a class="headerlink" href="#references_73" title="Permanent link">&para;</a></h2>
<p>.. [1] D'Antona, Gabriele, and A. Ferrero, 'Digital Signal Processing for
Measurement Systems', Springer Media, 2006, p. 70
:doi:<code>10.1007/0-387-28666-7</code>.</p>
<h2 id="examples_353">Examples<a class="headerlink" href="#examples_353" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.flattop(51)
plt.plot(window)
plt.title('Flat top window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the flat top window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Gaussian window.</p>
<h2 id="parameters_430">Parameters<a class="headerlink" href="#parameters_430" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
std : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_411">Returns<a class="headerlink" href="#returns_411" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_282">Notes<a class="headerlink" href="#notes_282" title="Permanent link">&para;</a></h2>
<p>The Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 }</p>
<h2 id="examples_354">Examples<a class="headerlink" href="#examples_354" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.gaussian(51, std=7)
plt.plot(window)
plt.title(r'Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generic weighted sum of cosine terms window</p>
<h2 id="parameters_431">Parameters<a class="headerlink" href="#parameters_431" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window
a : array_like
Sequence of weighting coefficients. This uses the convention of being
centered on the origin, so these will typically all be positive
numbers, not alternating sign.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="references_74">References<a class="headerlink" href="#references_74" title="Permanent link">&para;</a></h2>
<p>.. [1] A. Nuttall, 'Some windows with very good sidelobe behavior,' IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. :doi:<code>10.1109/TASSP.1981.1163506</code>.
.. [2] Heinzel G. et al., 'Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows', February 15, 2002
https://holometer.fnal.gov/GH_FFT.pdf</p>
<h2 id="examples_355">Examples<a class="headerlink" href="#examples_355" title="Permanent link">&para;</a></h2>
<p>Heinzel describes a flat-top window named 'HFT90D' with formula: [2]_</p>
<p>.. math::  w_j = 1 - 1.942604 \cos(z) + 1.340318 \cos(2z)
- 0.440811 \cos(3z) + 0.043097 \cos(4z)</p>
<p>where</p>
<p>.. math::  z = \frac{2 \pi j}{N}, j = 0...N - 1</p>
<p>Since this uses the convention of starting at the origin, to reproduce the
window, we need to convert every other coefficient to a positive number:</p>
<blockquote>
<blockquote>
<blockquote>
<p>HFT90D = [1, 1.942604, 1.340318, 0.440811, 0.043097]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The paper states that the highest sidelobe is at -90.2 dB.  Reproduce
Figure 42 by plotting the window and its frequency response, and confirm
the sidelobe level in red:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal.windows import general_cosine
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = general_cosine(1000, HFT90D, sym=False)
plt.plot(window)
plt.title('HFT90D window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 10000) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-50/1000, 50/1000, -140, 0])
plt.title('Frequency response of the HFT90D window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')
plt.axhline(-90.2, color='red')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">sig_</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a generalized Gaussian shape.</p>
<h2 id="parameters_432">Parameters<a class="headerlink" href="#parameters_432" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
p : float
Shape parameter.  p = 1 is identical to <code>gaussian</code>, p = 0.5 is
the same shape as the Laplace distribution.
sig : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_412">Returns<a class="headerlink" href="#returns_412" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_283">Notes<a class="headerlink" href="#notes_283" title="Permanent link">&para;</a></h2>
<p>The generalized Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} }</p>
<p>the half-power point is at</p>
<p>.. math::  (2 \log(2))^{1/(2 p)} \sigma</p>
<h2 id="examples_356">Examples<a class="headerlink" href="#examples_356" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.general_gaussian(51, p=1.5, sig=7)
plt.plot(window)
plt.title(r'Generalized Gaussian window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Freq. resp. of the gen. Gaussian '
...           r'window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a generalized Hamming window.</p>
<p>The generalized Hamming window is constructed by multiplying a rectangular
window by one period of a cosine function [1]_.</p>
<h2 id="parameters_433">Parameters<a class="headerlink" href="#parameters_433" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
alpha : float
The window coefficient, :math:<code>\alpha</code>
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_413">Returns<a class="headerlink" href="#returns_413" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_284">Notes<a class="headerlink" href="#notes_284" title="Permanent link">&para;</a></h2>
<p>The generalized Hamming window is defined as</p>
<p>.. math:: w(n) = \alpha - \left(1 - \alpha\right) \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>Both the common Hamming window and Hann window are special cases of the
generalized Hamming window with :math:<code>\alpha</code> = 0.54 and :math:<code>\alpha</code> =
0.5, respectively [2]_.</p>
<h2 id="see-also_301">See Also<a class="headerlink" href="#see-also_301" title="Permanent link">&para;</a></h2>
<p>hamming, hann</p>
<h2 id="examples_357">Examples<a class="headerlink" href="#examples_357" title="Permanent link">&para;</a></h2>
<p>The Sentinel-1A/B Instrument Processing Facility uses generalized Hamming
windows in the processing of spaceborne Synthetic Aperture Radar (SAR)
data [3]<em>. The facility uses various values for the :math:<code>\alpha</code>
parameter based on operating mode of the SAR instrument. Some common
:math:<code>\alpha</code> values include 0.75, 0.7 and 0.52 [4]</em>. As an example, we
plot these different windows.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal.windows import general_hamming
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>fig1, spatial_plot = plt.subplots()
spatial_plot.set_title('Generalized Hamming Windows')
spatial_plot.set_ylabel('Amplitude')
spatial_plot.set_xlabel('Sample')</p>
<p>fig2, freq_plot = plt.subplots()
freq_plot.set_title('Frequency Responses')
freq_plot.set_ylabel('Normalized magnitude [dB]')
freq_plot.set_xlabel('Normalized frequency [cycles per sample]')</p>
<p>for alpha in [0.75, 0.7, 0.52]:
...     window = general_hamming(41, alpha)
...     spatial_plot.plot(window, label='{:.2f}'.format(alpha))
...     A = fft(window, 2048) / (len(window)/2.0)
...     freq = np.linspace(-0.5, 0.5, len(A))
...     response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
...     freq_plot.plot(freq, response, label='{:.2f}'.format(alpha))
freq_plot.legend(loc='upper right')
spatial_plot.legend(loc='upper right')</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_75">References<a class="headerlink" href="#references_75" title="Permanent link">&para;</a></h2>
<p>.. [1] DSPRelated, 'Generalized Hamming Window Family',
https://www.dsprelated.com/freebooks/sasp/Generalized_Hamming_Window_Family.html
.. [2] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [3] Riccardo Piantanida ESA, 'Sentinel-1 Level 1 Detailed Algorithm
Definition',
https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Level-1-Detailed-Algorithm-Definition
.. [4] Matthieu Bourbigot ESA, 'Sentinel-1 Product Definition',
https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Product-Definition</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_window</span> <span class="o">:</span> <span class="o">?</span><span class="n">fftbins</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window of a given length and type.</p>
<h2 id="parameters_434">Parameters<a class="headerlink" href="#parameters_434" title="Permanent link">&para;</a></h2>
<p>window : string, float, or tuple
The type of window to create. See below for more details.
Nx : int
The number of samples in the window.
fftbins : bool, optional
If True (default), create a 'periodic' window, ready to use with
<code>ifftshift</code> and be multiplied by the result of an FFT (see also
:func:<code>~scipy.fft.fftfreq</code>).
If False, create a 'symmetric' window, for use in filter design.</p>
<h2 id="returns_414">Returns<a class="headerlink" href="#returns_414" title="Permanent link">&para;</a></h2>
<p>get_window : ndarray
Returns a window of length <code>Nx</code> and type <code>window</code></p>
<h2 id="notes_285">Notes<a class="headerlink" href="#notes_285" title="Permanent link">&para;</a></h2>
<p>Window types:</p>
<ul>
<li><code>~scipy.signal.windows.boxcar</code></li>
<li><code>~scipy.signal.windows.triang</code></li>
<li><code>~scipy.signal.windows.blackman</code></li>
<li><code>~scipy.signal.windows.hamming</code></li>
<li><code>~scipy.signal.windows.hann</code></li>
<li><code>~scipy.signal.windows.bartlett</code></li>
<li><code>~scipy.signal.windows.flattop</code></li>
<li><code>~scipy.signal.windows.parzen</code></li>
<li><code>~scipy.signal.windows.bohman</code></li>
<li><code>~scipy.signal.windows.blackmanharris</code></li>
<li><code>~scipy.signal.windows.nuttall</code></li>
<li><code>~scipy.signal.windows.barthann</code></li>
<li><code>~scipy.signal.windows.kaiser</code> (needs beta)</li>
<li><code>~scipy.signal.windows.gaussian</code> (needs standard deviation)</li>
<li><code>~scipy.signal.windows.general_gaussian</code> (needs power, width)</li>
<li><code>~scipy.signal.windows.slepian</code> (needs width)</li>
<li><code>~scipy.signal.windows.dpss</code> (needs normalized half-bandwidth)</li>
<li><code>~scipy.signal.windows.chebwin</code> (needs attenuation)</li>
<li><code>~scipy.signal.windows.exponential</code> (needs decay scale)</li>
<li><code>~scipy.signal.windows.tukey</code> (needs taper fraction)</li>
</ul>
<p>If the window requires no parameters, then <code>window</code> can be a string.</p>
<p>If the window requires parameters, then <code>window</code> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <code>window</code> is a floating point number, it is interpreted as the beta
parameter of the <code>~scipy.signal.windows.kaiser</code> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<h2 id="examples_358">Examples<a class="headerlink" href="#examples_358" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.get_window('triang', 7)
array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])
signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])
signal.get_window(4.0, 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hamming window.</p>
<p>The Hamming window is a taper formed by using a raised cosine with
non-zero endpoints, optimized to minimize the nearest side lobe.</p>
<h2 id="parameters_435">Parameters<a class="headerlink" href="#parameters_435" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_415">Returns<a class="headerlink" href="#returns_415" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_286">Notes<a class="headerlink" href="#notes_286" title="Permanent link">&para;</a></h2>
<p>The Hamming window is defined as</p>
<p>.. math::  w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_76">References<a class="headerlink" href="#references_76" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_359">Examples<a class="headerlink" href="#examples_359" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hamming(51)
plt.plot(window)
plt.title('Hamming window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hamming window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hann</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hann window.</p>
<p>The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.</p>
<h2 id="parameters_436">Parameters<a class="headerlink" href="#parameters_436" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_416">Returns<a class="headerlink" href="#returns_416" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_287">Notes<a class="headerlink" href="#notes_287" title="Permanent link">&para;</a></h2>
<p>The Hann window is defined as</p>
<p>.. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The window was named for Julius von Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the 'Hanning' window, from the use of 'hann' as a verb in the original
paper and confusion with the very similar Hamming window.</p>
<p>Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_77">References<a class="headerlink" href="#references_77" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_360">Examples<a class="headerlink" href="#examples_360" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hann(51)
plt.plot(window)
plt.title('Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hanning</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>hanning</code> is deprecated, use <code>scipy.signal.windows.hann</code> instead!</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<h2 id="parameters_437">Parameters<a class="headerlink" href="#parameters_437" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
beta : float
Shape parameter, determines trade-off between main-lobe width and
side lobe level. As beta gets large, the window narrows.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_417">Returns<a class="headerlink" href="#returns_417" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_288">Notes<a class="headerlink" href="#notes_288" title="Permanent link">&para;</a></h2>
<p>The Kaiser window is defined as</p>
<p>.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)</p>
<p>with</p>
<p>.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},</p>
<p>where :math:<code>I_0</code> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.</p>
<p>The Kaiser can approximate other windows by varying the beta parameter.
(Some literature uses alpha = beta/pi.) [4]_</p>
<p>====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hann
8.6   Similar to a Blackman
====  =======================</p>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
be returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_78">References<a class="headerlink" href="#references_78" title="Permanent link">&para;</a></h2>
<p>.. [1] J. F. Kaiser, 'Digital Filters' - Ch 7 in 'Systems analysis by
digital computer', Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transform,' Proceedings of the IEEE, vol. 66,
no. 1, pp. 51-83, Jan. 1978. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_361">Examples<a class="headerlink" href="#examples_361" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.kaiser(51, beta=14)
plt.plot(window)
plt.title(r'Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nuttall</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window according to Nuttall.</p>
<p>This variation is called 'Nuttall4c' by Heinzel. [2]_</p>
<h2 id="parameters_438">Parameters<a class="headerlink" href="#parameters_438" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_418">Returns<a class="headerlink" href="#returns_418" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_79">References<a class="headerlink" href="#references_79" title="Permanent link">&para;</a></h2>
<p>.. [1] A. Nuttall, 'Some windows with very good sidelobe behavior,' IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. :doi:<code>10.1109/TASSP.1981.1163506</code>.
.. [2] Heinzel G. et al., 'Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows', February 15, 2002
https://holometer.fnal.gov/GH_FFT.pdf</p>
<h2 id="examples_362">Examples<a class="headerlink" href="#examples_362" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.nuttall(51)
plt.plot(window)
plt.title('Nuttall window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Nuttall window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">parzen</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Parzen window.</p>
<h2 id="parameters_439">Parameters<a class="headerlink" href="#parameters_439" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_419">Returns<a class="headerlink" href="#returns_419" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_80">References<a class="headerlink" href="#references_80" title="Permanent link">&para;</a></h2>
<p>.. [1] E. Parzen, 'Mathematical Considerations in the Estimation of
Spectra', Technometrics,  Vol. 3, No. 2 (May, 1961), pp. 167-190</p>
<h2 id="examples_363">Examples<a class="headerlink" href="#examples_363" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.parzen(51)
plt.plot(window)
plt.title('Parzen window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Parzen window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">slepian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a digital Slepian (DPSS) window.</p>
<p>Used to maximize the energy concentration in the main lobe.  Also called
the digital prolate spheroidal sequence (DPSS).</p>
<p>.. note:: Deprecated in SciPy 1.1.
<code>slepian</code> will be removed in a future version of SciPy, it is
replaced by <code>dpss</code>, which uses the standard definition of a
digital Slepian window.</p>
<h2 id="parameters_440">Parameters<a class="headerlink" href="#parameters_440" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
width : float
Bandwidth
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_420">Returns<a class="headerlink" href="#returns_420" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="see-also_302">See Also<a class="headerlink" href="#see-also_302" title="Permanent link">&para;</a></h2>
<p>dpss</p>
<h2 id="references_81">References<a class="headerlink" href="#references_81" title="Permanent link">&para;</a></h2>
<p>.. [1] D. Slepian &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-I,' Bell Syst. Tech. J., vol.40,
pp.43-63, 1961. https://archive.org/details/bstj40-1-43
.. [2] H. J. Landau &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-II,' Bell Syst. Tech. J. , vol.40,
pp.65-83, 1961. https://archive.org/details/bstj40-1-65</p>
<h2 id="examples_364">Examples<a class="headerlink" href="#examples_364" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.slepian(51, width=0.3)
plt.plot(window)
plt.title('Slepian (DPSS) window (BW=0.3)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Slepian window (BW=0.3)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sp_fft</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>==============================================
Discrete Fourier transforms (:mod:<code>scipy.fft</code>)
==============================================</p>
<p>.. currentmodule:: scipy.fft</p>
<h1 id="fast-fourier-transforms-ffts_3">Fast Fourier Transforms (FFTs)<a class="headerlink" href="#fast-fourier-transforms-ffts_3" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fft - Fast (discrete) Fourier Transform (FFT)
ifft - Inverse FFT
fft2 - Two dimensional FFT
ifft2 - Two dimensional inverse FFT
fftn - n-dimensional FFT
ifftn - n-dimensional inverse FFT
rfft - FFT of strictly real-valued sequence
irfft - Inverse of rfft
rfft2 - Two dimensional FFT of real sequence
irfft2 - Inverse of rfft2
rfftn - n-dimensional FFT of real sequence
irfftn - Inverse of rfftn
hfft - FFT of a Hermitian sequence (real spectrum)
ihfft - Inverse of hfft
hfft2 - Two dimensional FFT of a Hermitian sequence
ihfft2 - Inverse of hfft2
hfftn - n-dimensional FFT of a Hermitian sequence
ihfftn - Inverse of hfftn</p>
<h1 id="discrete-sin-and-cosine-transforms-dst-and-dct_3">Discrete Sin and Cosine Transforms (DST and DCT)<a class="headerlink" href="#discrete-sin-and-cosine-transforms-dst-and-dct_3" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>dct - Discrete cosine transform
idct - Inverse discrete cosine transform
dctn - n-dimensional Discrete cosine transform
idctn - n-dimensional Inverse discrete cosine transform
dst - Discrete sine transform
idst - Inverse discrete sine transform
dstn - n-dimensional Discrete sine transform
idstn - n-dimensional Inverse discrete sine transform</p>
<h1 id="helper-functions_3">Helper functions<a class="headerlink" href="#helper-functions_3" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>fftshift - Shift the zero-frequency component to the center of the spectrum
ifftshift - The inverse of <code>fftshift</code>
fftfreq - Return the Discrete Fourier Transform sample frequencies
rfftfreq - DFT sample frequencies (for usage with rfft, irfft)
next_fast_len - Find the optimal length to zero-pad an FFT for speed
set_workers - Context manager to set default number of workers
get_workers - Get the current default number of workers</p>
<h1 id="backend-control_3">Backend control<a class="headerlink" href="#backend-control_3" title="Permanent link">&para;</a></h1>
<p>.. autosummary::
:toctree: generated/</p>
<p>set_backend - Context manager to set the backend within a fixed scope
skip_backend - Context manager to skip a backend within a fixed scope
set_global_backend - Sets the global fft backend
register_backend - Register a backend for permanent use</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triang</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a triangular window.</p>
<h2 id="parameters_441">Parameters<a class="headerlink" href="#parameters_441" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_421">Returns<a class="headerlink" href="#returns_421" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_303">See Also<a class="headerlink" href="#see-also_303" title="Permanent link">&para;</a></h2>
<p>bartlett : A triangular window that touches zero</p>
<h2 id="examples_365">Examples<a class="headerlink" href="#examples_365" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.triang(51)
plt.plot(window)
plt.title('Triangular window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the triangular window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tukey</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Tukey window, also known as a tapered cosine window.</p>
<h2 id="parameters_442">Parameters<a class="headerlink" href="#parameters_442" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
alpha : float, optional
Shape parameter of the Tukey window, representing the fraction of the
window inside the cosine tapered region.
If zero, the Tukey window is equivalent to a rectangular window.
If one, the Tukey window is equivalent to a Hann window.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_422">Returns<a class="headerlink" href="#returns_422" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_82">References<a class="headerlink" href="#references_82" title="Permanent link">&para;</a></h2>
<p>.. [1] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>
.. [2] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function#Tukey_window</p>
<h2 id="examples_366">Examples<a class="headerlink" href="#examples_366" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.tukey(51)
plt.plot(window)
plt.title('Tukey window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')
plt.ylim([0, 1.1])</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Tukey window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">barthann</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a modified Bartlett-Hann window.</p>
<h2 id="parameters_443">Parameters<a class="headerlink" href="#parameters_443" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_423">Returns<a class="headerlink" href="#returns_423" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_367">Examples<a class="headerlink" href="#examples_367" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.barthann(51)
plt.plot(window)
plt.title('Bartlett-Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett-Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bartlett</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<h2 id="parameters_444">Parameters<a class="headerlink" href="#parameters_444" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_424">Returns<a class="headerlink" href="#returns_424" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The triangular window, with the first and last samples equal to zero
and the maximum value normalized to 1 (though the value 1 does not
appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_304">See Also<a class="headerlink" href="#see-also_304" title="Permanent link">&para;</a></h2>
<p>triang : A triangular window that does not touch zero at the ends</p>
<h2 id="notes_289">Notes<a class="headerlink" href="#notes_289" title="Permanent link">&para;</a></h2>
<p>The Bartlett window is defined as</p>
<p>.. math:: w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)</p>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means'removing the foot', i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The Fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich. [2]_</p>
<h2 id="references_83">References<a class="headerlink" href="#references_83" title="Permanent link">&para;</a></h2>
<p>.. [1] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, 'Discrete-Time Signal
Processing', Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 429.</p>
<h2 id="examples_368">Examples<a class="headerlink" href="#examples_368" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bartlett(51)
plt.plot(window)
plt.title('Bartlett window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackman</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three terms of
a summation of cosines. It was designed to have close to the minimal
leakage possible.  It is close to optimal, only slightly worse than a
Kaiser window.</p>
<h2 id="parameters_445">Parameters<a class="headerlink" href="#parameters_445" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_425">Returns<a class="headerlink" href="#returns_425" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_290">Notes<a class="headerlink" href="#notes_290" title="Permanent link">&para;</a></h2>
<p>The Blackman window is defined as</p>
<p>.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)</p>
<p>The 'exact Blackman' window was designed to null out the third and fourth
sidelobes, but has discontinuities at the boundaries, resulting in a
6 dB/oct fall-off.  This window is an approximation of the 'exact' window,
which does not null the sidelobes as well, but is smooth at the edges,
improving the fall-off rate to 18 dB/oct. [3]_</p>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
'near optimal' tapering function, almost as good (by some measures)
as the Kaiser window.</p>
<h2 id="references_84">References<a class="headerlink" href="#references_84" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
.. [3] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_369">Examples<a class="headerlink" href="#examples_369" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackman(51)
plt.plot(window)
plt.title('Blackman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackmanharris</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window.</p>
<h2 id="parameters_446">Parameters<a class="headerlink" href="#parameters_446" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_426">Returns<a class="headerlink" href="#returns_426" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_370">Examples<a class="headerlink" href="#examples_370" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackmanharris(51)
plt.plot(window)
plt.title('Blackman-Harris window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman-Harris window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bohman</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bohman window.</p>
<h2 id="parameters_447">Parameters<a class="headerlink" href="#parameters_447" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_427">Returns<a class="headerlink" href="#returns_427" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_371">Examples<a class="headerlink" href="#examples_371" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bohman(51)
plt.plot(window)
plt.title('Bohman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bohman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcar</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a boxcar or rectangular window.</p>
<p>Also known as a rectangular window or Dirichlet window, this is equivalent
to no window at all.</p>
<h2 id="parameters_448">Parameters<a class="headerlink" href="#parameters_448" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
Whether the window is symmetric. (Has no effect for boxcar.)</p>
<h2 id="returns_428">Returns<a class="headerlink" href="#returns_428" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1.</p>
<h2 id="examples_372">Examples<a class="headerlink" href="#examples_372" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.boxcar(51)
plt.plot(window)
plt.title('Boxcar window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the boxcar window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">at</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Dolph-Chebyshev window.</p>
<h2 id="parameters_449">Parameters<a class="headerlink" href="#parameters_449" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
at : float
Attenuation (in dB).
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_429">Returns<a class="headerlink" href="#returns_429" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="notes_291">Notes<a class="headerlink" href="#notes_291" title="Permanent link">&para;</a></h2>
<p>This window optimizes for the narrowest main lobe width for a given order
<code>M</code> and sidelobe equiripple attenuation <code>at</code>, using Chebyshev
polynomials.  It was originally developed by Dolph to optimize the
directionality of radio antenna arrays.</p>
<p>Unlike most windows, the Dolph-Chebyshev is defined in terms of its
frequency response:</p>
<p>.. math:: W(k) = \frac
{\cos{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]}}
{\cosh[M \cosh^{-1}(\beta)]}</p>
<p>where</p>
<p>.. math:: \beta = \cosh \left [\frac{1}{M}
\cosh^{-1}(10^\frac{A}{20}) \right ]</p>
<p>and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (<code>at</code>).</p>
<p>The time domain window is then generated using the IFFT, so
power-of-two <code>M</code> are the fastest to generate, and prime number <code>M</code> are
the slowest.</p>
<p>The equiripple condition in the frequency domain creates impulses in the
time domain, which appear at the ends of the window.</p>
<h2 id="references_85">References<a class="headerlink" href="#references_85" title="Permanent link">&para;</a></h2>
<p>.. [1] C. Dolph, 'A current distribution for broadside arrays which
optimizes the relationship between beam width and side-lobe level',
Proceedings of the IEEE, Vol. 34, Issue 6
.. [2] Peter Lynch, 'The Dolph-Chebyshev Window: A Simple Optimal Filter',
American Meteorological Society (April 1997)
http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf
.. [3] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transforms', Proceedings of the IEEE, Vol. 66,
No. 1, January 1978</p>
<h2 id="examples_373">Examples<a class="headerlink" href="#examples_373" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.chebwin(51, at=100)
plt.plot(window)
plt.title('Dolph-Chebyshev window (100 dB)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Dolph-Chebyshev window (100 dB)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a simple cosine shape.</p>
<h2 id="parameters_450">Parameters<a class="headerlink" href="#parameters_450" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_430">Returns<a class="headerlink" href="#returns_430" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_292">Notes<a class="headerlink" href="#notes_292" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<h2 id="examples_374">Examples<a class="headerlink" href="#examples_374" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.cosine(51)
plt.plot(window)
plt.title('Cosine window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the cosine window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dpss</span> <span class="o">:</span> <span class="o">?</span><span class="n">kmax</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">T_2</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Optional</span> <span class="k">of</span> <span class="o">[`</span><span class="nc">T_subsample_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Approximate</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_ratios</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">nw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Discrete Prolate Spheroidal Sequences (DPSS).</p>
<p>DPSS (or Slepian sequences) are often used in multitaper power spectral
density estimation (see [1]_). The first window in the sequence can be
used to maximize the energy concentration in the main lobe, and is also
called the Slepian window.</p>
<h2 id="parameters_451">Parameters<a class="headerlink" href="#parameters_451" title="Permanent link">&para;</a></h2>
<p>M : int
Window length.
NW : float
Standardized half bandwidth corresponding to <code>2*NW = BW/f0 = BW*N*dt</code>
where <code>dt</code> is taken as 1.
Kmax : int | None, optional
Number of DPSS windows to return (orders <code>0</code> through <code>Kmax-1</code>).
If None (default), return only a single window of shape <code>(M,)</code>
instead of an array of windows of shape <code>(Kmax, M)</code>.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.
norm : {2, 'approximate', 'subsample'} | None, optional
If 'approximate' or 'subsample', then the windows are normalized by the
maximum, and a correction scale-factor for even-length windows
is applied either using <code>M**2/(M**2+NW)</code> ('approximate') or
a FFT-based subsample shift ('subsample'), see Notes for details.
If None, then 'approximate' is used when <code>Kmax=None</code> and 2 otherwise
(which uses the l2 norm).
return_ratios : bool, optional
If True, also return the concentration ratios in addition to the
windows.</p>
<h2 id="returns_431">Returns<a class="headerlink" href="#returns_431" title="Permanent link">&para;</a></h2>
<p>v : ndarray, shape (Kmax, N) or (N,)
The DPSS windows. Will be 1D if <code>Kmax</code> is None.
r : ndarray, shape (Kmax,) or float, optional
The concentration ratios for the windows. Only returned if
<code>return_ratios</code> evaluates to True. Will be 0D if <code>Kmax</code> is None.</p>
<h2 id="notes_293">Notes<a class="headerlink" href="#notes_293" title="Permanent link">&para;</a></h2>
<p>This computation uses the tridiagonal eigenvector formulation given
in [2]_.</p>
<p>The default normalization for <code>Kmax=None</code>, i.e. window-generation mode,
simply using the l-infinity norm would create a window with two unity
values, which creates slight normalization differences between even and odd
orders. The approximate correction of <code>M**2/float(M**2+NW)</code> for even
sample numbers is used to counteract this effect (see Examples below).</p>
<p>For very long signals (e.g., 1e6 elements), it can be useful to compute
windows orders of magnitude shorter and use interpolation (e.g.,
<code>scipy.interpolate.interp1d</code>) to obtain tapers of length <code>M</code>,
but this in general will not preserve orthogonality between the tapers.</p>
<p>.. versionadded:: 1.1</p>
<h2 id="references_86">References<a class="headerlink" href="#references_86" title="Permanent link">&para;</a></h2>
<p>.. [1] Percival DB, Walden WT. Spectral Analysis for Physical Applications:
Multitaper and Conventional Univariate Techniques.
Cambridge University Press; 1993.
.. [2] Slepian, D. Prolate spheroidal wave functions, Fourier analysis, and
uncertainty V: The discrete case. Bell System Technical Journal,
Volume 57 (1978), 1371430.
.. [3] Kaiser, JF, Schafer RW. On the Use of the I0-Sinh Window for
Spectrum Analysis. IEEE Transactions on Acoustics, Speech and
Signal Processing. ASSP-28 (1): 105-107; 1980.</p>
<h2 id="examples_375">Examples<a class="headerlink" href="#examples_375" title="Permanent link">&para;</a></h2>
<p>We can compare the window to <code>kaiser</code>, which was invented as an alternative
that was easier to calculate [3]<em> (example adapted from
<code>here &lt;https://ccrma.stanford.edu/~jos/sasp/Kaiser_DPSS_Windows_Compared.html&gt;</code></em>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import windows, freqz
N = 51
fig, axes = plt.subplots(3, 2, figsize=(5, 7))
for ai, alpha in enumerate((1, 3, 5)):
...     win_dpss = windows.dpss(N, alpha)
...     beta = alpha*np.pi
...     win_kaiser = windows.kaiser(N, beta)
...     for win, c in ((win_dpss, 'k'), (win_kaiser, 'r')):
...         win /= win.sum()
...         axes[ai, 0].plot(win, color=c, lw=1.)
...         axes[ai, 0].set(xlim=[0, N-1], title=r'<span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> = %s' % alpha,
...                         ylabel='Amplitude')
...         w, h = freqz(win)
...         axes[ai, 1].plot(w, 20 * np.log10(np.abs(h)), color=c, lw=1.)
...         axes[ai, 1].set(xlim=[0, np.pi],
...                         title=r'<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> = %0.2f' % beta,
...                         ylabel='Magnitude (dB)')
for ax in axes.ravel():
...     ax.grid(True)
axes[2, 1].legend(['DPSS', 'Kaiser'])
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>And here are examples of the first four windows, along with their
concentration ratios:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = 512
NW = 2.5
win, eigvals = windows.dpss(M, NW, 4, return_ratios=True)
fig, ax = plt.subplots(1)
ax.plot(win.T, linewidth=1.)
ax.set(xlim=[0, M-1], ylim=[-0.1, 0.1], xlabel='Samples',
...        title='DPSS, M=%d, NW=%0.1f' % (M, NW))
ax.legend(['win[%d] (%0.4f)' % (ii, ratio)
...            for ii, ratio in enumerate(eigvals)])
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using a standard :math:<code>l_{\infty}</code> norm would produce two unity values
for even <code>M</code>, but only one unity value for odd <code>M</code>. This produces uneven
window power that can be counteracted by the approximate correction
<code>M**2/float(M**2+NW)</code>, which can be selected by using
<code>norm='approximate'</code> (which is the same as <code>norm=None</code> when
<code>Kmax=None</code>, as is the case here). Alternatively, the slower
<code>norm='subsample'</code> can be used, which uses subsample shifting in the
frequency domain (FFT) to compute the correction:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Ms = np.arange(1, 41)
factors = (50, 20, 10, 5, 2.0001)
energy = np.empty((3, len(Ms), len(factors)))
for mi, M in enumerate(Ms):
...     for fi, factor in enumerate(factors):
...         NW = M / float(factor)
...         # Corrected using empirical approximation (default)
...         win = windows.dpss(M, NW)
...         energy[0, mi, fi] = np.sum(win <strong> 2) / np.sqrt(M)
...         # Corrected using subsample shifting
...         win = windows.dpss(M, NW, norm='subsample')
...         energy[1, mi, fi] = np.sum(win </strong> 2) / np.sqrt(M)
...         # Uncorrected (using l-infinity norm)
...         win /= win.max()
...         energy[2, mi, fi] = np.sum(win ** 2) / np.sqrt(M)
fig, ax = plt.subplots(1)
hs = ax.plot(Ms, energy[2], '-o', markersize=4,
...              markeredgecolor='none')
leg = [hs[-1]]
for hi, hh in enumerate(hs):
...     h1 = ax.plot(Ms, energy[0, :, hi], '-o', markersize=4,
...                  color=hh.get_color(), markeredgecolor='none',
...                  alpha=0.66)
...     h2 = ax.plot(Ms, energy[1, :, hi], '-o', markersize=4,
...                  color=hh.get_color(), markeredgecolor='none',
...                  alpha=0.33)
...     if hi == len(hs) - 1:
...         leg.insert(0, h1[0])
...         leg.insert(0, h2[0])
ax.set(xlabel='M (samples)', ylabel=r'Power / <span><span class="MathJax_Preview">\sqrt{M}</span><script type="math/tex">\sqrt{M}</script></span>')
ax.legend(leg, ['Uncorrected', r'Corrected: <span><span class="MathJax_Preview">\frac{M^2}{M^2+NW}</span><script type="math/tex">\frac{M^2}{M^2+NW}</script></span>',
...                 'Corrected (subsample)'])
fig.tight_layout()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exponential</span> <span class="o">:</span> <span class="o">?</span><span class="n">center</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tau</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an exponential (or Poisson) window.</p>
<h2 id="parameters_452">Parameters<a class="headerlink" href="#parameters_452" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
center : float, optional
Parameter defining the center location of the window function.
The default value if not given is <code>center = (M-1) / 2</code>.  This
parameter must take its default value for symmetric windows.
tau : float, optional
Parameter defining the decay.  For <code>center = 0</code> use
<code>tau = -(M-1) / ln(x)</code> if <code>x</code> is the fraction of the window
remaining at the end.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_432">Returns<a class="headerlink" href="#returns_432" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_294">Notes<a class="headerlink" href="#notes_294" title="Permanent link">&para;</a></h2>
<p>The Exponential window is defined as</p>
<p>.. math::  w(n) = e^{-|n-center| / \tau}</p>
<h2 id="references_87">References<a class="headerlink" href="#references_87" title="Permanent link">&para;</a></h2>
<p>S. Gade and H. Herlufsen, 'Windows to FFT analysis (Part I)',
Technical Review 3, Bruel &amp; Kjaer, 1987.</p>
<h2 id="examples_376">Examples<a class="headerlink" href="#examples_376" title="Permanent link">&para;</a></h2>
<p>Plot the symmetric window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>M = 51
tau = 3.0
window = signal.exponential(M, tau=tau)
plt.plot(window)
plt.title('Exponential Window (tau=3.0)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -35, 0])
plt.title('Frequency response of the Exponential window (tau=3.0)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function can also generate non-symmetric windows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>tau2 = -(M-1) / np.log(0.01)
window2 = signal.exponential(M, 0, tau2, False)
plt.figure()
plt.plot(window2)
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flattop</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flat top window.</p>
<h2 id="parameters_453">Parameters<a class="headerlink" href="#parameters_453" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_433">Returns<a class="headerlink" href="#returns_433" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_295">Notes<a class="headerlink" href="#notes_295" title="Permanent link">&para;</a></h2>
<p>Flat top windows are used for taking accurate measurements of signal
amplitude in the frequency domain, with minimal scalloping error from the
center of a frequency bin to its edges, compared to others.  This is a
5th-order cosine window, with the 5 terms optimized to make the main lobe
maximally flat. [1]_</p>
<h2 id="references_88">References<a class="headerlink" href="#references_88" title="Permanent link">&para;</a></h2>
<p>.. [1] D'Antona, Gabriele, and A. Ferrero, 'Digital Signal Processing for
Measurement Systems', Springer Media, 2006, p. 70
:doi:<code>10.1007/0-387-28666-7</code>.</p>
<h2 id="examples_377">Examples<a class="headerlink" href="#examples_377" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.flattop(51)
plt.plot(window)
plt.title('Flat top window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the flat top window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Gaussian window.</p>
<h2 id="parameters_454">Parameters<a class="headerlink" href="#parameters_454" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
std : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_434">Returns<a class="headerlink" href="#returns_434" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_296">Notes<a class="headerlink" href="#notes_296" title="Permanent link">&para;</a></h2>
<p>The Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 }</p>
<h2 id="examples_378">Examples<a class="headerlink" href="#examples_378" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.gaussian(51, std=7)
plt.plot(window)
plt.title(r'Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generic weighted sum of cosine terms window</p>
<h2 id="parameters_455">Parameters<a class="headerlink" href="#parameters_455" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window
a : array_like
Sequence of weighting coefficients. This uses the convention of being
centered on the origin, so these will typically all be positive
numbers, not alternating sign.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="references_89">References<a class="headerlink" href="#references_89" title="Permanent link">&para;</a></h2>
<p>.. [1] A. Nuttall, 'Some windows with very good sidelobe behavior,' IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. :doi:<code>10.1109/TASSP.1981.1163506</code>.
.. [2] Heinzel G. et al., 'Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows', February 15, 2002
https://holometer.fnal.gov/GH_FFT.pdf</p>
<h2 id="examples_379">Examples<a class="headerlink" href="#examples_379" title="Permanent link">&para;</a></h2>
<p>Heinzel describes a flat-top window named 'HFT90D' with formula: [2]_</p>
<p>.. math::  w_j = 1 - 1.942604 \cos(z) + 1.340318 \cos(2z)
- 0.440811 \cos(3z) + 0.043097 \cos(4z)</p>
<p>where</p>
<p>.. math::  z = \frac{2 \pi j}{N}, j = 0...N - 1</p>
<p>Since this uses the convention of starting at the origin, to reproduce the
window, we need to convert every other coefficient to a positive number:</p>
<blockquote>
<blockquote>
<blockquote>
<p>HFT90D = [1, 1.942604, 1.340318, 0.440811, 0.043097]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The paper states that the highest sidelobe is at -90.2 dB.  Reproduce
Figure 42 by plotting the window and its frequency response, and confirm
the sidelobe level in red:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal.windows import general_cosine
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = general_cosine(1000, HFT90D, sym=False)
plt.plot(window)
plt.title('HFT90D window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 10000) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-50/1000, 50/1000, -140, 0])
plt.title('Frequency response of the HFT90D window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')
plt.axhline(-90.2, color='red')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">sig_</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a generalized Gaussian shape.</p>
<h2 id="parameters_456">Parameters<a class="headerlink" href="#parameters_456" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
p : float
Shape parameter.  p = 1 is identical to <code>gaussian</code>, p = 0.5 is
the same shape as the Laplace distribution.
sig : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_435">Returns<a class="headerlink" href="#returns_435" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_297">Notes<a class="headerlink" href="#notes_297" title="Permanent link">&para;</a></h2>
<p>The generalized Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} }</p>
<p>the half-power point is at</p>
<p>.. math::  (2 \log(2))^{1/(2 p)} \sigma</p>
<h2 id="examples_380">Examples<a class="headerlink" href="#examples_380" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.general_gaussian(51, p=1.5, sig=7)
plt.plot(window)
plt.title(r'Generalized Gaussian window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Freq. resp. of the gen. Gaussian '
...           r'window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a generalized Hamming window.</p>
<p>The generalized Hamming window is constructed by multiplying a rectangular
window by one period of a cosine function [1]_.</p>
<h2 id="parameters_457">Parameters<a class="headerlink" href="#parameters_457" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
alpha : float
The window coefficient, :math:<code>\alpha</code>
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_436">Returns<a class="headerlink" href="#returns_436" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_298">Notes<a class="headerlink" href="#notes_298" title="Permanent link">&para;</a></h2>
<p>The generalized Hamming window is defined as</p>
<p>.. math:: w(n) = \alpha - \left(1 - \alpha\right) \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>Both the common Hamming window and Hann window are special cases of the
generalized Hamming window with :math:<code>\alpha</code> = 0.54 and :math:<code>\alpha</code> =
0.5, respectively [2]_.</p>
<h2 id="see-also_305">See Also<a class="headerlink" href="#see-also_305" title="Permanent link">&para;</a></h2>
<p>hamming, hann</p>
<h2 id="examples_381">Examples<a class="headerlink" href="#examples_381" title="Permanent link">&para;</a></h2>
<p>The Sentinel-1A/B Instrument Processing Facility uses generalized Hamming
windows in the processing of spaceborne Synthetic Aperture Radar (SAR)
data [3]<em>. The facility uses various values for the :math:<code>\alpha</code>
parameter based on operating mode of the SAR instrument. Some common
:math:<code>\alpha</code> values include 0.75, 0.7 and 0.52 [4]</em>. As an example, we
plot these different windows.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal.windows import general_hamming
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>fig1, spatial_plot = plt.subplots()
spatial_plot.set_title('Generalized Hamming Windows')
spatial_plot.set_ylabel('Amplitude')
spatial_plot.set_xlabel('Sample')</p>
<p>fig2, freq_plot = plt.subplots()
freq_plot.set_title('Frequency Responses')
freq_plot.set_ylabel('Normalized magnitude [dB]')
freq_plot.set_xlabel('Normalized frequency [cycles per sample]')</p>
<p>for alpha in [0.75, 0.7, 0.52]:
...     window = general_hamming(41, alpha)
...     spatial_plot.plot(window, label='{:.2f}'.format(alpha))
...     A = fft(window, 2048) / (len(window)/2.0)
...     freq = np.linspace(-0.5, 0.5, len(A))
...     response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
...     freq_plot.plot(freq, response, label='{:.2f}'.format(alpha))
freq_plot.legend(loc='upper right')
spatial_plot.legend(loc='upper right')</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_90">References<a class="headerlink" href="#references_90" title="Permanent link">&para;</a></h2>
<p>.. [1] DSPRelated, 'Generalized Hamming Window Family',
https://www.dsprelated.com/freebooks/sasp/Generalized_Hamming_Window_Family.html
.. [2] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [3] Riccardo Piantanida ESA, 'Sentinel-1 Level 1 Detailed Algorithm
Definition',
https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Level-1-Detailed-Algorithm-Definition
.. [4] Matthieu Bourbigot ESA, 'Sentinel-1 Product Definition',
https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Product-Definition</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_window</span> <span class="o">:</span> <span class="o">?</span><span class="n">fftbins</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window of a given length and type.</p>
<h2 id="parameters_458">Parameters<a class="headerlink" href="#parameters_458" title="Permanent link">&para;</a></h2>
<p>window : string, float, or tuple
The type of window to create. See below for more details.
Nx : int
The number of samples in the window.
fftbins : bool, optional
If True (default), create a 'periodic' window, ready to use with
<code>ifftshift</code> and be multiplied by the result of an FFT (see also
:func:<code>~scipy.fft.fftfreq</code>).
If False, create a 'symmetric' window, for use in filter design.</p>
<h2 id="returns_437">Returns<a class="headerlink" href="#returns_437" title="Permanent link">&para;</a></h2>
<p>get_window : ndarray
Returns a window of length <code>Nx</code> and type <code>window</code></p>
<h2 id="notes_299">Notes<a class="headerlink" href="#notes_299" title="Permanent link">&para;</a></h2>
<p>Window types:</p>
<ul>
<li><code>~scipy.signal.windows.boxcar</code></li>
<li><code>~scipy.signal.windows.triang</code></li>
<li><code>~scipy.signal.windows.blackman</code></li>
<li><code>~scipy.signal.windows.hamming</code></li>
<li><code>~scipy.signal.windows.hann</code></li>
<li><code>~scipy.signal.windows.bartlett</code></li>
<li><code>~scipy.signal.windows.flattop</code></li>
<li><code>~scipy.signal.windows.parzen</code></li>
<li><code>~scipy.signal.windows.bohman</code></li>
<li><code>~scipy.signal.windows.blackmanharris</code></li>
<li><code>~scipy.signal.windows.nuttall</code></li>
<li><code>~scipy.signal.windows.barthann</code></li>
<li><code>~scipy.signal.windows.kaiser</code> (needs beta)</li>
<li><code>~scipy.signal.windows.gaussian</code> (needs standard deviation)</li>
<li><code>~scipy.signal.windows.general_gaussian</code> (needs power, width)</li>
<li><code>~scipy.signal.windows.slepian</code> (needs width)</li>
<li><code>~scipy.signal.windows.dpss</code> (needs normalized half-bandwidth)</li>
<li><code>~scipy.signal.windows.chebwin</code> (needs attenuation)</li>
<li><code>~scipy.signal.windows.exponential</code> (needs decay scale)</li>
<li><code>~scipy.signal.windows.tukey</code> (needs taper fraction)</li>
</ul>
<p>If the window requires no parameters, then <code>window</code> can be a string.</p>
<p>If the window requires parameters, then <code>window</code> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <code>window</code> is a floating point number, it is interpreted as the beta
parameter of the <code>~scipy.signal.windows.kaiser</code> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<h2 id="examples_382">Examples<a class="headerlink" href="#examples_382" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.get_window('triang', 7)
array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])
signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])
signal.get_window(4.0, 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hamming window.</p>
<p>The Hamming window is a taper formed by using a raised cosine with
non-zero endpoints, optimized to minimize the nearest side lobe.</p>
<h2 id="parameters_459">Parameters<a class="headerlink" href="#parameters_459" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_438">Returns<a class="headerlink" href="#returns_438" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_300">Notes<a class="headerlink" href="#notes_300" title="Permanent link">&para;</a></h2>
<p>The Hamming window is defined as</p>
<p>.. math::  w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_91">References<a class="headerlink" href="#references_91" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_383">Examples<a class="headerlink" href="#examples_383" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hamming(51)
plt.plot(window)
plt.title('Hamming window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hamming window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hann</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hann window.</p>
<p>The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.</p>
<h2 id="parameters_460">Parameters<a class="headerlink" href="#parameters_460" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_439">Returns<a class="headerlink" href="#returns_439" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_301">Notes<a class="headerlink" href="#notes_301" title="Permanent link">&para;</a></h2>
<p>The Hann window is defined as</p>
<p>.. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The window was named for Julius von Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the 'Hanning' window, from the use of 'hann' as a verb in the original
paper and confusion with the very similar Hamming window.</p>
<p>Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_92">References<a class="headerlink" href="#references_92" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_384">Examples<a class="headerlink" href="#examples_384" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hann(51)
plt.plot(window)
plt.title('Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hanning</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>hanning</code> is deprecated, use <code>scipy.signal.windows.hann</code> instead!</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">beta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<h2 id="parameters_461">Parameters<a class="headerlink" href="#parameters_461" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
beta : float
Shape parameter, determines trade-off between main-lobe width and
side lobe level. As beta gets large, the window narrows.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_440">Returns<a class="headerlink" href="#returns_440" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_302">Notes<a class="headerlink" href="#notes_302" title="Permanent link">&para;</a></h2>
<p>The Kaiser window is defined as</p>
<p>.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)</p>
<p>with</p>
<p>.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},</p>
<p>where :math:<code>I_0</code> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.</p>
<p>The Kaiser can approximate other windows by varying the beta parameter.
(Some literature uses alpha = beta/pi.) [4]_</p>
<p>====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hann
8.6   Similar to a Blackman
====  =======================</p>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
be returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_93">References<a class="headerlink" href="#references_93" title="Permanent link">&para;</a></h2>
<p>.. [1] J. F. Kaiser, 'Digital Filters' - Ch 7 in 'Systems analysis by
digital computer', Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transform,' Proceedings of the IEEE, vol. 66,
no. 1, pp. 51-83, Jan. 1978. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_385">Examples<a class="headerlink" href="#examples_385" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.kaiser(51, beta=14)
plt.plot(window)
plt.title(r'Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nuttall</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window according to Nuttall.</p>
<p>This variation is called 'Nuttall4c' by Heinzel. [2]_</p>
<h2 id="parameters_462">Parameters<a class="headerlink" href="#parameters_462" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_441">Returns<a class="headerlink" href="#returns_441" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_94">References<a class="headerlink" href="#references_94" title="Permanent link">&para;</a></h2>
<p>.. [1] A. Nuttall, 'Some windows with very good sidelobe behavior,' IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. :doi:<code>10.1109/TASSP.1981.1163506</code>.
.. [2] Heinzel G. et al., 'Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows', February 15, 2002
https://holometer.fnal.gov/GH_FFT.pdf</p>
<h2 id="examples_386">Examples<a class="headerlink" href="#examples_386" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.nuttall(51)
plt.plot(window)
plt.title('Nuttall window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Nuttall window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">parzen</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Parzen window.</p>
<h2 id="parameters_463">Parameters<a class="headerlink" href="#parameters_463" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_442">Returns<a class="headerlink" href="#returns_442" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_95">References<a class="headerlink" href="#references_95" title="Permanent link">&para;</a></h2>
<p>.. [1] E. Parzen, 'Mathematical Considerations in the Estimation of
Spectra', Technometrics,  Vol. 3, No. 2 (May, 1961), pp. 167-190</p>
<h2 id="examples_387">Examples<a class="headerlink" href="#examples_387" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.parzen(51)
plt.plot(window)
plt.title('Parzen window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Parzen window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">slepian</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a digital Slepian (DPSS) window.</p>
<p>Used to maximize the energy concentration in the main lobe.  Also called
the digital prolate spheroidal sequence (DPSS).</p>
<p>.. note:: Deprecated in SciPy 1.1.
<code>slepian</code> will be removed in a future version of SciPy, it is
replaced by <code>dpss</code>, which uses the standard definition of a
digital Slepian window.</p>
<h2 id="parameters_464">Parameters<a class="headerlink" href="#parameters_464" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
width : float
Bandwidth
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_443">Returns<a class="headerlink" href="#returns_443" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="see-also_306">See Also<a class="headerlink" href="#see-also_306" title="Permanent link">&para;</a></h2>
<p>dpss</p>
<h2 id="references_96">References<a class="headerlink" href="#references_96" title="Permanent link">&para;</a></h2>
<p>.. [1] D. Slepian &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-I,' Bell Syst. Tech. J., vol.40,
pp.43-63, 1961. https://archive.org/details/bstj40-1-43
.. [2] H. J. Landau &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-II,' Bell Syst. Tech. J. , vol.40,
pp.65-83, 1961. https://archive.org/details/bstj40-1-65</p>
<h2 id="examples_388">Examples<a class="headerlink" href="#examples_388" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.slepian(51, width=0.3)
plt.plot(window)
plt.title('Slepian (DPSS) window (BW=0.3)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Slepian window (BW=0.3)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triang</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a triangular window.</p>
<h2 id="parameters_465">Parameters<a class="headerlink" href="#parameters_465" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_444">Returns<a class="headerlink" href="#returns_444" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_307">See Also<a class="headerlink" href="#see-also_307" title="Permanent link">&para;</a></h2>
<p>bartlett : A triangular window that touches zero</p>
<h2 id="examples_389">Examples<a class="headerlink" href="#examples_389" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.triang(51)
plt.plot(window)
plt.title('Triangular window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the triangular window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tukey</span> <span class="o">:</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sym</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Tukey window, also known as a tapered cosine window.</p>
<h2 id="parameters_466">Parameters<a class="headerlink" href="#parameters_466" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
alpha : float, optional
Shape parameter of the Tukey window, representing the fraction of the
window inside the cosine tapered region.
If zero, the Tukey window is equivalent to a rectangular window.
If one, the Tukey window is equivalent to a Hann window.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_445">Returns<a class="headerlink" href="#returns_445" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_97">References<a class="headerlink" href="#references_97" title="Permanent link">&para;</a></h2>
<p>.. [1] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>
.. [2] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function#Tukey_window</p>
<h2 id="examples_390">Examples<a class="headerlink" href="#examples_390" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.tukey(51)
plt.plot(window)
plt.title('Tukey window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')
plt.ylim([0, 1.1])</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Tukey window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">abcd_normalize</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">c</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">d</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Check state-space matrices and ensure they are two-dimensional.</p>
<p>If enough information on the system is provided, that is, enough
properly-shaped arrays are passed to the function, the missing ones
are built from this information, ensuring the correct number of
rows and columns. Otherwise a ValueError is raised.</p>
<h2 id="parameters_467">Parameters<a class="headerlink" href="#parameters_467" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array_like, optional
State-space matrices. All of them are None (missing) by default.
See <code>ss2tf</code> for format.</p>
<h2 id="returns_446">Returns<a class="headerlink" href="#returns_446" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : array
Properly shaped state-space matrices.</p>
<h2 id="raises_78">Raises<a class="headerlink" href="#raises_78" title="Permanent link">&para;</a></h2>
<p>ValueError
If not enough information on the system was provided.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argrelextrema</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">comparator</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the relative extrema of <code>data</code>.</p>
<h2 id="parameters_468">Parameters<a class="headerlink" href="#parameters_468" title="Permanent link">&para;</a></h2>
<p>data : ndarray
Array in which to find the relative extrema.
comparator : callable
Function to use to compare two data points.
Should take two arrays as arguments.
axis : int, optional
Axis over which to select from <code>data</code>.  Default is 0.
order : int, optional
How many points on each side to use for the comparison
to consider <code>comparator(n, n+x)</code> to be True.
mode : str, optional
How the edges of the vector are treated.  'wrap' (wrap around) or
'clip' (treat overflow as the same as the last (or first) element).
Default is 'clip'.  See <code>numpy.take</code>.</p>
<h2 id="returns_447">Returns<a class="headerlink" href="#returns_447" title="Permanent link">&para;</a></h2>
<p>extrema : tuple of ndarrays
Indices of the maxima in arrays of integers.  <code>extrema[k]</code> is
the array of indices of axis <code>k</code> of <code>data</code>.  Note that the
return value is a tuple even when <code>data</code> is one-dimensional.</p>
<h2 id="see-also_308">See Also<a class="headerlink" href="#see-also_308" title="Permanent link">&para;</a></h2>
<p>argrelmin, argrelmax</p>
<h2 id="notes_303">Notes<a class="headerlink" href="#notes_303" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_391">Examples<a class="headerlink" href="#examples_391" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import argrelextrema
x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
argrelextrema(x, np.greater)
(array([3, 6]),)
y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
argrelextrema(y, np.less, axis=1)
(array([0, 2]), array([2, 1]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argrelmax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the relative maxima of <code>data</code>.</p>
<h2 id="parameters_469">Parameters<a class="headerlink" href="#parameters_469" title="Permanent link">&para;</a></h2>
<p>data : ndarray
Array in which to find the relative maxima.
axis : int, optional
Axis over which to select from <code>data</code>.  Default is 0.
order : int, optional
How many points on each side to use for the comparison
to consider <code>comparator(n, n+x)</code> to be True.
mode : str, optional
How the edges of the vector are treated.
Available options are 'wrap' (wrap around) or 'clip' (treat overflow
as the same as the last (or first) element).
Default 'clip'.  See <code>numpy.take</code>.</p>
<h2 id="returns_448">Returns<a class="headerlink" href="#returns_448" title="Permanent link">&para;</a></h2>
<p>extrema : tuple of ndarrays
Indices of the maxima in arrays of integers.  <code>extrema[k]</code> is
the array of indices of axis <code>k</code> of <code>data</code>.  Note that the
return value is a tuple even when <code>data</code> is one-dimensional.</p>
<h2 id="see-also_309">See Also<a class="headerlink" href="#see-also_309" title="Permanent link">&para;</a></h2>
<p>argrelextrema, argrelmin, find_peaks</p>
<h2 id="notes_304">Notes<a class="headerlink" href="#notes_304" title="Permanent link">&para;</a></h2>
<p>This function uses <code>argrelextrema</code> with np.greater as comparator. Therefore
it  requires a strict inequality on both sides of a value to consider it a
maximum. This means flat maxima (more than one sample wide) are not detected.
In case of one-dimensional <code>data</code> <code>find_peaks</code> can be used to detect all
local maxima, including flat ones.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_392">Examples<a class="headerlink" href="#examples_392" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import argrelmax
x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
argrelmax(x)
(array([3, 6]),)
y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
argrelmax(y, axis=1)
(array([0]), array([1]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argrelmin</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the relative minima of <code>data</code>.</p>
<h2 id="parameters_470">Parameters<a class="headerlink" href="#parameters_470" title="Permanent link">&para;</a></h2>
<p>data : ndarray
Array in which to find the relative minima.
axis : int, optional
Axis over which to select from <code>data</code>.  Default is 0.
order : int, optional
How many points on each side to use for the comparison
to consider <code>comparator(n, n+x)</code> to be True.
mode : str, optional
How the edges of the vector are treated.
Available options are 'wrap' (wrap around) or 'clip' (treat overflow
as the same as the last (or first) element).
Default 'clip'. See numpy.take</p>
<h2 id="returns_449">Returns<a class="headerlink" href="#returns_449" title="Permanent link">&para;</a></h2>
<p>extrema : tuple of ndarrays
Indices of the minima in arrays of integers.  <code>extrema[k]</code> is
the array of indices of axis <code>k</code> of <code>data</code>.  Note that the
return value is a tuple even when <code>data</code> is one-dimensional.</p>
<h2 id="see-also_310">See Also<a class="headerlink" href="#see-also_310" title="Permanent link">&para;</a></h2>
<p>argrelextrema, argrelmax, find_peaks</p>
<h2 id="notes_305">Notes<a class="headerlink" href="#notes_305" title="Permanent link">&para;</a></h2>
<p>This function uses <code>argrelextrema</code> with np.less as comparator. Therefore it
requires a strict inequality on both sides of a value to consider it a
minimum. This means flat minima (more than one sample wide) are not detected.
In case of one-dimensional <code>data</code> <code>find_peaks</code> can be used to detect all
local minima, including flat ones, by calling it with negated <code>data</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_393">Examples<a class="headerlink" href="#examples_393" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import argrelmin
x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
argrelmin(x)
(array([1, 5]),)
y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
argrelmin(y, axis=1)
(array([0, 2]), array([2, 1]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">band_stop_obj</span> <span class="o">:</span> <span class="n">wp</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">ind</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">passb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">stopb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">type_</span><span class="o">:[`</span><span class="nc">Butter</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Cheby</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ellip</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Band Stop Objective Function for order minimization.</p>
<p>Returns the non-integer order for an analog band stop filter.</p>
<h2 id="parameters_471">Parameters<a class="headerlink" href="#parameters_471" title="Permanent link">&para;</a></h2>
<p>wp : scalar
Edge of passband <code>passb</code>.
ind : int, {0, 1}
Index specifying which <code>passb</code> edge to vary (0 or 1).
passb : ndarray
Two element sequence of fixed passband edges.
stopb : ndarray
Two element sequence of fixed stopband edges.
gstop : float
Amount of attenuation in stopband in dB.
gpass : float
Amount of ripple in the passband in dB.
type : {'butter', 'cheby', 'ellip'}
Type of filter.</p>
<h2 id="returns_450">Returns<a class="headerlink" href="#returns_450" title="Permanent link">&para;</a></h2>
<p>n : scalar
Filter order (possibly non-integer).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">barthann</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a modified Bartlett-Hann window.</p>
<p>.. warning:: scipy.signal.barthann is deprecated,
use scipy.signal.windows.barthann instead.</p>
<h2 id="parameters_472">Parameters<a class="headerlink" href="#parameters_472" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_451">Returns<a class="headerlink" href="#returns_451" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_394">Examples<a class="headerlink" href="#examples_394" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.barthann(51)
plt.plot(window)
plt.title('Bartlett-Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett-Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bartlett</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<p>.. warning:: scipy.signal.bartlett is deprecated,
use scipy.signal.windows.bartlett instead.</p>
<h2 id="parameters_473">Parameters<a class="headerlink" href="#parameters_473" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_452">Returns<a class="headerlink" href="#returns_452" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The triangular window, with the first and last samples equal to zero
and the maximum value normalized to 1 (though the value 1 does not
appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_311">See Also<a class="headerlink" href="#see-also_311" title="Permanent link">&para;</a></h2>
<p>triang : A triangular window that does not touch zero at the ends</p>
<h2 id="notes_306">Notes<a class="headerlink" href="#notes_306" title="Permanent link">&para;</a></h2>
<p>The Bartlett window is defined as</p>
<p>.. math:: w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)</p>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means'removing the foot', i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The Fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich. [2]_</p>
<h2 id="references_98">References<a class="headerlink" href="#references_98" title="Permanent link">&para;</a></h2>
<p>.. [1] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, 'Discrete-Time Signal
Processing', Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 429.</p>
<h2 id="examples_395">Examples<a class="headerlink" href="#examples_395" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bartlett(51)
plt.plot(window)
plt.title('Bartlett window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bartlett window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bessel</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">Phase</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Delay</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mag</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Bessel/Thomson digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Bessel filter and return the
filter coefficients.</p>
<h2 id="parameters_474">Parameters<a class="headerlink" href="#parameters_474" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies (defined
by the <code>norm</code> parameter).
For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.  (See Notes.)
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba'.
norm : {'phase', 'delay', 'mag'}, optional
Critical frequency normalization:</p>
<p><code>phase</code>
The filter is normalized such that the phase response reaches its
midpoint at angular (e.g. rad/s) frequency <code>Wn</code>.  This happens for
both low-pass and high-pass filters, so this is the
'phase-matched' case.</p>
<p>The magnitude response asymptotes are the same as a Butterworth
filter of the same order with a cutoff of <code>Wn</code>.</p>
<p>This is the default, and matches MATLAB's implementation.</p>
<p><code>delay</code>
The filter is normalized such that the group delay in the passband
is 1/<code>Wn</code> (e.g. seconds).  This is the 'natural' type obtained by
solving Bessel polynomials.</p>
<p><code>mag</code>
The filter is normalized such that the gain magnitude is -3 dB at
angular frequency <code>Wn</code>.</p>
<p>.. versionadded:: 0.18.0
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_453">Returns<a class="headerlink" href="#returns_453" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="notes_307">Notes<a class="headerlink" href="#notes_307" title="Permanent link">&para;</a></h2>
<p>Also known as a Thomson filter, the analog Bessel filter has maximally
flat group delay and maximally linear phase response, with very little
ringing in the step response. [1]_</p>
<p>The Bessel is inherently an analog filter.  This function generates digital
Bessel filters using the bilinear transform, which does not preserve the
phase response of the analog filter.  As such, it is only approximately
correct at frequencies below about fs/4.  To get maximally-flat group
delay at higher frequencies, the analog Bessel filter must be transformed
using phase-preserving techniques.</p>
<p>See <code>besselap</code> for implementation details and references.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_396">Examples<a class="headerlink" href="#examples_396" title="Permanent link">&para;</a></h2>
<p>Plot the phase-normalized frequency response, showing the relationship
to the Butterworth's cutoff frequency (green):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.butter(4, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')
b, a = signal.bessel(4, 100, 'low', analog=True, norm='phase')
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)))
plt.title('Bessel filter magnitude response (with Butterworth)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green')  # cutoff frequency
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>and the phase midpoint:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.semilogx(w, np.unwrap(np.angle(h)))
plt.axvline(100, color='green')  # cutoff frequency
plt.axhline(-np.pi, color='red')  # phase midpoint
plt.title('Bessel filter phase response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Phase [radians]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the magnitude-normalized frequency response, showing the -3 dB cutoff:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.bessel(3, 10, 'low', analog=True, norm='mag')
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(np.abs(h)))
plt.axhline(-3, color='red')  # -3 dB magnitude
plt.axvline(10, color='green')  # cutoff frequency
plt.title('Magnitude-normalized Bessel filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the delay-normalized filter, showing the maximally-flat group delay
at 0.1 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.bessel(5, 1/0.1, 'low', analog=True, norm='delay')
w, h = signal.freqs(b, a)
plt.figure()
plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))
plt.axhline(0.1, color='red')  # 0.1 seconds group delay
plt.title('Bessel filter group delay')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Group delay [seconds]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_99">References<a class="headerlink" href="#references_99" title="Permanent link">&para;</a></h2>
<p>.. [1] Thomson, W.E., 'Delay Networks having Maximally Flat Frequency
Characteristics', Proceedings of the Institution of Electrical
Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">besselap</span> <span class="o">:</span> <span class="o">?</span><span class="n">norm</span><span class="o">:[`</span><span class="nc">Phase</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Delay</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mag</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return (z,p,k) for analog prototype of an Nth-order Bessel filter.</p>
<h2 id="parameters_475">Parameters<a class="headerlink" href="#parameters_475" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
norm : {'phase', 'delay', 'mag'}, optional
Frequency normalization:</p>
<p><code>phase</code>
The filter is normalized such that the phase response reaches its
midpoint at an angular (e.g. rad/s) cutoff frequency of 1.  This
happens for both low-pass and high-pass filters, so this is the
'phase-matched' case. [6]_</p>
<p>The magnitude response asymptotes are the same as a Butterworth
filter of the same order with a cutoff of <code>Wn</code>.</p>
<p>This is the default, and matches MATLAB's implementation.</p>
<p><code>delay</code>
The filter is normalized such that the group delay in the passband
is 1 (e.g. 1 second).  This is the 'natural' type obtained by
solving Bessel polynomials</p>
<p><code>mag</code>
The filter is normalized such that the gain magnitude is -3 dB at
angular frequency 1.  This is called 'frequency normalization' by
Bond. [1]_</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_454">Returns<a class="headerlink" href="#returns_454" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function. Is always an empty array.
p : ndarray
Poles of the transfer function.
k : scalar
Gain of the transfer function.  For phase-normalized, this is always 1.</p>
<h2 id="see-also_312">See Also<a class="headerlink" href="#see-also_312" title="Permanent link">&para;</a></h2>
<p>bessel : Filter design function using this prototype</p>
<h2 id="notes_308">Notes<a class="headerlink" href="#notes_308" title="Permanent link">&para;</a></h2>
<p>To find the pole locations, approximate starting points are generated [2]<em>
for the zeros of the ordinary Bessel polynomial [3]</em>, then the
Aberth-Ehrlich method [4]<em> [5]</em> is used on the Kv(x) Bessel function to
calculate more accurate zeros, and these locations are then inverted about
the unit circle.</p>
<h2 id="references_100">References<a class="headerlink" href="#references_100" title="Permanent link">&para;</a></h2>
<p>.. [1] C.R. Bond, 'Bessel Filter Constants',
http://www.crbond.com/papers/bsf.pdf
.. [2] Campos and Calderon, 'Approximate closed-form formulas for the
zeros of the Bessel Polynomials', :arXiv:<code>1105.0957</code>.
.. [3] Thomson, W.E., 'Delay Networks having Maximally Flat Frequency
Characteristics', Proceedings of the Institution of Electrical
Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490.
.. [4] Aberth, 'Iteration Methods for Finding all Zeros of a Polynomial
Simultaneously', Mathematics of Computation, Vol. 27, No. 122,
April 1973
.. [5] Ehrlich, 'A modified Newton method for polynomials', Communications
of the ACM, Vol. 10, Issue 2, pp. 107-108, Feb. 1967,
:DOI:<code>10.1145/363067.363115</code>
.. [6] Miller and Bohn, 'A Bessel Filter Crossover, and Its Relation to
Others', RaneNote 147, 1998, http://www.rane.com/note147.html</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bilinear</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a digital IIR filter from an analog one using a bilinear transform.</p>
<p>Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes <code>(z-1) / (z+1)</code> for
<code>s</code>, maintaining the shape of the frequency response.</p>
<h2 id="parameters_476">Parameters<a class="headerlink" href="#parameters_476" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of the analog filter transfer function.
a : array_like
Denominator of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g. hertz). No prewarping is
done in this function.</p>
<h2 id="returns_455">Returns<a class="headerlink" href="#returns_455" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Numerator of the transformed digital filter transfer function.
p : ndarray
Denominator of the transformed digital filter transfer function.</p>
<h2 id="see-also_313">See Also<a class="headerlink" href="#see-also_313" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bp, lp2bs
bilinear_zpk</p>
<h2 id="examples_397">Examples<a class="headerlink" href="#examples_397" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 100
bf = 2 * np.pi * np.array([7, 13])
filts = signal.lti( <em>signal.butter(4, bf, btype='bandpass', analog=True))
filtz = signal.lti( </em>signal.bilinear(filts.num, filts.den, fs))
wz, hz = signal.freqz(filtz.num, filtz.den)
ws, hs = signal.freqs(filts.num, filts.den, worN=fs*wz)</p>
<p>plt.semilogx(wz<em>fs/(2</em>np.pi), 20<em>np.log10(np.abs(hz).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H(j \omega)|</span><script type="math/tex">|H(j \omega)|</script></span>')
plt.semilogx(wz</em>fs/(2<em>np.pi), 20</em>np.log10(np.abs(hs).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H_z(e^{j \omega})|</span><script type="math/tex">|H_z(e^{j \omega})|</script></span>')
plt.legend()
plt.xlabel('Frequency [Hz]')
plt.ylabel('Magnitude [dB]')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bilinear_zpk</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return a digital IIR filter from an analog one using a bilinear transform.</p>
<p>Transform a set of poles and zeros from the analog s-plane to the digital
z-plane using Tustin's method, which substitutes <code>(z-1) / (z+1)</code> for
<code>s</code>, maintaining the shape of the frequency response.</p>
<h2 id="parameters_477">Parameters<a class="headerlink" href="#parameters_477" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
fs : float
Sample rate, as ordinary frequency (e.g. hertz). No prewarping is
done in this function.</p>
<h2 id="returns_456">Returns<a class="headerlink" href="#returns_456" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed digital filter transfer function.
p : ndarray
Poles of the transformed digital filter transfer function.
k : float
System gain of the transformed digital filter.</p>
<h2 id="see-also_314">See Also<a class="headerlink" href="#see-also_314" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, lp2bs_zpk
bilinear</p>
<h2 id="notes_309">Notes<a class="headerlink" href="#notes_309" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_398">Examples<a class="headerlink" href="#examples_398" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 100
bf = 2 * np.pi * np.array([7, 13])
filts = signal.lti( <em>signal.butter(4, bf, btype='bandpass', analog=True, output='zpk'))
filtz = signal.lti( </em>signal.bilinear_zpk(filts.zeros, filts.poles, filts.gain, fs))
wz, hz = signal.freqz_zpk(filtz.zeros, filtz.poles, filtz.gain)
ws, hs = signal.freqs_zpk(filts.zeros, filts.poles, filts.gain, worN=fs<em>wz)
plt.semilogx(wz</em>fs/(2<em>np.pi), 20</em>np.log10(np.abs(hz).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H(j \omega)|</span><script type="math/tex">|H(j \omega)|</script></span>')
plt.semilogx(wz<em>fs/(2</em>np.pi), 20*np.log10(np.abs(hs).clip(1e-15)), label=r'<span><span class="MathJax_Preview">|H_z(e^{j \omega})|</span><script type="math/tex">|H_z(e^{j \omega})|</script></span>')
plt.legend()
plt.xlabel('Frequency [Hz]')
plt.ylabel('Magnitude [dB]')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackman</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three terms of
a summation of cosines. It was designed to have close to the minimal
leakage possible.  It is close to optimal, only slightly worse than a
Kaiser window.</p>
<p>.. warning:: scipy.signal.blackman is deprecated,
use scipy.signal.windows.blackman instead.</p>
<h2 id="parameters_478">Parameters<a class="headerlink" href="#parameters_478" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_457">Returns<a class="headerlink" href="#returns_457" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_310">Notes<a class="headerlink" href="#notes_310" title="Permanent link">&para;</a></h2>
<p>The Blackman window is defined as</p>
<p>.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)</p>
<p>The 'exact Blackman' window was designed to null out the third and fourth
sidelobes, but has discontinuities at the boundaries, resulting in a
6 dB/oct fall-off.  This window is an approximation of the 'exact' window,
which does not null the sidelobes as well, but is smooth at the edges,
improving the fall-off rate to 18 dB/oct. [3]_</p>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
'near optimal' tapering function, almost as good (by some measures)
as the Kaiser window.</p>
<h2 id="references_101">References<a class="headerlink" href="#references_101" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
.. [3] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_399">Examples<a class="headerlink" href="#examples_399" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackman(51)
plt.plot(window)
plt.title('Blackman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">blackmanharris</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window.</p>
<p>.. warning:: scipy.signal.blackmanharris is deprecated,
use scipy.signal.windows.blackmanharris instead.</p>
<h2 id="parameters_479">Parameters<a class="headerlink" href="#parameters_479" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_458">Returns<a class="headerlink" href="#returns_458" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_400">Examples<a class="headerlink" href="#examples_400" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.blackmanharris(51)
plt.plot(window)
plt.title('Blackman-Harris window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Blackman-Harris window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a continuous-time system.</p>
<h2 id="parameters_480">Parameters<a class="headerlink" href="#parameters_480" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in rad/s). Magnitude and phase data is calculated
for every value in this array. If not given a reasonable set will be
calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_459">Returns<a class="headerlink" href="#returns_459" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/s]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]</p>
<h2 id="notes_311">Notes<a class="headerlink" href="#notes_311" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_401">Examples<a class="headerlink" href="#examples_401" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sys = signal.TransferFunction([1], [1, 1])
w, mag, phase = signal.bode(sys)</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bohman</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Bohman window.</p>
<p>.. warning:: scipy.signal.bohman is deprecated,
use scipy.signal.windows.bohman instead.</p>
<h2 id="parameters_481">Parameters<a class="headerlink" href="#parameters_481" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_460">Returns<a class="headerlink" href="#returns_460" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="examples_402">Examples<a class="headerlink" href="#examples_402" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.bohman(51)
plt.plot(window)
plt.title('Bohman window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Bohman window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">boxcar</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a boxcar or rectangular window.</p>
<p>Also known as a rectangular window or Dirichlet window, this is equivalent
to no window at all.</p>
<p>.. warning:: scipy.signal.boxcar is deprecated,
use scipy.signal.windows.boxcar instead.</p>
<h2 id="parameters_482">Parameters<a class="headerlink" href="#parameters_482" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
Whether the window is symmetric. (Has no effect for boxcar.)</p>
<h2 id="returns_461">Returns<a class="headerlink" href="#returns_461" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1.</p>
<h2 id="examples_403">Examples<a class="headerlink" href="#examples_403" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.boxcar(51)
plt.plot(window)
plt.title('Boxcar window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the boxcar window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">bspline</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>B-spline basis function of order n.</p>
<h2 id="notes_312">Notes<a class="headerlink" href="#notes_312" title="Permanent link">&para;</a></h2>
<p>Uses numpy.piecewise and automatic function-generator.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">buttap</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for analog prototype of Nth-order Butterworth filter.</p>
<p>The filter will have an angular (e.g. rad/s) cutoff frequency of 1.</p>
<h2 id="see-also_315">See Also<a class="headerlink" href="#see-also_315" title="Permanent link">&para;</a></h2>
<p>butter : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">butter</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Butterworth digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Butterworth filter and return
the filter coefficients.</p>
<h2 id="parameters_483">Parameters<a class="headerlink" href="#parameters_483" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
The critical frequency or frequencies. For lowpass and highpass
filters, Wn is a scalar; for bandpass and bandstop filters,
Wn is a length-2 sequence.</p>
<p>For a Butterworth filter, this is the point at which the gain
drops to 1/sqrt(2) that of the passband (the '-3 dB point').</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_462">Returns<a class="headerlink" href="#returns_462" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_316">See Also<a class="headerlink" href="#see-also_316" title="Permanent link">&para;</a></h2>
<p>buttord, buttap</p>
<h2 id="notes_313">Notes<a class="headerlink" href="#notes_313" title="Permanent link">&para;</a></h2>
<p>The Butterworth filter has maximally flat frequency response in the
passband.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_404">Examples<a class="headerlink" href="#examples_404" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.butter(4, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Butterworth filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.butter(10, 15, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 15 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">buttord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Butterworth filter order selection.</p>
<p>Return the order of the lowest order digital or analog Butterworth filter
that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_484">Parameters<a class="headerlink" href="#parameters_484" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_463">Returns<a class="headerlink" href="#returns_463" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Butterworth filter which meets specs.
wn : ndarray or float
The Butterworth natural frequency (i.e. the '3dB frequency').  Should
be used with <code>butter</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>butter</code>.</p>
<h2 id="see-also_317">See Also<a class="headerlink" href="#see-also_317" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheb1ord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_405">Examples<a class="headerlink" href="#examples_405" title="Permanent link">&para;</a></h2>
<p>Design an analog bandpass filter with passband within 3 dB from 20 to
50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s.
Plot its frequency response, showing the passband and stopband
constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True)
b, a = signal.butter(N, Wn, 'band', True)
w, h = signal.freqs(b, a, np.logspace(1, 2, 500))
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Butterworth bandpass filter fit to constraints')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop
plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass
plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop
plt.axis([10, 100, -60, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cascade</span> <span class="o">:</span> <span class="o">?</span><span class="n">j</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">hk</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return (x, phi, psi) at dyadic points <code>K/2**J</code> from filter coefficients.</p>
<h2 id="parameters_485">Parameters<a class="headerlink" href="#parameters_485" title="Permanent link">&para;</a></h2>
<p>hk : array_like
Coefficients of low-pass filter.
J : int, optional
Values will be computed at grid points <code>K/2**J</code>. Default is 7.</p>
<h2 id="returns_464">Returns<a class="headerlink" href="#returns_464" title="Permanent link">&para;</a></h2>
<p>x : ndarray
The dyadic points <code>K/2**J</code> for <code>K=0...N * (2**J)-1</code> where
<code>len(hk) = len(gk) = N+1</code>.
phi : ndarray
The scaling function <code>phi(x)</code> at <code>x</code>:
<code>phi(x) = sum(hk * phi(2x-k))</code>, where k is from 0 to N.
psi : ndarray, optional
The wavelet function <code>psi(x)</code> at <code>x</code>:
<code>phi(x) = sum(gk * phi(2x-k))</code>, where k is from 0 to N.
<code>psi</code> is only returned if <code>gk</code> is not None.</p>
<h2 id="notes_314">Notes<a class="headerlink" href="#notes_314" title="Permanent link">&para;</a></h2>
<p>The algorithm uses the vector cascade algorithm described by Strang and
Nguyen in 'Wavelets and Filter Banks'.  It builds a dictionary of values
and slices for quick reuse.  Then inserts vectors into final vector at the
end.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb1ap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p>
<p>The returned filter prototype has <code>rp</code> decibels of ripple in the passband.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below <code>-rp</code>.</p>
<h2 id="see-also_318">See Also<a class="headerlink" href="#see-also_318" title="Permanent link">&para;</a></h2>
<p>cheby1 : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb1ord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Chebyshev type I filter order selection.</p>
<p>Return the order of the lowest order digital or analog Chebyshev Type I
filter that loses no more than <code>gpass</code> dB in the passband and has at
least <code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_486">Parameters<a class="headerlink" href="#parameters_486" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_465">Returns<a class="headerlink" href="#returns_465" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Chebyshev type I filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>cheby1</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>cheby1</code>.</p>
<h2 id="see-also_319">See Also<a class="headerlink" href="#see-also_319" title="Permanent link">&para;</a></h2>
<p>cheby1 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_406">Examples<a class="headerlink" href="#examples_406" title="Permanent link">&para;</a></h2>
<p>Design a digital lowpass filter such that the passband is within 3 dB up
to 0.2<em>(fs/2), while rejecting at least -40 dB above 0.3</em>(fs/2).  Plot its
frequency response, showing the passband and stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40)
b, a = signal.cheby1(N, 3, Wn, 'low')
w, h = signal.freqz(b, a)
plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
plt.title('Chebyshev I lowpass filter fit to constraints')
plt.xlabel('Normalized frequency')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop
plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass
plt.axis([0.08, 1, -60, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb2ap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.</p>
<p>The returned filter prototype has <code>rs</code> decibels of ripple in the stopband.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first reaches <code>-rs</code>.</p>
<h2 id="see-also_320">See Also<a class="headerlink" href="#see-also_320" title="Permanent link">&para;</a></h2>
<p>cheby2 : Filter design function using this prototype</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheb2ord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Chebyshev type II filter order selection.</p>
<p>Return the order of the lowest order digital or analog Chebyshev Type II
filter that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_487">Parameters<a class="headerlink" href="#parameters_487" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_466">Returns<a class="headerlink" href="#returns_466" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for a Chebyshev type II filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>cheby2</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>cheby2</code>.</p>
<h2 id="see-also_321">See Also<a class="headerlink" href="#see-also_321" title="Permanent link">&para;</a></h2>
<p>cheby2 : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, ellipord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_407">Examples<a class="headerlink" href="#examples_407" title="Permanent link">&para;</a></h2>
<p>Design a digital bandstop filter which rejects -60 dB from 0.2<em>(fs/2) to
0.5</em>(fs/2), while staying within 3 dB below 0.1<em>(fs/2) or above
0.6</em>(fs/2).  Plot its frequency response, showing the passband and
stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60)
b, a = signal.cheby2(N, 60, Wn, 'stop')
w, h = signal.freqz(b, a)
plt.semilogx(w / np.pi, 20 * np.log10(abs(h)))
plt.title('Chebyshev II bandstop filter fit to constraints')
plt.xlabel('Normalized frequency')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop
plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass
plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop
plt.axis([0.06, 1, -80, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Dolph-Chebyshev window.</p>
<p>.. warning:: scipy.signal.chebwin is deprecated,
use scipy.signal.windows.chebwin instead.</p>
<h2 id="parameters_488">Parameters<a class="headerlink" href="#parameters_488" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
at : float
Attenuation (in dB).
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_467">Returns<a class="headerlink" href="#returns_467" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="notes_315">Notes<a class="headerlink" href="#notes_315" title="Permanent link">&para;</a></h2>
<p>This window optimizes for the narrowest main lobe width for a given order
<code>M</code> and sidelobe equiripple attenuation <code>at</code>, using Chebyshev
polynomials.  It was originally developed by Dolph to optimize the
directionality of radio antenna arrays.</p>
<p>Unlike most windows, the Dolph-Chebyshev is defined in terms of its
frequency response:</p>
<p>.. math:: W(k) = \frac
{\cos{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]}}
{\cosh[M \cosh^{-1}(\beta)]}</p>
<p>where</p>
<p>.. math:: \beta = \cosh \left [\frac{1}{M}
\cosh^{-1}(10^\frac{A}{20}) \right ]</p>
<p>and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (<code>at</code>).</p>
<p>The time domain window is then generated using the IFFT, so
power-of-two <code>M</code> are the fastest to generate, and prime number <code>M</code> are
the slowest.</p>
<p>The equiripple condition in the frequency domain creates impulses in the
time domain, which appear at the ends of the window.</p>
<h2 id="references_102">References<a class="headerlink" href="#references_102" title="Permanent link">&para;</a></h2>
<p>.. [1] C. Dolph, 'A current distribution for broadside arrays which
optimizes the relationship between beam width and side-lobe level',
Proceedings of the IEEE, Vol. 34, Issue 6
.. [2] Peter Lynch, 'The Dolph-Chebyshev Window: A Simple Optimal Filter',
American Meteorological Society (April 1997)
http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf
.. [3] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transforms', Proceedings of the IEEE, Vol. 66,
No. 1, January 1978</p>
<h2 id="examples_408">Examples<a class="headerlink" href="#examples_408" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.chebwin(51, at=100)
plt.plot(window)
plt.title('Dolph-Chebyshev window (100 dB)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Dolph-Chebyshev window (100 dB)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheby1</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev type I digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Chebyshev type I filter and
return the filter coefficients.</p>
<h2 id="parameters_489">Parameters<a class="headerlink" href="#parameters_489" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rp : float
The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For Type I filters, this is the point in the transition band at which
the gain first drops below -<code>rp</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_468">Returns<a class="headerlink" href="#returns_468" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_322">See Also<a class="headerlink" href="#see-also_322" title="Permanent link">&para;</a></h2>
<p>cheb1ord, cheb1ap</p>
<h2 id="notes_316">Notes<a class="headerlink" href="#notes_316" title="Permanent link">&para;</a></h2>
<p>The Chebyshev type I filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the passband and increased ringing in the step response.</p>
<p>Type I filters roll off faster than Type II (<code>cheby2</code>), but Type II
filters do not have any ripple in the passband.</p>
<p>The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_409">Examples<a class="headerlink" href="#examples_409" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.cheby1(4, 5, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Chebyshev Type I frequency response (rp=5)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-5, color='green') # rp
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.cheby1(10, 1, 15, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 15 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cheby2</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Chebyshev type II digital and analog filter design.</p>
<p>Design an Nth-order digital or analog Chebyshev type II filter and
return the filter coefficients.</p>
<h2 id="parameters_490">Parameters<a class="headerlink" href="#parameters_490" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rs : float
The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For Type II filters, this is the point in the transition band at which
the gain first reaches -<code>rs</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_469">Returns<a class="headerlink" href="#returns_469" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_323">See Also<a class="headerlink" href="#see-also_323" title="Permanent link">&para;</a></h2>
<p>cheb2ord, cheb2ap</p>
<h2 id="notes_317">Notes<a class="headerlink" href="#notes_317" title="Permanent link">&para;</a></h2>
<p>The Chebyshev type II filter maximizes the rate of cutoff between the
frequency response's passband and stopband, at the expense of ripple in
the stopband and increased ringing in the step response.</p>
<p>Type II filters do not roll off as fast as Type I (<code>cheby1</code>).</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_410">Examples<a class="headerlink" href="#examples_410" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.cheby2(4, 40, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Chebyshev Type II frequency response (rs=40)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-40, color='green') # rs
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.cheby2(12, 20, 17, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 17 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_COLA</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check whether the Constant OverLap Add (COLA) constraint is met</p>
<h2 id="parameters_491">Parameters<a class="headerlink" href="#parameters_491" title="Permanent link">&para;</a></h2>
<p>window : str or tuple or array_like
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.</p>
<h2 id="returns_470">Returns<a class="headerlink" href="#returns_470" title="Permanent link">&para;</a></h2>
<p>verdict : bool
<code>True</code> if chosen combination satisfies COLA within <code>tol</code>,
<code>False</code> otherwise</p>
<h2 id="see-also_324">See Also<a class="headerlink" href="#see-also_324" title="Permanent link">&para;</a></h2>
<p>check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform</p>
<h2 id="notes_318">Notes<a class="headerlink" href="#notes_318" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, it is sufficient that the signal windowing obeys the constraint of
'Constant OverLap Add' (COLA). This ensures that every point in the input
data is equally weighted, thereby avoiding aliasing and allowing full
reconstruction.</p>
<p>Some examples of windows that satisfy COLA:
- Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...
- Bartlett window at overlap of 1/2, 3/4, 5/6, ...
- Hann window at 1/2, 2/3, 3/4, ...
- Any Blackman family window at 2/3 overlap
- Any window with <code>noverlap = nperseg-1</code></p>
<p>A very comprehensive list of other windows may be found in [2]_,
wherein the COLA condition is satisfied when the 'Amplitude
Flatness' is unity.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_103">References<a class="headerlink" href="#references_103" title="Permanent link">&para;</a></h2>
<p>.. [1] Julius O. Smith III, 'Spectral Audio Signal Processing', W3K
Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, 'Spectrum and
spectral density estimation by the Discrete Fourier transform
(DFT), including a comprehensive list of window functions and
some new at-top windows', 2002,
http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</p>
<h2 id="examples_411">Examples<a class="headerlink" href="#examples_411" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Confirm COLA condition for rectangular window of 75% (3/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.boxcar(100), 100, 75)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>COLA is not true for 25% (1/4) overlap, though:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.boxcar(100), 100, 25)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Symmetrical' Hann window (for filter design) is not COLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.hann(120, sym=True), 120, 60)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Periodic' or 'DFT-even' Hann window (for FFT analysis) is COLA for
overlap of 1/2, 2/3, 3/4, etc.:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 60)
True</p>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 80)
True</p>
<p>signal.check_COLA(signal.hann(120, sym=False), 120, 90)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">check_NOLA</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check whether the Nonzero Overlap Add (NOLA) constraint is met</p>
<h2 id="parameters_492">Parameters<a class="headerlink" href="#parameters_492" title="Permanent link">&para;</a></h2>
<p>window : str or tuple or array_like
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
nperseg : int
Length of each segment.
noverlap : int
Number of points to overlap between segments.
tol : float, optional
The allowed variance of a bin's weighted sum from the median bin
sum.</p>
<h2 id="returns_471">Returns<a class="headerlink" href="#returns_471" title="Permanent link">&para;</a></h2>
<p>verdict : bool
<code>True</code> if chosen combination satisfies the NOLA constraint within
<code>tol</code>, <code>False</code> otherwise</p>
<h2 id="see-also_325">See Also<a class="headerlink" href="#see-also_325" title="Permanent link">&para;</a></h2>
<p>check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
stft: Short Time Fourier Transform
istft: Inverse Short Time Fourier Transform</p>
<h2 id="notes_319">Notes<a class="headerlink" href="#notes_319" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, the signal windowing must obey the constraint of 'nonzero
overlap add' (NOLA):</p>
<p>.. math:: \sum_{t}w^{2}[n-tH] \ne 0</p>
<p>for all :math:<code>n</code>, where :math:<code>w</code> is the window function, :math:<code>t</code> is the
frame index, and :math:<code>H</code> is the hop size (:math:<code>H</code> = <code>nperseg</code> -
<code>noverlap</code>).</p>
<p>This ensures that the normalization factors in the denominator of the
overlap-add inversion equation are not zero. Only very pathological windows
will fail the NOLA constraint.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="references_104">References<a class="headerlink" href="#references_104" title="Permanent link">&para;</a></h2>
<p>.. [1] Julius O. Smith III, 'Spectral Audio Signal Processing', W3K
Publishing, 2011,ISBN 978-0-9745607-3-1.
.. [2] G. Heinzel, A. Ruediger and R. Schilling, 'Spectrum and
spectral density estimation by the Discrete Fourier transform
(DFT), including a comprehensive list of window functions and
some new at-top windows', 2002,
http://hdl.handle.net/11858/00-001M-0000-0013-557A-5</p>
<h2 id="examples_412">Examples<a class="headerlink" href="#examples_412" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
</blockquote>
</blockquote>
</blockquote>
<p>Confirm NOLA condition for rectangular window of 75% (3/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.boxcar(100), 100, 75)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>NOLA is also true for 25% (1/4) overlap:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.boxcar(100), 100, 25)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>'Symmetrical' Hann window (for filter design) is also NOLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.hann(120, sym=True), 120, 60)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>As long as there is overlap, it takes quite a pathological window to fail
NOLA:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = np.ones(64, dtype='float')
w[::2] = 0
signal.check_NOLA(w, 64, 32)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is not enough overlap, a window with zeros at the ends will not
work:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.check_NOLA(signal.hann(64), 64, 0)
False
signal.check_NOLA(signal.hann(64), 64, 1)
False
signal.check_NOLA(signal.hann(64), 64, 2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chirp</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Linear</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Quadratic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Logarithmic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Hyperbolic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">phi</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">vertex_zero</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">t1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">f1</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Frequency-swept cosine generator.</p>
<p>In the following, 'Hz' should be interpreted as 'cycles per unit';
there is no requirement here that the unit is one second.  The
important distinction is that the units of rotation are cycles, not
radians. Likewise, <code>t</code> could be a measurement of space instead of time.</p>
<h2 id="parameters_493">Parameters<a class="headerlink" href="#parameters_493" title="Permanent link">&para;</a></h2>
<p>t : array_like
Times at which to evaluate the waveform.
f0 : float
Frequency (e.g. Hz) at time t=0.
t1 : float
Time at which <code>f1</code> is specified.
f1 : float
Frequency (e.g. Hz) of the waveform at time <code>t1</code>.
method : {'linear', 'quadratic', 'logarithmic', 'hyperbolic'}, optional
Kind of frequency sweep.  If not given, <code>linear</code> is assumed.  See
Notes below for more details.
phi : float, optional
Phase offset, in degrees. Default is 0.
vertex_zero : bool, optional
This parameter is only used when <code>method</code> is 'quadratic'.
It determines whether the vertex of the parabola that is the graph
of the frequency is at t=0 or t=t1.</p>
<h2 id="returns_472">Returns<a class="headerlink" href="#returns_472" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A numpy array containing the signal evaluated at <code>t</code> with the
requested time-varying frequency.  More precisely, the function
returns <code>cos(phase + (pi/180)*phi)</code> where <code>phase</code> is the integral
(from 0 to <code>t</code>) of <code>2*pi*f(t)</code>. <code>f(t)</code> is defined below.</p>
<h2 id="see-also_326">See Also<a class="headerlink" href="#see-also_326" title="Permanent link">&para;</a></h2>
<p>sweep_poly</p>
<h2 id="notes_320">Notes<a class="headerlink" href="#notes_320" title="Permanent link">&para;</a></h2>
<p>There are four options for the <code>method</code>.  The following formulas give
the instantaneous frequency (in Hz) of the signal generated by
<code>chirp()</code>.  For convenience, the shorter names shown below may also be
used.</p>
<p>linear, lin, li:</p>
<p><code>f(t) = f0 + (f1 - f0) * t / t1</code></p>
<p>quadratic, quad, q:</p>
<p>The graph of the frequency f(t) is a parabola through (0, f0) and
(t1, f1).  By default, the vertex of the parabola is at (0, f0).
If <code>vertex_zero</code> is False, then the vertex is at (t1, f1).  The
formula is:</p>
<p>if vertex_zero is True:</p>
<p><code>f(t) = f0 + (f1 - f0) * t**2 / t1**2</code></p>
<p>else:</p>
<p><code>f(t) = f1 - (f1 - f0) * (t1 - t)**2 / t1**2</code></p>
<p>To use a more general quadratic function, or an arbitrary
polynomial, use the function <code>scipy.signal.sweep_poly</code>.</p>
<p>logarithmic, log, lo:</p>
<p><code>f(t) = f0 * (f1/f0)**(t/t1)</code></p>
<p>f0 and f1 must be nonzero and have the same sign.</p>
<p>This signal is also known as a geometric or exponential chirp.</p>
<p>hyperbolic, hyp:</p>
<p><code>f(t) = f0*f1*t1 / ((f0 - f1)*t + f1*t1)</code></p>
<p>f0 and f1 must be nonzero.</p>
<h2 id="examples_413">Examples<a class="headerlink" href="#examples_413" title="Permanent link">&para;</a></h2>
<p>The following will be used in the examples:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import chirp, spectrogram
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>For the first example, we'll plot the waveform for a linear chirp
from 6 Hz to 1 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 10, 5001)
w = chirp(t, f0=6, f1=1, t1=10, method='linear')
plt.plot(t, w)
plt.title('Linear Chirp, f(0)=6, f(10)=1')
plt.xlabel('t (sec)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>For the remaining examples, we'll use higher frequency ranges,
and demonstrate the result using <code>scipy.signal.spectrogram</code>.
We'll use a 10 second interval sampled at 8000 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 8000
T = 10
t = np.linspace(0, T, T*fs, endpoint=False)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Quadratic chirp from 1500 Hz to 250 Hz over 10 seconds
(vertex of the parabolic curve of the frequency is at t=0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='quadratic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Quadratic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Quadratic chirp from 1500 Hz to 250 Hz over 10 seconds
(vertex of the parabolic curve of the frequency is at t=10):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='quadratic',
...           vertex_zero=False)
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Quadratic Chirp, f(0)=1500, f(10)=250\n' +
...           '(vertex_zero=False)')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Logarithmic chirp from 1500 Hz to 250 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='logarithmic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Logarithmic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Hyperbolic chirp from 1500 Hz to 250 Hz over 10 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w = chirp(t, f0=1500, f1=250, t1=10, method='hyperbolic')
ff, tt, Sxx = spectrogram(w, fs=fs, noverlap=256, nperseg=512,
...                           nfft=2048)
plt.pcolormesh(tt, ff[:513], Sxx[:513], cmap='gray_r')
plt.title('Hyperbolic Chirp, f(0)=1500, f(10)=250')
plt.xlabel('t (sec)')
plt.ylabel('Frequency (Hz)')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">choose_conv_method</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">measure</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find the fastest convolution/correlation method.</p>
<p>This primarily exists to be called during the <code>method='auto'</code> option in
<code>convolve</code> and <code>correlate</code>. It can also be used to determine the value of
<code>method</code> for many different convolutions of the same dtype/shape.
In addition, it supports timing the convolution to adapt the value of
<code>method</code> to a particular set of inputs and/or hardware.</p>
<h2 id="parameters_494">Parameters<a class="headerlink" href="#parameters_494" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
The first argument passed into the convolution function.
in2 : array_like
The second argument passed into the convolution function.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
measure : bool, optional
If True, run and time the convolution of <code>in1</code> and <code>in2</code> with both
methods and return the fastest. If False (default), predict the fastest
method using precomputed values.</p>
<h2 id="returns_473">Returns<a class="headerlink" href="#returns_473" title="Permanent link">&para;</a></h2>
<p>method : str
A string indicating which convolution method is fastest, either
'direct' or 'fft'
times : dict, optional
A dictionary containing the times (in seconds) needed for each method.
This value is only returned if <code>measure=True</code>.</p>
<h2 id="see-also_327">See Also<a class="headerlink" href="#see-also_327" title="Permanent link">&para;</a></h2>
<p>convolve
correlate</p>
<h2 id="notes_321">Notes<a class="headerlink" href="#notes_321" title="Permanent link">&para;</a></h2>
<p>Generally, this method is 99% accurate for 2D signals and 85% accurate
for 1D signals for randomly chosen input sizes. For precision, use
<code>measure=True</code> to find the fastest method by timing the convolution.
This can be used to avoid the minimal overhead of finding the fastest
<code>method</code> later, or to adapt the value of <code>method</code> to a particular set
of inputs.</p>
<p>Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this
function. These experiments measured the ratio between the time required
when using <code>method='auto'</code> and the time required for the fastest method
(i.e., <code>ratio = time_auto / min(time_fft, time_direct)</code>). In these
experiments, we found:</p>
<ul>
<li>There is a 95% chance of this ratio being less than 1.5 for 1D signals
and a 99% chance of being less than 2.5 for 2D signals.</li>
<li>The ratio was always less than 2.5/5 for 1D/2D signals respectively.</li>
<li>This function is most inaccurate for 1D convolutions that take between 1
and 10 milliseconds with <code>method='direct'</code>. A good proxy for this
(at least in our experiments) is <code>1e6 &lt;= in1.size * in2.size &lt;= 1e7</code>.</li>
</ul>
<p>The 2D results almost certainly generalize to 3D/4D/etc because the
implementation is the same (the 1D implementation is different).</p>
<p>All the numbers above are specific to the EC2 machine. However, we did find
that this function generalizes fairly decently across hardware. The speed
tests were of similar quality (and even slightly better) than the same
tests performed on the machine to tune this function's numbers (a mid-2014
15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor).</p>
<p>There are cases when <code>fftconvolve</code> supports the inputs but this function
returns <code>direct</code> (e.g., to protect against floating point integer
precision).</p>
<p>.. versionadded:: 0.19</p>
<h2 id="examples_414">Examples<a class="headerlink" href="#examples_414" title="Permanent link">&para;</a></h2>
<p>Estimate the fastest method for a given input:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
img = np.random.rand(32, 32)
filter = np.random.rand(8, 8)
method = signal.choose_conv_method(img, filter, mode='same')
method
'fft'</p>
</blockquote>
</blockquote>
</blockquote>
<p>This can then be applied to other arrays of the same dtype and shape:</p>
<blockquote>
<blockquote>
<blockquote>
<p>img2 = np.random.rand(32, 32)
filter2 = np.random.rand(8, 8)
corr2 = signal.correlate(img2, filter2, mode='same', method=method)
conv2 = signal.convolve(img2, filter2, mode='same', method=method)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The output of this function (<code>method</code>) works with <code>correlate</code> and
<code>convolve</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cmplx_sort</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Sort roots based on magnitude.</p>
<h2 id="parameters_495">Parameters<a class="headerlink" href="#parameters_495" title="Permanent link">&para;</a></h2>
<p>p : array_like
The roots to sort, as a 1-D array.</p>
<h2 id="returns_474">Returns<a class="headerlink" href="#returns_474" title="Permanent link">&para;</a></h2>
<p>p_sorted : ndarray
Sorted roots.
indx : ndarray
Array of indices needed to sort the input <code>p</code>.</p>
<h2 id="examples_415">Examples<a class="headerlink" href="#examples_415" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
vals = [1, 4, 1+1.j, 3]
p_sorted, indx = signal.cmplx_sort(vals)
p_sorted
array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j])
indx
array([0, 2, 3, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coherence</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate the magnitude squared coherence estimate, Cxy, of
discrete-time signals X and Y using Welch's method.</p>
<p><code>Cxy = abs(Pxy)**2/(Pxx*Pyy)</code>, where <code>Pxx</code> and <code>Pyy</code> are power
spectral density estimates of X and Y, and <code>Pxy</code> is the cross
spectral density estimate of X and Y.</p>
<h2 id="parameters_496">Parameters<a class="headerlink" href="#parameters_496" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
y : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> and <code>y</code> time series. Defaults
to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap: int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
axis : int, optional
Axis along which the coherence is computed for both inputs; the
default is over the last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_475">Returns<a class="headerlink" href="#returns_475" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Cxy : ndarray
Magnitude squared coherence of x and y.</p>
<h2 id="see-also_328">See Also<a class="headerlink" href="#see-also_328" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.</p>
<h2 id="notes_322">Notes<a class="headerlink" href="#notes_322" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_105">References<a class="headerlink" href="#references_105" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Stoica, Petre, and Randolph Moses, 'Spectral Analysis of
Signals' Prentice Hall, 2005</p>
<h2 id="examples_416">Examples<a class="headerlink" href="#examples_416" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate two test signals with some common features.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 20
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
b, a = signal.butter(2, 0.25, 'low')
x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
y = signal.lfilter(b, a, x)
x += amp<em>np.sin(2</em>np.pi<em>freq</em>time)
y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the coherence.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Cxy = signal.coherence(x, y, fs, nperseg=1024)
plt.semilogy(f, Cxy)
plt.xlabel('frequency [Hz]')
plt.ylabel('Coherence')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cont2discrete</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">alpha</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">dt</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transform a continuous to a discrete state-space system.</p>
<h2 id="parameters_497">Parameters<a class="headerlink" href="#parameters_497" title="Permanent link">&para;</a></h2>
<p>system : a tuple describing the system or an instance of <code>lti</code>
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>dt : float
The discretization time step.
method : str, optional
Which method to use:</p>
<ul>
<li>gbt: generalized bilinear transformation</li>
<li>bilinear: Tustin's approximation ('gbt' with alpha=0.5)</li>
<li>euler: Euler (or forward differencing) method ('gbt' with alpha=0)</li>
<li>backward_diff: Backwards differencing ('gbt' with alpha=1.0)</li>
<li>zoh: zero-order hold (default)</li>
<li>foh: first-order hold ( <em>versionadded: 1.3.0</em> )</li>
<li>impulse: equivalent impulse response ( <em>versionadded: 1.3.0</em> )</li>
</ul>
<p>alpha : float within [0, 1], optional
The generalized bilinear transformation weighting parameter, which
should only be specified with method='gbt', and is ignored otherwise</p>
<h2 id="returns_476">Returns<a class="headerlink" href="#returns_476" title="Permanent link">&para;</a></h2>
<p>sysd : tuple containing the discrete system
Based on the input type, the output will be of the form</p>
<ul>
<li>(num, den, dt)   for transfer function input</li>
<li>(zeros, poles, gain, dt)   for zeros-poles-gain input</li>
<li>(A, B, C, D, dt) for state-space system input</li>
</ul>
<h2 id="notes_323">Notes<a class="headerlink" href="#notes_323" title="Permanent link">&para;</a></h2>
<p>By default, the routine uses a Zero-Order Hold (zoh) method to perform
the transformation.  Alternatively, a generalized bilinear transformation
may be used, which includes the common Tustin's bilinear approximation,
an Euler's method technique, or a backwards differencing technique.</p>
<p>The Zero-Order Hold (zoh) method is based on [1]<em>, the generalized bilinear
approximation is based on [2]</em> and [3]<em>, the First-Order Hold (foh) method
is based on [4]</em>.</p>
<h2 id="references_106">References<a class="headerlink" href="#references_106" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Discretization#Discretization_of_linear_state_space_models</p>
<p>.. [2] http://techteach.no/publications/discretetime_signals_systems/discrete.pdf</p>
<p>.. [3] G. Zhang, X. Chen, and T. Chen, Digital redesign via the generalized
bilinear transformation, Int. J. Control, vol. 82, no. 4, pp. 741-754,
2009.
(https://www.mypolyuweb.hk/~magzhang/Research/ZCC09_IJC.pdf)</p>
<p>.. [4] G. F. Franklin, J. D. Powell, and M. L. Workman, Digital control
of dynamic systems, 3rd ed. Menlo Park, Calif: Addison-Wesley,
pp. 204-206, 1998.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fft</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays.</p>
<p>Convolve <code>in1</code> and <code>in2</code>, with the output size determined by the
<code>mode</code> argument.</p>
<h2 id="parameters_498">Parameters<a class="headerlink" href="#parameters_498" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the convolution.</p>
<p><code>direct</code>
The convolution is determined directly from sums, the definition of
convolution.
<code>fft</code>
The Fourier Transform is used to perform the convolution by calling
<code>fftconvolve</code>.
<code>auto</code>
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See Notes for more detail.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="returns_477">Returns<a class="headerlink" href="#returns_477" title="Permanent link">&para;</a></h2>
<p>convolve : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_329">See Also<a class="headerlink" href="#see-also_329" title="Permanent link">&para;</a></h2>
<p>numpy.polymul : performs polynomial multiplication (same operation, but
also accepts poly1d objects)
choose_conv_method : chooses the fastest appropriate convolution method
fftconvolve : Always uses the FFT method.
oaconvolve : Uses the overlap-add method to do convolution, which is
generally faster when the input arrays are large and
significantly different in size.</p>
<h2 id="notes_324">Notes<a class="headerlink" href="#notes_324" title="Permanent link">&para;</a></h2>
<p>By default, <code>convolve</code> and <code>correlate</code> use <code>method='auto'</code>, which calls
<code>choose_conv_method</code> to choose the fastest method using pre-computed
values (<code>choose_conv_method</code> can also measure real-world timing with a
keyword argument). Because <code>fftconvolve</code> relies on floating point numbers,
there are certain constraints that may force <code>method=direct</code> (more detail
in <code>choose_conv_method</code> docstring).</p>
<h2 id="examples_417">Examples<a class="headerlink" href="#examples_417" title="Permanent link">&para;</a></h2>
<p>Smooth a square pulse using a Hann window:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.repeat([0., 1., 0.], 100)
win = signal.hann(50)
filtered = signal.convolve(sig, win, mode='same') / sum(win)</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)
ax_orig.plot(sig)
ax_orig.set_title('Original pulse')
ax_orig.margins(0, 0.1)
ax_win.plot(win)
ax_win.set_title('Filter impulse response')
ax_win.margins(0, 0.1)
ax_filt.plot(filtered)
ax_filt.set_title('Filtered signal')
ax_filt.margins(0, 0.1)
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolve2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">Fill</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Symm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fillvalue</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two 2-dimensional arrays.</p>
<p>Convolve <code>in1</code> and <code>in2</code> with output size determined by <code>mode</code>, and
boundary conditions determined by <code>boundary</code> and <code>fillvalue</code>.</p>
<h2 id="parameters_499">Parameters<a class="headerlink" href="#parameters_499" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
A flag indicating how to handle boundaries:</p>
<p><code>fill</code>
pad input arrays with fillvalue. (default)
<code>wrap</code>
circular boundary conditions.
<code>symm</code>
symmetrical boundary conditions.</p>
<p>fillvalue : scalar, optional
Value to fill pad input arrays with. Default is 0.</p>
<h2 id="returns_478">Returns<a class="headerlink" href="#returns_478" title="Permanent link">&para;</a></h2>
<p>out : ndarray
A 2-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="examples_418">Examples<a class="headerlink" href="#examples_418" title="Permanent link">&para;</a></h2>
<p>Compute the gradient of an image by 2D convolution with a complex Scharr
operator.  (Horizontal operator is real, vertical is imaginary.)  Use
symmetric boundary condition to avoid creating edges at the image
boundaries.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy import misc
ascent = misc.ascent()
scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],
...                    [-10+0j, 0+ 0j, +10 +0j],
...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy
grad = signal.convolve2d(ascent, scharr, boundary='symm', mode='same')</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))
ax_orig.imshow(ascent, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_mag.imshow(np.absolute(grad), cmap='gray')
ax_mag.set_title('Gradient magnitude')
ax_mag.set_axis_off()
ax_ang.imshow(np.angle(grad), cmap='hsv') # hsv is cyclic, like angles
ax_ang.set_title('Gradient orientation')
ax_ang.set_axis_off()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Auto</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fft</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cross-correlate two N-dimensional arrays.</p>
<p>Cross-correlate <code>in1</code> and <code>in2</code>, with the output size determined by the
<code>mode</code> argument.</p>
<h2 id="parameters_500">Parameters<a class="headerlink" href="#parameters_500" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear cross-correlation
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
method : str {'auto', 'direct', 'fft'}, optional
A string indicating which method to use to calculate the correlation.</p>
<p><code>direct</code>
The correlation is determined directly from sums, the definition of
correlation.
<code>fft</code>
The Fast Fourier Transform is used to perform the correlation more
quickly (only available for numerical arrays.)
<code>auto</code>
Automatically chooses direct or Fourier method based on an estimate
of which is faster (default).  See <code>convolve</code> Notes for more detail.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="returns_479">Returns<a class="headerlink" href="#returns_479" title="Permanent link">&para;</a></h2>
<p>correlate : array
An N-dimensional array containing a subset of the discrete linear
cross-correlation of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_330">See Also<a class="headerlink" href="#see-also_330" title="Permanent link">&para;</a></h2>
<p>choose_conv_method : contains more documentation on <code>method</code>.</p>
<h2 id="notes_325">Notes<a class="headerlink" href="#notes_325" title="Permanent link">&para;</a></h2>
<p>The correlation z of two d-dimensional arrays x and y is defined as::</p>
<p>z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])</p>
<p>This way, if x and y are 1-D arrays and <code>z = correlate(x, y, 'full')</code>
then</p>
<p>.. math::</p>
<p>z[k] = (x * y)(k - N + 1)
= \sum_{l=0}^{ ||x||-1}x_l y_{l-k+N-1}^{*}</p>
<p>for :math:<code>k = 0, 1, ..., ||x|| + ||y|| - 2</code></p>
<p>where :math:<code>||x||</code> is the length of <code>x</code>, :math:<code>N = \max(||x||,||y||)</code>,
and :math:<code>y_m</code> is 0 when m is outside the range of y.</p>
<p><code>method='fft'</code> only works for numerical arrays as it relies on
<code>fftconvolve</code>. In certain cases (i.e., arrays of objects or when
rounding integers can lose precision), <code>method='direct'</code> is always used.</p>
<h2 id="examples_419">Examples<a class="headerlink" href="#examples_419" title="Permanent link">&para;</a></h2>
<p>Implement a matched filter using cross-correlation, to recover a signal
that has passed through a noisy channel.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)
sig_noise = sig + np.random.randn(len(sig))
corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128</p>
<p>import matplotlib.pyplot as plt
clock = np.arange(64, len(sig), 128)
fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)
ax_orig.plot(sig)
ax_orig.plot(clock, sig[clock], 'ro')
ax_orig.set_title('Original signal')
ax_noise.plot(sig_noise)
ax_noise.set_title('Signal with noise')
ax_corr.plot(corr)
ax_corr.plot(clock, corr[clock], 'ro')
ax_corr.axhline(0.5, ls=':')
ax_corr.set_title('Cross-correlated with rectangular pulse')
ax_orig.margins(0, 0.1)
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlate2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">Fill</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Wrap</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Symm</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fillvalue</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cross-correlate two 2-dimensional arrays.</p>
<p>Cross correlate <code>in1</code> and <code>in2</code> with output size determined by <code>mode</code>, and
boundary conditions determined by <code>boundary</code> and <code>fillvalue</code>.</p>
<h2 id="parameters_501">Parameters<a class="headerlink" href="#parameters_501" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear cross-correlation
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
boundary : str {'fill', 'wrap', 'symm'}, optional
A flag indicating how to handle boundaries:</p>
<p><code>fill</code>
pad input arrays with fillvalue. (default)
<code>wrap</code>
circular boundary conditions.
<code>symm</code>
symmetrical boundary conditions.</p>
<p>fillvalue : scalar, optional
Value to fill pad input arrays with. Default is 0.</p>
<h2 id="returns_480">Returns<a class="headerlink" href="#returns_480" title="Permanent link">&para;</a></h2>
<p>correlate2d : ndarray
A 2-dimensional array containing a subset of the discrete linear
cross-correlation of <code>in1</code> with <code>in2</code>.</p>
<h2 id="examples_420">Examples<a class="headerlink" href="#examples_420" title="Permanent link">&para;</a></h2>
<p>Use 2D cross-correlation to find the location of a template in a noisy
image:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy import misc
face = misc.face(gray=True) - misc.face(gray=True).mean()
template = np.copy(face[300:365, 670:750])  # right eye
template -= template.mean()
face = face + np.random.randn( *face.shape) * 50  # add noise
corr = signal.correlate2d(face, template, boundary='symm', mode='same')
y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,
...                                                     figsize=(6, 15))
ax_orig.imshow(face, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_template.imshow(template, cmap='gray')
ax_template.set_title('Template')
ax_template.set_axis_off()
ax_corr.imshow(corr, cmap='gray')
ax_corr.set_title('Cross-correlation')
ax_corr.set_axis_off()
ax_orig.plot(x, y, 'ro')
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a simple cosine shape.</p>
<p>.. warning:: scipy.signal.cosine is deprecated,
use scipy.signal.windows.cosine instead.</p>
<h2 id="parameters_502">Parameters<a class="headerlink" href="#parameters_502" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_481">Returns<a class="headerlink" href="#returns_481" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_326">Notes<a class="headerlink" href="#notes_326" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.13.0</p>
<h2 id="examples_421">Examples<a class="headerlink" href="#examples_421" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.cosine(51)
plt.plot(window)
plt.title('Cosine window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the cosine window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">csd</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">average</span><span class="o">:[`</span><span class="nc">Mean</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Median</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate the cross power spectral density, Pxy, using Welch's
method.</p>
<h2 id="parameters_503">Parameters<a class="headerlink" href="#parameters_503" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
y : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> and <code>y</code> time series. Defaults
to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap: int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the cross spectral density ('density')
where <code>Pxy</code> has units of V<strong>2/Hz and computing the cross spectrum
('spectrum') where <code>Pxy</code> has units of V</strong>2, if <code>x</code> and <code>y</code> are
measured in V and <code>fs</code> is measured in Hz. Defaults to 'density'
axis : int, optional
Axis along which the CSD is computed for both inputs; the
default is over the last axis (i.e. <code>axis=-1</code>).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. Defaults to 'mean'.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_482">Returns<a class="headerlink" href="#returns_482" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxy : ndarray
Cross spectral density or cross power spectrum of x,y.</p>
<h2 id="see-also_331">See Also<a class="headerlink" href="#see-also_331" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method. [Equivalent to
csd(x,x)]
coherence: Magnitude squared coherence by Welch's method.</p>
<h2 id="notes_327">Notes<a class="headerlink" href="#notes_327" title="Permanent link">&para;</a></h2>
<p>By convention, Pxy is computed with the conjugate FFT of X
multiplied by the FFT of Y.</p>
<p>If the input series differ in length, the shorter series will be
zero-padded to match.</p>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_107">References<a class="headerlink" href="#references_107" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] Rabiner, Lawrence R., and B. Gold. 'Theory and Application of
Digital Signal Processing' Prentice-Hall, pp. 414-419, 1975</p>
<h2 id="examples_422">Examples<a class="headerlink" href="#examples_422" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate two test signals with some common features.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 20
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
b, a = signal.butter(2, 0.25, 'low')
x = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
y = signal.lfilter(b, a, x)
x += amp<em>np.sin(2</em>np.pi<em>freq</em>time)
y += np.random.normal(scale=0.1*np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the magnitude of the cross spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxy = signal.csd(x, y, fs, nperseg=1024)
plt.semilogy(f, np.abs(Pxy))
plt.xlabel('frequency [Hz]')
plt.ylabel('CSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cspline1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">lamb</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute cubic spline coefficients for rank-1 array.</p>
<p>Find the cubic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 4.0, 1.0]/ 6.0 .</p>
<h2 id="parameters_504">Parameters<a class="headerlink" href="#parameters_504" title="Permanent link">&para;</a></h2>
<p>signal : ndarray
A rank-1 array representing samples of a signal.
lamb : float, optional
Smoothing coefficient, default is 0.0.</p>
<h2 id="returns_483">Returns<a class="headerlink" href="#returns_483" title="Permanent link">&para;</a></h2>
<p>c : ndarray
Cubic spline coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cspline1d_eval</span> <span class="o">:</span> <span class="o">?</span><span class="n">dx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cj</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">newx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a spline at the new set of points.</p>
<p><code>dx</code> is the old sample-spacing while <code>x0</code> was the old origin.  In
other-words the old-sample points (knot-points) for which the <code>cj</code>
represent spline coefficients were at equally-spaced points of:</p>
<p>oldx = x0 + j*dx  j=0...N-1, with N=len(cj)</p>
<p>Edges are handled using mirror-symmetric boundary conditions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cubic</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A cubic B-spline.</p>
<p>This is a special case of <code>bspline</code>, and equivalent to <code>bspline(x, 3)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cwt</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">wavelet</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">widths</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Continuous wavelet transform.</p>
<p>Performs a continuous wavelet transform on <code>data</code>,
using the <code>wavelet</code> function. A CWT performs a convolution
with <code>data</code> using the <code>wavelet</code> function, which is characterized
by a width parameter and length parameter. The <code>wavelet</code> function
is allowed to be complex.</p>
<h2 id="parameters_505">Parameters<a class="headerlink" href="#parameters_505" title="Permanent link">&para;</a></h2>
<p>data : (N,) ndarray
data on which to perform the transform.
wavelet : function
Wavelet function, which should take 2 arguments.
The first argument is the number of points that the returned vector
will have (len(wavelet(length,width)) == length).
The second is a width parameter, defining the size of the wavelet
(e.g. standard deviation of a gaussian). See <code>ricker</code>, which
satisfies these requirements.
widths : (M,) sequence
Widths to use for transform.
dtype : data-type, optional
The desired data type of output. Defaults to <code>float64</code> if the
output of <code>wavelet</code> is real and <code>complex128</code> if it is complex.</p>
<p>.. versionadded:: 1.4.0</p>
<p>kwargs
Keyword arguments passed to wavelet function.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_484">Returns<a class="headerlink" href="#returns_484" title="Permanent link">&para;</a></h2>
<p>cwt: (M, N) ndarray
Will have shape of (len(widths), len(data)).</p>
<h2 id="notes_328">Notes<a class="headerlink" href="#notes_328" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<p>For non-symmetric, complex-valued wavelets, the input signal is convolved
with the time-reversed complex-conjugate of the wavelet data [1].</p>
<p>::</p>
<p>length = min(10 * width[ii], len(data))
cwt[ii,:] = signal.convolve(data, np.conj(wavelet(length, width[ii],
**kwargs))[::-1], mode='same')</p>
<h2 id="references_108">References<a class="headerlink" href="#references_108" title="Permanent link">&para;</a></h2>
<p>.. [1] S. Mallat, 'A Wavelet Tour of Signal Processing (3rd Edition)',
Academic Press, 2009.</p>
<h2 id="examples_423">Examples<a class="headerlink" href="#examples_423" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 200, endpoint=False)
sig  = np.cos(2 * np.pi * 7 * t) + signal.gausspulse(t - 0.4, fc=2)
widths = np.arange(1, 31)
cwtmatr = signal.cwt(sig, signal.ricker, widths)
plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',
...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">daub</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>The coefficients for the FIR low-pass filter producing Daubechies wavelets.</p>
<p>p&gt;=1 gives the order of the zero at f=1/2.
There are 2p filter coefficients.</p>
<h2 id="parameters_506">Parameters<a class="headerlink" href="#parameters_506" title="Permanent link">&para;</a></h2>
<p>p : int
Order of the zero at f=1/2, can have values from 1 to 34.</p>
<h2 id="returns_485">Returns<a class="headerlink" href="#returns_485" title="Permanent link">&para;</a></h2>
<p>daub : ndarray
Return</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dbode</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate Bode magnitude and phase data of a discrete-time system.</p>
<h2 id="parameters_507">Parameters<a class="headerlink" href="#parameters_507" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>dlti</code>)</li>
<li>2 (num, den, dt)</li>
<li>3 (zeros, poles, gain, dt)</li>
<li>4 (A, B, C, D, dt)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_486">Returns<a class="headerlink" href="#returns_486" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/time_unit]
mag : 1D ndarray
Magnitude array [dB]
phase : 1D ndarray
Phase array [deg]</p>
<h2 id="notes_329">Notes<a class="headerlink" href="#notes_329" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>z^2 + 3z + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_424">Examples<a class="headerlink" href="#examples_424" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3)</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Equivalent: sys.bode()</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, mag, phase = signal.dbode(sys)</p>
<p>plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">decimate</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:[`</span><span class="nc">Fir</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iir</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_dlti_instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zero_phase</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Downsample the signal after applying an anti-aliasing filter.</p>
<p>By default, an order 8 Chebyshev type I filter is used. A 30 point FIR
filter with Hamming window is used if <code>ftype</code> is 'fir'.</p>
<h2 id="parameters_508">Parameters<a class="headerlink" href="#parameters_508" title="Permanent link">&para;</a></h2>
<p>x : array_like
The signal to be downsampled, as an N-dimensional array.
q : int
The downsampling factor. When using IIR downsampling, it is recommended
to call <code>decimate</code> multiple times for downsampling factors higher than
13.
n : int, optional
The order of the filter (1 less than the length for 'fir'). Defaults to
8 for 'iir' and 20 times the downsampling factor for 'fir'.
ftype : str {'iir', 'fir'} or <code>dlti</code> instance, optional
If 'iir' or 'fir', specifies the type of lowpass filter. If an instance
of an <code>dlti</code> object, uses that object to filter before downsampling.
axis : int, optional
The axis along which to decimate.
zero_phase : bool, optional
Prevent phase shift by filtering with <code>filtfilt</code> instead of <code>lfilter</code>
when using an IIR filter, and shifting the outputs back by the filter's
group delay when using an FIR filter. The default value of <code>True</code> is
recommended, since a phase shift is generally not desired.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="returns_487">Returns<a class="headerlink" href="#returns_487" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The down-sampled signal.</p>
<h2 id="see-also_332">See Also<a class="headerlink" href="#see-also_332" title="Permanent link">&para;</a></h2>
<p>resample : Resample up or down using the FFT method.
resample_poly : Resample using polyphase filtering and an FIR filter.</p>
<h2 id="notes_330">Notes<a class="headerlink" href="#notes_330" title="Permanent link">&para;</a></h2>
<p>The <code>zero_phase</code> keyword was added in 0.18.0.
The possibility to use instances of <code>dlti</code> as <code>ftype</code> was added in
0.18.0.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">deconvolve</span> <span class="o">:</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">divisor</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Deconvolves <code>divisor</code> out of <code>signal</code> using inverse filtering.</p>
<p>Returns the quotient and remainder such that
<code>signal = convolve(divisor, quotient) + remainder</code></p>
<h2 id="parameters_509">Parameters<a class="headerlink" href="#parameters_509" title="Permanent link">&para;</a></h2>
<p>signal : array_like
Signal data, typically a recorded signal
divisor : array_like
Divisor data, typically an impulse response or filter that was
applied to the original signal</p>
<h2 id="returns_488">Returns<a class="headerlink" href="#returns_488" title="Permanent link">&para;</a></h2>
<p>quotient : ndarray
Quotient, typically the recovered original signal
remainder : ndarray
Remainder</p>
<h2 id="examples_425">Examples<a class="headerlink" href="#examples_425" title="Permanent link">&para;</a></h2>
<p>Deconvolve a signal that's been filtered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
original = [0, 1, 0, 0, 1, 1, 0, 0]
impulse_response = [2, 1]
recorded = signal.convolve(impulse_response, original)
recorded
array([0, 2, 1, 0, 2, 3, 1, 0, 0])
recovered, remainder = signal.deconvolve(recorded, impulse_response)
recovered
array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_333">See Also<a class="headerlink" href="#see-also_333" title="Permanent link">&para;</a></h2>
<p>numpy.polydiv : performs polynomial division (same operation, but
also accepts poly1d objects)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">detrend</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Linear</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Constant</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_data</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Remove linear trend along axis from data.</p>
<h2 id="parameters_510">Parameters<a class="headerlink" href="#parameters_510" title="Permanent link">&para;</a></h2>
<p>data : array_like
The input data.
axis : int, optional
The axis along which to detrend the data. By default this is the
last axis (-1).
type : {'linear', 'constant'}, optional
The type of detrending. If <code>type == 'linear'</code> (default),
the result of a linear least-squares fit to <code>data</code> is subtracted
from <code>data</code>.
If <code>type == 'constant'</code>, only the mean of <code>data</code> is subtracted.
bp : array_like of ints, optional
A sequence of break points. If given, an individual linear fit is
performed for each part of <code>data</code> between two break points.
Break points are specified as indices into <code>data</code>.
overwrite_data : bool, optional
If True, perform in place detrending and avoid a copy. Default is False</p>
<h2 id="returns_489">Returns<a class="headerlink" href="#returns_489" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
The detrended input data.</p>
<h2 id="examples_426">Examples<a class="headerlink" href="#examples_426" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
randgen = np.random.RandomState(9)
npoints = 1000
noise = randgen.randn(npoints)
x = 3 + 2*np.linspace(0, 1, npoints) + noise
(signal.detrend(x) - noise).max() &lt; 0.01
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dfreqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the frequency response of a discrete-time system.</p>
<h2 id="parameters_511">Parameters<a class="headerlink" href="#parameters_511" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>dlti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>dlti</code>)</li>
<li>2 (numerator, denominator, dt)</li>
<li>3 (zeros, poles, gain, dt)</li>
<li>4 (A, B, C, D, dt)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in radians/sample). Magnitude and phase data is
calculated for every value in this array. If not given a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.
whole : bool, optional
Normally, if 'w' is not given, frequencies are computed from 0 to the
Nyquist frequency, pi radians/sample (upper-half of unit-circle). If
<code>whole</code> is True, compute frequencies from 0 to 2*pi radians/sample.</p>
<h2 id="returns_490">Returns<a class="headerlink" href="#returns_490" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [radians/sample]
H : 1D ndarray
Array of complex magnitude values</p>
<h2 id="notes_331">Notes<a class="headerlink" href="#notes_331" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>z^2 + 3z + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_427">Examples<a class="headerlink" href="#examples_427" title="Permanent link">&para;</a></h2>
<p>Generating the Nyquist plot of a transfer function</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(z) = 1 / (z^2 + 2z + 3)</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05)</p>
<p>w, H = signal.dfreqresp(sys)</p>
<p>plt.figure()
plt.plot(H.real, H.imag, 'b')
plt.plot(H.real, -H.imag, 'r')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dimpulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of discrete-time system.</p>
<h2 id="parameters_512">Parameters<a class="headerlink" href="#parameters_512" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like or instance of <code>dlti</code>
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>x0 : array_like, optional
Initial state-vector.  Defaults to zero.
t : array_like, optional
Time points.  Computed if not given.
n : int, optional
The number of time points to compute (if <code>t</code> is not given).</p>
<h2 id="returns_491">Returns<a class="headerlink" href="#returns_491" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Time values for the output, as a 1-D array.
yout : tuple of ndarray
Impulse response of system.  Each element of the tuple represents
the output of the system based on an impulse in each input.</p>
<h2 id="see-also_334">See Also<a class="headerlink" href="#see-also_334" title="Permanent link">&para;</a></h2>
<p>impulse, dstep, dlsim, cont2discrete</p>
<h2 id="examples_428">Examples<a class="headerlink" href="#examples_428" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>butter = signal.dlti( *signal.butter(3, 0.5))
t, y = signal.dimpulse(butter, n=25)
plt.step(t, np.squeeze(y))
plt.grid()
plt.xlabel('n [samples]')
plt.ylabel('Amplitude')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dlsim</span> <span class="o">:</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a discrete-time linear system.</p>
<h2 id="parameters_513">Parameters<a class="headerlink" href="#parameters_513" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like or instance of <code>dlti</code>
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>u : array_like
An input array describing the input at each time <code>t</code> (interpolation is
assumed between given times).  If there are multiple inputs, then each
column of the rank-2 array represents an input.
t : array_like, optional
The time steps at which the input is defined.  If <code>t</code> is given, it
must be the same length as <code>u</code>, and the final value in <code>t</code> determines
the number of steps returned in the output.
x0 : array_like, optional
The initial conditions on the state vector (zero by default).</p>
<h2 id="returns_492">Returns<a class="headerlink" href="#returns_492" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Time values for the output, as a 1-D array.
yout : ndarray
System response, as a 1-D array.
xout : ndarray, optional
Time-evolution of the state-vector.  Only generated if the input is a
<code>StateSpace</code> system.</p>
<h2 id="see-also_335">See Also<a class="headerlink" href="#see-also_335" title="Permanent link">&para;</a></h2>
<p>lsim, dstep, dimpulse, cont2discrete</p>
<h2 id="examples_429">Examples<a class="headerlink" href="#examples_429" title="Permanent link">&para;</a></h2>
<p>A simple integrator transfer function with a discrete time step of 1.0
could be implemented as:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
tf = ([1.0,], [1.0, -1.0], 1.0)
t_in = [0.0, 1.0, 2.0, 3.0]
u = np.asarray([0.0, 0.0, 1.0, 1.0])
t_out, y = signal.dlsim(tf, u, t=t_in)
y.T
array([[ 0.,  0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dstep</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of discrete-time system.</p>
<h2 id="parameters_514">Parameters<a class="headerlink" href="#parameters_514" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like
A tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>dlti</code>)</li>
<li>3: (num, den, dt)</li>
<li>4: (zeros, poles, gain, dt)</li>
<li>5: (A, B, C, D, dt)</li>
</ul>
<p>x0 : array_like, optional
Initial state-vector.  Defaults to zero.
t : array_like, optional
Time points.  Computed if not given.
n : int, optional
The number of time points to compute (if <code>t</code> is not given).</p>
<h2 id="returns_493">Returns<a class="headerlink" href="#returns_493" title="Permanent link">&para;</a></h2>
<p>tout : ndarray
Output time points, as a 1-D array.
yout : tuple of ndarray
Step response of system.  Each element of the tuple represents
the output of the system based on a step response to each input.</p>
<h2 id="see-also_336">See Also<a class="headerlink" href="#see-also_336" title="Permanent link">&para;</a></h2>
<p>step, dimpulse, dlsim, cont2discrete</p>
<h2 id="examples_430">Examples<a class="headerlink" href="#examples_430" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>butter = signal.dlti( *signal.butter(3, 0.5))
t, y = signal.dstep(butter, n=25)
plt.step(t, np.squeeze(y))
plt.grid()
plt.xlabel('n [samples]')
plt.ylabel('Amplitude')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellip</span> <span class="o">:</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Elliptic (Cauer) digital and analog filter design.</p>
<p>Design an Nth-order digital or analog elliptic filter and return
the filter coefficients.</p>
<h2 id="parameters_515">Parameters<a class="headerlink" href="#parameters_515" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
rp : float
The maximum ripple allowed below unity gain in the passband.
Specified in decibels, as a positive number.
rs : float
The minimum attenuation required in the stop band.
Specified in decibels, as a positive number.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.
For elliptic filters, this is the point in the transition band at
which the gain first drops below -<code>rp</code>.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
The type of filter.  Default is 'lowpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_494">Returns<a class="headerlink" href="#returns_494" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_337">See Also<a class="headerlink" href="#see-also_337" title="Permanent link">&para;</a></h2>
<p>ellipord, ellipap</p>
<h2 id="notes_332">Notes<a class="headerlink" href="#notes_332" title="Permanent link">&para;</a></h2>
<p>Also known as Cauer or Zolotarev filters, the elliptical filter maximizes
the rate of transition between the frequency response's passband and
stopband, at the expense of ripple in both, and increased ringing in the
step response.</p>
<p>As <code>rp</code> approaches 0, the elliptical filter becomes a Chebyshev
type II filter (<code>cheby2</code>).  As <code>rs</code> approaches 0, it becomes a Chebyshev
type I filter (<code>cheby1</code>).  As both approach 0, it becomes a Butterworth
filter (<code>butter</code>).</p>
<p>The equiripple passband has N maxima or minima (for example, a
5th-order filter has 3 maxima and 2 minima).  Consequently, the DC gain is
unity for odd-order filters, or -rp dB for even-order filters.</p>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_431">Examples<a class="headerlink" href="#examples_431" title="Permanent link">&para;</a></h2>
<p>Design an analog filter and plot its frequency response, showing the
critical points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True)
w, h = signal.freqs(b, a)
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Elliptic filter frequency response (rp=5, rs=40)')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.axhline(-40, color='green') # rs
plt.axhline(-5, color='green') # rp
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1, 1000, False)  # 1 second
sig = np.sin(2<em>np.pi</em>10<em>t) + np.sin(2</em>np.pi<em>20</em>t)
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)
ax1.plot(t, sig)
ax1.set_title('10 Hz and 20 Hz sinusoids')
ax1.axis([0, 1, -2, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and
apply it to the signal.  (It's recommended to use second-order sections
format when filtering, to avoid numerical error with transfer function
(<code>ba</code>) format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.ellip(8, 1, 100, 17, 'hp', fs=1000, output='sos')
filtered = signal.sosfilt(sos, sig)
ax2.plot(t, filtered)
ax2.set_title('After 17 Hz high-pass filter')
ax2.axis([0, 1, -2, 2])
ax2.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipap</span> <span class="o">:</span> <span class="n">n</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rs</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return (z,p,k) of Nth-order elliptic analog lowpass filter.</p>
<p>The filter is a normalized prototype that has <code>rp</code> decibels of ripple
in the passband and a stopband <code>rs</code> decibels down.</p>
<p>The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1,
defined as the point at which the gain first drops below <code>-rp</code>.</p>
<h2 id="see-also_338">See Also<a class="headerlink" href="#see-also_338" title="Permanent link">&para;</a></h2>
<p>ellip : Filter design function using this prototype</p>
<h2 id="references_109">References<a class="headerlink" href="#references_109" title="Permanent link">&para;</a></h2>
<p>.. [1] Lutova, Tosic, and Evans, 'Filter Design for Signal Processing',
Chapters 5 and 12.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ellipord</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Elliptic (Cauer) filter order selection.</p>
<p>Return the order of the lowest order digital or analog elliptic filter
that loses no more than <code>gpass</code> dB in the passband and has at least
<code>gstop</code> dB attenuation in the stopband.</p>
<h2 id="parameters_516">Parameters<a class="headerlink" href="#parameters_516" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.</p>
<p>For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>wp</code> and <code>ws</code> are thus in
half-cycles / sample.)  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_495">Returns<a class="headerlink" href="#returns_495" title="Permanent link">&para;</a></h2>
<p>ord : int
The lowest order for an Elliptic (Cauer) filter that meets specs.
wn : ndarray or float
The Chebyshev natural frequency (the '3dB frequency') for use with
<code>ellip</code> to give filter results. If <code>fs</code> is specified,
this is in the same units, and <code>fs</code> must also be passed to <code>ellip</code>.</p>
<h2 id="see-also_339">See Also<a class="headerlink" href="#see-also_339" title="Permanent link">&para;</a></h2>
<p>ellip : Filter design using order and critical points
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord
iirfilter : General filter design using order and critical frequencies
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="examples_432">Examples<a class="headerlink" href="#examples_432" title="Permanent link">&para;</a></h2>
<p>Design an analog highpass filter such that the passband is within 3 dB
above 30 rad/s, while rejecting -60 dB at 10 rad/s.  Plot its
frequency response, showing the passband and stopband constraints in gray.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>N, Wn = signal.ellipord(30, 10, 3, 60, True)
b, a = signal.ellip(N, 3, 60, Wn, 'high', True)
w, h = signal.freqs(b, a, np.logspace(0, 3, 500))
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Elliptical highpass filter fit to constraints')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop
plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass
plt.axis([1, 300, -80, 3])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">exponential</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return an exponential (or Poisson) window.</p>
<p>.. warning:: scipy.signal.exponential is deprecated,
use scipy.signal.windows.exponential instead.</p>
<h2 id="parameters_517">Parameters<a class="headerlink" href="#parameters_517" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
center : float, optional
Parameter defining the center location of the window function.
The default value if not given is <code>center = (M-1) / 2</code>.  This
parameter must take its default value for symmetric windows.
tau : float, optional
Parameter defining the decay.  For <code>center = 0</code> use
<code>tau = -(M-1) / ln(x)</code> if <code>x</code> is the fraction of the window
remaining at the end.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_496">Returns<a class="headerlink" href="#returns_496" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_333">Notes<a class="headerlink" href="#notes_333" title="Permanent link">&para;</a></h2>
<p>The Exponential window is defined as</p>
<p>.. math::  w(n) = e^{-|n-center| / \tau}</p>
<h2 id="references_110">References<a class="headerlink" href="#references_110" title="Permanent link">&para;</a></h2>
<p>S. Gade and H. Herlufsen, 'Windows to FFT analysis (Part I)',
Technical Review 3, Bruel &amp; Kjaer, 1987.</p>
<h2 id="examples_433">Examples<a class="headerlink" href="#examples_433" title="Permanent link">&para;</a></h2>
<p>Plot the symmetric window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>M = 51
tau = 3.0
window = signal.exponential(M, tau=tau)
plt.plot(window)
plt.title('Exponential Window (tau=3.0)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -35, 0])
plt.title('Frequency response of the Exponential window (tau=3.0)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<p>This function can also generate non-symmetric windows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>tau2 = -(M-1) / np.log(0.01)
window2 = signal.exponential(M, 0, tau2, False)
plt.figure()
plt.plot(window2)
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fftconvolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays using FFT.</p>
<p>Convolve <code>in1</code> and <code>in2</code> using the fast Fourier transform method, with
the output size determined by the <code>mode</code> argument.</p>
<p>This is generally much faster than <code>convolve</code> for large arrays (n &gt; ~500),
but can be slower when only a few output values are needed, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<p>As of v0.19, <code>convolve</code> automatically chooses this method or the direct
method based on an estimation of which is faster.</p>
<h2 id="parameters_518">Parameters<a class="headerlink" href="#parameters_518" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
axes : int or array_like of ints or None, optional
Axes over which to compute the convolution.
The default is over all axes.</p>
<h2 id="returns_497">Returns<a class="headerlink" href="#returns_497" title="Permanent link">&para;</a></h2>
<p>out : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_340">See Also<a class="headerlink" href="#see-also_340" title="Permanent link">&para;</a></h2>
<p>convolve : Uses the direct convolution or FFT convolution algorithm
depending on which is faster.
oaconvolve : Uses the overlap-add method to do convolution, which is
generally faster when the input arrays are large and
significantly different in size.</p>
<h2 id="examples_434">Examples<a class="headerlink" href="#examples_434" title="Permanent link">&para;</a></h2>
<p>Autocorrelation of white noise is an impulse.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.random.randn(1000)
autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
ax_orig.plot(sig)
ax_orig.set_title('White noise')
ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)
ax_mag.set_title('Autocorrelation')
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Gaussian blur implemented using FFT convolution.  Notice the dark borders
around the image, due to the zero-padding beyond its boundaries.
The <code>convolve2d</code> function allows for other types of image boundaries,
but is far slower.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import misc
face = misc.face(gray=True)
kernel = np.outer(signal.gaussian(70, 8), signal.gaussian(70, 8))
blurred = signal.fftconvolve(face, kernel, mode='same')</p>
<p>fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,
...                                                      figsize=(6, 15))
ax_orig.imshow(face, cmap='gray')
ax_orig.set_title('Original')
ax_orig.set_axis_off()
ax_kernel.imshow(kernel, cmap='gray')
ax_kernel.set_title('Gaussian kernel')
ax_kernel.set_axis_off()
ax_blurred.imshow(blurred, cmap='gray')
ax_blurred.set_title('Blurred')
ax_blurred.set_axis_off()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">filtfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">irlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply a digital filter forward and backward to a signal.</p>
<p>This function applies a linear digital filter twice, once forward and
once backwards.  The combined filter has zero phase and a filter order
twice that of the original.</p>
<p>The function provides options for handling the edges of the signal.</p>
<p>The function <code>sosfiltfilt</code> (and filter design using <code>output='sos'</code>)
should be preferred over <code>filtfilt</code> for most filtering tasks, as
second-order sections have fewer numerical problems.</p>
<h2 id="parameters_519">Parameters<a class="headerlink" href="#parameters_519" title="Permanent link">&para;</a></h2>
<p>b : (N,) array_like
The numerator coefficient vector of the filter.
a : (N,) array_like
The denominator coefficient vector of the filter.  If <code>a[0]</code>
is not 1, then both <code>a</code> and <code>b</code> are normalized by <code>a[0]</code>.
x : array_like
The array of data to be filtered.
axis : int, optional
The axis of <code>x</code> to which the filter is applied.
Default is -1.
padtype : str or None, optional
Must be 'odd', 'even', 'constant', or None.  This determines the
type of extension to use for the padded signal to which the filter
is applied.  If <code>padtype</code> is None, no padding is used.  The default
is 'odd'.
padlen : int or None, optional
The number of elements by which to extend <code>x</code> at both ends of
<code>axis</code> before applying the filter.  This value must be less than
<code>x.shape[axis] - 1</code>.  <code>padlen=0</code> implies no padding.
The default value is <code>3 * max(len(a), len(b))</code>.
method : str, optional
Determines the method for handling the edges of the signal, either
'pad' or 'gust'.  When <code>method</code> is 'pad', the signal is padded; the
type of padding is determined by <code>padtype</code> and <code>padlen</code>, and <code>irlen</code>
is ignored.  When <code>method</code> is 'gust', Gustafsson's method is used,
and <code>padtype</code> and <code>padlen</code> are ignored.
irlen : int or None, optional
When <code>method</code> is 'gust', <code>irlen</code> specifies the length of the
impulse response of the filter.  If <code>irlen</code> is None, no part
of the impulse response is ignored.  For a long signal, specifying
<code>irlen</code> can significantly improve the performance of the filter.</p>
<h2 id="returns_498">Returns<a class="headerlink" href="#returns_498" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The filtered output with the same shape as <code>x</code>.</p>
<h2 id="see-also_341">See Also<a class="headerlink" href="#see-also_341" title="Permanent link">&para;</a></h2>
<p>sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt</p>
<h2 id="notes_334">Notes<a class="headerlink" href="#notes_334" title="Permanent link">&para;</a></h2>
<p>When <code>method</code> is 'pad', the function pads the data along the given axis
in one of three ways: odd, even or constant.  The odd and even extensions
have the corresponding symmetry about the end point of the data.  The
constant extension extends the data with the values at the end points. On
both the forward and backward passes, the initial condition of the
filter is found by using <code>lfilter_zi</code> and scaling it by the end point of
the extended data.</p>
<p>When <code>method</code> is 'gust', Gustafsson's method [1]_ is used.  Initial
conditions are chosen for the forward and backward passes so that the
forward-backward filter gives the same result as the backward-forward
filter.</p>
<p>The option to use Gustaffson's method was added in scipy version 0.16.0.</p>
<h2 id="references_111">References<a class="headerlink" href="#references_111" title="Permanent link">&para;</a></h2>
<p>.. [1] F. Gustaffson, 'Determining the initial states in forward-backward
filtering', Transactions on Signal Processing, Vol. 46, pp. 988-992,
1996.</p>
<h2 id="examples_435">Examples<a class="headerlink" href="#examples_435" title="Permanent link">&para;</a></h2>
<p>The examples will use several functions from <code>scipy.signal</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we create a one second signal that is the sum of two pure sine
waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 1.0, 2001)
xlow = np.sin(2 * np.pi * 5 * t)
xhigh = np.sin(2 * np.pi * 250 * t)
x = xlow + xhigh</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now create a lowpass Butterworth filter with a cutoff of 0.125 times
the Nyquist frequency, or 125 Hz, and apply it to <code>x</code> with <code>filtfilt</code>.
The result should be approximately <code>xlow</code>, with no phase shift.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.butter(8, 0.125)
y = signal.filtfilt(b, a, x, padlen=150)
np.abs(y - xlow).max()
9.1086182074789912e-06</p>
</blockquote>
</blockquote>
</blockquote>
<p>We get a fairly clean result for this artificial example because
the odd extension is exact, and with the moderately long padding,
the filter's transients have dissipated by the time the actual data
is reached.  In general, transient effects at the edges are
unavoidable.</p>
<p>The following example demonstrates the option <code>method='gust'</code>.</p>
<p>First, create a filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.
np.random.seed(123456)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>sig</code> is a random input signal to be filtered.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 60
sig = np.random.randn(n)*<em>3 + 3</em>np.random.randn(n).cumsum()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply <code>filtfilt</code> to <code>sig</code>, once using the Gustafsson method, and
once using padding, and plot the results for comparison.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fgust = signal.filtfilt(b, a, sig, method='gust')
fpad = signal.filtfilt(b, a, sig, padlen=50)
plt.plot(sig, 'k-', label='input')
plt.plot(fgust, 'b-', linewidth=4, label='gust')
plt.plot(fpad, 'c-', linewidth=1.5, label='pad')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>irlen</code> argument can be used to improve the performance
of Gustafsson's method.</p>
<p>Estimate the impulse response length of the filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z, p, k = signal.tf2zpk(b, a)
eps = 1e-9
r = np.max(np.abs(p))
approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))
approx_impulse_len
137</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter to a longer signal, with and without the <code>irlen</code>
argument.  The difference between <code>y1</code> and <code>y2</code> is small.  For long
signals, using <code>irlen</code> gives a significant performance improvement.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.random.randn(5000)
y1 = signal.filtfilt(b, a, x, method='gust')
y2 = signal.filtfilt(b, a, x, method='gust', irlen=approx_impulse_len)
print(np.max(np.abs(y1 - y2)))
1.80056858312e-10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_peaks</span> <span class="o">:</span> <span class="o">?</span><span class="n">height</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">threshold</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distance</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prominence</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">width</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">wlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rel_height</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plateau_size</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Find peaks inside a signal based on peak properties.</p>
<p>This function takes a one-dimensional array and finds all local maxima by
simple comparison of neighbouring values. Optionally, a subset of these
peaks can be selected by specifying conditions for a peak's properties.</p>
<h2 id="parameters_520">Parameters<a class="headerlink" href="#parameters_520" title="Permanent link">&para;</a></h2>
<p>x : sequence
A signal with peaks.
height : number or ndarray or sequence, optional
Required height of peaks. Either a number, <code>None</code>, an array matching
<code>x</code> or a 2-element sequence of the former. The first element is
always interpreted as the  minimal and the second, if supplied, as the
maximal required height.
threshold : number or ndarray or sequence, optional
Required threshold of peaks, the vertical distance to its neighbouring
samples. Either a number, <code>None</code>, an array matching <code>x</code> or a
2-element sequence of the former. The first element is always
interpreted as the  minimal and the second, if supplied, as the maximal
required threshold.
distance : number, optional
Required minimal horizontal distance (&gt;= 1) in samples between
neighbouring peaks. Smaller peaks are removed first until the condition
is fulfilled for all remaining peaks.
prominence : number or ndarray or sequence, optional
Required prominence of peaks. Either a number, <code>None</code>, an array
matching <code>x</code> or a 2-element sequence of the former. The first
element is always interpreted as the  minimal and the second, if
supplied, as the maximal required prominence.
width : number or ndarray or sequence, optional
Required width of peaks in samples. Either a number, <code>None</code>, an array
matching <code>x</code> or a 2-element sequence of the former. The first
element is always interpreted as the  minimal and the second, if
supplied, as the maximal required width.
wlen : int, optional
Used for calculation of the peaks prominences, thus it is only used if
one of the arguments <code>prominence</code> or <code>width</code> is given. See argument
<code>wlen</code> in <code>peak_prominences</code> for a full description of its effects.
rel_height : float, optional
Used for calculation of the peaks width, thus it is only used if <code>width</code>
is given. See argument  <code>rel_height</code> in <code>peak_widths</code> for a full
description of its effects.
plateau_size : number or ndarray or sequence, optional
Required size of the flat top of peaks in samples. Either a number,
<code>None</code>, an array matching <code>x</code> or a 2-element sequence of the former.
The first element is always interpreted as the minimal and the second,
if supplied as the maximal required plateau size.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_499">Returns<a class="headerlink" href="#returns_499" title="Permanent link">&para;</a></h2>
<p>peaks : ndarray
Indices of peaks in <code>x</code> that satisfy all given conditions.
properties : dict
A dictionary containing properties of the returned peaks which were
calculated as intermediate results during evaluation of the specified
conditions:</p>
<ul>
<li>'peak_heights'
If <code>height</code> is given, the height of each peak in <code>x</code>.</li>
<li>'left_thresholds', 'right_thresholds'
If <code>threshold</code> is given, these keys contain a peaks vertical
distance to its neighbouring samples.</li>
<li>'prominences', 'right_bases', 'left_bases'
If <code>prominence</code> is given, these keys are accessible. See
<code>peak_prominences</code> for a description of their content.</li>
<li>'width_heights', 'left_ips', 'right_ips'
If <code>width</code> is given, these keys are accessible. See <code>peak_widths</code>
for a description of their content.</li>
<li>'plateau_sizes', left_edges', 'right_edges'
If <code>plateau_size</code> is given, these keys are accessible and contain
the indices of a peak's edges (edges are still part of the
plateau) and the calculated plateau sizes.</li>
</ul>
<p>.. versionadded:: 1.2.0</p>
<p>To calculate and return properties without excluding peaks, provide the
open interval <code>(None, None)</code> as a value to the appropriate argument
(excluding <code>distance</code>).</p>
<h2 id="warns">Warns<a class="headerlink" href="#warns" title="Permanent link">&para;</a></h2>
<p>PeakPropertyWarning
Raised if a peak's properties have unexpected values (see
<code>peak_prominences</code> and <code>peak_widths</code>).</p>
<h2 id="warnings">Warnings<a class="headerlink" href="#warnings" title="Permanent link">&para;</a></h2>
<p>This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.</p>
<h2 id="see-also_342">See Also<a class="headerlink" href="#see-also_342" title="Permanent link">&para;</a></h2>
<p>find_peaks_cwt
Find peaks using the wavelet transformation.
peak_prominences
Directly calculate the prominence of peaks.
peak_widths
Directly calculate the width of peaks.</p>
<h2 id="notes_335">Notes<a class="headerlink" href="#notes_335" title="Permanent link">&para;</a></h2>
<p>In the context of this function, a peak or local maximum is defined as any
sample whose two direct neighbours have a smaller amplitude. For flat peaks
(more than one sample of equal amplitude wide) the index of the middle
sample is returned (rounded down in case the number of samples is even).
For noisy signals the peak locations can be off because the noise might
change the position of local maxima. In those cases consider smoothing the
signal before searching for peaks or use other peak finding and fitting
methods (like <code>find_peaks_cwt</code>).</p>
<p>Some additional comments on specifying conditions:</p>
<ul>
<li>Almost all conditions (excluding <code>distance</code>) can be given as half-open or
closed intervals, e.g <code>1</code> or <code>(1, None)</code> defines the half-open
interval :math:<code>[1, \infty]</code> while <code>(None, 1)</code> defines the interval
:math:<code>[-\infty, 1]</code>. The open interval <code>(None, None)</code> can be specified
as well, which returns the matching properties without exclusion of peaks.</li>
<li>The border is always included in the interval used to select valid peaks.</li>
<li>For several conditions the interval borders can be specified with
arrays matching <code>x</code> in shape which enables dynamic constrains based on
the sample position.</li>
<li>The conditions are evaluated in the following order: <code>plateau_size</code>,
<code>height</code>, <code>threshold</code>, <code>distance</code>, <code>prominence</code>, <code>width</code>. In most cases
this order is the fastest one because faster operations are applied first
to reduce the number of peaks that need to be evaluated later.</li>
<li>While indices in <code>peaks</code> are guaranteed to be at least <code>distance</code> samples
apart, edges of flat peaks may be closer than the allowed <code>distance</code>.</li>
<li>Use <code>wlen</code> to reduce the time it takes to evaluate the conditions for
<code>prominence</code> or <code>width</code> if <code>x</code> is large or has many local maxima
(see <code>peak_prominences</code>).</li>
</ul>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_436">Examples<a class="headerlink" href="#examples_436" title="Permanent link">&para;</a></h2>
<p>To demonstrate this function's usage we use a signal <code>x</code> supplied with
SciPy (see <code>scipy.misc.electrocardiogram</code>). Let's find all peaks (local
maxima) in <code>x</code> whose amplitude lies above 0.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy.misc import electrocardiogram
from scipy.signal import find_peaks
x = electrocardiogram()[2000:4000]
peaks, _ = find_peaks(x, height=0)
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.plot(np.zeros_like(x), '--', color='gray')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can select peaks below 0 with <code>height=(None, 0)</code> or use arrays matching
<code>x</code> in size to reflect a changing condition for different parts of the
signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>border = np.sin(np.linspace(0, 3 * np.pi, x.size))
peaks, _ = find_peaks(x, height=(-border, border))
plt.plot(x)
plt.plot(-border, '--', color='gray')
plt.plot(border, ':', color='gray')
plt.plot(peaks, x[peaks], 'x')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Another useful condition for periodic signals can be given with the
<code>distance</code> argument. In this case we can easily select the positions of
QRS complexes within the electrocardiogram (ECG) by demanding a distance of
at least 150 samples.</p>
<blockquote>
<blockquote>
<blockquote>
<p>peaks, _ = find_peaks(x, distance=150)
np.diff(peaks)
array([186, 180, 177, 171, 177, 169, 167, 164, 158, 162, 172])
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Especially for noisy signals peaks can be easily grouped by their
prominence (see <code>peak_prominences</code>). E.g. we can select all peaks except
for the mentioned QRS complexes by limiting the allowed prominence to 0.6.</p>
<blockquote>
<blockquote>
<blockquote>
<p>peaks, properties = find_peaks(x, prominence=(None, 0.6))
properties['prominences'].max()
0.5049999999999999
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>And finally let's examine a different section of the ECG which contains
beat forms of different shape. To select only the atypical heart beats we
combine two conditions: a minimal prominence of 1 and width of at least 20
samples.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = electrocardiogram()[17000:18000]
peaks, properties = find_peaks(x, prominence=1, width=20)
properties['prominences'], properties['widths']
(array([1.495, 2.3  ]), array([36.93773946, 39.32723577]))
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.vlines(x=peaks, ymin=x[peaks] - properties['prominences'],
...            ymax = x[peaks], color = 'C1')
plt.hlines(y=properties['width_heights'], xmin=properties['left_ips'],
...            xmax=properties['right_ips'], color = 'C1')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_peaks_cwt</span> <span class="o">:</span> <span class="o">?</span><span class="n">wavelet</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_distances</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">gap_thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">min_length</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">min_snr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noise_perc</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">vector</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">widths</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find peaks in a 1-D array with wavelet transformation.</p>
<p>The general approach is to smooth <code>vector</code> by convolving it with
<code>wavelet(width)</code> for each width in <code>widths</code>. Relative maxima which
appear at enough length scales, and with sufficiently high SNR, are
accepted.</p>
<h2 id="parameters_521">Parameters<a class="headerlink" href="#parameters_521" title="Permanent link">&para;</a></h2>
<p>vector : ndarray
1-D array in which to find the peaks.
widths : sequence
1-D array of widths to use for calculating the CWT matrix. In general,
this range should cover the expected width of peaks of interest.
wavelet : callable, optional
Should take two parameters and return a 1-D array to convolve
with <code>vector</code>. The first parameter determines the number of points
of the returned wavelet array, the second parameter is the scale
(<code>width</code>) of the wavelet. Should be normalized and symmetric.
Default is the ricker wavelet.
max_distances : ndarray, optional
At each row, a ridge line is only connected if the relative max at
row[n] is within <code>max_distances[n]</code> from the relative max at
<code>row[n+1]</code>.  Default value is <code>widths/4</code>.
gap_thresh : float, optional
If a relative maximum is not found within <code>max_distances</code>,
there will be a gap. A ridge line is discontinued if there are more
than <code>gap_thresh</code> points without connecting a new relative maximum.
Default is the first value of the widths array i.e. widths[0].
min_length : int, optional
Minimum length a ridge line needs to be acceptable.
Default is <code>cwt.shape[0] / 4</code>, ie 1/4-th the number of widths.
min_snr : float, optional
Minimum SNR ratio. Default 1. The signal is the value of
the cwt matrix at the shortest length scale (<code>cwt[0, loc]</code>), the
noise is the <code>noise_perc</code>th percentile of datapoints contained within a
window of <code>window_size</code> around <code>cwt[0, loc]</code>.
noise_perc : float, optional
When calculating the noise floor, percentile of data points
examined below which to consider noise. Calculated using
<code>stats.scoreatpercentile</code>.  Default is 10.</p>
<h2 id="returns_500">Returns<a class="headerlink" href="#returns_500" title="Permanent link">&para;</a></h2>
<p>peaks_indices : ndarray
Indices of the locations in the <code>vector</code> where peaks were found.
The list is sorted.</p>
<h2 id="see-also_343">See Also<a class="headerlink" href="#see-also_343" title="Permanent link">&para;</a></h2>
<p>cwt
Continuous wavelet transform.
find_peaks
Find peaks inside a signal based on peak properties.</p>
<h2 id="notes_336">Notes<a class="headerlink" href="#notes_336" title="Permanent link">&para;</a></h2>
<p>This approach was designed for finding sharp peaks among noisy data,
however with proper parameter selection it should function well for
different peak shapes.</p>
<p>The algorithm is as follows:
1. Perform a continuous wavelet transform on <code>vector</code>, for the supplied
<code>widths</code>. This is a convolution of <code>vector</code> with <code>wavelet(width)</code> for
each width in <code>widths</code>. See <code>cwt</code>
2. Identify 'ridge lines' in the cwt matrix. These are relative maxima
at each row, connected across adjacent rows. See identify_ridge_lines
3. Filter the ridge_lines using filter_ridge_lines.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_112">References<a class="headerlink" href="#references_112" title="Permanent link">&para;</a></h2>
<p>.. [1] Bioinformatics (2006) 22 (17): 2059-2065.
:doi:<code>10.1093/bioinformatics/btl355</code>
http://bioinformatics.oxfordjournals.org/content/22/17/2059.long</p>
<h2 id="examples_437">Examples<a class="headerlink" href="#examples_437" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
xs = np.arange(0, np.pi, 0.05)
data = np.sin(xs)
peakind = signal.find_peaks_cwt(data, np.arange(1,10))
peakind, xs[peakind], data[peakind]
([32], array([ 1.6]), array([ 0.9995736]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">findfreqs</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">den</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find array of frequencies for computing the response of an analog filter.</p>
<h2 id="parameters_522">Parameters<a class="headerlink" href="#parameters_522" title="Permanent link">&para;</a></h2>
<p>num, den : array_like, 1-D
The polynomial coefficients of the numerator and denominator of the
transfer function of the filter or LTI system, where the coefficients
are ordered from highest to lowest degree. Or, the roots  of the
transfer function numerator and denominator (i.e. zeroes and poles).
N : int
The length of the array to be computed.
kind : str {'ba', 'zp'}, optional
Specifies whether the numerator and denominator are specified by their
polynomial coefficients ('ba'), or their roots ('zp').</p>
<h2 id="returns_501">Returns<a class="headerlink" href="#returns_501" title="Permanent link">&para;</a></h2>
<p>w : (N,) ndarray
A 1-D array of frequencies, logarithmically spaced.</p>
<h2 id="examples_438">Examples<a class="headerlink" href="#examples_438" title="Permanent link">&para;</a></h2>
<p>Find a set of nine frequencies that span the 'interesting part' of the
frequency response for the filter with the transfer function</p>
<p>H(s) = s / (s^2 + 8s + 25)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.findfreqs([1, 0], [1, 8, 25], N=9)
array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01,
3.16227766e-01,   1.00000000e+00,   3.16227766e+00,
1.00000000e+01,   3.16227766e+01,   1.00000000e+02])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firls</span> <span class="o">:</span> <span class="o">?</span><span class="n">weight</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">bands</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">desired</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using least-squares error minimization.</p>
<p>Calculate the filter coefficients for the linear-phase finite
impulse response (FIR) filter which has the best approximation
to the desired frequency response described by <code>bands</code> and
<code>desired</code> in the least squares sense (i.e., the integral of the
weighted mean-squared error within the specified bands is
minimized).</p>
<h2 id="parameters_523">Parameters<a class="headerlink" href="#parameters_523" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.  <code>numtaps</code> must be odd.
bands : array_like
A monotonic nondecreasing sequence containing the band edges in
Hz. All elements must be non-negative and less than or equal to
the Nyquist frequency given by <code>nyq</code>.
desired : array_like
A sequence the same size as <code>bands</code> containing the desired gain
at the start and end point of each band.
weight : array_like, optional
A relative weighting to give to each band region when solving
the least squares problem. <code>weight</code> has to be half the size of
<code>bands</code>.
nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>
Nyquist frequency. Each frequency in <code>bands</code> must be between 0
and <code>nyq</code> (inclusive).  Default is 1.
fs : float, optional
The sampling frequency of the signal. Each frequency in <code>bands</code>
must be between 0 and <code>fs/2</code> (inclusive).  Default is 2.</p>
<h2 id="returns_502">Returns<a class="headerlink" href="#returns_502" title="Permanent link">&para;</a></h2>
<p>coeffs : ndarray
Coefficients of the optimal (in a least squares sense) FIR filter.</p>
<h2 id="see-also_344">See also<a class="headerlink" href="#see-also_344" title="Permanent link">&para;</a></h2>
<p>firwin
firwin2
minimum_phase
remez</p>
<h2 id="notes_337">Notes<a class="headerlink" href="#notes_337" title="Permanent link">&para;</a></h2>
<p>This implementation follows the algorithm given in [1]_.
As noted there, least squares design has multiple advantages:</p>
<ol>
<li>Optimal in a least-squares sense.</li>
<li>Simple, non-iterative method.</li>
<li>The general solution can obtained by solving a linear
system of equations.</li>
<li>Allows the use of a frequency dependent weighting function.</li>
</ol>
<p>This function constructs a Type I linear phase FIR filter, which
contains an odd number of <code>coeffs</code> satisfying for :math:<code>n &lt; numtaps</code>:</p>
<p>.. math:: coeffs(n) = coeffs(numtaps - 1 - n)</p>
<p>The odd number of coefficients and filter symmetry avoid boundary
conditions that could otherwise occur at the Nyquist and 0 frequencies
(e.g., for Type II, III, or IV variants).</p>
<p>.. versionadded:: 0.18</p>
<h2 id="references_113">References<a class="headerlink" href="#references_113" title="Permanent link">&para;</a></h2>
<p>.. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares.
OpenStax CNX. Aug 9, 2005.
http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7</p>
<h2 id="examples_439">Examples<a class="headerlink" href="#examples_439" title="Permanent link">&para;</a></h2>
<p>We want to construct a band-pass filter. Note that the behavior in the
frequency ranges between our stop bands and pass bands is unspecified,
and thus may overshoot depending on the parameters of our filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
fig, axs = plt.subplots(2)
fs = 10.0  # Hz
desired = (0, 0, 1, 1, 0, 0)
for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):
...     fir_firls = signal.firls(73, bands, desired, fs=fs)
...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs)
...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs)
...     hs = list()
...     ax = axs[bi]
...     for fir in (fir_firls, fir_remez, fir_firwin2):
...         freq, response = signal.freqz(fir)
...         hs.append(ax.semilogy(0.5<em>fs</em>freq/np.pi, np.abs(response))[0])
...     for band, gains in zip(zip(bands[::2], bands[1::2]),
...                            zip(desired[::2], desired[1::2])):
...         ax.semilogy(band, np.maximum(gains, 1e-7), 'k--', linewidth=2)
...     if bi == 0:
...         ax.legend(hs, ('firls', 'remez', 'firwin2'),
...                   loc='lower center', frameon=False)
...     else:
...         ax.set_xlabel('Frequency (Hz)')
...     ax.grid(True)
...     ax.set(title='Band-pass %d-%d Hz' % bands[2:4], ylabel='Magnitude')
...
fig.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firwin</span> <span class="o">:</span> <span class="o">?</span><span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple_of_string_and_parameter_values</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pass_zero</span><span class="o">:[`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandpass</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">cutoff</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T1D_array_like</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using the window method.</p>
<p>This function computes the coefficients of a finite impulse response
filter.  The filter will have linear phase; it will be Type I if
<code>numtaps</code> is odd and Type II if <code>numtaps</code> is even.</p>
<p>Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with <code>numtaps</code> even and
having a passband whose right end is at the Nyquist frequency.</p>
<h2 id="parameters_524">Parameters<a class="headerlink" href="#parameters_524" title="Permanent link">&para;</a></h2>
<p>numtaps : int
Length of the filter (number of coefficients, i.e. the filter
order + 1).  <code>numtaps</code> must be odd if a passband includes the
Nyquist frequency.
cutoff : float or 1D array_like
Cutoff frequency of filter (expressed in the same units as <code>fs</code>)
OR an array of cutoff frequencies (that is, band edges). In the
latter case, the frequencies in <code>cutoff</code> should be positive and
monotonically increasing between 0 and <code>fs/2</code>.  The values 0 and
<code>fs/2</code> must not be included in <code>cutoff</code>.
width : float or None, optional
If <code>width</code> is not None, then assume it is the approximate width
of the transition region (expressed in the same units as <code>fs</code>)
for use in Kaiser FIR filter design.  In this case, the <code>window</code>
argument is ignored.
window : string or tuple of string and parameter values, optional
Desired window to use. See <code>scipy.signal.get_window</code> for a list
of windows and required parameters.
pass_zero : {True, False, 'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
If True, the gain at the frequency 0 (i.e. the 'DC gain') is 1.
If False, the DC gain is 0. Can also be a string argument for the
desired filter type (equivalent to <code>btype</code> in IIR design functions).</p>
<p>.. versionadded:: 1.3.0
Support for string arguments.
scale : bool, optional
Set to True to scale the coefficients so that the frequency
response is exactly unity at a certain frequency.
That frequency is either:</p>
<ul>
<li>0 (DC) if the first passband starts at 0 (i.e. pass_zero
is True)</li>
<li><code>fs/2</code> (the Nyquist frequency) if the first passband ends at
<code>fs/2</code> (i.e the filter is a single band highpass filter);
center of first passband otherwise</li>
</ul>
<p>nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>  This is the Nyquist frequency.
Each frequency in <code>cutoff</code> must be between 0 and <code>nyq</code>. Default
is 1.
fs : float, optional
The sampling frequency of the signal.  Each frequency in <code>cutoff</code>
must be between 0 and <code>fs/2</code>.  Default is 2.</p>
<h2 id="returns_503">Returns<a class="headerlink" href="#returns_503" title="Permanent link">&para;</a></h2>
<p>h : (numtaps,) ndarray
Coefficients of length <code>numtaps</code> FIR filter.</p>
<h2 id="raises_79">Raises<a class="headerlink" href="#raises_79" title="Permanent link">&para;</a></h2>
<p>ValueError
If any value in <code>cutoff</code> is less than or equal to 0 or greater
than or equal to <code>fs/2</code>, if the values in <code>cutoff</code> are not strictly
monotonically increasing, or if <code>numtaps</code> is even but a passband
includes the Nyquist frequency.</p>
<h2 id="see-also_345">See Also<a class="headerlink" href="#see-also_345" title="Permanent link">&para;</a></h2>
<p>firwin2
firls
minimum_phase
remez</p>
<h2 id="examples_440">Examples<a class="headerlink" href="#examples_440" title="Permanent link">&para;</a></h2>
<p>Low-pass from 0 to f:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
numtaps = 3
f = 0.1
signal.firwin(numtaps, f)
array([ 0.06799017,  0.86401967,  0.06799017])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use a specific window function:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, window='nuttall')
array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</p>
</blockquote>
</blockquote>
</blockquote>
<p>High-pass ('stop' from 0 to f):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, f, pass_zero=False)
array([-0.00859313,  0.98281375, -0.00859313])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-pass:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f1, f2 = 0.1, 0.2
signal.firwin(numtaps, [f1, f2], pass_zero=False)
array([ 0.06301614,  0.88770441,  0.06301614])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Band-stop:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2])
array([-0.00801395,  1.0160279 , -0.00801395])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>f3, f4 = 0.3, 0.4
signal.firwin(numtaps, [f1, f2, f3, f4])
array([-0.01376344,  1.02752689, -0.01376344])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multi-band (passbands are [f1, f2] and [f3,f4]):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)
array([ 0.04890915,  0.91284326,  0.04890915])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">firwin2</span> <span class="o">:</span> <span class="o">?</span><span class="n">nfreqs</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">T_string_float_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nyq</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">antisymmetric</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">freq</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T1D</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">gain</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>FIR filter design using the window method.</p>
<p>From the given frequencies <code>freq</code> and corresponding gains <code>gain</code>,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.</p>
<h2 id="parameters_525">Parameters<a class="headerlink" href="#parameters_525" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.  <code>numtaps</code> must be less than
<code>nfreqs</code>.
freq : array_like, 1D
The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
Nyquist.  The Nyquist frequency is half <code>fs</code>.
The values in <code>freq</code> must be nondecreasing.  A value can be repeated
once to implement a discontinuity.  The first value in <code>freq</code> must
be 0, and the last value must be <code>fs/2</code>. Values 0 and <code>fs/2</code> must
not be repeated.
gain : array_like
The filter gains at the frequency sampling points. Certain
constraints to gain values, depending on the filter type, are applied,
see Notes for details.
nfreqs : int, optional
The size of the interpolation mesh used to construct the filter.
For most efficient behavior, this should be a power of 2 plus 1
(e.g, 129, 257, etc).  The default is one more than the smallest
power of 2 that is not less than <code>numtaps</code>.  <code>nfreqs</code> must be greater
than <code>numtaps</code>.
window : string or (string, float) or float, or None, optional
Window function to use. Default is 'hamming'.  See
<code>scipy.signal.get_window</code> for the complete list of possible values.
If None, no window function is applied.
nyq : float, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>  This is the Nyquist frequency.
Each frequency in <code>freq</code> must be between 0 and <code>nyq</code>.  Default is 1.
antisymmetric : bool, optional
Whether resulting impulse response is symmetric/antisymmetric.
See Notes for more details.
fs : float, optional
The sampling frequency of the signal.  Each frequency in <code>cutoff</code>
must be between 0 and <code>fs/2</code>.  Default is 2.</p>
<h2 id="returns_504">Returns<a class="headerlink" href="#returns_504" title="Permanent link">&para;</a></h2>
<p>taps : ndarray
The filter coefficients of the FIR filter, as a 1-D array of length
<code>numtaps</code>.</p>
<h2 id="see-also_346">See also<a class="headerlink" href="#see-also_346" title="Permanent link">&para;</a></h2>
<p>firls
firwin
minimum_phase
remez</p>
<h2 id="notes_338">Notes<a class="headerlink" href="#notes_338" title="Permanent link">&para;</a></h2>
<p>From the given set of frequencies and gains, the desired response is
constructed in the frequency domain.  The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first <code>numtaps</code> coefficients of this kernel, scaled by <code>window</code>, are
returned.</p>
<p>The FIR filter will have linear phase. The type of filter is determined by
the value of 'numtaps<code>and</code>antisymmetric` flag.
There are four possible combinations:</p>
<ul>
<li>odd  <code>numtaps</code>, <code>antisymmetric</code> is False, type I filter is produced</li>
<li>even <code>numtaps</code>, <code>antisymmetric</code> is False, type II filter is produced</li>
<li>odd  <code>numtaps</code>, <code>antisymmetric</code> is True, type III filter is produced</li>
<li>even <code>numtaps</code>, <code>antisymmetric</code> is True, type IV filter is produced</li>
</ul>
<p>Magnitude response of all but type I filters are subjects to following
constraints:</p>
<ul>
<li>type II  -- zero at the Nyquist frequency</li>
<li>type III -- zero at zero and Nyquist frequencies</li>
<li>type IV  -- zero at zero frequency</li>
</ul>
<p>.. versionadded:: 0.9.0</p>
<h2 id="references_114">References<a class="headerlink" href="#references_114" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, A. V. and Schafer, R. W., 'Discrete-Time Signal
Processing', Prentice-Hall, Englewood Cliffs, New Jersey (1989).
(See, for example, Section 7.4.)</p>
<p>.. [2] Smith, Steven W., 'The Scientist and Engineer's Guide to Digital
Signal Processing', Ch. 17. http://www.dspguide.com/ch17/1.htm</p>
<h2 id="examples_441">Examples<a class="headerlink" href="#examples_441" title="Permanent link">&para;</a></h2>
<p>A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and
that decreases linearly on [0.5, 1.0] from 1 to 0:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])
print(taps[72:78])
[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flattop</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a flat top window.</p>
<p>.. warning:: scipy.signal.flattop is deprecated,
use scipy.signal.windows.flattop instead.</p>
<h2 id="parameters_526">Parameters<a class="headerlink" href="#parameters_526" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_505">Returns<a class="headerlink" href="#returns_505" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_339">Notes<a class="headerlink" href="#notes_339" title="Permanent link">&para;</a></h2>
<p>Flat top windows are used for taking accurate measurements of signal
amplitude in the frequency domain, with minimal scalloping error from the
center of a frequency bin to its edges, compared to others.  This is a
5th-order cosine window, with the 5 terms optimized to make the main lobe
maximally flat. [1]_</p>
<h2 id="references_115">References<a class="headerlink" href="#references_115" title="Permanent link">&para;</a></h2>
<p>.. [1] D'Antona, Gabriele, and A. Ferrero, 'Digital Signal Processing for
Measurement Systems', Springer Media, 2006, p. 70
:doi:<code>10.1007/0-387-28666-7</code>.</p>
<h2 id="examples_442">Examples<a class="headerlink" href="#examples_442" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.flattop(51)
plt.plot(window)
plt.title('Flat top window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the flat top window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqresp</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the frequency response of a continuous-time system.</p>
<h2 id="parameters_527">Parameters<a class="headerlink" href="#parameters_527" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>lti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>w : array_like, optional
Array of frequencies (in rad/s). Magnitude and phase data is
calculated for every value in this array. If not given, a reasonable
set will be calculated.
n : int, optional
Number of frequency points to compute if <code>w</code> is not given. The <code>n</code>
frequencies are logarithmically spaced in an interval chosen to
include the influence of the poles and zeros of the system.</p>
<h2 id="returns_506">Returns<a class="headerlink" href="#returns_506" title="Permanent link">&para;</a></h2>
<p>w : 1D ndarray
Frequency array [rad/s]
H : 1D ndarray
Array of complex magnitude values</p>
<h2 id="notes_340">Notes<a class="headerlink" href="#notes_340" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_443">Examples<a class="headerlink" href="#examples_443" title="Permanent link">&para;</a></h2>
<p>Generating the Nyquist plot of a transfer function</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Transfer function: H(s) = 5 / (s-1)^3</p>
<blockquote>
<blockquote>
<blockquote>
<p>s1 = signal.ZerosPolesGain([], [1, 1, 1], [5])</p>
<p>w, H = signal.freqresp(s1)</p>
<p>plt.figure()
plt.plot(H.real, H.imag, 'b')
plt.plot(H.real, -H.imag, 'r')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of an analog
filter, compute its frequency response::</p>
<p>b[0]<em>(jw)</em><em>M + b[1]</em>(jw)<strong>(M-1) + ... + b[M]
H(w) = ----------------------------------------------
a[0]*(jw)</strong>N + a[1]<em>(jw)</em>*(N-1) + ... + a[N]</p>
<h2 id="parameters_528">Parameters<a class="headerlink" href="#parameters_528" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.
a : array_like
Denominator of a linear filter.
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.
plot : callable, optional
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqs</code>.</p>
<h2 id="returns_507">Returns<a class="headerlink" href="#returns_507" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_347">See Also<a class="headerlink" href="#see-also_347" title="Permanent link">&para;</a></h2>
<p>freqz : Compute the frequency response of a digital filter.</p>
<h2 id="notes_341">Notes<a class="headerlink" href="#notes_341" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's 'plot' function as the callable for <code>plot</code> produces
unexpected results,  this plots the real part of the complex transfer
function, not the magnitude.  Try <code>lambda w, h: plot(w, abs(h))</code>.</p>
<h2 id="examples_444">Examples<a class="headerlink" href="#examples_444" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs, iirfilter</p>
<p>b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1')</p>
<p>w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqs_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute frequency response of analog filter.</p>
<p>Given the zeros <code>z</code>, poles <code>p</code>, and gain <code>k</code> of a filter, compute its
frequency response::</p>
<p>(jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1])
H(w) = k * ----------------------------------------
(jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1])</p>
<h2 id="parameters_529">Parameters<a class="headerlink" href="#parameters_529" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If None, then compute at 200 frequencies around the interesting parts
of the response curve (determined by pole-zero locations).  If a single
integer, then compute at that many frequencies.  Otherwise, compute the
response at the angular frequencies (e.g. rad/s) given in <code>worN</code>.</p>
<h2 id="returns_508">Returns<a class="headerlink" href="#returns_508" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The angular frequencies at which <code>h</code> was computed.
h : ndarray
The frequency response.</p>
<h2 id="see-also_348">See Also<a class="headerlink" href="#see-also_348" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqz : Compute the frequency response of a digital filter in TF form
freqz_zpk : Compute the frequency response of a digital filter in ZPK form</p>
<h2 id="notes_342">Notes<a class="headerlink" href="#notes_342" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_445">Examples<a class="headerlink" href="#examples_445" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import freqs_zpk, iirfilter</p>
<p>z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1',
...                     output='zpk')</p>
<p>w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000))</p>
<p>import matplotlib.pyplot as plt
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency')
plt.ylabel('Amplitude response [dB]')
plt.grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">plot</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter.</p>
<p>Given the M-order numerator <code>b</code> and N-order denominator <code>a</code> of a digital
filter, compute its frequency response::</p>
<p>jw                 -jw              -jwM
jw    B(e  )    b[0] + b[1]e    + ... + b[M]e
H(e  ) = ------ = -----------------------------------
jw                 -jw              -jwN
A(e  )    a[0] + a[1]e    + ... + a[N]e</p>
<h2 id="parameters_530">Parameters<a class="headerlink" href="#parameters_530" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
a : array_like
Denominator of a linear filter.  If <code>b</code> has dimension greater than 1,
it is assumed that the coefficients are stored in the first dimension,
and <code>b.shape[1:]</code>, <code>a.shape[1:]</code>, and the shape of the frequencies
array must be compatible for broadcasting.
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).  This is a convenient alternative to::</p>
<p>np.linspace(0, fs if whole else fs/2, N, endpoint=False)</p>
<p>Using a number that is fast for FFT computations can result in
faster computations (see Notes).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
plot : callable
A callable that takes two arguments. If given, the return parameters
<code>w</code> and <code>h</code> are passed to plot. Useful for plotting the frequency
response inside <code>freqz</code>.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_509">Returns<a class="headerlink" href="#returns_509" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_349">See Also<a class="headerlink" href="#see-also_349" title="Permanent link">&para;</a></h2>
<p>freqz_zpk
sosfreqz</p>
<h2 id="notes_343">Notes<a class="headerlink" href="#notes_343" title="Permanent link">&para;</a></h2>
<p>Using Matplotlib's :func:<code>matplotlib.pyplot.plot</code> function as the callable
for <code>plot</code> produces unexpected results, as this plots the real part of the
complex transfer function, not the magnitude.
Try <code>lambda w, h: plot(w, np.abs(h))</code>.</p>
<p>A direct computation via (R)FFT is used to compute the frequency response
when the following conditions are met:</p>
<ol>
<li>An integer value is given for <code>worN</code>.</li>
<li><code>worN</code> is fast to compute via FFT (i.e.,
<code>next_fast_len(worN) &lt;scipy.fft.next_fast_len&gt;</code> equals <code>worN</code>).</li>
<li>The denominator coefficients are a single value (<code>a.shape[0] == 1</code>).</li>
<li><code>worN</code> is at least as long as the numerator coefficients
(<code>worN &gt;= b.shape[0]</code>).</li>
<li>If <code>b.ndim &gt; 1</code>, then <code>b.shape[-1] == 1</code>.</li>
</ol>
<p>For long FIR filters, the FFT approach can have lower error and be much
faster than the equivalent direct polynomial calculation.</p>
<h2 id="examples_446">Examples<a class="headerlink" href="#examples_446" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
b = signal.firwin(80, 0.5, window=('kaiser', 8))
w, h = signal.freqz(b)</p>
<p>import matplotlib.pyplot as plt
fig, ax1 = plt.subplots()
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [rad/sample]')</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle (radians)', color='g')
ax2.grid()
ax2.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting Examples</p>
<p>Suppose we have two FIR filters whose coefficients are stored in the
rows of an array with shape (2, 25).  For this demonstration we'll
use random data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(42)
b = np.random.rand(2, 25)</p>
</blockquote>
</blockquote>
</blockquote>
<p>To compute the frequency response for these two filters with one call
to <code>freqz</code>, we must pass in <code>b.T</code>, because <code>freqz</code> expects the first
axis to hold the coefficients. We must then extend the shape with a
trivial dimension of length 1 to allow broadcasting with the array
of frequencies.  That is, we pass in <code>b.T[..., np.newaxis]</code>, which has
shape (25, 2, 1):</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b.T[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now suppose we have two transfer functions, with the same numerator
coefficients <code>b = [0.5, 0.5]</code>. The coefficients for the two denominators
are stored in the first dimension of the two-dimensional array  <code>a</code>::</p>
<p>a = [   1      1  ]
[ -0.25, -0.5 ]</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([0.5, 0.5])
a = np.array([[1, 1], [-0.25, -0.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Only <code>a</code> is more than one-dimensional.  To make it compatible for
broadcasting with the frequencies, we extend it with a trivial dimension
in the call to <code>freqz</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.freqz(b, a[..., np.newaxis], worN=1024)
w.shape
(1024,)
h.shape
(2, 1024)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">freqz_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter in ZPK form.</p>
<p>Given the Zeros, Poles and Gain of a digital filter, compute its frequency
response:</p>
<p>:math:<code>H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])</code></p>
<p>where :math:<code>k</code> is the <code>gain</code>, :math:<code>Z</code> are the <code>zeros</code> and :math:<code>P</code> are
the <code>poles</code>.</p>
<h2 id="parameters_531">Parameters<a class="headerlink" href="#parameters_531" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeroes of a linear filter
p : array_like
Poles of a linear filter
k : scalar
Gain of a linear filter
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).</p>
<p>If an array_like, compute the response at the frequencies given.
These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_510">Returns<a class="headerlink" href="#returns_510" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_350">See Also<a class="headerlink" href="#see-also_350" title="Permanent link">&para;</a></h2>
<p>freqs : Compute the frequency response of an analog filter in TF form
freqs_zpk : Compute the frequency response of an analog filter in ZPK form
freqz : Compute the frequency response of a digital filter in TF form</p>
<h2 id="notes_344">Notes<a class="headerlink" href="#notes_344" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_447">Examples<a class="headerlink" href="#examples_447" title="Permanent link">&para;</a></h2>
<p>Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a
system with sample rate of 1000 Hz, and plot the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
z, p, k = signal.butter(4, 100, output='zpk', fs=1000)
w, h = signal.freqz_zpk(z, p, k, fs=1000)</p>
<p>import matplotlib.pyplot as plt
fig = plt.figure()
ax1 = fig.add_subplot(1, 1, 1)
ax1.set_title('Digital filter frequency response')</p>
<p>ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [Hz]')
ax1.grid()</p>
<p>ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle [radians]', color='g')</p>
<p>plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gauss_spline</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Gaussian approximation to B-spline basis function of order n.</p>
<h2 id="parameters_532">Parameters<a class="headerlink" href="#parameters_532" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the spline. Must be nonnegative, i.e. n &gt;= 0</p>
<h2 id="references_116">References<a class="headerlink" href="#references_116" title="Permanent link">&para;</a></h2>
<p>.. [1] Bouma H., Vilanova A., Bescos J.O., ter Haar Romeny B.M., Gerritsen
F.A. (2007) Fast and Accurate Gaussian Derivatives Based on B-Splines. In:
Sgallari F., Murli A., Paragios N. (eds) Scale Space and Variational
Methods in Computer Vision. SSVM 2007. Lecture Notes in Computer
Science, vol 4485. Springer, Berlin, Heidelberg</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Gaussian window.</p>
<p>.. warning:: scipy.signal.gaussian is deprecated,
use scipy.signal.windows.gaussian instead.</p>
<h2 id="parameters_533">Parameters<a class="headerlink" href="#parameters_533" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
std : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_511">Returns<a class="headerlink" href="#returns_511" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_345">Notes<a class="headerlink" href="#notes_345" title="Permanent link">&para;</a></h2>
<p>The Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 }</p>
<h2 id="examples_448">Examples<a class="headerlink" href="#examples_448" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.gaussian(51, std=7)
plt.plot(window)
plt.title(r'Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Gaussian window (<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">gausspulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">fc</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bwr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tpr</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retquad</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">retenv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">The_string_cutoff_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a Gaussian modulated sinusoid:</p>
<p><code>exp(-a t^2) exp(1j*2*pi*fc*t).</code></p>
<p>If <code>retquad</code> is True, then return the real and imaginary parts
(in-phase and quadrature).
If <code>retenv</code> is True, then return the envelope (unmodulated signal).
Otherwise, return the real part of the modulated sinusoid.</p>
<h2 id="parameters_534">Parameters<a class="headerlink" href="#parameters_534" title="Permanent link">&para;</a></h2>
<p>t : ndarray or the string 'cutoff'
Input array.
fc : int, optional
Center frequency (e.g. Hz).  Default is 1000.
bw : float, optional
Fractional bandwidth in frequency domain of pulse (e.g. Hz).
Default is 0.5.
bwr : float, optional
Reference level at which fractional bandwidth is calculated (dB).
Default is -6.
tpr : float, optional
If <code>t</code> is 'cutoff', then the function returns the cutoff
time for when the pulse amplitude falls below <code>tpr</code> (in dB).
Default is -60.
retquad : bool, optional
If True, return the quadrature (imaginary) as well as the real part
of the signal.  Default is False.
retenv : bool, optional
If True, return the envelope of the signal.  Default is False.</p>
<h2 id="returns_512">Returns<a class="headerlink" href="#returns_512" title="Permanent link">&para;</a></h2>
<p>yI : ndarray
Real part of signal.  Always returned.
yQ : ndarray
Imaginary part of signal.  Only returned if <code>retquad</code> is True.
yenv : ndarray
Envelope of signal.  Only returned if <code>retenv</code> is True.</p>
<h2 id="see-also_351">See Also<a class="headerlink" href="#see-also_351" title="Permanent link">&para;</a></h2>
<p>scipy.signal.morlet</p>
<h2 id="examples_449">Examples<a class="headerlink" href="#examples_449" title="Permanent link">&para;</a></h2>
<p>Plot real component, imaginary component, and envelope for a 5 Hz pulse,
sampled at 100 Hz for 2 seconds:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 2 * 100, endpoint=False)
i, q, e = signal.gausspulse(t, fc=5, retquad=True, retenv=True)
plt.plot(t, i, t, q, t, e, '--')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">general_gaussian</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window with a generalized Gaussian shape.</p>
<p>.. warning:: scipy.signal.general_gaussian is deprecated,
use scipy.signal.windows.general_gaussian instead.</p>
<h2 id="parameters_535">Parameters<a class="headerlink" href="#parameters_535" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
p : float
Shape parameter.  p = 1 is identical to <code>gaussian</code>, p = 0.5 is
the same shape as the Laplace distribution.
sig : float
The standard deviation, sigma.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_513">Returns<a class="headerlink" href="#returns_513" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_346">Notes<a class="headerlink" href="#notes_346" title="Permanent link">&para;</a></h2>
<p>The generalized Gaussian window is defined as</p>
<p>.. math::  w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} }</p>
<p>the half-power point is at</p>
<p>.. math::  (2 \log(2))^{1/(2 p)} \sigma</p>
<h2 id="examples_450">Examples<a class="headerlink" href="#examples_450" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.general_gaussian(51, p=1.5, sig=7)
plt.plot(window)
plt.title(r'Generalized Gaussian window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Freq. resp. of the gen. Gaussian '
...           r'window (p=1.5, <span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>=7)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_window</span> <span class="o">:</span> <span class="o">?</span><span class="n">fftbins</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a window of a given length and type.</p>
<h2 id="parameters_536">Parameters<a class="headerlink" href="#parameters_536" title="Permanent link">&para;</a></h2>
<p>window : string, float, or tuple
The type of window to create. See below for more details.
Nx : int
The number of samples in the window.
fftbins : bool, optional
If True (default), create a 'periodic' window, ready to use with
<code>ifftshift</code> and be multiplied by the result of an FFT (see also
:func:<code>~scipy.fft.fftfreq</code>).
If False, create a 'symmetric' window, for use in filter design.</p>
<h2 id="returns_514">Returns<a class="headerlink" href="#returns_514" title="Permanent link">&para;</a></h2>
<p>get_window : ndarray
Returns a window of length <code>Nx</code> and type <code>window</code></p>
<h2 id="notes_347">Notes<a class="headerlink" href="#notes_347" title="Permanent link">&para;</a></h2>
<p>Window types:</p>
<ul>
<li><code>~scipy.signal.windows.boxcar</code></li>
<li><code>~scipy.signal.windows.triang</code></li>
<li><code>~scipy.signal.windows.blackman</code></li>
<li><code>~scipy.signal.windows.hamming</code></li>
<li><code>~scipy.signal.windows.hann</code></li>
<li><code>~scipy.signal.windows.bartlett</code></li>
<li><code>~scipy.signal.windows.flattop</code></li>
<li><code>~scipy.signal.windows.parzen</code></li>
<li><code>~scipy.signal.windows.bohman</code></li>
<li><code>~scipy.signal.windows.blackmanharris</code></li>
<li><code>~scipy.signal.windows.nuttall</code></li>
<li><code>~scipy.signal.windows.barthann</code></li>
<li><code>~scipy.signal.windows.kaiser</code> (needs beta)</li>
<li><code>~scipy.signal.windows.gaussian</code> (needs standard deviation)</li>
<li><code>~scipy.signal.windows.general_gaussian</code> (needs power, width)</li>
<li><code>~scipy.signal.windows.slepian</code> (needs width)</li>
<li><code>~scipy.signal.windows.dpss</code> (needs normalized half-bandwidth)</li>
<li><code>~scipy.signal.windows.chebwin</code> (needs attenuation)</li>
<li><code>~scipy.signal.windows.exponential</code> (needs decay scale)</li>
<li><code>~scipy.signal.windows.tukey</code> (needs taper fraction)</li>
</ul>
<p>If the window requires no parameters, then <code>window</code> can be a string.</p>
<p>If the window requires parameters, then <code>window</code> must be a tuple
with the first argument the string name of the window, and the next
arguments the needed parameters.</p>
<p>If <code>window</code> is a floating point number, it is interpreted as the beta
parameter of the <code>~scipy.signal.windows.kaiser</code> window.</p>
<p>Each of the window types listed above is also the name of
a function that can be called directly to create a window of
that type.</p>
<h2 id="examples_451">Examples<a class="headerlink" href="#examples_451" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.get_window('triang', 7)
array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375])
signal.get_window(('kaiser', 4.0), 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])
signal.get_window(4.0, 9)
array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093,
0.97885093,  0.82160913,  0.56437221,  0.29425961])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">group_delay</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the group delay of a digital filter.</p>
<p>The group delay measures by how many samples amplitude envelopes of
various spectral components of a signal are delayed by a filter.
It is formally defined as the derivative of continuous (unwrapped) phase::</p>
<p>d        jw
D(w) = - -- arg H(e)
dw</p>
<h2 id="parameters_537">Parameters<a class="headerlink" href="#parameters_537" title="Permanent link">&para;</a></h2>
<p>system : tuple of array_like (b, a)
Numerator and denominator coefficients of a filter transfer function.
w : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).</p>
<p>If an array_like, compute the delay at the frequencies given.  These
are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.  Ignored if w is array_like.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_515">Returns<a class="headerlink" href="#returns_515" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which group delay was computed, in the same units
as <code>fs</code>.  By default, <code>w</code> is normalized to the range [0, pi)
(radians/sample).
gd : ndarray
The group delay.</p>
<h2 id="notes_348">Notes<a class="headerlink" href="#notes_348" title="Permanent link">&para;</a></h2>
<p>The similar function in MATLAB is called <code>grpdelay</code>.</p>
<p>If the transfer function :math:<code>H(z)</code> has zeros or poles on the unit
circle, the group delay at corresponding frequencies is undefined.
When such a case arises the warning is raised and the group delay
is set to 0 at those frequencies.</p>
<p>For the details of numerical computation of the group delay refer to [1]_.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="see-also_352">See Also<a class="headerlink" href="#see-also_352" title="Permanent link">&para;</a></h2>
<p>freqz : Frequency response of a digital filter</p>
<h2 id="references_117">References<a class="headerlink" href="#references_117" title="Permanent link">&para;</a></h2>
<p>.. [1] Richard G. Lyons, 'Understanding Digital Signal Processing,
3rd edition', p. 830.</p>
<h2 id="examples_452">Examples<a class="headerlink" href="#examples_452" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype='cheby1')
w, gd = signal.group_delay((b, a))</p>
<p>import matplotlib.pyplot as plt
plt.title('Digital filter group delay')
plt.plot(w, gd)
plt.ylabel('Group delay [samples]')
plt.xlabel('Frequency [rad/sample]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hamming window.</p>
<p>The Hamming window is a taper formed by using a raised cosine with
non-zero endpoints, optimized to minimize the nearest side lobe.</p>
<p>.. warning:: scipy.signal.hamming is deprecated,
use scipy.signal.windows.hamming instead.</p>
<h2 id="parameters_538">Parameters<a class="headerlink" href="#parameters_538" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_516">Returns<a class="headerlink" href="#returns_516" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_349">Notes<a class="headerlink" href="#notes_349" title="Permanent link">&para;</a></h2>
<p>The Hamming window is defined as</p>
<p>.. math::  w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_118">References<a class="headerlink" href="#references_118" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_453">Examples<a class="headerlink" href="#examples_453" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hamming(51)
plt.plot(window)
plt.title('Hamming window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hamming window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hann</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Hann window.</p>
<p>The Hann window is a taper formed by using a raised cosine or sine-squared
with ends that touch zero.</p>
<p>.. warning:: scipy.signal.hann is deprecated,
use scipy.signal.windows.hann instead.</p>
<h2 id="parameters_539">Parameters<a class="headerlink" href="#parameters_539" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_517">Returns<a class="headerlink" href="#returns_517" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_350">Notes<a class="headerlink" href="#notes_350" title="Permanent link">&para;</a></h2>
<p>The Hann window is defined as</p>
<p>.. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1</p>
<p>The window was named for Julius von Hann, an Austrian meteorologist. It is
also known as the Cosine Bell. It is sometimes erroneously referred to as
the 'Hanning' window, from the use of 'hann' as a verb in the original
paper and confusion with the very similar Hamming window.</p>
<p>Most references to the Hann window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_119">References<a class="headerlink" href="#references_119" title="Permanent link">&para;</a></h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics',
The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
'Numerical Recipes', Cambridge University Press, 1986, page 425.</p>
<h2 id="examples_454">Examples<a class="headerlink" href="#examples_454" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.hann(51)
plt.plot(window)
plt.title('Hann window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Hann window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hanning</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>hanning</code> is deprecated, use <code>scipy.signal.windows.hann</code> instead!</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the analytic signal, using the Hilbert transform.</p>
<p>The transformation is done along the last axis by default.</p>
<h2 id="parameters_540">Parameters<a class="headerlink" href="#parameters_540" title="Permanent link">&para;</a></h2>
<p>x : array_like
Signal data.  Must be real.
N : int, optional
Number of Fourier components.  Default: <code>x.shape[axis]</code>
axis : int, optional
Axis along which to do the transformation.  Default: -1.</p>
<h2 id="returns_518">Returns<a class="headerlink" href="#returns_518" title="Permanent link">&para;</a></h2>
<p>xa : ndarray
Analytic signal of <code>x</code>, of each 1-D array along <code>axis</code></p>
<h2 id="notes_351">Notes<a class="headerlink" href="#notes_351" title="Permanent link">&para;</a></h2>
<p>The analytic signal <code>x_a(t)</code> of signal <code>x(t)</code> is:</p>
<p>.. math:: x_a = F^{-1}(F(x) 2U) = x + i y</p>
<p>where <code>F</code> is the Fourier transform, <code>U</code> the unit step function,
and <code>y</code> the Hilbert transform of <code>x</code>. [1]_</p>
<p>In other words, the negative half of the frequency spectrum is zeroed
out, turning the real-valued signal into a complex signal.  The Hilbert
transformed signal can be obtained from <code>np.imag(hilbert(x))</code>, and the
original signal from <code>np.real(hilbert(x))</code>.</p>
<h2 id="examples_455">Examples<a class="headerlink" href="#examples_455" title="Permanent link">&para;</a></h2>
<p>In this example we use the Hilbert transform to determine the amplitude
envelope and instantaneous frequency of an amplitude-modulated signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import hilbert, chirp</p>
<p>duration = 1.0
fs = 400.0
samples = int(fs*duration)
t = np.arange(samples) / fs</p>
</blockquote>
</blockquote>
</blockquote>
<p>We create a chirp of which the frequency increases from 20 Hz to 100 Hz and
apply an amplitude modulation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal = chirp(t, 20.0, t[-1], 100.0)
signal <em>= (1.0 + 0.5 * np.sin(2.0</em>np.pi<em>3.0</em>t) )</p>
</blockquote>
</blockquote>
</blockquote>
<p>The amplitude envelope is given by magnitude of the analytic signal. The
instantaneous frequency can be obtained by differentiating the
instantaneous phase in respect to time. The instantaneous phase corresponds
to the phase angle of the analytic signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>analytic_signal = hilbert(signal)
amplitude_envelope = np.abs(analytic_signal)
instantaneous_phase = np.unwrap(np.angle(analytic_signal))
instantaneous_frequency = (np.diff(instantaneous_phase) /
...                            (2.0*np.pi) * fs)</p>
<p>fig = plt.figure()
ax0 = fig.add_subplot(211)
ax0.plot(t, signal, label='signal')
ax0.plot(t, amplitude_envelope, label='envelope')
ax0.set_xlabel('time in seconds')
ax0.legend()
ax1 = fig.add_subplot(212)
ax1.plot(t[1:], instantaneous_frequency)
ax1.set_xlabel('time in seconds')
ax1.set_ylim(0.0, 120.0)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_120">References<a class="headerlink" href="#references_120" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Analytic signal'.
https://en.wikipedia.org/wiki/Analytic_signal
.. [2] Leon Cohen, 'Time-Frequency Analysis', 1995. Chapter 2.
.. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal
Processing, Third Edition, 2009. Chapter 12.
ISBN 13: 978-1292-02572-8</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert2</span> <span class="o">:</span> <span class="o">?</span><span class="n">n</span><span class="o">:[`</span><span class="nc">Tuple_of_two_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the '2-D' analytic signal of <code>x</code></p>
<h2 id="parameters_541">Parameters<a class="headerlink" href="#parameters_541" title="Permanent link">&para;</a></h2>
<p>x : array_like
2-D signal data.
N : int or tuple of two ints, optional
Number of Fourier components. Default is <code>x.shape</code></p>
<h2 id="returns_519">Returns<a class="headerlink" href="#returns_519" title="Permanent link">&para;</a></h2>
<p>xa : ndarray
Analytic signal of <code>x</code> taken along axes (0,1).</p>
<h2 id="references_121">References<a class="headerlink" href="#references_121" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Analytic signal',
https://en.wikipedia.org/wiki/Analytic_signal</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirdesign</span> <span class="o">:</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">wp</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ws</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">gpass</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">gstop</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complete IIR digital and analog filter design.</p>
<p>Given passband and stopband frequencies and gains, construct an analog or
digital IIR filter of minimum order for a given basic type.  Return the
output in numerator, denominator ('ba'), pole-zero ('zpk') or second order
sections ('sos') form.</p>
<h2 id="parameters_542">Parameters<a class="headerlink" href="#parameters_542" title="Permanent link">&para;</a></h2>
<p>wp, ws : float
Passband and stopband edge frequencies.
For digital filters, these are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  For example:</p>
<ul>
<li>Lowpass:   wp = 0.2,          ws = 0.3</li>
<li>Highpass:  wp = 0.3,          ws = 0.2</li>
<li>Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]</li>
<li>Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]</li>
</ul>
<p>For analog filters, <code>wp</code> and <code>ws</code> are angular frequencies (e.g. rad/s).
gpass : float
The maximum loss in the passband (dB).
gstop : float
The minimum attenuation in the stopband (dB).
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
ftype : str, optional
The type of IIR filter to design:</p>
<ul>
<li>Butterworth   : 'butter'</li>
<li>Chebyshev I   : 'cheby1'</li>
<li>Chebyshev II  : 'cheby2'</li>
<li>Cauer/elliptic: 'ellip'</li>
<li>Bessel/Thomson: 'bessel'</li>
</ul>
<p>output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_520">Returns<a class="headerlink" href="#returns_520" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_353">See Also<a class="headerlink" href="#see-also_353" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirfilter : General filter design using order and critical frequencies</p>
<h2 id="notes_352">Notes<a class="headerlink" href="#notes_352" title="Permanent link">&para;</a></h2>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_456">Examples<a class="headerlink" href="#examples_456" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
import matplotlib.ticker</p>
<p>wp = 0.2
ws = 0.3
gpass = 1
gstop = 40</p>
<p>system = signal.iirdesign(wp, ws, gpass, gstop)
w, h = signal.freqz( *system)</p>
<p>fig, ax1 = plt.subplots()
ax1.set_title('Digital filter frequency response')
ax1.plot(w, 20 * np.log10(abs(h)), 'b')
ax1.set_ylabel('Amplitude [dB]', color='b')
ax1.set_xlabel('Frequency [rad/sample]')
ax1.grid()
ax1.set_ylim([-120, 20])
ax2 = ax1.twinx()
angles = np.unwrap(np.angle(h))
ax2.plot(w, angles, 'g')
ax2.set_ylabel('Angle (radians)', color='g')
ax2.grid()
ax2.axis('tight')
ax2.set_ylim([-6, 1])
nticks = 8
ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirfilter</span> <span class="o">:</span> <span class="o">?</span><span class="n">rp</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">btype</span><span class="o">:[`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lowpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Highpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bandstop</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">analog</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ftype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Ba</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zpk</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sos</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">wn</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>IIR digital and analog filter design given order and critical points.</p>
<p>Design an Nth-order digital or analog filter and return the filter
coefficients.</p>
<h2 id="parameters_543">Parameters<a class="headerlink" href="#parameters_543" title="Permanent link">&para;</a></h2>
<p>N : int
The order of the filter.
Wn : array_like
A scalar or length-2 sequence giving the critical frequencies.</p>
<p>For digital filters, <code>Wn</code> are in the same units as <code>fs</code>.  By default,
<code>fs</code> is 2 half-cycles/sample, so these are normalized from 0 to 1,
where 1 is the Nyquist frequency.  (<code>Wn</code> is thus in
half-cycles / sample.)</p>
<p>For analog filters, <code>Wn</code> is an angular frequency (e.g. rad/s).
rp : float, optional
For Chebyshev and elliptic filters, provides the maximum ripple
in the passband. (dB)
rs : float, optional
For Chebyshev and elliptic filters, provides the minimum attenuation
in the stop band. (dB)
btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
The type of filter.  Default is 'bandpass'.
analog : bool, optional
When True, return an analog filter, otherwise a digital filter is
returned.
ftype : str, optional
The type of IIR filter to design:</p>
<ul>
<li>Butterworth   : 'butter'</li>
<li>Chebyshev I   : 'cheby1'</li>
<li>Chebyshev II  : 'cheby2'</li>
<li>Cauer/elliptic: 'ellip'</li>
<li>Bessel/Thomson: 'bessel'</li>
</ul>
<p>output : {'ba', 'zpk', 'sos'}, optional
Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or
second-order sections ('sos'). Default is 'ba' for backwards
compatibility, but 'sos' should be used for general-purpose filtering.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_521">Returns<a class="headerlink" href="#returns_521" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials of the IIR filter.
Only returned if <code>output='ba'</code>.
z, p, k : ndarray, ndarray, float
Zeros, poles, and system gain of the IIR filter transfer
function.  Only returned if <code>output='zpk'</code>.
sos : ndarray
Second-order sections representation of the IIR filter.
Only returned if <code>output=='sos'</code>.</p>
<h2 id="see-also_354">See Also<a class="headerlink" href="#see-also_354" title="Permanent link">&para;</a></h2>
<p>butter : Filter design using order and critical points
cheby1, cheby2, ellip, bessel
buttord : Find order and critical points from passband and stopband spec
cheb1ord, cheb2ord, ellipord
iirdesign : General filter design using passband and stopband spec</p>
<h2 id="notes_353">Notes<a class="headerlink" href="#notes_353" title="Permanent link">&para;</a></h2>
<p>The <code>'sos'</code> output parameter was added in 0.16.0.</p>
<h2 id="examples_457">Examples<a class="headerlink" href="#examples_457" title="Permanent link">&para;</a></h2>
<p>Generate a 17th-order Chebyshev II analog bandpass filter from 50 Hz to
200 Hz and plot the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>b, a = signal.iirfilter(17, [2<em>np.pi</em>50, 2<em>np.pi</em>200], rs=60,
...                         btype='band', analog=True, ftype='cheby2')
w, h = signal.freqs(b, a, 1000)
fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.semilogx(w / (2*np.pi), 20 * np.log10(np.maximum(abs(h), 1e-5)))
ax.set_title('Chebyshev Type II bandpass frequency response')
ax.set_xlabel('Frequency [Hz]')
ax.set_ylabel('Amplitude [dB]')
ax.axis((10, 1000, -100, 10))
ax.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a digital filter with the same properties, in a system with
sampling rate of 2000 Hz, and plot the frequency response.  (Second-order
sections implementation is required to ensure stability of a filter of
this order):</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.iirfilter(17, [50, 200], rs=60, btype='band',
...                        analog=False, ftype='cheby2', fs=2000,
...                        output='sos')
w, h = signal.sosfreqz(sos, 2000, fs=2000)
fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.semilogx(w, 20 * np.log10(np.maximum(abs(h), 1e-5)))
ax.set_title('Chebyshev Type II bandpass frequency response')
ax.set_xlabel('Frequency [Hz]')
ax.set_ylabel('Amplitude [dB]')
ax.axis((10, 1000, -100, 10))
ax.grid(which='both', axis='both')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirnotch</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Design second-order IIR notch digital filter.</p>
<p>A notch filter is a band-stop filter with a narrow bandwidth
(high quality factor). It rejects a narrow frequency band and
leaves the rest of the spectrum little changed.</p>
<h2 id="parameters_544">Parameters<a class="headerlink" href="#parameters_544" title="Permanent link">&para;</a></h2>
<p>w0 : float
Frequency to remove from a signal. If <code>fs</code> is specified, this is in
the same units as <code>fs</code>. By default, it is a normalized scalar that must
satisfy  <code>0 &lt; w0 &lt; 1</code>, with <code>w0 = 1</code> corresponding to half of the
sampling frequency.
Q : float
Quality factor. Dimensionless parameter that characterizes
notch filter -3 dB bandwidth <code>bw</code> relative to its center
frequency, <code>Q = w0/bw</code>.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_522">Returns<a class="headerlink" href="#returns_522" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials
of the IIR filter.</p>
<h2 id="see-also_355">See Also<a class="headerlink" href="#see-also_355" title="Permanent link">&para;</a></h2>
<p>iirpeak</p>
<h2 id="notes_354">Notes<a class="headerlink" href="#notes_354" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_122">References<a class="headerlink" href="#references_122" title="Permanent link">&para;</a></h2>
<p>.. [1] Sophocles J. Orfanidis, 'Introduction To Signal Processing',
Prentice-Hall, 1996</p>
<h2 id="examples_458">Examples<a class="headerlink" href="#examples_458" title="Permanent link">&para;</a></h2>
<p>Design and plot filter to remove the 60 Hz component from a
signal sampled at 200 Hz, using a quality factor Q = 30</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 200.0  # Sample frequency (Hz)
f0 = 60.0  # Frequency to be removed from signal (Hz)
Q = 30.0  # Quality factor</p>
<h1 id="design-notch-filter_1">Design notch filter<a class="headerlink" href="#design-notch-filter_1" title="Permanent link">&para;</a></h1>
<p>b, a = signal.iirnotch(f0, Q, fs)</p>
<h1 id="frequency-response_2">Frequency response<a class="headerlink" href="#frequency-response_2" title="Permanent link">&para;</a></h1>
<p>freq, h = signal.freqz(b, a, fs=fs)</p>
<h1 id="plot_2">Plot<a class="headerlink" href="#plot_2" title="Permanent link">&para;</a></h1>
<p>fig, ax = plt.subplots(2, 1, figsize=(8, 6))
ax[0].plot(freq, 20<em>np.log10(abs(h)), color='blue')
ax[0].set_title('Frequency Response')
ax[0].set_ylabel('Amplitude (dB)', color='blue')
ax[0].set_xlim([0, 100])
ax[0].set_ylim([-25, 10])
ax[0].grid()
ax[1].plot(freq, np.unwrap(np.angle(h))</em>180/np.pi, color='green')
ax[1].set_ylabel('Angle (degrees)', color='green')
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_xlim([0, 100])
ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
ax[1].set_ylim([-90, 90])
ax[1].grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iirpeak</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">w0</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Design second-order IIR peak (resonant) digital filter.</p>
<p>A peak filter is a band-pass filter with a narrow bandwidth
(high quality factor). It rejects components outside a narrow
frequency band.</p>
<h2 id="parameters_545">Parameters<a class="headerlink" href="#parameters_545" title="Permanent link">&para;</a></h2>
<p>w0 : float
Frequency to be retained in a signal. If <code>fs</code> is specified, this is in
the same units as <code>fs</code>. By default, it is a normalized scalar that must
satisfy  <code>0 &lt; w0 &lt; 1</code>, with <code>w0 = 1</code> corresponding to half of the
sampling frequency.
Q : float
Quality factor. Dimensionless parameter that characterizes
peak filter -3 dB bandwidth <code>bw</code> relative to its center
frequency, <code>Q = w0/bw</code>.
fs : float, optional
The sampling frequency of the digital system.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_523">Returns<a class="headerlink" href="#returns_523" title="Permanent link">&para;</a></h2>
<p>b, a : ndarray, ndarray
Numerator (<code>b</code>) and denominator (<code>a</code>) polynomials
of the IIR filter.</p>
<h2 id="see-also_356">See Also<a class="headerlink" href="#see-also_356" title="Permanent link">&para;</a></h2>
<p>iirnotch</p>
<h2 id="notes_355">Notes<a class="headerlink" href="#notes_355" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_123">References<a class="headerlink" href="#references_123" title="Permanent link">&para;</a></h2>
<p>.. [1] Sophocles J. Orfanidis, 'Introduction To Signal Processing',
Prentice-Hall, 1996</p>
<h2 id="examples_459">Examples<a class="headerlink" href="#examples_459" title="Permanent link">&para;</a></h2>
<p>Design and plot filter to remove the frequencies other than the 300 Hz
component from a signal sampled at 1000 Hz, using a quality factor Q = 30</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>fs = 1000.0  # Sample frequency (Hz)
f0 = 300.0  # Frequency to be retained (Hz)
Q = 30.0  # Quality factor</p>
<h1 id="design-peak-filter_1">Design peak filter<a class="headerlink" href="#design-peak-filter_1" title="Permanent link">&para;</a></h1>
<p>b, a = signal.iirpeak(f0, Q, fs)</p>
<h1 id="frequency-response_3">Frequency response<a class="headerlink" href="#frequency-response_3" title="Permanent link">&para;</a></h1>
<p>freq, h = signal.freqz(b, a, fs=fs)</p>
<h1 id="plot_3">Plot<a class="headerlink" href="#plot_3" title="Permanent link">&para;</a></h1>
<p>fig, ax = plt.subplots(2, 1, figsize=(8, 6))
ax[0].plot(freq, 20<em>np.log10(np.maximum(abs(h), 1e-5)), color='blue')
ax[0].set_title('Frequency Response')
ax[0].set_ylabel('Amplitude (dB)', color='blue')
ax[0].set_xlim([0, 500])
ax[0].set_ylim([-50, 10])
ax[0].grid()
ax[1].plot(freq, np.unwrap(np.angle(h))</em>180/np.pi, color='green')
ax[1].set_ylabel('Angle (degrees)', color='green')
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_xlim([0, 500])
ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90])
ax[1].set_ylim([-90, 90])
ax[1].grid()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of continuous-time system.</p>
<h2 id="parameters_546">Parameters<a class="headerlink" href="#parameters_546" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector.  Defaults to zero.
T : array_like, optional
Time points.  Computed if not given.
N : int, optional
The number of time points to compute (if <code>T</code> is not given).</p>
<h2 id="returns_524">Returns<a class="headerlink" href="#returns_524" title="Permanent link">&para;</a></h2>
<p>T : ndarray
A 1-D array of time points.
yout : ndarray
A 1-D array containing the impulse response of the system (except for
singularities at zero).</p>
<h2 id="notes_356">Notes<a class="headerlink" href="#notes_356" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_460">Examples<a class="headerlink" href="#examples_460" title="Permanent link">&para;</a></h2>
<p>Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = u(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = ([1.0], [1.0, 2.0, 1.0])
t, y = signal.impulse2(system)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">impulse2</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Impulse response of a single-input, continuous-time linear system.</p>
<h2 id="parameters_547">Parameters<a class="headerlink" href="#parameters_547" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : 1-D array_like, optional
The initial condition of the state vector.  Default: 0 (the
zero vector).
T : 1-D array_like, optional
The time steps at which the input is defined and at which the
output is desired.  If <code>T</code> is not given, the function will
generate a set of time samples automatically.
N : int, optional
Number of time points to compute.  Default: 100.
kwargs : various types
Additional keyword arguments are passed on to the function
<code>scipy.signal.lsim2</code>, which in turn passes them on to
<code>scipy.integrate.odeint</code>; see the latter's documentation for
information about these arguments.</p>
<h2 id="returns_525">Returns<a class="headerlink" href="#returns_525" title="Permanent link">&para;</a></h2>
<p>T : ndarray
The time values for the output.
yout : ndarray
The output response of the system.</p>
<h2 id="see-also_357">See Also<a class="headerlink" href="#see-also_357" title="Permanent link">&para;</a></h2>
<p>impulse, lsim2, scipy.integrate.odeint</p>
<h2 id="notes_357">Notes<a class="headerlink" href="#notes_357" title="Permanent link">&para;</a></h2>
<p>The solution is generated by calling <code>scipy.signal.lsim2</code>, which uses
the differential equation solver <code>scipy.integrate.odeint</code>.</p>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_461">Examples<a class="headerlink" href="#examples_461" title="Permanent link">&para;</a></h2>
<p>Second order system with a repeated root: x''(t) + 2*x(t) + x(t) = u(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = ([1.0], [1.0, 2.0, 1.0])
t, y = signal.impulse2(system)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invres</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute b(s) and a(s) from partial fraction expansion.</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(s)     b[0] s<strong>(M) + b[1] s</strong>(M-1) + ... + b[M]
H(s) = ------ = ------------------------------------------
a(s)     a[0] s<strong>(N) + a[1] s</strong>(N-1) + ... + a[N]</p>
<p>then the partial-fraction expansion H(s) is defined as::</p>
<p>r[0]       r[1]             r[-1]
= -------- + -------- + ... + --------- + k(s)
(s-p[0])   (s-p[1])         (s-p[-1])</p>
<p>If there are any repeated roots (closer together than <code>tol</code>), then H(s)
has terms like::</p>
<p>r[i]      r[i+1]              r[i+n-1]
-------- + ----------- + ... + -----------
(s-p[i])  (s-p[i])<strong>2          (s-p[i])</strong>n</p>
<p>This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use <code>invresz</code>.</p>
<h2 id="parameters_548">Parameters<a class="headerlink" href="#parameters_548" title="Permanent link">&para;</a></h2>
<p>r : array_like
Residues corresponding to the poles. For repeated poles, the residues
must be ordered to correspond to ascending by power fractions.
p : array_like
Poles. Equal poles must be adjacent.
k : array_like
Coefficients of the direct polynomial term.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_526">Returns<a class="headerlink" href="#returns_526" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="see-also_358">See Also<a class="headerlink" href="#see-also_358" title="Permanent link">&para;</a></h2>
<p>residue, invresz, unique_roots</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invresz</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute b(z) and a(z) from partial fraction expansion.</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(z)     b[0] + b[1] z<strong>(-1) + ... + b[M] z</strong>(-M)
H(z) = ------ = ------------------------------------------
a(z)     a[0] + a[1] z<strong>(-1) + ... + a[N] z</strong>(-N)</p>
<p>then the partial-fraction expansion H(z) is defined as::</p>
<p>r[0]                   r[-1]
= --------------- + ... + ---------------- + k[0] + k[1]z<strong>(-1) ...
(1-p[0]z</strong>(-1))         (1-p[-1]z**(-1))</p>
<p>If there are any repeated roots (closer than <code>tol</code>), then the partial
fraction expansion has terms like::</p>
<p>r[i]              r[i+1]                    r[i+n-1]
-------------- + ------------------ + ... + ------------------
(1-p[i]z<strong>(-1))  (1-p[i]z</strong>(-1))<strong>2         (1-p[i]z</strong>(-1))**n</p>
<p>This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use <code>invres</code>.</p>
<h2 id="parameters_549">Parameters<a class="headerlink" href="#parameters_549" title="Permanent link">&para;</a></h2>
<p>r : array_like
Residues corresponding to the poles. For repeated poles, the residues
must be ordered to correspond to ascending by power fractions.
p : array_like
Poles. Equal poles must be adjacent.
k : array_like
Coefficients of the direct polynomial term.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_527">Returns<a class="headerlink" href="#returns_527" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="see-also_359">See Also<a class="headerlink" href="#see-also_359" title="Permanent link">&para;</a></h2>
<p>residuez, unique_roots, invres</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">istft</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">input_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">time_axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">freq_axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">zxx</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Perform the inverse Short Time Fourier transform (iSTFT).</p>
<h2 id="parameters_550">Parameters<a class="headerlink" href="#parameters_550" title="Permanent link">&para;</a></h2>
<p>Zxx : array_like
STFT of the signal to be reconstructed. If a purely real array
is passed, it will be cast to a complex data type.
fs : float, optional
Sampling frequency of the time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window. Must match the window used to generate the
STFT for faithful inversion.
nperseg : int, optional
Number of data points corresponding to each STFT segment. This
parameter must be specified if the number of data points per
segment is odd, or if the STFT was padded via <code>nfft &gt;
nperseg</code>. If <code>None</code>, the value depends on the shape of
<code>Zxx</code> and <code>input_onesided</code>. If <code>input_onesided</code> is <code>True</code>,
<code>nperseg=2*(Zxx.shape[freq_axis] - 1)</code>. Otherwise,
<code>nperseg=Zxx.shape[freq_axis]</code>. Defaults to <code>None</code>.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>, half
of the segment length. Defaults to <code>None</code>. When specified, the
COLA constraint must be met (see Notes below), and should match
the parameter used to generate the STFT. Defaults to <code>None</code>.
nfft : int, optional
Number of FFT points corresponding to each STFT segment. This
parameter must be specified if the STFT was padded via <code>nfft &gt;
nperseg</code>. If <code>None</code>, the default values are the same as for
<code>nperseg</code>, detailed above, with one exception: if
<code>input_onesided</code> is True and
<code>nperseg==2*Zxx.shape[freq_axis] - 1</code>, <code>nfft</code> also takes on
that value. This case allows the proper inversion of an
odd-length unpadded STFT using <code>nfft=None</code>. Defaults to
<code>None</code>.
input_onesided : bool, optional
If <code>True</code>, interpret the input array as one-sided FFTs, such
as is returned by <code>stft</code> with <code>return_onesided=True</code> and
<code>numpy.fft.rfft</code>. If <code>False</code>, interpret the input as a a
two-sided FFT. Defaults to <code>True</code>.
boundary : bool, optional
Specifies whether the input signal was extended at its
boundaries by supplying a non-<code>None</code> <code>boundary</code> argument to
<code>stft</code>. Defaults to <code>True</code>.
time_axis : int, optional
Where the time segments of the STFT is located; the default is
the last axis (i.e. <code>axis=-1</code>).
freq_axis : int, optional
Where the frequency axis of the STFT is located; the default is
the penultimate axis (i.e. <code>axis=-2</code>).</p>
<h2 id="returns_528">Returns<a class="headerlink" href="#returns_528" title="Permanent link">&para;</a></h2>
<p>t : ndarray
Array of output data times.
x : ndarray
iSTFT of <code>Zxx</code>.</p>
<h2 id="see-also_360">See Also<a class="headerlink" href="#see-also_360" title="Permanent link">&para;</a></h2>
<p>stft: Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met</p>
<h2 id="notes_358">Notes<a class="headerlink" href="#notes_358" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT with
<code>istft</code>, the signal windowing must obey the constraint of 'nonzero
overlap add' (NOLA):</p>
<p>.. math:: \sum_{t}w^{2}[n-tH] \ne 0</p>
<p>This ensures that the normalization factors that appear in the denominator
of the overlap-add reconstruction equation</p>
<p>.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</p>
<p>are not zero. The NOLA constraint can be checked with the <code>check_NOLA</code>
function.</p>
<p>An STFT which has been modified (via masking or otherwise) is not
guaranteed to correspond to a exactly realizible signal. This
function implements the iSTFT via the least-squares estimation
algorithm detailed in [2]_, which produces a signal that minimizes
the mean squared error between the STFT of the returned signal and
the modified STFT.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_124">References<a class="headerlink" href="#references_124" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim 'Signal Estimation from
Modified Short-Time Fourier Transform', IEEE 1984,
10.1109/TASSP.1984.1164317</p>
<h2 id="examples_462">Examples<a class="headerlink" href="#examples_462" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by
0.001 V**2/Hz of white noise sampled at 1024 Hz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 1024
N = 10<em>fs
nperseg = 512
amp = 2 * np.sqrt(2)
noise_power = 0.001 * fs / 2
time = np.arange(N) / float(fs)
carrier = amp * np.sin(2</em>np.pi<em>50</em>time)
noise = np.random.normal(scale=np.sqrt(noise_power),
...                          size=time.shape)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the STFT, and plot its magnitude</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)
plt.figure()
plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp)
plt.ylim([f[1], f[-1]])
plt.title('STFT Magnitude')
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.yscale('log')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Zero the components that are 10% or less of the carrier magnitude,
then convert back to a time series via inverse STFT</p>
<blockquote>
<blockquote>
<blockquote>
<p>Zxx = np.where(np.abs(Zxx) &gt;= amp/10, Zxx, 0)
_, xrec = signal.istft(Zxx, fs)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare the cleaned signal with the original and true carrier signals.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.plot(time, x, time, xrec, time, carrier)
plt.xlim([2, 2.1])
plt.xlabel('Time [sec]')
plt.ylabel('Signal')
plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the cleaned signal does not start as abruptly as the original,
since some of the coefficients of the transient were also removed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
plt.plot(time, x, time, xrec, time, carrier)
plt.xlim([0, 0.1])
plt.xlabel('Time [sec]')
plt.ylabel('Signal')
plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<p>.. warning:: scipy.signal.kaiser is deprecated,
use scipy.signal.windows.kaiser instead.</p>
<h2 id="parameters_551">Parameters<a class="headerlink" href="#parameters_551" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
beta : float
Shape parameter, determines trade-off between main-lobe width and
side lobe level. As beta gets large, the window narrows.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_529">Returns<a class="headerlink" href="#returns_529" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="notes_359">Notes<a class="headerlink" href="#notes_359" title="Permanent link">&para;</a></h2>
<p>The Kaiser window is defined as</p>
<p>.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)</p>
<p>with</p>
<p>.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},</p>
<p>where :math:<code>I_0</code> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.</p>
<p>The Kaiser can approximate other windows by varying the beta parameter.
(Some literature uses alpha = beta/pi.) [4]_</p>
<p>====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hann
8.6   Similar to a Blackman
====  =======================</p>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
be returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
'removing the foot', i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<h2 id="references_125">References<a class="headerlink" href="#references_125" title="Permanent link">&para;</a></h2>
<p>.. [1] J. F. Kaiser, 'Digital Filters' - Ch 7 in 'Systems analysis by
digital computer', Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, 'Time Sequence Analysis in Geophysics', The
University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function
.. [4] F. J. Harris, 'On the use of windows for harmonic analysis with the
discrete Fourier transform,' Proceedings of the IEEE, vol. 66,
no. 1, pp. 51-83, Jan. 1978. :doi:<code>10.1109/PROC.1978.10837</code>.</p>
<h2 id="examples_463">Examples<a class="headerlink" href="#examples_463" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.kaiser(51, beta=14)
plt.plot(window)
plt.title(r'Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title(r'Frequency response of the Kaiser window (<span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>=14)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser_atten</span> <span class="o">:</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the attenuation of a Kaiser FIR filter.</p>
<p>Given the number of taps <code>N</code> and the transition width <code>width</code>, compute the
attenuation <code>a</code> in dB, given by Kaiser's formula:</p>
<p>a = 2.285 * (N - 1) * pi * width + 7.95</p>
<h2 id="parameters_552">Parameters<a class="headerlink" href="#parameters_552" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The number of taps in the FIR filter.
width : float
The desired width of the transition region between passband and
stopband (or, in general, at any discontinuity) for the filter,
expressed as a fraction of the Nyquist frequency.</p>
<h2 id="returns_530">Returns<a class="headerlink" href="#returns_530" title="Permanent link">&para;</a></h2>
<p>a : float
The attenuation of the ripple, in dB.</p>
<h2 id="see-also_361">See Also<a class="headerlink" href="#see-also_361" title="Permanent link">&para;</a></h2>
<p>kaiserord, kaiser_beta</p>
<h2 id="examples_464">Examples<a class="headerlink" href="#examples_464" title="Permanent link">&para;</a></h2>
<p>Suppose we want to design a FIR filter using the Kaiser window method
that will have 211 taps and a transition width of 9 Hz for a signal that
is sampled at 480 Hz.  Expressed as a fraction of the Nyquist frequency,
the width is 9/(0.5*480) = 0.0375.  The approximate attenuation (in dB)
is computed as follows:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiser_atten
kaiser_atten(211, 0.0375)
64.48099630593983</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiser_beta</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Kaiser parameter <code>beta</code>, given the attenuation <code>a</code>.</p>
<h2 id="parameters_553">Parameters<a class="headerlink" href="#parameters_553" title="Permanent link">&para;</a></h2>
<p>a : float
The desired attenuation in the stopband and maximum ripple in
the passband, in dB.  This should be a <em>positive</em> number.</p>
<h2 id="returns_531">Returns<a class="headerlink" href="#returns_531" title="Permanent link">&para;</a></h2>
<p>beta : float
The <code>beta</code> parameter to be used in the formula for a Kaiser window.</p>
<h2 id="references_126">References<a class="headerlink" href="#references_126" title="Permanent link">&para;</a></h2>
<p>Oppenheim, Schafer, 'Discrete-Time Signal Processing', p.475-476.</p>
<h2 id="examples_465">Examples<a class="headerlink" href="#examples_465" title="Permanent link">&para;</a></h2>
<p>Suppose we want to design a lowpass filter, with 65 dB attenuation
in the stop band.  The Kaiser window parameter to be used in the
window method is computed by <code>kaiser_beta(65)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiser_beta
kaiser_beta(65)
6.20426</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kaiserord</span> <span class="o">:</span> <span class="n">ripple</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">width</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Determine the filter window parameters for the Kaiser window method.</p>
<p>The parameters returned by this function are generally used to create
a finite impulse response filter using the window method, with either
<code>firwin</code> or <code>firwin2</code>.</p>
<h2 id="parameters_554">Parameters<a class="headerlink" href="#parameters_554" title="Permanent link">&para;</a></h2>
<p>ripple : float
Upper bound for the deviation (in dB) of the magnitude of the
filter's frequency response from that of the desired filter (not
including frequencies in any transition intervals).  That is, if w
is the frequency expressed as a fraction of the Nyquist frequency,
A(w) is the actual frequency response of the filter and D(w) is the
desired frequency response, the design requirement is that::</p>
<p>abs(A(w) - D(w))) &lt; 10**(-ripple/20)</p>
<p>for 0 &lt;= w &lt;= 1 and w not in a transition interval.
width : float
Width of transition region, normalized so that 1 corresponds to pi
radians / sample.  That is, the frequency is expressed as a fraction
of the Nyquist frequency.</p>
<h2 id="returns_532">Returns<a class="headerlink" href="#returns_532" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The length of the Kaiser window.
beta : float
The beta parameter for the Kaiser window.</p>
<h2 id="see-also_362">See Also<a class="headerlink" href="#see-also_362" title="Permanent link">&para;</a></h2>
<p>kaiser_beta, kaiser_atten</p>
<h2 id="notes_360">Notes<a class="headerlink" href="#notes_360" title="Permanent link">&para;</a></h2>
<p>There are several ways to obtain the Kaiser window:</p>
<ul>
<li><code>signal.kaiser(numtaps, beta, sym=True)</code></li>
<li><code>signal.get_window(beta, numtaps)</code></li>
<li><code>signal.get_window(('kaiser', beta), numtaps)</code></li>
</ul>
<p>The empirical equations discovered by Kaiser are used.</p>
<h2 id="references_127">References<a class="headerlink" href="#references_127" title="Permanent link">&para;</a></h2>
<p>Oppenheim, Schafer, 'Discrete-Time Signal Processing', p.475-476.</p>
<h2 id="examples_466">Examples<a class="headerlink" href="#examples_466" title="Permanent link">&para;</a></h2>
<p>We will use the Kaiser window method to design a lowpass FIR filter
for a signal that is sampled at 1000 Hz.</p>
<p>We want at least 65 dB rejection in the stop band, and in the pass
band the gain should vary no more than 0.5%.</p>
<p>We want a cutoff frequency of 175 Hz, with a transition between the
pass band and the stop band of 24 Hz.  That is, in the band [0, 163],
the gain varies no more than 0.5%, and in the band [187, 500], the
signal is attenuated by at least 65 dB.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import kaiserord, firwin, freqz
import matplotlib.pyplot as plt
fs = 1000.0
cutoff = 175
width = 24</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Kaiser method accepts just a single parameter to control the pass
band ripple and the stop band rejection, so we use the more restrictive
of the two.  In this case, the pass band ripple is 0.005, or 46.02 dB,
so we will use 65 dB as the design parameter.</p>
<p>Use <code>kaiserord</code> to determine the length of the filter and the
parameter for the Kaiser window.</p>
<blockquote>
<blockquote>
<blockquote>
<p>numtaps, beta = kaiserord(65, width/(0.5*fs))
numtaps
167
beta
6.20426</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use <code>firwin</code> to create the FIR filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>taps = firwin(numtaps, cutoff, window=('kaiser', beta),
...               scale=False, nyq=0.5*fs)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the frequency response of the filter.  <code>w</code> is the array of
frequencies, and <code>h</code> is the corresponding complex array of frequency
responses.</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = freqz(taps, worN=8000)
w <em>= 0.5</em>fs/np.pi  # Convert w to Hz.</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the deviation of the magnitude of the filter's response from
that of the ideal lowpass filter.  Values in the transition region are
set to <code>nan</code>, so they won't appear in the plot.</p>
<blockquote>
<blockquote>
<blockquote>
<p>ideal = w &lt; cutoff  # The 'ideal' frequency response.
deviation = np.abs(np.abs(h) - ideal)
deviation[(w &gt; cutoff - 0.5<em>width) &amp; (w &lt; cutoff + 0.5</em>width)] = np.nan</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the deviation.  A close look at the left end of the stop band shows
that the requirement for 65 dB attenuation is violated in the first lobe
by about 0.125 dB.  This is not unusual for the Kaiser window method.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(w, 20<em>np.log10(np.abs(deviation)))
plt.xlim(0, 0.5</em>fs)
plt.ylim(-90, -60)
plt.grid(alpha=0.25)
plt.axhline(-65, color='r', ls='--', alpha=0.3)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Deviation from ideal (dB)')
plt.title('Lowpass Filter Frequency Response')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfilter</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zi</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Filter data along one-dimension with an IIR or FIR filter.</p>
<p>Filter a data sequence, <code>x</code>, using a digital filter.  This works for many
fundamental data types (including Object type).  The filter is a direct
form II transposed implementation of the standard difference equation
(see Notes).</p>
<p>The function <code>sosfilt</code> (and filter design using <code>output='sos'</code>) should be
preferred over <code>lfilter</code> for most filtering tasks, as second-order sections
have fewer numerical problems.</p>
<h2 id="parameters_555">Parameters<a class="headerlink" href="#parameters_555" title="Permanent link">&para;</a></h2>
<p>b : array_like
The numerator coefficient vector in a 1-D sequence.
a : array_like
The denominator coefficient vector in a 1-D sequence.  If <code>a[0]</code>
is not 1, then both <code>a</code> and <code>b</code> are normalized by <code>a[0]</code>.
x : array_like
An N-dimensional input array.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.
zi : array_like, optional
Initial conditions for the filter delays.  It is a vector
(or array of vectors for an N-dimensional input) of length
<code>max(len(a), len(b)) - 1</code>.  If <code>zi</code> is None or is not given then
initial rest is assumed.  See <code>lfiltic</code> for more information.</p>
<h2 id="returns_533">Returns<a class="headerlink" href="#returns_533" title="Permanent link">&para;</a></h2>
<p>y : array
The output of the digital filter.
zf : array, optional
If <code>zi</code> is None, this is not returned, otherwise, <code>zf</code> holds the
final filter delay values.</p>
<h2 id="see-also_363">See Also<a class="headerlink" href="#see-also_363" title="Permanent link">&para;</a></h2>
<p>lfiltic : Construct initial conditions for <code>lfilter</code>.
lfilter_zi : Compute initial state (steady state of step response) for
<code>lfilter</code>.
filtfilt : A forward-backward filter, to obtain a filter with linear phase.
savgol_filter : A Savitzky-Golay filter.
sosfilt: Filter data using cascaded second-order sections.
sosfiltfilt: A forward-backward filter using second-order sections.</p>
<h2 id="notes_361">Notes<a class="headerlink" href="#notes_361" title="Permanent link">&para;</a></h2>
<p>The filter function is implemented as a direct II transposed structure.
This means that the filter implements::</p>
<p>a[0]<em>y[n] = b[0]</em>x[n] + b[1]<em>x[n-1] + ... + b[M]</em>x[n-M]
- a[1]<em>y[n-1] - ... - a[N]</em>y[n-N]</p>
<p>where <code>M</code> is the degree of the numerator, <code>N</code> is the degree of the
denominator, and <code>n</code> is the sample number.  It is implemented using
the following difference equations (assuming M = N)::</p>
<p>a[0]<em>y[n] = b[0] * x[n]               + d[0][n-1]
d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]
d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]
...
d[N-2][n] = b[N-1]</em>x[n] - a[N-1]*y[n] + d[N-1][n-1]
d[N-1][n] = b[N] * x[n] - a[N] * y[n]</p>
<p>where <code>d</code> are the state variables.</p>
<p>The rational transfer function describing this filter in the
z-transform domain is::</p>
<p>-1              -M
b[0] + b[1]z  + ... + b[M] z
Y(z) = -------------------------------- X(z)
-1              -N
a[0] + a[1]z  + ... + a[N] z</p>
<h2 id="examples_467">Examples<a class="headerlink" href="#examples_467" title="Permanent link">&para;</a></h2>
<p>Generate a noisy signal to be filtered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(-1, 1, 201)
x = (np.sin(2<em>np.pi</em>0.75<em>t</em>(1-t) + 2.1) +
...      0.1<em>np.sin(2</em>np.pi<em>1.25</em>t + 1) +
...      0.18<em>np.cos(2</em>np.pi<em>3.85</em>t))
xn = x + np.random.randn(len(t)) * 0.08</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create an order 3 lowpass butterworth filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.butter(3, 0.05)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter to xn.  Use lfilter_zi to choose the initial condition of
the filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>zi = signal.lfilter_zi(b, a)
z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply the filter again, to have a result filtered at an order the same as
filtfilt:</p>
<blockquote>
<blockquote>
<blockquote>
<p>z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use filtfilt to apply the filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = signal.filtfilt(b, a, xn)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the original signal and the various filtered versions:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure
plt.plot(t, xn, 'b', alpha=0.75)
plt.plot(t, z, 'r--', t, z2, 'r', t, y, 'k')
plt.legend(('noisy signal', 'lfilter, once', 'lfilter, twice',
...             'filtfilt'), loc='best')
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfilter_zi</span> <span class="o">:</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for lfilter for step response steady-state.</p>
<p>Compute an initial state <code>zi</code> for the <code>lfilter</code> function that corresponds
to the steady state of the step response.</p>
<p>A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.</p>
<h2 id="parameters_556">Parameters<a class="headerlink" href="#parameters_556" title="Permanent link">&para;</a></h2>
<p>b, a : array_like (1-D)
The IIR filter coefficients. See <code>lfilter</code> for more
information.</p>
<h2 id="returns_534">Returns<a class="headerlink" href="#returns_534" title="Permanent link">&para;</a></h2>
<p>zi : 1-D ndarray
The initial state for the filter.</p>
<h2 id="see-also_364">See Also<a class="headerlink" href="#see-also_364" title="Permanent link">&para;</a></h2>
<p>lfilter, lfiltic, filtfilt</p>
<h2 id="notes_362">Notes<a class="headerlink" href="#notes_362" title="Permanent link">&para;</a></h2>
<p>A linear filter with order m has a state space representation (A, B, C, D),
for which the output y of the filter can be expressed as::</p>
<p>z(n+1) = A<em>z(n) + B</em>x(n)
y(n)   = C<em>z(n) + D</em>x(n)</p>
<p>where z(n) is a vector of length m, A has shape (m, m), B has shape
(m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is
a scalar).  lfilter_zi solves::</p>
<p>zi = A*zi + B</p>
<p>In other words, it finds the initial condition for which the response
to an input of all ones is a constant.</p>
<p>Given the filter coefficients <code>a</code> and <code>b</code>, the state space matrices
for the transposed direct form II implementation of the linear filter,
which is the implementation used by scipy.signal.lfilter, are::</p>
<p>A = scipy.linalg.companion(a).T
B = b[1:] - a[1:]*b[0]</p>
<p>assuming <code>a[0]</code> is 1.0; if <code>a[0]</code> is not 1, <code>a</code> and <code>b</code> are first
divided by a[0].</p>
<h2 id="examples_468">Examples<a class="headerlink" href="#examples_468" title="Permanent link">&para;</a></h2>
<p>The following code creates a lowpass Butterworth filter. Then it
applies that filter to an array whose values are all 1.0; the
output is also all 1.0, as expected for a lowpass filter.  If the
<code>zi</code> argument of <code>lfilter</code> had not been given, the output would have
shown the transient signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array, ones
from scipy.signal import lfilter, lfilter_zi, butter
b, a = butter(5, 0.25)
zi = lfilter_zi(b, a)
y, zo = lfilter(b, a, ones(10), zi=zi)
y
array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Another example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])
y, zf = lfilter(b, a, x, zi=zi*x[0])
y
array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,
0.44399389,  0.35505241])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the <code>zi</code> argument to <code>lfilter</code> was computed using
<code>lfilter_zi</code> and scaled by <code>x[0]</code>.  Then the output <code>y</code> has no
transient until the input drops from 0.5 to 0.0.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lfiltic</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for lfilter given input and output vectors.</p>
<p>Given a linear filter (b, a) and initial conditions on the output <code>y</code>
and the input <code>x</code>, return the initial conditions on the state vector zi
which is used by <code>lfilter</code> to generate the output given the input.</p>
<h2 id="parameters_557">Parameters<a class="headerlink" href="#parameters_557" title="Permanent link">&para;</a></h2>
<p>b : array_like
Linear filter term.
a : array_like
Linear filter term.
y : array_like
Initial conditions.</p>
<p>If <code>N = len(a) - 1</code>, then <code>y = {y[-1], y[-2], ..., y[-N]}</code>.</p>
<p>If <code>y</code> is too short, it is padded with zeros.
x : array_like, optional
Initial conditions.</p>
<p>If <code>M = len(b) - 1</code>, then <code>x = {x[-1], x[-2], ..., x[-M]}</code>.</p>
<p>If <code>x</code> is not given, its initial conditions are assumed zero.</p>
<p>If <code>x</code> is too short, it is padded with zeros.</p>
<h2 id="returns_535">Returns<a class="headerlink" href="#returns_535" title="Permanent link">&para;</a></h2>
<p>zi : ndarray
The state vector <code>zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}</code>,
where <code>K = max(M, N)</code>.</p>
<h2 id="see-also_365">See Also<a class="headerlink" href="#see-also_365" title="Permanent link">&para;</a></h2>
<p>lfilter, lfilter_zi</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lombscargle</span> <span class="o">:</span> <span class="o">?</span><span class="n">precenter</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">normalize</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">freqs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lombscargle(x, y, freqs)</p>
<p>Computes the Lomb-Scargle periodogram.</p>
<p>The Lomb-Scargle periodogram was developed by Lomb [1]<em> and further
extended by Scargle [2]</em> to find, and test the significance of weak
periodic signals with uneven temporal sampling.</p>
<p>When <em>normalize</em> is False (default) the computed periodogram
is unnormalized, it takes the value <code>(A**2) * N/4</code> for a harmonic
signal with amplitude A for sufficiently large N.</p>
<p>When <em>normalize</em> is True the computed periodogram is normalized by
the residuals of the data around a constant reference model (at zero).</p>
<p>Input arrays should be one-dimensional and will be cast to float64.</p>
<h2 id="parameters_558">Parameters<a class="headerlink" href="#parameters_558" title="Permanent link">&para;</a></h2>
<p>x : array_like
Sample times.
y : array_like
Measurement values.
freqs : array_like
Angular frequencies for output periodogram.
precenter : bool, optional
Pre-center amplitudes by subtracting the mean.
normalize : bool, optional
Compute normalized periodogram.</p>
<h2 id="returns_536">Returns<a class="headerlink" href="#returns_536" title="Permanent link">&para;</a></h2>
<p>pgram : array_like
Lomb-Scargle periodogram.</p>
<h2 id="raises_80">Raises<a class="headerlink" href="#raises_80" title="Permanent link">&para;</a></h2>
<p>ValueError
If the input arrays <code>x</code> and <code>y</code> do not have the same shape.</p>
<h2 id="notes_363">Notes<a class="headerlink" href="#notes_363" title="Permanent link">&para;</a></h2>
<p>This subroutine calculates the periodogram using a slightly
modified algorithm due to Townsend [3]_ which allows the
periodogram to be calculated using only a single pass through
the input arrays for each frequency.</p>
<p>The algorithm running time scales roughly as O(x * freqs) or O(N^2)
for a large number of samples and frequencies.</p>
<h2 id="references_128">References<a class="headerlink" href="#references_128" title="Permanent link">&para;</a></h2>
<p>.. [1] N.R. Lomb 'Least-squares frequency analysis of unequally spaced
data', Astrophysics and Space Science, vol 39, pp. 447-462, 1976</p>
<p>.. [2] J.D. Scargle 'Studies in astronomical time series analysis. II -
Statistical aspects of spectral analysis of unevenly spaced data',
The Astrophysical Journal, vol 263, pp. 835-853, 1982</p>
<p>.. [3] R.H.D. Townsend, 'Fast calculation of the Lomb-Scargle
periodogram using graphics processing units.', The Astrophysical
Journal Supplement Series, vol 191, pp. 247-253, 2010</p>
<h2 id="see-also_366">See Also<a class="headerlink" href="#see-also_366" title="Permanent link">&para;</a></h2>
<p>istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint is met
welch: Power spectral density by Welch's method
spectrogram: Spectrogram by Welch's method
csd: Cross spectral density by Welch's method</p>
<h2 id="examples_469">Examples<a class="headerlink" href="#examples_469" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>First define some input parameters for the signal:</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = 2.
w = 1.
phi = 0.5 * np.pi
nin = 1000
nout = 100000
frac_points = 0.9 # Fraction of points to select</p>
</blockquote>
</blockquote>
</blockquote>
<p>Randomly select a fraction of an array with timesteps:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = np.random.rand(nin)
x = np.linspace(0.01, 10*np.pi, nin)
x = x[r &gt;= frac_points]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot a sine wave for the selected times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = A * np.sin(w*x+phi)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the array of frequencies for which to compute the periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = np.linspace(0.01, 10, nout)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate Lomb-Scargle periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.signal as signal
pgram = signal.lombscargle(x, y, f, normalize=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now make a plot of the input data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.subplot(2, 1, 1)
plt.plot(x, y, 'b+')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then plot the normalized periodogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.subplot(2, 1, 2)
plt.plot(f, pgram)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandpass filter.</p>
<p>Return an analog band-pass filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</p>
<h2 id="parameters_559">Parameters<a class="headerlink" href="#parameters_559" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired passband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired passband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_537">Returns<a class="headerlink" href="#returns_537" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed band-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed band-pass filter.</p>
<h2 id="see-also_367">See Also<a class="headerlink" href="#see-also_367" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bs, bilinear
lp2bp_zpk</p>
<h2 id="notes_364">Notes<a class="headerlink" href="#notes_364" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</p>
<p>This is the 'wideband' transformation, producing a passband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<h2 id="examples_470">Examples<a class="headerlink" href="#examples_470" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
bp = signal.lti( *signal.lp2bp(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_bp, p_bp = bp.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_bp, label='Bandpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandpass filter.</p>
<p>Return an analog band-pass filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_560">Parameters<a class="headerlink" href="#parameters_560" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired passband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired passband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_538">Returns<a class="headerlink" href="#returns_538" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed band-pass filter transfer function.
p : ndarray
Poles of the transformed band-pass filter transfer function.
k : float
System gain of the transformed band-pass filter.</p>
<h2 id="see-also_368">See Also<a class="headerlink" href="#see-also_368" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bs_zpk, bilinear
lp2bp</p>
<h2 id="notes_365">Notes<a class="headerlink" href="#notes_365" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}</p>
<p>This is the 'wideband' transformation, producing a passband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bs</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandstop filter.</p>
<p>Return an analog band-stop filter with center frequency <code>wo</code> and
bandwidth <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, in transfer function ('ba') representation.</p>
<h2 id="parameters_561">Parameters<a class="headerlink" href="#parameters_561" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired stopband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired stopband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_539">Returns<a class="headerlink" href="#returns_539" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed band-stop filter.
a : array_like
Denominator polynomial coefficients of the transformed band-stop filter.</p>
<h2 id="see-also_369">See Also<a class="headerlink" href="#see-also_369" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2hp, lp2bp, bilinear
lp2bs_zpk</p>
<h2 id="notes_366">Notes<a class="headerlink" href="#notes_366" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</p>
<p>This is the 'wideband' transformation, producing a stopband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<h2 id="examples_471">Examples<a class="headerlink" href="#examples_471" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.5])
bs = signal.lti( *signal.lp2bs(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_bs, p_bs = bs.bode(w)
plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_bs, label='Bandstop')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2bs_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">bw</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a bandstop filter.</p>
<p>Return an analog band-stop filter with center frequency <code>wo</code> and
stopband width <code>bw</code> from an analog low-pass filter prototype with unity
cutoff frequency, using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_562">Parameters<a class="headerlink" href="#parameters_562" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired stopband center, as angular frequency (e.g. rad/s).
Defaults to no change.
bw : float
Desired stopband width, as angular frequency (e.g. rad/s).
Defaults to 1.</p>
<h2 id="returns_540">Returns<a class="headerlink" href="#returns_540" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed band-stop filter transfer function.
p : ndarray
Poles of the transformed band-stop filter transfer function.
k : float
System gain of the transformed band-stop filter.</p>
<h2 id="see-also_370">See Also<a class="headerlink" href="#see-also_370" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, bilinear
lp2bs</p>
<h2 id="notes_367">Notes<a class="headerlink" href="#notes_367" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}</p>
<p>This is the 'wideband' transformation, producing a stopband with
geometric (log frequency) symmetry about <code>wo</code>.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2hp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a highpass filter.</p>
<p>Return an analog high-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</p>
<h2 id="parameters_563">Parameters<a class="headerlink" href="#parameters_563" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_541">Returns<a class="headerlink" href="#returns_541" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed high-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed high-pass filter.</p>
<h2 id="see-also_371">See Also<a class="headerlink" href="#see-also_371" title="Permanent link">&para;</a></h2>
<p>lp2lp, lp2bp, lp2bs, bilinear
lp2hp_zpk</p>
<h2 id="notes_368">Notes<a class="headerlink" href="#notes_368" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{\omega_0}{s}</p>
<p>This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.</p>
<h2 id="examples_472">Examples<a class="headerlink" href="#examples_472" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
hp = signal.lti( *signal.lp2hp(lp.num, lp.den))
w, mag_lp, p_lp = lp.bode()
w, mag_hp, p_hp = hp.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_hp, label='Highpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2hp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a highpass filter.</p>
<p>Return an analog high-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_564">Parameters<a class="headerlink" href="#parameters_564" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_542">Returns<a class="headerlink" href="#returns_542" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed high-pass filter transfer function.
p : ndarray
Poles of the transformed high-pass filter transfer function.
k : float
System gain of the transformed high-pass filter.</p>
<h2 id="see-also_372">See Also<a class="headerlink" href="#see-also_372" title="Permanent link">&para;</a></h2>
<p>lp2lp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2hp</p>
<h2 id="notes_369">Notes<a class="headerlink" href="#notes_369" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{\omega_0}{s}</p>
<p>This maintains symmetry of the lowpass and highpass responses on a
logarithmic scale.</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2lp</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a different frequency.</p>
<p>Return an analog low-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency, in
transfer function ('ba') representation.</p>
<h2 id="parameters_565">Parameters<a class="headerlink" href="#parameters_565" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_543">Returns<a class="headerlink" href="#returns_543" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients of the transformed low-pass filter.
a : array_like
Denominator polynomial coefficients of the transformed low-pass filter.</p>
<h2 id="see-also_373">See Also<a class="headerlink" href="#see-also_373" title="Permanent link">&para;</a></h2>
<p>lp2hp, lp2bp, lp2bs, bilinear
lp2lp_zpk</p>
<h2 id="notes_370">Notes<a class="headerlink" href="#notes_370" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s}{\omega_0}</p>
<h2 id="examples_473">Examples<a class="headerlink" href="#examples_473" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>lp = signal.lti([1.0], [1.0, 1.0])
lp2 = signal.lti( *signal.lp2lp(lp.num, lp.den, 2))
w, mag_lp, p_lp = lp.bode()
w, mag_lp2, p_lp2 = lp2.bode(w)</p>
<p>plt.plot(w, mag_lp, label='Lowpass')
plt.plot(w, mag_lp2, label='Transformed Lowpass')
plt.semilogx()
plt.grid()
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude [dB]')
plt.legend()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lp2lp_zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">wo</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Transform a lowpass filter prototype to a different frequency.</p>
<p>Return an analog low-pass filter with cutoff frequency <code>wo</code>
from an analog low-pass filter prototype with unity cutoff frequency,
using zeros, poles, and gain ('zpk') representation.</p>
<h2 id="parameters_566">Parameters<a class="headerlink" href="#parameters_566" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the analog filter transfer function.
p : array_like
Poles of the analog filter transfer function.
k : float
System gain of the analog filter transfer function.
wo : float
Desired cutoff, as angular frequency (e.g. rad/s).
Defaults to no change.</p>
<h2 id="returns_544">Returns<a class="headerlink" href="#returns_544" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transformed low-pass filter transfer function.
p : ndarray
Poles of the transformed low-pass filter transfer function.
k : float
System gain of the transformed low-pass filter.</p>
<h2 id="see-also_374">See Also<a class="headerlink" href="#see-also_374" title="Permanent link">&para;</a></h2>
<p>lp2hp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear
lp2lp</p>
<h2 id="notes_371">Notes<a class="headerlink" href="#notes_371" title="Permanent link">&para;</a></h2>
<p>This is derived from the s-plane substitution</p>
<p>.. math:: s \rightarrow \frac{s}{\omega_0}</p>
<p>.. versionadded:: 1.1.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsim</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">interp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a continuous-time linear system.</p>
<h2 id="parameters_567">Parameters<a class="headerlink" href="#parameters_567" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>U : array_like
An input array describing the input at each time <code>T</code>
(interpolation is assumed between given times).  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U = 0 or None, a zero input is used.
T : array_like
The time steps at which the input is defined and at which the
output is desired.  Must be nonnegative, increasing, and equally spaced.
X0 : array_like, optional
The initial conditions on the state vector (zero by default).
interp : bool, optional
Whether to use linear (True, the default) or zero-order-hold (False)
interpolation for the input array.</p>
<h2 id="returns_545">Returns<a class="headerlink" href="#returns_545" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Time values for the output.
yout : 1D ndarray
System response.
xout : ndarray
Time evolution of the state vector.</p>
<h2 id="notes_372">Notes<a class="headerlink" href="#notes_372" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_474">Examples<a class="headerlink" href="#examples_474" title="Permanent link">&para;</a></h2>
<p>Simulate a double integrator y'' = u, with a constant input u = 1</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
system = signal.lti([[0., 1.], [0., 0.]], [[0.], [1.]], [[1., 0.]], 0.)
t = np.linspace(0, 5)
u = np.ones_like(t)
tout, y, x = signal.lsim(system, u, t)
import matplotlib.pyplot as plt
plt.plot(t, y)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lsim2</span> <span class="o">:</span> <span class="o">?</span><span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Simulate output of a continuous-time linear system, by using
the ODE solver <code>scipy.integrate.odeint</code>.</p>
<h2 id="parameters_568">Parameters<a class="headerlink" href="#parameters_568" title="Permanent link">&para;</a></h2>
<p>system : an instance of the <code>lti</code> class or a tuple describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1: (instance of <code>lti</code>)</li>
<li>2: (num, den)</li>
<li>3: (zeros, poles, gain)</li>
<li>4: (A, B, C, D)</li>
</ul>
<p>U : array_like (1D or 2D), optional
An input array describing the input at each time T.  Linear
interpolation is used between given times.  If there are
multiple inputs, then each column of the rank-2 array
represents an input.  If U is not given, the input is assumed
to be zero.
T : array_like (1D or 2D), optional
The time steps at which the input is defined and at which the
output is desired.  The default is 101 evenly spaced points on
the interval [0,10.0].
X0 : array_like (1D), optional
The initial condition of the state vector.  If <code>X0</code> is not
given, the initial conditions are assumed to be 0.
kwargs : dict
Additional keyword arguments are passed on to the function
<code>odeint</code>.  See the notes below for more details.</p>
<h2 id="returns_546">Returns<a class="headerlink" href="#returns_546" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
The time values for the output.
yout : ndarray
The response of the system.
xout : ndarray
The time-evolution of the state-vector.</p>
<h2 id="notes_373">Notes<a class="headerlink" href="#notes_373" title="Permanent link">&para;</a></h2>
<p>This function uses <code>scipy.integrate.odeint</code> to solve the
system's differential equations.  Additional keyword arguments
given to <code>lsim2</code> are passed on to <code>odeint</code>.  See the documentation
for <code>scipy.integrate.odeint</code> for the full list of arguments.</p>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max_len_seq</span> <span class="o">:</span> <span class="o">?</span><span class="n">state</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">length</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">taps</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">nbits</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Maximum length sequence (MLS) generator.</p>
<h2 id="parameters_569">Parameters<a class="headerlink" href="#parameters_569" title="Permanent link">&para;</a></h2>
<p>nbits : int
Number of bits to use. Length of the resulting sequence will
be <code>(2**nbits) - 1</code>. Note that generating long sequences
(e.g., greater than <code>nbits == 16</code>) can take a long time.
state : array_like, optional
If array, must be of length <code>nbits</code>, and will be cast to binary
(bool) representation. If None, a seed of ones will be used,
producing a repeatable representation. If <code>state</code> is all
zeros, an error is raised as this is invalid. Default: None.
length : int, optional
Number of samples to compute. If None, the entire length
<code>(2**nbits) - 1</code> is computed.
taps : array_like, optional
Polynomial taps to use (e.g., <code>[7, 6, 1]</code> for an 8-bit sequence).
If None, taps will be automatically selected (for up to
<code>nbits == 32</code>).</p>
<h2 id="returns_547">Returns<a class="headerlink" href="#returns_547" title="Permanent link">&para;</a></h2>
<p>seq : array
Resulting MLS sequence of 0's and 1's.
state : array
The final state of the shift register.</p>
<h2 id="notes_374">Notes<a class="headerlink" href="#notes_374" title="Permanent link">&para;</a></h2>
<p>The algorithm for MLS generation is generically described in:</p>
<p>https://en.wikipedia.org/wiki/Maximum_length_sequence</p>
<p>The default values for taps are specifically taken from the first
option listed for each value of <code>nbits</code> in:</p>
<p>http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm</p>
<p>.. versionadded:: 0.15.0</p>
<h2 id="examples_475">Examples<a class="headerlink" href="#examples_475" title="Permanent link">&para;</a></h2>
<p>MLS uses binary convention:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import max_len_seq
max_len_seq(4)[0]
array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)</p>
</blockquote>
</blockquote>
</blockquote>
<p>MLS has a white spectrum (except for DC):</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from numpy.fft import fft, ifft, fftshift, fftfreq
seq = max_len_seq(6)[0]*2-1  # +1 and -1
spec = fft(seq)
N = len(seq)
plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')
plt.margins(0.1, 0.1)
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Circular autocorrelation of MLS is an impulse:</p>
<blockquote>
<blockquote>
<blockquote>
<p>acorrcirc = ifft(spec * np.conj(spec)).real
plt.figure()
plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')
plt.margins(0.1, 0.1)
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Linear autocorrelation of MLS is approximately an impulse:</p>
<blockquote>
<blockquote>
<blockquote>
<p>acorr = np.correlate(seq, seq, 'full')
plt.figure()
plt.plot(np.arange(-N+1, N), acorr, '.-')
plt.margins(0.1, 0.1)
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">medfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">kernel_size</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">volume</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform a median filter on an N-dimensional array.</p>
<p>Apply a median filter to the input array using a local window-size
given by <code>kernel_size</code>. The array will automatically be zero-padded.</p>
<h2 id="parameters_570">Parameters<a class="headerlink" href="#parameters_570" title="Permanent link">&para;</a></h2>
<p>volume : array_like
An N-dimensional input array.
kernel_size : array_like, optional
A scalar or an N-length list giving the size of the median filter
window in each dimension.  Elements of <code>kernel_size</code> should be odd.
If <code>kernel_size</code> is a scalar, then this scalar is used as the size in
each dimension. Default size is 3 for each dimension.</p>
<h2 id="returns_548">Returns<a class="headerlink" href="#returns_548" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array the same size as input containing the median filtered
result.</p>
<h2 id="see-also_375">See also<a class="headerlink" href="#see-also_375" title="Permanent link">&para;</a></h2>
<p>scipy.ndimage.median_filter</p>
<h2 id="notes_375">Notes<a class="headerlink" href="#notes_375" title="Permanent link">&para;</a></h2>
<p>The more general function <code>scipy.ndimage.median_filter</code> has a more
efficient implementation of a median filter and therefore runs much faster.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">medfilt2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">kernel_size</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Median filter a 2-dimensional array.</p>
<p>Apply a median filter to the <code>input</code> array using a local window-size
given by <code>kernel_size</code> (must be odd). The array is zero-padded
automatically.</p>
<h2 id="parameters_571">Parameters<a class="headerlink" href="#parameters_571" title="Permanent link">&para;</a></h2>
<p>input : array_like
A 2-dimensional input array.
kernel_size : array_like, optional
A scalar or a list of length 2, giving the size of the
median filter window in each dimension.  Elements of
<code>kernel_size</code> should be odd.  If <code>kernel_size</code> is a scalar,
then this scalar is used as the size in each dimension.
Default is a kernel of size (3, 3).</p>
<h2 id="returns_549">Returns<a class="headerlink" href="#returns_549" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array the same size as input containing the median filtered
result.</p>
<h2 id="see-also_376">See also<a class="headerlink" href="#see-also_376" title="Permanent link">&para;</a></h2>
<p>scipy.ndimage.median_filter</p>
<h2 id="notes_376">Notes<a class="headerlink" href="#notes_376" title="Permanent link">&para;</a></h2>
<p>The more general function <code>scipy.ndimage.median_filter</code> has a more
efficient implementation of a median filter and therefore runs much faster.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minimum_phase</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Hilbert</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Homomorphic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n_fft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a linear-phase FIR filter to minimum phase</p>
<h2 id="parameters_572">Parameters<a class="headerlink" href="#parameters_572" title="Permanent link">&para;</a></h2>
<p>h : array
Linear-phase FIR filter coefficients.
method : {'hilbert', 'homomorphic'}
The method to use:</p>
<p>'homomorphic' (default)
This method [4]<em> [5]</em> works best with filters with an
odd number of taps, and the resulting minimum phase filter
will have a magnitude response that approximates the square
root of the the original filter's magnitude response.</p>
<p>'hilbert'
This method [1]_ is designed to be used with equiripple
filters (e.g., from <code>remez</code>) with unity or zero gain
regions.</p>
<p>n_fft : int
The number of points to use for the FFT. Should be at least a
few times larger than the signal length (see Notes).</p>
<h2 id="returns_550">Returns<a class="headerlink" href="#returns_550" title="Permanent link">&para;</a></h2>
<p>h_minimum : array
The minimum-phase version of the filter, with length
<code>(length(h) + 1) // 2</code>.</p>
<h2 id="see-also_377">See Also<a class="headerlink" href="#see-also_377" title="Permanent link">&para;</a></h2>
<p>firwin
firwin2
remez</p>
<h2 id="notes_377">Notes<a class="headerlink" href="#notes_377" title="Permanent link">&para;</a></h2>
<p>Both the Hilbert [1]<em> or homomorphic [4]</em> [5]_ methods require selection
of an FFT length to estimate the complex cepstrum of the filter.</p>
<p>In the case of the Hilbert method, the deviation from the ideal
spectrum <code>epsilon</code> is related to the number of stopband zeros
<code>n_stop</code> and FFT length <code>n_fft</code> as::</p>
<p>epsilon = 2. * n_stop / n_fft</p>
<p>For example, with 100 stopband zeros and a FFT length of 2048,
<code>epsilon = 0.0976</code>. If we conservatively assume that the number of
stopband zeros is one less than the filter length, we can take the FFT
length to be the next power of 2 that satisfies <code>epsilon=0.01</code> as::</p>
<p>n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))</p>
<p>This gives reasonable results for both the Hilbert and homomorphic
methods, and gives the value used when <code>n_fft=None</code>.</p>
<p>Alternative implementations exist for creating minimum-phase filters,
including zero inversion [2]<em> and spectral factorization [3]</em> [4]_.
For more information, see:</p>
<p>http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters</p>
<h2 id="examples_476">Examples<a class="headerlink" href="#examples_476" title="Permanent link">&para;</a></h2>
<p>Create an optimal linear-phase filter, then convert it to minimum phase:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import remez, minimum_phase, freqz, group_delay
import matplotlib.pyplot as plt
freq = [0, 0.2, 0.3, 1.0]
desired = [1, 0]
h_linear = remez(151, freq, desired, Hz=2.)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert it to minimum phase:</p>
<blockquote>
<blockquote>
<blockquote>
<p>h_min_hom = minimum_phase(h_linear, method='homomorphic')
h_min_hil = minimum_phase(h_linear, method='hilbert')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare the three filters:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fig, axs = plt.subplots(4, figsize=(4, 8))
for h, style, color in zip((h_linear, h_min_hom, h_min_hil),
...                            ('-', '-', '--'), ('k', 'r', 'c')):
...     w, H = freqz(h)
...     w, gd = group_delay((h, 1))
...     w /= np.pi
...     axs[0].plot(h, color=color, linestyle=style)
...     axs[1].plot(w, np.abs(H), color=color, linestyle=style)
...     axs[2].plot(w, 20 * np.log10(np.abs(H)), color=color, linestyle=style)
...     axs[3].plot(w, gd, color=color, linestyle=style)
for ax in axs:
...     ax.grid(True, color='0.5')
...     ax.fill_between(freq[1:3], *ax.get_ylim(), color='#ffeeaa', zorder=1)
axs[0].set(xlim=[0, len(h_linear) - 1], ylabel='Amplitude', xlabel='Samples')
axs[1].legend(['Linear', 'Min-Hom', 'Min-Hil'], title='Phase')
for ax, ylim in zip(axs[1:], ([0, 1.1], [-150, 10], [-60, 60])):
...     ax.set(xlim=[0, 1], ylim=ylim, xlabel='Frequency')
axs[1].set(ylabel='Magnitude')
axs[2].set(ylabel='Magnitude (dB)')
axs[3].set(ylabel='Group delay')
plt.tight_layout()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_129">References<a class="headerlink" href="#references_129" title="Permanent link">&para;</a></h2>
<p>.. [1] N. Damera-Venkata and B. L. Evans, 'Optimal design of real and
complex minimum phase digital FIR filters,' Acoustics, Speech,
and Signal Processing, 1999. Proceedings., 1999 IEEE International
Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.
doi: 10.1109/ICASSP.1999.756179
.. [2] X. Chen and T. W. Parks, 'Design of optimal minimum phase FIR
filters by direct factorization,' Signal Processing,
vol. 10, no. 4, pp. 369-383, Jun. 1986.
.. [3] T. Saramaki, 'Finite Impulse Response Filter Design,' in
Handbook for Digital Signal Processing, chapter 4,
New York: Wiley-Interscience, 1993.
.. [4] J. S. Lim, Advanced Topics in Signal Processing.
Englewood Cliffs, N.J.: Prentice Hall, 1988.
.. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck,
'Discrete-Time Signal Processing,' 2nd edition.
Upper Saddle River, N.J.: Prentice Hall, 1999.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morlet</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">complete</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complex Morlet wavelet.</p>
<h2 id="parameters_573">Parameters<a class="headerlink" href="#parameters_573" title="Permanent link">&para;</a></h2>
<p>M : int
Length of the wavelet.
w : float, optional
Omega0. Default is 5
s : float, optional
Scaling factor, windowed from <code>-s*2*pi</code> to <code>+s*2*pi</code>. Default is 1.
complete : bool, optional
Whether to use the complete or the standard version.</p>
<h2 id="returns_551">Returns<a class="headerlink" href="#returns_551" title="Permanent link">&para;</a></h2>
<p>morlet : (M,) ndarray</p>
<h2 id="see-also_378">See Also<a class="headerlink" href="#see-also_378" title="Permanent link">&para;</a></h2>
<p>morlet2 : Implementation of Morlet wavelet, compatible with <code>cwt</code>.
scipy.signal.gausspulse</p>
<h2 id="notes_378">Notes<a class="headerlink" href="#notes_378" title="Permanent link">&para;</a></h2>
<p>The standard version::</p>
<p>pi<strong>-0.25 * exp(1j<em>w</em>x) * exp(-0.5*(x</strong>2))</p>
<p>This commonly used wavelet is often referred to simply as the
Morlet wavelet.  Note that this simplified version can cause
admissibility problems at low values of <code>w</code>.</p>
<p>The complete version::</p>
<p>pi<strong>-0.25 * (exp(1j<em>w</em>x) - exp(-0.5*(w</strong>2))) * exp(-0.5<em>(x</em>*2))</p>
<p>This version has a correction
term to improve admissibility. For <code>w</code> greater than 5, the
correction term is negligible.</p>
<p>Note that the energy of the return wavelet is not normalised
according to <code>s</code>.</p>
<p>The fundamental frequency of this wavelet in Hz is given
by <code>f = 2*s*w*r / M</code> where <code>r</code> is the sampling rate.</p>
<p>Note: This function was created before <code>cwt</code> and is not compatible
with it.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">morlet2</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Complex Morlet wavelet, designed to work with <code>cwt</code>.</p>
<p>Returns the complete version of morlet wavelet, normalised
according to <code>s</code>::</p>
<p>exp(1j<em>w</em>x/s) * exp(-0.5<em>(x/s)</em><em>2) * pi</em>*(-0.25) * sqrt(1/s)</p>
<h2 id="parameters_574">Parameters<a class="headerlink" href="#parameters_574" title="Permanent link">&para;</a></h2>
<p>M : int
Length of the wavelet.
s : float
Width parameter of the wavelet.
w : float, optional
Omega0. Default is 5</p>
<h2 id="returns_552">Returns<a class="headerlink" href="#returns_552" title="Permanent link">&para;</a></h2>
<p>morlet : (M,) ndarray</p>
<h2 id="see-also_379">See Also<a class="headerlink" href="#see-also_379" title="Permanent link">&para;</a></h2>
<p>morlet : Implementation of Morlet wavelet, incompatible with <code>cwt</code></p>
<h2 id="notes_379">Notes<a class="headerlink" href="#notes_379" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<p>This function was designed to work with <code>cwt</code>. Because <code>morlet2</code>
returns an array of complex numbers, the <code>dtype</code> argument of <code>cwt</code>
should be set to <code>complex128</code> for best results.</p>
<p>Note the difference in implementation with <code>morlet</code>.
The fundamental frequency of this wavelet in Hz is given by::</p>
<p>f = w<em>fs / (2</em>s*np.pi)</p>
<p>where <code>fs</code> is the sampling rate and <code>s</code> is the wavelet width parameter.
Similarly we can get the wavelet width parameter at <code>f</code>::</p>
<p>s = w<em>fs / (2</em>f*np.pi)</p>
<h2 id="examples_477">Examples<a class="headerlink" href="#examples_477" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>M = 100
s = 4.0
w = 2.0
wavelet = signal.morlet2(M, s, w)
plt.plot(abs(wavelet))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows basic use of <code>morlet2</code> with <code>cwt</code> in time-frequency
analysis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t, dt = np.linspace(0, 1, 200, retstep=True)
fs = 1/dt
w = 6.
sig = np.cos(2<em>np.pi</em>(50 + 10<em>t)</em>t) + np.sin(40<em>np.pi</em>t)
freq = np.linspace(1, fs/2, 100)
widths = w<em>fs / (2</em>freq*np.pi)
cwtm = signal.cwt(sig, signal.morlet2, widths, w=w)
plt.pcolormesh(t, freq, np.abs(cwtm), cmap='viridis')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">normalize</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Normalize numerator/denominator of a continuous-time transfer function.</p>
<p>If values of <code>b</code> are too close to 0, they are removed. In that case, a
BadCoefficients warning is emitted.</p>
<h2 id="parameters_575">Parameters<a class="headerlink" href="#parameters_575" title="Permanent link">&para;</a></h2>
<p>b: array_like
Numerator of the transfer function. Can be a 2d array to normalize
multiple transfer functions.
a: array_like
Denominator of the transfer function. At most 1d.</p>
<h2 id="returns_553">Returns<a class="headerlink" href="#returns_553" title="Permanent link">&para;</a></h2>
<p>num: array
The numerator of the normalized transfer function. At least a 1d
array. A 2d-array if the input <code>num</code> is a 2d array.
den: 1d-array
The denominator of the normalized transfer function.</p>
<h2 id="notes_380">Notes<a class="headerlink" href="#notes_380" title="Permanent link">&para;</a></h2>
<p>Coefficients for both the numerator and denominator should be specified in
descending exponent order (e.g., <code>s^2 + 3s + 5</code> would be represented as
<code>[1, 3, 5]</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nuttall</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a minimum 4-term Blackman-Harris window according to Nuttall.</p>
<p>This variation is called 'Nuttall4c' by Heinzel. [2]_</p>
<p>.. warning:: scipy.signal.nuttall is deprecated,
use scipy.signal.windows.nuttall instead.</p>
<h2 id="parameters_576">Parameters<a class="headerlink" href="#parameters_576" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_554">Returns<a class="headerlink" href="#returns_554" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_130">References<a class="headerlink" href="#references_130" title="Permanent link">&para;</a></h2>
<p>.. [1] A. Nuttall, 'Some windows with very good sidelobe behavior,' IEEE
Transactions on Acoustics, Speech, and Signal Processing, vol. 29,
no. 1, pp. 84-91, Feb 1981. :doi:<code>10.1109/TASSP.1981.1163506</code>.
.. [2] Heinzel G. et al., 'Spectrum and spectral density estimation by the
Discrete Fourier transform (DFT), including a comprehensive list of
window functions and some new flat-top windows', February 15, 2002
https://holometer.fnal.gov/GH_FFT.pdf</p>
<h2 id="examples_478">Examples<a class="headerlink" href="#examples_478" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.nuttall(51)
plt.plot(window)
plt.title('Nuttall window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Nuttall window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">oaconvolve</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Valid</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Same</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axes</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Array_like_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">in1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">in2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convolve two N-dimensional arrays using the overlap-add method.</p>
<p>Convolve <code>in1</code> and <code>in2</code> using the overlap-add method, with
the output size determined by the <code>mode</code> argument.</p>
<p>This is generally much faster than <code>convolve</code> for large arrays (n &gt; ~500),
and generally much faster than <code>fftconvolve</code> when one array is much
larger than the other, but can be slower when only a few output values are
needed or when the arrays are very similar in shape, and can only
output float arrays (int or object array inputs will be cast to float).</p>
<h2 id="parameters_577">Parameters<a class="headerlink" href="#parameters_577" title="Permanent link">&para;</a></h2>
<p>in1 : array_like
First input.
in2 : array_like
Second input. Should have the same number of dimensions as <code>in1</code>.
mode : str {'full', 'valid', 'same'}, optional
A string indicating the size of the output:</p>
<p><code>full</code>
The output is the full discrete linear convolution
of the inputs. (Default)
<code>valid</code>
The output consists only of those elements that do not
rely on the zero-padding. In 'valid' mode, either <code>in1</code> or <code>in2</code>
must be at least as large as the other in every dimension.
<code>same</code>
The output is the same size as <code>in1</code>, centered
with respect to the 'full' output.
axes : int or array_like of ints or None, optional
Axes over which to compute the convolution.
The default is over all axes.</p>
<h2 id="returns_555">Returns<a class="headerlink" href="#returns_555" title="Permanent link">&para;</a></h2>
<p>out : array
An N-dimensional array containing a subset of the discrete linear
convolution of <code>in1</code> with <code>in2</code>.</p>
<h2 id="see-also_380">See Also<a class="headerlink" href="#see-also_380" title="Permanent link">&para;</a></h2>
<p>convolve : Uses the direct convolution or FFT convolution algorithm
depending on which is faster.
fftconvolve : An implementation of convolution using FFT.</p>
<h2 id="notes_381">Notes<a class="headerlink" href="#notes_381" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.4.0</p>
<h2 id="examples_479">Examples<a class="headerlink" href="#examples_479" title="Permanent link">&para;</a></h2>
<p>Convolve a 100,000 sample signal with a 512-sample filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sig = np.random.randn(100000)
filt = signal.firwin(512, 0.01)
fsig = signal.oaconvolve(sig, filt)</p>
<p>import matplotlib.pyplot as plt
fig, (ax_orig, ax_mag) = plt.subplots(2, 1)
ax_orig.plot(sig)
ax_orig.set_title('White noise')
ax_mag.plot(fsig)
ax_mag.set_title('Filtered noise')
fig.tight_layout()
fig.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_131">References<a class="headerlink" href="#references_131" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia, 'Overlap-add_method'.
https://en.wikipedia.org/wiki/Overlap-add_method
.. [2] Richard G. Lyons. Understanding Digital Signal Processing,
Third Edition, 2011. Chapter 13.10.
ISBN 13: 978-0137-02741-5</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">order_filter</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">domain</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rank</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform an order filter on an N-dimensional array.</p>
<p>Perform an order filter on the array in.  The domain argument acts as a
mask centered over each pixel.  The non-zero elements of domain are
used to select elements surrounding each input pixel which are placed
in a list.   The list is sorted, and the output for that pixel is the
element corresponding to rank in the sorted list.</p>
<h2 id="parameters_578">Parameters<a class="headerlink" href="#parameters_578" title="Permanent link">&para;</a></h2>
<p>a : ndarray
The N-dimensional input array.
domain : array_like
A mask array with the same number of dimensions as <code>a</code>.
Each dimension should have an odd number of elements.
rank : int
A non-negative integer which selects the element from the
sorted list (0 corresponds to the smallest element, 1 is the
next smallest element, etc.).</p>
<h2 id="returns_556">Returns<a class="headerlink" href="#returns_556" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The results of the order filter in an array with the same
shape as <code>a</code>.</p>
<h2 id="examples_480">Examples<a class="headerlink" href="#examples_480" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
x = np.arange(25).reshape(5, 5)
domain = np.identity(3)
x
array([[ 0,  1,  2,  3,  4],
[ 5,  6,  7,  8,  9],
[10, 11, 12, 13, 14],
[15, 16, 17, 18, 19],
[20, 21, 22, 23, 24]])
signal.order_filter(x, domain, 0)
array([[  0.,   0.,   0.,   0.,   0.],
[  0.,   0.,   1.,   2.,   0.],
[  0.,   5.,   6.,   7.,   0.],
[  0.,  10.,  11.,  12.,   0.],
[  0.,   0.,   0.,   0.,   0.]])
signal.order_filter(x, domain, 2)
array([[  6.,   7.,   8.,   9.,   4.],
[ 11.,  12.,  13.,  14.,   9.],
[ 16.,  17.,  18.,  19.,  14.],
[ 21.,  22.,  23.,  24.,  19.],
[ 20.,  21.,  22.,  23.,  24.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">parzen</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Parzen window.</p>
<p>.. warning:: scipy.signal.parzen is deprecated,
use scipy.signal.windows.parzen instead.</p>
<h2 id="parameters_579">Parameters<a class="headerlink" href="#parameters_579" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_557">Returns<a class="headerlink" href="#returns_557" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_132">References<a class="headerlink" href="#references_132" title="Permanent link">&para;</a></h2>
<p>.. [1] E. Parzen, 'Mathematical Considerations in the Estimation of
Spectra', Technometrics,  Vol. 3, No. 2 (May, 1961), pp. 167-190</p>
<h2 id="examples_481">Examples<a class="headerlink" href="#examples_481" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.parzen(51)
plt.plot(window)
plt.title('Parzen window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Parzen window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">peak_prominences</span> <span class="o">:</span> <span class="o">?</span><span class="n">wlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">peaks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the prominence of each peak in a signal.</p>
<p>The prominence of a peak measures how much a peak stands out from the
surrounding baseline of the signal and is defined as the vertical distance
between the peak and its lowest contour line.</p>
<h2 id="parameters_580">Parameters<a class="headerlink" href="#parameters_580" title="Permanent link">&para;</a></h2>
<p>x : sequence
A signal with peaks.
peaks : sequence
Indices of peaks in <code>x</code>.
wlen : int, optional
A window length in samples that optionally limits the evaluated area for
each peak to a subset of <code>x</code>. The peak is always placed in the middle of
the window therefore the given length is rounded up to the next odd
integer. This parameter can speed up the calculation (see Notes).</p>
<h2 id="returns_558">Returns<a class="headerlink" href="#returns_558" title="Permanent link">&para;</a></h2>
<p>prominences : ndarray
The calculated prominences for each peak in <code>peaks</code>.
left_bases, right_bases : ndarray
The peaks' bases as indices in <code>x</code> to the left and right of each peak.
The higher base of each pair is a peak's lowest contour line.</p>
<h2 id="raises_81">Raises<a class="headerlink" href="#raises_81" title="Permanent link">&para;</a></h2>
<p>ValueError
If a value in <code>peaks</code> is an invalid index for <code>x</code>.</p>
<h2 id="warns_1">Warns<a class="headerlink" href="#warns_1" title="Permanent link">&para;</a></h2>
<p>PeakPropertyWarning
For indices in <code>peaks</code> that don't point to valid local maxima in <code>x</code>
the returned prominence will be 0 and this warning is raised. This
also happens if <code>wlen</code> is smaller than the plateau size of a peak.</p>
<h2 id="warnings_1">Warnings<a class="headerlink" href="#warnings_1" title="Permanent link">&para;</a></h2>
<p>This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.</p>
<h2 id="see-also_381">See Also<a class="headerlink" href="#see-also_381" title="Permanent link">&para;</a></h2>
<p>find_peaks
Find peaks inside a signal based on peak properties.
peak_widths
Calculate the width of peaks.</p>
<h2 id="notes_382">Notes<a class="headerlink" href="#notes_382" title="Permanent link">&para;</a></h2>
<p>Strategy to compute a peak's prominence:</p>
<ol>
<li>Extend a horizontal line from the current peak to the left and right
until the line either reaches the window border (see <code>wlen</code>) or
intersects the signal again at the slope of a higher peak. An
intersection with a peak of the same height is ignored.</li>
<li>On each side find the minimal signal value within the interval defined
above. These points are the peak's bases.</li>
<li>The higher one of the two bases marks the peak's lowest contour line. The
prominence can then be calculated as the vertical difference between the
peaks height itself and its lowest contour line.</li>
</ol>
<p>Searching for the peak's bases can be slow for large <code>x</code> with periodic
behavior because large chunks or even the full signal need to be evaluated
for the first algorithmic step. This evaluation area can be limited with the
parameter <code>wlen</code> which restricts the algorithm to a window around the
current peak and can shorten the calculation time if the window length is
short in relation to <code>x</code>.
However this may stop the algorithm from finding the true global contour
line if the peak's true bases are outside this window. Instead a higher
contour line is found within the restricted window leading to a smaller
calculated prominence. In practice this is only relevant for the highest set
of peaks in <code>x</code>. This behavior may even be used intentionally to calculate
'local' prominences.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="references_133">References<a class="headerlink" href="#references_133" title="Permanent link">&para;</a></h2>
<p>.. [1] Wikipedia Article for Topographic Prominence:
https://en.wikipedia.org/wiki/Topographic_prominence</p>
<h2 id="examples_482">Examples<a class="headerlink" href="#examples_482" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import find_peaks, peak_prominences
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a test signal with two overlayed harmonics</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(0, 6 * np.pi, 1000)
x = np.sin(x) + 0.6 * np.sin(2.6 * x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find all peaks and calculate prominences</p>
<blockquote>
<blockquote>
<blockquote>
<p>peaks, _ = find_peaks(x)
prominences = peak_prominences(x, peaks)[0]
prominences
array([1.24159486, 0.47840168, 0.28470524, 3.10716793, 0.284603  ,
0.47822491, 2.48340261, 0.47822491])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate the height of each peak's contour line and plot the results</p>
<blockquote>
<blockquote>
<blockquote>
<p>contour_heights = x[peaks] - prominences
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.vlines(x=peaks, ymin=contour_heights, ymax=x[peaks])
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Let's evaluate a second example that demonstrates several edge cases for
one peak at index 5.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([0, 1, 0, 3, 1, 3, 0, 4, 0])
peaks = np.array([5])
plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.show()
peak_prominences(x, peaks)  # -&gt; (prominences, left_bases, right_bases)
(array([3.]), array([2]), array([6]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note how the peak at index 3 of the same height is not considered as a
border while searching for the left base. Instead two minima at 0 and 2
are found in which case the one closer to the evaluated peak is always
chosen. On the right side however the base must be placed at 6 because the
higher peak represents the right border to the evaluated area.</p>
<blockquote>
<blockquote>
<blockquote>
<p>peak_prominences(x, peaks, wlen=3.1)
(array([2.]), array([4]), array([6]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here we restricted the algorithm to a window from 3 to 7 (the length is 5
samples because <code>wlen</code> was rounded up to the next odd integer). Thus the
only two candidates in the evaluated area are the two neighbouring samples
and a smaller prominence is calculated.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">peak_widths</span> <span class="o">:</span> <span class="o">?</span><span class="n">rel_height</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">prominence_data</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">wlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">peaks</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the width of each peak in a signal.</p>
<p>This function calculates the width of a peak in samples at a relative
distance to the peak's height and prominence.</p>
<h2 id="parameters_581">Parameters<a class="headerlink" href="#parameters_581" title="Permanent link">&para;</a></h2>
<p>x : sequence
A signal with peaks.
peaks : sequence
Indices of peaks in <code>x</code>.
rel_height : float, optional
Chooses the relative height at which the peak width is measured as a
percentage of its prominence. 1.0 calculates the width of the peak at
its lowest contour line while 0.5 evaluates at half the prominence
height. Must be at least 0. See notes for further explanation.
prominence_data : tuple, optional
A tuple of three arrays matching the output of <code>peak_prominences</code> when
called with the same arguments <code>x</code> and <code>peaks</code>. This data is calculated
internally if not provided.
wlen : int, optional
A window length in samples passed to <code>peak_prominences</code> as an optional
argument for internal calculation of <code>prominence_data</code>. This argument
is ignored if <code>prominence_data</code> is given.</p>
<h2 id="returns_559">Returns<a class="headerlink" href="#returns_559" title="Permanent link">&para;</a></h2>
<p>widths : ndarray
The widths for each peak in samples.
width_heights : ndarray
The height of the contour lines at which the <code>widths</code> where evaluated.
left_ips, right_ips : ndarray
Interpolated positions of left and right intersection points of a
horizontal line at the respective evaluation height.</p>
<h2 id="raises_82">Raises<a class="headerlink" href="#raises_82" title="Permanent link">&para;</a></h2>
<p>ValueError
If <code>prominence_data</code> is supplied but doesn't satisfy the condition
<code>0 &lt;= left_base &lt;= peak &lt;= right_base &lt; x.shape[0]</code> for each peak,
has the wrong dtype, is not C-contiguous or does not have the same
shape.</p>
<h2 id="warns_2">Warns<a class="headerlink" href="#warns_2" title="Permanent link">&para;</a></h2>
<p>PeakPropertyWarning
Raised if any calculated width is 0. This may stem from the supplied
<code>prominence_data</code> or if <code>rel_height</code> is set to 0.</p>
<h2 id="warnings_2">Warnings<a class="headerlink" href="#warnings_2" title="Permanent link">&para;</a></h2>
<p>This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.</p>
<h2 id="see-also_382">See Also<a class="headerlink" href="#see-also_382" title="Permanent link">&para;</a></h2>
<p>find_peaks
Find peaks inside a signal based on peak properties.
peak_prominences
Calculate the prominence of peaks.</p>
<h2 id="notes_383">Notes<a class="headerlink" href="#notes_383" title="Permanent link">&para;</a></h2>
<p>The basic algorithm to calculate a peak's width is as follows:</p>
<ul>
<li>Calculate the evaluation height :math:<code>h_{eval}</code> with the formula
:math:<code>h_{eval} = h_{Peak} - P \cdot R</code>, where :math:<code>h_{Peak}</code> is the
height of the peak itself, :math:<code>P</code> is the peak's prominence and
:math:<code>R</code> a positive ratio specified with the argument <code>rel_height</code>.</li>
<li>Draw a horizontal line at the evaluation height to both sides, starting at
the peak's current vertical position until the lines either intersect a
slope, the signal border or cross the vertical position of the peak's
base (see <code>peak_prominences</code> for an definition). For the first case,
intersection with the signal, the true intersection point is estimated
with linear interpolation.</li>
<li>Calculate the width as the horizontal distance between the chosen
endpoints on both sides. As a consequence of this the maximal possible
width for each peak is the horizontal distance between its bases.</li>
</ul>
<p>As shown above to calculate a peak's width its prominence and bases must be
known. You can supply these yourself with the argument <code>prominence_data</code>.
Otherwise they are internally calculated (see <code>peak_prominences</code>).</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_483">Examples<a class="headerlink" href="#examples_483" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import chirp, find_peaks, peak_widths
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a test signal with two overlayed harmonics</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.linspace(0, 6 * np.pi, 1000)
x = np.sin(x) + 0.6 * np.sin(2.6 * x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find all peaks and calculate their widths at the relative height of 0.5
(contour line at half the prominence height) and 1 (at the lowest contour
line at full prominence height).</p>
<blockquote>
<blockquote>
<blockquote>
<p>peaks, _ = find_peaks(x)
results_half = peak_widths(x, peaks, rel_height=0.5)
results_half[0]  # widths
array([ 64.25172825,  41.29465463,  35.46943289, 104.71586081,
35.46729324,  41.30429622, 181.93835853,  45.37078546])
results_full = peak_widths(x, peaks, rel_height=1)
results_full[0]  # widths
array([181.9396084 ,  72.99284945,  61.28657872, 373.84622694,
61.78404617,  72.48822812, 253.09161876,  79.36860878])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot signal, peaks and contour lines at which the widths where calculated</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(x)
plt.plot(peaks, x[peaks], 'x')
plt.hlines( <em>results_half[1:], color='C2')
plt.hlines( </em>results_full[1:], color='C3')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">periodogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate power spectral density using a periodogram.</p>
<h2 id="parameters_582">Parameters<a class="headerlink" href="#parameters_582" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to 'boxcar'.
nfft : int, optional
Length of the FFT used. If <code>None</code> the length of <code>x</code> will be
used.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Pxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Pxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'
axis : int, optional
Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_560">Returns<a class="headerlink" href="#returns_560" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxx : ndarray
Power spectral density or power spectrum of <code>x</code>.</p>
<h2 id="notes_384">Notes<a class="headerlink" href="#notes_384" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.12.0</p>
<h2 id="see-also_383">See Also<a class="headerlink" href="#see-also_383" title="Permanent link">&para;</a></h2>
<p>welch: Estimate power spectral density using Welch's method
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="examples_484">Examples<a class="headerlink" href="#examples_484" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
np.random.seed(1234)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2<em>np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp</em>np.sin(2<em>np.pi</em>freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the power spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_den = signal.periodogram(x, fs)
plt.semilogy(f, Pxx_den)
plt.ylim([1e-7, 1e2])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.mean(Pxx_den[25000:])
0.00099728892368242854</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute and plot the power spectrum.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum')
plt.figure()
plt.semilogy(f, np.sqrt(Pxx_spec))
plt.ylim([1e-4, 1e1])
plt.xlabel('frequency [Hz]')
plt.ylabel('Linear spectrum [V RMS]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt(Pxx_spec.max())
2.0077340678640727</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">place_poles</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">YT</span> <span class="o">|</span> <span class="o">`</span><span class="nc">KNV0</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">poles</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute K such that eigenvalues (A - dot(B, K))=poles.</p>
<p>K is the gain matrix such as the plant described by the linear system
<code>AX+BU</code> will have its closed-loop poles, i.e the eigenvalues <code>A - B*K</code>,
as close as possible to those asked for in poles.</p>
<p>SISO, MISO and MIMO systems are supported.</p>
<h2 id="parameters_583">Parameters<a class="headerlink" href="#parameters_583" title="Permanent link">&para;</a></h2>
<p>A, B : ndarray
State-space representation of linear system <code>AX + BU</code>.
poles : array_like
Desired real poles and/or complex conjugates poles.
Complex poles are only supported with <code>method='YT'</code> (default).
method: {'YT', 'KNV0'}, optional
Which method to choose to find the gain matrix K. One of:</p>
<ul>
<li>'YT': Yang Tits</li>
<li>'KNV0': Kautsky, Nichols, Van Dooren update method 0</li>
</ul>
<p>See References and Notes for details on the algorithms.
rtol: float, optional
After each iteration the determinant of the eigenvectors of
<code>A - B*K</code> is compared to its previous value, when the relative
error between these two values becomes lower than <code>rtol</code> the algorithm
stops.  Default is 1e-3.
maxiter: int, optional
Maximum number of iterations to compute the gain matrix.
Default is 30.</p>
<h2 id="returns_561">Returns<a class="headerlink" href="#returns_561" title="Permanent link">&para;</a></h2>
<p>full_state_feedback : Bunch object
full_state_feedback is composed of:
gain_matrix : 1-D ndarray
The closed loop matrix K such as the eigenvalues of <code>A-BK</code>
are as close as possible to the requested poles.
computed_poles : 1-D ndarray
The poles corresponding to <code>A-BK</code> sorted as first the real
poles in increasing order, then the complex congugates in
lexicographic order.
requested_poles : 1-D ndarray
The poles the algorithm was asked to place sorted as above,
they may differ from what was achieved.
X : 2-D ndarray
The transfer matrix such as <code>X * diag(poles) = (A - B*K)*X</code>
(see Notes)
rtol : float
The relative tolerance achieved on <code>det(X)</code> (see Notes).
<code>rtol</code> will be NaN if it is possible to solve the system
<code>diag(poles) = (A - B*K)</code>, or 0 when the optimization
algorithms can't do anything i.e when <code>B.shape[1] == 1</code>.
nb_iter : int
The number of iterations performed before converging.
<code>nb_iter</code> will be NaN if it is possible to solve the system
<code>diag(poles) = (A - B*K)</code>, or 0 when the optimization
algorithms can't do anything i.e when <code>B.shape[1] == 1</code>.</p>
<h2 id="notes_385">Notes<a class="headerlink" href="#notes_385" title="Permanent link">&para;</a></h2>
<p>The Tits and Yang (YT), [2]<em> paper is an update of the original Kautsky et
al. (KNV) paper [1]</em>.  KNV relies on rank-1 updates to find the transfer
matrix X such that <code>X * diag(poles) = (A - B*K)*X</code>, whereas YT uses
rank-2 updates. This yields on average more robust solutions (see [2]_
pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV
does not in its original version.  Only update method 0 proposed by KNV has
been implemented here, hence the name <code>'KNV0'</code>.</p>
<p>KNV extended to complex poles is used in Matlab's <code>place</code> function, YT is
distributed under a non-free licence by Slicot under the name <code>robpole</code>.
It is unclear and undocumented how KNV0 has been extended to complex poles
(Tits and Yang claim on page 14 of their paper that their method can not be
used to extend KNV to complex poles), therefore only YT supports them in
this implementation.</p>
<p>As the solution to the problem of pole placement is not unique for MIMO
systems, both methods start with a tentative transfer matrix which is
altered in various way to increase its determinant.  Both methods have been
proven to converge to a stable solution, however depending on the way the
initial transfer matrix is chosen they will converge to different
solutions and therefore there is absolutely no guarantee that using
<code>'KNV0'</code> will yield results similar to Matlab's or any other
implementation of these algorithms.</p>
<p>Using the default method <code>'YT'</code> should be fine in most cases; <code>'KNV0'</code>
is only provided because it is needed by <code>'YT'</code> in some specific cases.
Furthermore <code>'YT'</code> gives on average more robust results than <code>'KNV0'</code>
when <code>abs(det(X))</code> is used as a robustness indicator.</p>
<p>[2]_ is available as a technical report on the following URL:
https://hdl.handle.net/1903/5598</p>
<h2 id="references_134">References<a class="headerlink" href="#references_134" title="Permanent link">&para;</a></h2>
<p>.. [1] J. Kautsky, N.K. Nichols and P. van Dooren, 'Robust pole assignment
in linear state feedback', International Journal of Control, Vol. 41
pp. 1129-1155, 1985.
.. [2] A.L. Tits and Y. Yang, 'Globally convergent algorithms for robust
pole assignment by state feedback', IEEE Transactions on Automatic
Control, Vol. 41, pp. 1432-1452, 1996.</p>
<h2 id="examples_485">Examples<a class="headerlink" href="#examples_485" title="Permanent link">&para;</a></h2>
<p>A simple example demonstrating real pole placement using both KNV and YT
algorithms.  This is example number 1 from section 4 of the reference KNV
publication ([1]_):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ],
...               [-0.5814, -4.290,   0,      0.6750 ],
...               [ 1.067,   4.273,  -6.654,  5.893  ],
...               [ 0.0480,  4.273,   1.343, -2.104  ]])
B = np.array([[ 0,      5.679 ],
...               [ 1.136,  1.136 ],
...               [ 0,      0,    ],
...               [-3.146,  0     ]])
P = np.array([-0.2, -0.5, -5.0566, -8.6659])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute K with KNV method 0, with the default YT method and with the YT
method while forcing 100 iterations of the algorithm and print some results
after each call.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fsf1 = signal.place_poles(A, B, P, method='KNV0')
fsf1.gain_matrix
array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785],
[ 0.50587268,  0.57779091,  0.51795763, -0.41991442]])</p>
<p>fsf2 = signal.place_poles(A, B, P)  # uses YT method
fsf2.computed_poles
array([-8.6659, -5.0566, -0.5   , -0.2   ])</p>
<p>fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100)
fsf3.X
array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j],
[-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j],
[-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j],
[ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The absolute value of the determinant of X is a good indicator to check the
robustness of the results, both <code>'KNV0'</code> and <code>'YT'</code> aim at maximizing
it.  Below a comparison of the robustness of the results above:</p>
<blockquote>
<blockquote>
<blockquote>
<p>abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X))
True
abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X))
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now a simple example for complex poles:</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = np.array([[ 0,  7/3.,  0,   0   ],
...               [ 0,   0,    0,  7/9. ],
...               [ 0,   0,    0,   0   ],
...               [ 0,   0,    0,   0   ]])
B = np.array([[ 0,  0 ],
...               [ 0,  0 ],
...               [ 1,  0 ],
...               [ 0,  1 ]])
P = np.array([-3, -1, -2-1j, -2+1j]) / 3.
fsf = signal.place_poles(A, B, P, method='YT')</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can plot the desired and computed poles in the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, 2*np.pi, 401)
plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle
plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag,
...          'wo', label='Desired')
plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx',
...          label='Placed')
plt.grid()
plt.axis('image')
plt.axis([-1.1, 1.1, -1.1, 1.1])
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qmf</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return high-pass qmf filter from low-pass</p>
<h2 id="parameters_584">Parameters<a class="headerlink" href="#parameters_584" title="Permanent link">&para;</a></h2>
<p>hk : array_like
Coefficients of high-pass filter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qspline1d</span> <span class="o">:</span> <span class="o">?</span><span class="n">lamb</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">signal</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute quadratic spline coefficients for rank-1 array.</p>
<p>Find the quadratic spline coefficients for a 1-D signal assuming
mirror-symmetric boundary conditions.   To obtain the signal back from the
spline representation mirror-symmetric-convolve these coefficients with a
length 3 FIR window [1.0, 6.0, 1.0]/ 8.0 .</p>
<h2 id="parameters_585">Parameters<a class="headerlink" href="#parameters_585" title="Permanent link">&para;</a></h2>
<p>signal : ndarray
A rank-1 array representing samples of a signal.
lamb : float, optional
Smoothing coefficient (must be zero for now).</p>
<h2 id="returns_562">Returns<a class="headerlink" href="#returns_562" title="Permanent link">&para;</a></h2>
<p>c : ndarray
Cubic spline coefficients.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qspline1d_eval</span> <span class="o">:</span> <span class="o">?</span><span class="n">dx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">x0</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cj</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">newx</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Evaluate a quadratic spline at the new set of points.</p>
<p><code>dx</code> is the old sample-spacing while <code>x0</code> was the old origin.  In
other-words the old-sample points (knot-points) for which the <code>cj</code>
represent spline coefficients were at equally-spaced points of::</p>
<p>oldx = x0 + j*dx  j=0...N-1, with N=len(cj)</p>
<p>Edges are handled using mirror-symmetric boundary conditions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">quadratic</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A quadratic B-spline.</p>
<p>This is a special case of <code>bspline</code>, and equivalent to <code>bspline(x, 2)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">remez</span> <span class="o">:</span> <span class="o">?</span><span class="n">weight</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hz</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:[`</span><span class="nc">Bandpass</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Differentiator</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Hilbert</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">maxiter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">grid_density</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">numtaps</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">bands</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">desired</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate the minimax optimal filter using the Remez exchange algorithm.</p>
<p>Calculate the filter-coefficients for the finite impulse response
(FIR) filter whose transfer function minimizes the maximum error
between the desired gain and the realized gain in the specified
frequency bands using the Remez exchange algorithm.</p>
<h2 id="parameters_586">Parameters<a class="headerlink" href="#parameters_586" title="Permanent link">&para;</a></h2>
<p>numtaps : int
The desired number of taps in the filter. The number of taps is
the number of terms in the filter, or the filter order plus one.
bands : array_like
A monotonic sequence containing the band edges.
All elements must be non-negative and less than half the sampling
frequency as given by <code>fs</code>.
desired : array_like
A sequence half the size of bands containing the desired gain
in each of the specified bands.
weight : array_like, optional
A relative weighting to give to each band region. The length of
<code>weight</code> has to be half the length of <code>bands</code>.
Hz : scalar, optional
<em>Deprecated.  Use <code>fs</code> instead.</em>
The sampling frequency in Hz. Default is 1.
type : {'bandpass', 'differentiator', 'hilbert'}, optional
The type of filter:</p>
<ul>
<li>
<p>'bandpass' : flat response in bands. This is the default.</p>
</li>
<li>
<p>'differentiator' : frequency proportional response in bands.</p>
</li>
<li>
<p>'hilbert' : filter with odd symmetry, that is, type III
(for even order) or type IV (for odd order)
linear phase filters.</p>
</li>
</ul>
<p>maxiter : int, optional
Maximum number of iterations of the algorithm. Default is 25.
grid_density : int, optional
Grid density. The dense grid used in <code>remez</code> is of size
<code>(numtaps + 1) * grid_density</code>. Default is 16.
fs : float, optional
The sampling frequency of the signal.  Default is 1.</p>
<h2 id="returns_563">Returns<a class="headerlink" href="#returns_563" title="Permanent link">&para;</a></h2>
<p>out : ndarray
A rank-1 array containing the coefficients of the optimal
(in a minimax sense) filter.</p>
<h2 id="see-also_384">See Also<a class="headerlink" href="#see-also_384" title="Permanent link">&para;</a></h2>
<p>firls
firwin
firwin2
minimum_phase</p>
<h2 id="references_135">References<a class="headerlink" href="#references_135" title="Permanent link">&para;</a></h2>
<p>.. [1] J. H. McClellan and T. W. Parks, 'A unified approach to the
design of optimum FIR linear phase digital filters',
IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.
.. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, 'A Computer
Program for Designing Optimum FIR Linear Phase Digital
Filters', IEEE Trans. Audio Electroacoust., vol. AU-21,
pp. 506-525, 1973.</p>
<h2 id="examples_486">Examples<a class="headerlink" href="#examples_486" title="Permanent link">&para;</a></h2>
<p>In these examples <code>remez</code> gets used creating a bandpass, bandstop, lowpass
and highpass filter.  The used parameters are the filter order, an array
with according frequency boundaries, the desired attenuation values and the
sampling frequency.  Using <code>freqz</code> the corresponding frequency response
gets calculated and plotted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>def plot_response(fs, w, h, title):
...     'Utility function to plot response functions'
...     fig = plt.figure()
...     ax = fig.add_subplot(111)
...     ax.plot(0.5<em>fs</em>w/np.pi, 20<em>np.log10(np.abs(h)))
...     ax.set_ylim(-40, 5)
...     ax.set_xlim(0, 0.5</em>fs)
...     ax.grid(True)
...     ax.set_xlabel('Frequency (Hz)')
...     ax.set_ylabel('Gain (dB)')
...     ax.set_title(title)</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows a steep low pass transition according to the small
transition width and high filter order:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22050.0       # Sample rate, Hz
cutoff = 8000.0    # Desired cutoff frequency, Hz
trans_width = 100  # Width of transition from pass band to stop band, Hz
numtaps = 400      # Size of the FIR filter.
taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], [1, 0], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Low-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>This example shows a high pass filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22050.0       # Sample rate, Hz
cutoff = 2000.0    # Desired cutoff frequency, Hz
trans_width = 250  # Width of transition from pass band to stop band, Hz
numtaps = 125      # Size of the FIR filter.
taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs],
...                     [0, 1], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'High-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>For a signal sampled with 22 kHz a bandpass filter with a pass band of 2-5
kHz gets calculated using the Remez algorithm.  The transition width is 260
Hz and the filter order 10:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 22000.0         # Sample rate, Hz
band = [2000, 5000]  # Desired pass band, Hz
trans_width = 260    # Width of transition from pass band to stop band, Hz
numtaps = 10        # Size of the FIR filter.
edges = [0, band[0] - trans_width, band[0], band[1],
...          band[1] + trans_width, 0.5*fs]
taps = signal.remez(numtaps, edges, [0, 1, 0], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Band-pass Filter')</p>
</blockquote>
</blockquote>
</blockquote>
<p>It can be seen that for this bandpass filter, the low order leads to higher
ripple and less steep transitions.  There is very low attenuation in the
stop band and little overshoot in the pass band.  Of course the desired
gain can be better approximated with a higher filter order.</p>
<p>The next example shows a bandstop filter. Because of the high filter order
the transition is quite steep:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 20000.0         # Sample rate, Hz
band = [6000, 8000]  # Desired stop band, Hz
trans_width = 200    # Width of transition from pass band to stop band, Hz
numtaps = 175        # Size of the FIR filter.
edges = [0, band[0] - trans_width, band[0], band[1], band[1] + trans_width, 0.5*fs]
taps = signal.remez(numtaps, edges, [1, 0, 1], Hz=fs)
w, h = signal.freqz(taps, [1], worN=2000)
plot_response(fs, w, h, 'Band-stop Filter')</p>
<p>plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resample</span> <span class="o">:</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resample <code>x</code> to <code>num</code> samples using Fourier method along the given axis.</p>
<p>The resampled signal starts at the same value as <code>x</code> but is sampled
with a spacing of <code>len(x) / num * (spacing of x)</code>.  Because a
Fourier method is used, the signal is assumed to be periodic.</p>
<h2 id="parameters_587">Parameters<a class="headerlink" href="#parameters_587" title="Permanent link">&para;</a></h2>
<p>x : array_like
The data to be resampled.
num : int
The number of samples in the resampled signal.
t : array_like, optional
If <code>t</code> is given, it is assumed to be the equally spaced sample
positions associated with the signal data in <code>x</code>.
axis : int, optional
The axis of <code>x</code> that is resampled.  Default is 0.
window : array_like, callable, string, float, or tuple, optional
Specifies the window applied to the signal in the Fourier
domain.  See below for details.</p>
<h2 id="returns_564">Returns<a class="headerlink" href="#returns_564" title="Permanent link">&para;</a></h2>
<p>resampled_x or (resampled_x, resampled_t)
Either the resampled array, or, if <code>t</code> was given, a tuple
containing the resampled array and the corresponding resampled
positions.</p>
<h2 id="see-also_385">See Also<a class="headerlink" href="#see-also_385" title="Permanent link">&para;</a></h2>
<p>decimate : Downsample the signal after applying an FIR or IIR filter.
resample_poly : Resample using polyphase filtering and an FIR filter.</p>
<h2 id="notes_386">Notes<a class="headerlink" href="#notes_386" title="Permanent link">&para;</a></h2>
<p>The argument <code>window</code> controls a Fourier-domain window that tapers
the Fourier spectrum before zero-padding to alleviate ringing in
the resampled values for sampled signals you didn't intend to be
interpreted as band-limited.</p>
<p>If <code>window</code> is a function, then it is called with a vector of inputs
indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</p>
<p>If <code>window</code> is an array of the same length as <code>x.shape[axis]</code> it is
assumed to be the window to be applied directly in the Fourier
domain (with dc and low-frequency first).</p>
<p>For any other type of <code>window</code>, the function <code>scipy.signal.get_window</code>
is called to generate the window.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector.  The spacing between samples is changed
from <code>dx</code> to <code>dx * len(x) / num</code>.</p>
<p>If <code>t</code> is not None, then it is used solely to calculate the resampled
positions <code>resampled_t</code></p>
<p>As noted, <code>resample</code> uses FFT transformations, which can be very
slow if the number of input or output samples is large and prime;
see <code>scipy.fft.fft</code>.</p>
<h2 id="examples_487">Examples<a class="headerlink" href="#examples_487" title="Permanent link">&para;</a></h2>
<p>Note that the end of the resampled data rises to meet the first
sample of the next cycle:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>x = np.linspace(0, 10, 20, endpoint=False)
y = np.cos(-x**2/6.0)
f = signal.resample(y, 100)
xnew = np.linspace(0, 10, 100, endpoint=False)</p>
<p>import matplotlib.pyplot as plt
plt.plot(x, y, 'go-', xnew, f, '.-', 10, y[0], 'ro')
plt.legend(['data', 'resampled'], loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">resample_poly</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">up</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">down</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Resample <code>x</code> along the given axis using polyphase filtering.</p>
<p>The signal <code>x</code> is upsampled by the factor <code>up</code>, a zero-phase low-pass
FIR filter is applied, and then it is downsampled by the factor <code>down</code>.
The resulting sample rate is <code>up / down</code> times the original sample
rate. By default, values beyond the boundary of the signal are assumed
to be zero during the filtering step.</p>
<h2 id="parameters_588">Parameters<a class="headerlink" href="#parameters_588" title="Permanent link">&para;</a></h2>
<p>x : array_like
The data to be resampled.
up : int
The upsampling factor.
down : int
The downsampling factor.
axis : int, optional
The axis of <code>x</code> that is resampled. Default is 0.
window : string, tuple, or array_like, optional
Desired window to use to design the low-pass filter, or the FIR filter
coefficients to employ. See below for details.
padtype : string, optional
<code>constant</code>, <code>line</code>, <code>mean</code>, <code>median</code>, <code>maximum</code>, <code>minimum</code> or any of
the other signal extension modes supported by <code>scipy.signal.upfirdn</code>.
Changes assumptions on values beyond the boundary. If <code>constant</code>,
assumed to be <code>cval</code> (default zero). If <code>line</code> assumed to continue a
linear trend defined by the first and last points. <code>mean</code>, <code>median</code>,
<code>maximum</code> and <code>minimum</code> work as in <code>np.pad</code> and assume that the values
beyond the boundary are the mean, median, maximum or minimum
respectively of the array along the axis.</p>
<p>.. versionadded:: 1.4.0
cval : float, optional
Value to use if <code>padtype='constant'</code>. Default is zero.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_565">Returns<a class="headerlink" href="#returns_565" title="Permanent link">&para;</a></h2>
<p>resampled_x : array
The resampled array.</p>
<h2 id="see-also_386">See Also<a class="headerlink" href="#see-also_386" title="Permanent link">&para;</a></h2>
<p>decimate : Downsample the signal after applying an FIR or IIR filter.
resample : Resample up or down using the FFT method.</p>
<h2 id="notes_387">Notes<a class="headerlink" href="#notes_387" title="Permanent link">&para;</a></h2>
<p>This polyphase method will likely be faster than the Fourier method
in <code>scipy.signal.resample</code> when the number of samples is large and
prime, or when the number of samples is large and <code>up</code> and <code>down</code>
share a large greatest common denominator. The length of the FIR
filter used will depend on <code>max(up, down) // gcd(up, down)</code>, and
the number of operations during polyphase filtering will depend on
the filter length and <code>down</code> (see <code>scipy.signal.upfirdn</code> for details).</p>
<p>The argument <code>window</code> specifies the FIR low-pass filter design.</p>
<p>If <code>window</code> is an array_like it is assumed to be the FIR filter
coefficients. Note that the FIR filter is applied after the upsampling
step, so it should be designed to operate on a signal at a sampling
frequency higher than the original by a factor of <code>up//gcd(up, down)</code>.
This function's output will be centered with respect to this array, so it
is best to pass a symmetric filter with an odd number of samples if, as
is usually the case, a zero-phase filter is desired.</p>
<p>For any other type of <code>window</code>, the functions <code>scipy.signal.get_window</code>
and <code>scipy.signal.firwin</code> are called to generate the appropriate filter
coefficients.</p>
<p>The first sample of the returned vector is the same as the first
sample of the input vector. The spacing between samples is changed
from <code>dx</code> to <code>dx * down / float(up)</code>.</p>
<h2 id="examples_488">Examples<a class="headerlink" href="#examples_488" title="Permanent link">&para;</a></h2>
<p>By default, the end of the resampled data rises to meet the first
sample of the next cycle for the FFT method, and gets closer to zero
for the polyphase method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal</p>
<p>x = np.linspace(0, 10, 20, endpoint=False)
y = np.cos(-x**2/6.0)
f_fft = signal.resample(y, 100)
f_poly = signal.resample_poly(y, 100, 20)
xnew = np.linspace(0, 10, 100, endpoint=False)</p>
<p>import matplotlib.pyplot as plt
plt.plot(xnew, f_fft, 'b.-', xnew, f_poly, 'r.-')
plt.plot(x, y, 'ko-')
plt.plot(10, y[0], 'bo', 10, 0., 'ro')  # boundaries
plt.legend(['resample', 'resamp_poly', 'data'], loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>This default behaviour can be changed by using the padtype option:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy import signal</p>
<p>N = 5
x = np.linspace(0, 1, N, endpoint=False)
y = 2 + x<strong>2 - 1.7<em>np.sin(x) + .2</em>np.cos(11*x)
y2 = 1 + x</strong>3 + 0.1<em>np.sin(x) + .1</em>np.cos(11<em>x)
Y = np.stack([y, y2], axis=-1)
up = 4
xr = np.linspace(0, 1, N</em>up, endpoint=False)</p>
<p>y2 = signal.resample_poly(Y, up, 1, padtype='constant')
y3 = signal.resample_poly(Y, up, 1, padtype='mean')
y4 = signal.resample_poly(Y, up, 1, padtype='line')</p>
<p>import matplotlib.pyplot as plt
for i in [0,1]:
...     plt.figure()
...     plt.plot(xr, y4[:,i], 'g.', label='line')
...     plt.plot(xr, y3[:,i], 'y.', label='mean')
...     plt.plot(xr, y2[:,i], 'r.', label='constant')
...     plt.plot(x, Y[:,i], 'k-')
...     plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">residue</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute partial-fraction expansion of b(s) / a(s).</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(s)     b[0] s<strong>(M) + b[1] s</strong>(M-1) + ... + b[M]
H(s) = ------ = ------------------------------------------
a(s)     a[0] s<strong>(N) + a[1] s</strong>(N-1) + ... + a[N]</p>
<p>then the partial-fraction expansion H(s) is defined as::</p>
<p>r[0]       r[1]             r[-1]
= -------- + -------- + ... + --------- + k(s)
(s-p[0])   (s-p[1])         (s-p[-1])</p>
<p>If there are any repeated roots (closer together than <code>tol</code>), then H(s)
has terms like::</p>
<p>r[i]      r[i+1]              r[i+n-1]
-------- + ----------- + ... + -----------
(s-p[i])  (s-p[i])<strong>2          (s-p[i])</strong>n</p>
<p>This function is used for polynomials in positive powers of s or z,
such as analog filters or digital filters in controls engineering.  For
negative powers of z (typical for digital filters in DSP), use <code>residuez</code>.</p>
<p>See Notes for details about the algorithm.</p>
<h2 id="parameters_589">Parameters<a class="headerlink" href="#parameters_589" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_566">Returns<a class="headerlink" href="#returns_566" title="Permanent link">&para;</a></h2>
<p>r : ndarray
Residues corresponding to the poles. For repeated poles, the residues
are ordered to correspond to ascending by power fractions.
p : ndarray
Poles ordered by magnitude in ascending order.
k : ndarray
Coefficients of the direct polynomial term.</p>
<h2 id="see-also_387">See Also<a class="headerlink" href="#see-also_387" title="Permanent link">&para;</a></h2>
<p>invres, residuez, numpy.poly, unique_roots</p>
<h2 id="notes_388">Notes<a class="headerlink" href="#notes_388" title="Permanent link">&para;</a></h2>
<p>The 'deflation through subtraction' algorithm is used for
computations --- method 6 in [1]_.</p>
<p>The form of partial fraction expansion depends on poles multiplicity in
the exact mathematical sense. However there is no way to exactly
determine multiplicity of roots of a polynomial in numerical computing.
Thus you should think of the result of <code>residue</code> with given <code>tol</code> as
partial fraction expansion computed for the denominator composed of the
computed poles with empirically determined multiplicity. The choice of
<code>tol</code> can drastically change the result if there are close poles.</p>
<h2 id="references_136">References<a class="headerlink" href="#references_136" title="Permanent link">&para;</a></h2>
<p>.. [1] J. F. Mahoney, B. D. Sivazlian, 'Partial fractions expansion: a
review of computational methodology and efficiency', Journal of
Computational and Applied Mathematics, Vol. 9, 1983.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">residuez</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Max</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute partial-fraction expansion of b(z) / a(z).</p>
<p>If <code>M</code> is the degree of numerator <code>b</code> and <code>N</code> the degree of denominator
<code>a</code>::</p>
<p>b(z)     b[0] + b[1] z<strong>(-1) + ... + b[M] z</strong>(-M)
H(z) = ------ = ------------------------------------------
a(z)     a[0] + a[1] z<strong>(-1) + ... + a[N] z</strong>(-N)</p>
<p>then the partial-fraction expansion H(z) is defined as::</p>
<p>r[0]                   r[-1]
= --------------- + ... + ---------------- + k[0] + k[1]z<strong>(-1) ...
(1-p[0]z</strong>(-1))         (1-p[-1]z**(-1))</p>
<p>If there are any repeated roots (closer than <code>tol</code>), then the partial
fraction expansion has terms like::</p>
<p>r[i]              r[i+1]                    r[i+n-1]
-------------- + ------------------ + ... + ------------------
(1-p[i]z<strong>(-1))  (1-p[i]z</strong>(-1))<strong>2         (1-p[i]z</strong>(-1))**n</p>
<p>This function is used for polynomials in negative powers of z,
such as digital filters in DSP.  For positive powers, use <code>residue</code>.</p>
<p>See Notes of <code>residue</code> for details about the algorithm.</p>
<h2 id="parameters_590">Parameters<a class="headerlink" href="#parameters_590" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. See <code>unique_roots</code>
for further details.
rtype : {'avg', 'min', 'max'}, optional
Method for computing a root to represent a group of identical roots.
Default is 'avg'. See <code>unique_roots</code> for further details.</p>
<h2 id="returns_567">Returns<a class="headerlink" href="#returns_567" title="Permanent link">&para;</a></h2>
<p>r : ndarray
Residues corresponding to the poles. For repeated poles, the residues
are ordered to correspond to ascending by power fractions.
p : ndarray
Poles ordered by magnitude in ascending order.
k : ndarray
Coefficients of the direct polynomial term.</p>
<h2 id="see-also_388">See Also<a class="headerlink" href="#see-also_388" title="Permanent link">&para;</a></h2>
<p>invresz, residue, unique_roots</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ricker</span> <span class="o">:</span> <span class="n">points</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Ricker wavelet, also known as the 'Mexican hat wavelet'.</p>
<p>It models the function:</p>
<p><code>A * (1 - (x/a)**2) * exp(-0.5*(x/a)**2)</code>,</p>
<p>where <code>A = 2/(sqrt(3*a)*(pi**0.25))</code>.</p>
<h2 id="parameters_591">Parameters<a class="headerlink" href="#parameters_591" title="Permanent link">&para;</a></h2>
<p>points : int
Number of points in <code>vector</code>.
Will be centered around 0.
a : scalar
Width parameter of the wavelet.</p>
<h2 id="returns_568">Returns<a class="headerlink" href="#returns_568" title="Permanent link">&para;</a></h2>
<p>vector : (N,) ndarray
Array of length <code>points</code> in shape of ricker curve.</p>
<h2 id="examples_489">Examples<a class="headerlink" href="#examples_489" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>points = 100
a = 4.0
vec2 = signal.ricker(points, a)
print(len(vec2))
100
plt.plot(vec2)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">savgol_coeffs</span> <span class="o">:</span> <span class="o">?</span><span class="n">deriv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">delta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pos</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">use</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">window_length</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">polyorder</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the coefficients for a 1-d Savitzky-Golay FIR filter.</p>
<h2 id="parameters_592">Parameters<a class="headerlink" href="#parameters_592" title="Permanent link">&para;</a></h2>
<p>window_length : int
The length of the filter window (i.e. the number of coefficients).
<code>window_length</code> must be an odd positive integer.
polyorder : int
The order of the polynomial used to fit the samples.
<code>polyorder</code> must be less than <code>window_length</code>.
deriv : int, optional
The order of the derivative to compute.  This must be a
nonnegative integer.  The default is 0, which means to filter
the data without differentiating.
delta : float, optional
The spacing of the samples to which the filter will be applied.
This is only used if deriv &gt; 0.
pos : int or None, optional
If pos is not None, it specifies evaluation position within the
window.  The default is the middle of the window.
use : str, optional
Either 'conv' or 'dot'.  This argument chooses the order of the
coefficients.  The default is 'conv', which means that the
coefficients are ordered to be used in a convolution.  With
use='dot', the order is reversed, so the filter is applied by
dotting the coefficients with the data set.</p>
<h2 id="returns_569">Returns<a class="headerlink" href="#returns_569" title="Permanent link">&para;</a></h2>
<p>coeffs : 1-d ndarray
The filter coefficients.</p>
<h2 id="references_137">References<a class="headerlink" href="#references_137" title="Permanent link">&para;</a></h2>
<p>A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of Data by
Simplified Least Squares Procedures. Analytical Chemistry, 1964, 36 (8),
pp 1627-1639.</p>
<h2 id="see-also_389">See Also<a class="headerlink" href="#see-also_389" title="Permanent link">&para;</a></h2>
<p>savgol_filter</p>
<h2 id="notes_389">Notes<a class="headerlink" href="#notes_389" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_490">Examples<a class="headerlink" href="#examples_490" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import savgol_coeffs
savgol_coeffs(5, 2)
array([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429])
savgol_coeffs(5, 2, deriv=1)
array([ 2.00000000e-01,  1.00000000e-01,  2.07548111e-16, -1.00000000e-01,
-2.00000000e-01])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that use='dot' simply reverses the coefficients.</p>
<blockquote>
<blockquote>
<blockquote>
<p>savgol_coeffs(5, 2, pos=3)
array([ 0.25714286,  0.37142857,  0.34285714,  0.17142857, -0.14285714])
savgol_coeffs(5, 2, pos=3, use='dot')
array([-0.14285714,  0.17142857,  0.34285714,  0.37142857,  0.25714286])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>x</code> contains data from the parabola x = t**2, sampled at
t = -1, 0, 1, 2, 3.  <code>c</code> holds the coefficients that will compute the
derivative at the last position.  When dotted with <code>x</code> the result should
be 6.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 0, 1, 4, 9])
c = savgol_coeffs(5, 2, pos=4, deriv=1, use='dot')
c.dot(x)
6.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">savgol_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">deriv</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">delta</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">window_length</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">polyorder</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply a Savitzky-Golay filter to an array.</p>
<p>This is a 1-d filter.  If <code>x</code>  has dimension greater than 1, <code>axis</code>
determines the axis along which the filter is applied.</p>
<h2 id="parameters_593">Parameters<a class="headerlink" href="#parameters_593" title="Permanent link">&para;</a></h2>
<p>x : array_like
The data to be filtered.  If <code>x</code> is not a single or double precision
floating point array, it will be converted to type <code>numpy.float64</code>
before filtering.
window_length : int
The length of the filter window (i.e. the number of coefficients).
<code>window_length</code> must be a positive odd integer. If <code>mode</code> is 'interp',
<code>window_length</code> must be less than or equal to the size of <code>x</code>.
polyorder : int
The order of the polynomial used to fit the samples.
<code>polyorder</code> must be less than <code>window_length</code>.
deriv : int, optional
The order of the derivative to compute.  This must be a
nonnegative integer.  The default is 0, which means to filter
the data without differentiating.
delta : float, optional
The spacing of the samples to which the filter will be applied.
This is only used if deriv &gt; 0.  Default is 1.0.
axis : int, optional
The axis of the array <code>x</code> along which the filter is to be applied.
Default is -1.
mode : str, optional
Must be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'.  This
determines the type of extension to use for the padded signal to
which the filter is applied.  When <code>mode</code> is 'constant', the padding
value is given by <code>cval</code>.  See the Notes for more details on 'mirror',
'constant', 'wrap', and 'nearest'.
When the 'interp' mode is selected (the default), no extension
is used.  Instead, a degree <code>polyorder</code> polynomial is fit to the
last <code>window_length</code> values of the edges, and this polynomial is
used to evaluate the last <code>window_length // 2</code> output values.
cval : scalar, optional
Value to fill past the edges of the input if <code>mode</code> is 'constant'.
Default is 0.0.</p>
<h2 id="returns_570">Returns<a class="headerlink" href="#returns_570" title="Permanent link">&para;</a></h2>
<p>y : ndarray, same shape as <code>x</code>
The filtered data.</p>
<h2 id="see-also_390">See Also<a class="headerlink" href="#see-also_390" title="Permanent link">&para;</a></h2>
<p>savgol_coeffs</p>
<h2 id="notes_390">Notes<a class="headerlink" href="#notes_390" title="Permanent link">&para;</a></h2>
<p>Details on the <code>mode</code> options:</p>
<p>'mirror':
Repeats the values at the edges in reverse order.  The value
closest to the edge is not included.
'nearest':
The extension contains the nearest input value.
'constant':
The extension contains the value given by the <code>cval</code> argument.
'wrap':
The extension contains the values from the other end of the array.</p>
<p>For example, if the input is [1, 2, 3, 4, 5, 6, 7, 8], and
<code>window_length</code> is 7, the following shows the extended data for
the various <code>mode</code> options (assuming <code>cval</code> is 0)::</p>
<p>mode       |   Ext   |         Input          |   Ext
-----------+---------+------------------------+---------
'mirror'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5
'nearest'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8
'constant' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0
'wrap'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3</p>
<p>.. versionadded:: 0.14.0</p>
<h2 id="examples_491">Examples<a class="headerlink" href="#examples_491" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import savgol_filter
np.set_printoptions(precision=2)  # For compact display.
x = np.array([2, 2, 5, 2, 1, 0, 1, 4, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Filter with a window length of 5 and a degree 2 polynomial.  Use
the defaults for all other parameters.</p>
<blockquote>
<blockquote>
<blockquote>
<p>savgol_filter(x, 5, 2)
array([1.66, 3.17, 3.54, 2.86, 0.66, 0.17, 1.  , 4.  , 9.  ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that the last five values in x are samples of a parabola, so
when mode='interp' (the default) is used with polyorder=2, the last
three values are unchanged.  Compare that to, for example,
<code>mode='nearest'</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>savgol_filter(x, 5, 2, mode='nearest')
array([1.74, 3.03, 3.54, 2.86, 0.66, 0.17, 1.  , 4.6 , 7.97])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sawtooth</span> <span class="o">:</span> <span class="o">?</span><span class="n">width</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a periodic sawtooth or triangle waveform.</p>
<p>The sawtooth waveform has a period <code>2*pi</code>, rises from -1 to 1 on the
interval 0 to <code>width*2*pi</code>, then drops from 1 to -1 on the interval
<code>width*2*pi</code> to <code>2*pi</code>. <code>width</code> must be in the interval [0, 1].</p>
<p>Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.</p>
<h2 id="parameters_594">Parameters<a class="headerlink" href="#parameters_594" title="Permanent link">&para;</a></h2>
<p>t : array_like
Time.
width : array_like, optional
Width of the rising ramp as a proportion of the total cycle.
Default is 1, producing a rising ramp, while 0 produces a falling
ramp.  <code>width</code> = 0.5 produces a triangle wave.
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
<h2 id="returns_571">Returns<a class="headerlink" href="#returns_571" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing the sawtooth waveform.</p>
<h2 id="examples_492">Examples<a class="headerlink" href="#examples_492" title="Permanent link">&para;</a></h2>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(0, 1, 500)
plt.plot(t, signal.sawtooth(2 * np.pi * 5 * t))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sepfir2d</span> <span class="o">:</span> <span class="n">input</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hrow</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hcol</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sepfir2d(input, hrow, hcol) -&gt; output</p>
<p>Description:</p>
<p>Convolve the rank-2 input array with the separable filter defined by the
rank-1 arrays hrow, and hcol. Mirror symmetric boundary conditions are
assumed.  This function can be used to find an image given its B-spline
representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">slepian</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a digital Slepian (DPSS) window.</p>
<p>Used to maximize the energy concentration in the main lobe.  Also called
the digital prolate spheroidal sequence (DPSS).</p>
<p>.. note:: Deprecated in SciPy 1.1.
<code>slepian</code> will be removed in a future version of SciPy, it is
replaced by <code>dpss</code>, which uses the standard definition of a
digital Slepian window.</p>
<p>.. warning:: scipy.signal.slepian is deprecated,
use scipy.signal.windows.slepian instead.</p>
<h2 id="parameters_595">Parameters<a class="headerlink" href="#parameters_595" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
width : float
Bandwidth
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_572">Returns<a class="headerlink" href="#returns_572" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value always normalized to 1</p>
<h2 id="see-also_391">See Also<a class="headerlink" href="#see-also_391" title="Permanent link">&para;</a></h2>
<p>dpss</p>
<h2 id="references_138">References<a class="headerlink" href="#references_138" title="Permanent link">&para;</a></h2>
<p>.. [1] D. Slepian &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-I,' Bell Syst. Tech. J., vol.40,
pp.43-63, 1961. https://archive.org/details/bstj40-1-43
.. [2] H. J. Landau &amp; H. O. Pollak: 'Prolate spheroidal wave functions,
Fourier analysis and uncertainty-II,' Bell Syst. Tech. J. , vol.40,
pp.65-83, 1961. https://archive.org/details/bstj40-1-65</p>
<h2 id="examples_493">Examples<a class="headerlink" href="#examples_493" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.slepian(51, width=0.3)
plt.plot(window)
plt.title('Slepian (DPSS) window (BW=0.3)')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Slepian window (BW=0.3)')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sos2tf</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return a single transfer function from a series of second-order sections</p>
<h2 id="parameters_596">Parameters<a class="headerlink" href="#parameters_596" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_573">Returns<a class="headerlink" href="#returns_573" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
<h2 id="notes_391">Notes<a class="headerlink" href="#notes_391" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sos2zpk</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zeros, poles, and gain of a series of second-order sections</p>
<h2 id="parameters_597">Parameters<a class="headerlink" href="#parameters_597" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_574">Returns<a class="headerlink" href="#returns_574" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_392">Notes<a class="headerlink" href="#notes_392" title="Permanent link">&para;</a></h2>
<p>The number of zeros and poles returned will be <code>n_sections * 2</code>
even if some of these are (effectively) zero.</p>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">zi</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Filter data along one dimension using cascaded second-order sections.</p>
<p>Filter a data sequence, <code>x</code>, using a digital IIR filter defined by
<code>sos</code>.</p>
<h2 id="parameters_598">Parameters<a class="headerlink" href="#parameters_598" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
x : array_like
An N-dimensional input array.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis.  Default is -1.
zi : array_like, optional
Initial conditions for the cascaded filter delays.  It is a (at
least 2D) vector of shape <code>(n_sections, ..., 2, ...)</code>, where
<code>..., 2, ...</code> denotes the shape of <code>x</code>, but with <code>x.shape[axis]</code>
replaced by 2.  If <code>zi</code> is None or is not given then initial rest
(i.e. all zeros) is assumed.
Note that these initial conditions are <em>not</em> the same as the initial
conditions given by <code>lfiltic</code> or <code>lfilter_zi</code>.</p>
<h2 id="returns_575">Returns<a class="headerlink" href="#returns_575" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The output of the digital filter.
zf : ndarray, optional
If <code>zi</code> is None, this is not returned, otherwise, <code>zf</code> holds the
final filter delay values.</p>
<h2 id="see-also_392">See Also<a class="headerlink" href="#see-also_392" title="Permanent link">&para;</a></h2>
<p>zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz</p>
<h2 id="notes_393">Notes<a class="headerlink" href="#notes_393" title="Permanent link">&para;</a></h2>
<p>The filter function is implemented as a series of second-order filters
with direct-form II transposed structure. It is designed to minimize
numerical precision errors for high-order filters.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_494">Examples<a class="headerlink" href="#examples_494" title="Permanent link">&para;</a></h2>
<p>Plot a 13th-order filter's impulse response using both <code>lfilter</code> and
<code>sosfilt</code>, showing the instability that results from trying to do a
13th-order filter in a single stage (the numerical error pushes some poles
outside of the unit circle):</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy import signal
b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba')
sos = signal.ellip(13, 0.009, 80, 0.05, output='sos')
x = signal.unit_impulse(700)
y_tf = signal.lfilter(b, a, x)
y_sos = signal.sosfilt(sos, x)
plt.plot(y_tf, 'r', label='TF')
plt.plot(y_sos, 'k', label='SOS')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfilt_zi</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct initial conditions for sosfilt for step response steady-state.</p>
<p>Compute an initial state <code>zi</code> for the <code>sosfilt</code> function that corresponds
to the steady state of the step response.</p>
<p>A typical use of this function is to set the initial state so that the
output of the filter starts at the same value as the first element of
the signal to be filtered.</p>
<h2 id="parameters_599">Parameters<a class="headerlink" href="#parameters_599" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="returns_576">Returns<a class="headerlink" href="#returns_576" title="Permanent link">&para;</a></h2>
<p>zi : ndarray
Initial conditions suitable for use with <code>sosfilt</code>, shape
<code>(n_sections, 2)</code>.</p>
<h2 id="see-also_393">See Also<a class="headerlink" href="#see-also_393" title="Permanent link">&para;</a></h2>
<p>sosfilt, zpk2sos</p>
<h2 id="notes_394">Notes<a class="headerlink" href="#notes_394" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_495">Examples<a class="headerlink" href="#examples_495" title="Permanent link">&para;</a></h2>
<p>Filter a rectangular pulse that begins at time 0, with and without
the use of the <code>zi</code> argument of <code>scipy.signal.sosfilt</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
<p>sos = signal.butter(9, 0.125, output='sos')
zi = signal.sosfilt_zi(sos)
x = (np.arange(250) &lt; 100).astype(int)
f1 = signal.sosfilt(sos, x)
f2, zo = signal.sosfilt(sos, x, zi=zi)</p>
<p>plt.plot(x, 'k--', label='x')
plt.plot(f1, 'b', alpha=0.5, linewidth=2, label='filtered')
plt.plot(f2, 'g', alpha=0.25, linewidth=4, label='filtered with zi')
plt.legend(loc='best')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfiltfilt</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padlen</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>A forward-backward digital filter using cascaded second-order sections.</p>
<p>See <code>filtfilt</code> for more complete information about this method.</p>
<h2 id="parameters_600">Parameters<a class="headerlink" href="#parameters_600" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
x : array_like
The array of data to be filtered.
axis : int, optional
The axis of <code>x</code> to which the filter is applied.
Default is -1.
padtype : str or None, optional
Must be 'odd', 'even', 'constant', or None.  This determines the
type of extension to use for the padded signal to which the filter
is applied.  If <code>padtype</code> is None, no padding is used.  The default
is 'odd'.
padlen : int or None, optional
The number of elements by which to extend <code>x</code> at both ends of
<code>axis</code> before applying the filter.  This value must be less than
<code>x.shape[axis] - 1</code>.  <code>padlen=0</code> implies no padding.
The default value is::</p>
<p>3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),
(sos[:, 5] == 0).sum()))</p>
<p>The extra subtraction at the end attempts to compensate for poles
and zeros at the origin (e.g. for odd-order filters) to yield
equivalent estimates of <code>padlen</code> to those of <code>filtfilt</code> for
second-order section filters built with <code>scipy.signal</code> functions.</p>
<h2 id="returns_577">Returns<a class="headerlink" href="#returns_577" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The filtered output with the same shape as <code>x</code>.</p>
<h2 id="see-also_394">See Also<a class="headerlink" href="#see-also_394" title="Permanent link">&para;</a></h2>
<p>filtfilt, sosfilt, sosfilt_zi, sosfreqz</p>
<h2 id="notes_395">Notes<a class="headerlink" href="#notes_395" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.18.0</p>
<h2 id="examples_496">Examples<a class="headerlink" href="#examples_496" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sosfiltfilt, butter
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create an interesting signal to filter.</p>
<blockquote>
<blockquote>
<blockquote>
<p>n = 201
t = np.linspace(0, 1, n)
np.random.seed(123)
x = 1 + (t &lt; 0.5) - 0.25<em>t</em><em>2 + 0.05</em>np.random.randn(n)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create a lowpass Butterworth filter, and use it to filter <code>x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = butter(4, 0.125, output='sos')
y = sosfiltfilt(sos, x)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For comparison, apply an 8th order filter using <code>sosfilt</code>.  The filter
is initialized using the mean of the first four values of <code>x</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sosfilt, sosfilt_zi
sos8 = butter(8, 0.125, output='sos')
zi = x[:4].mean() * sosfilt_zi(sos8)
y2, zo = sosfilt(sos8, x, zi=zi)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the results.  Note that the phase of <code>y</code> matches the input, while
<code>y2</code> has a significant phase delay.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(t, x, alpha=0.5, label='x(t)')
plt.plot(t, y, label='y(t)')
plt.plot(t, y2, label='y2(t)')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.xlabel('t')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sosfreqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">worN</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">whole</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">sos</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the frequency response of a digital filter in SOS format.</p>
<p>Given <code>sos</code>, an array with shape (n, 6) of second order sections of
a digital filter, compute the frequency response of the system function::</p>
<p>B0(z)   B1(z)         B{n-1}(z)
H(z) = ----- * ----- * ... * ---------
A0(z)   A1(z)         A{n-1}(z)</p>
<p>for z = exp(omega*1j), where B{k}(z) and A{k}(z) are numerator and
denominator of the transfer function of the k-th second order section.</p>
<h2 id="parameters_601">Parameters<a class="headerlink" href="#parameters_601" title="Permanent link">&para;</a></h2>
<p>sos : array_like
Array of second-order filter coefficients, must have shape
<code>(n_sections, 6)</code>. Each row corresponds to a second-order
section, with the first three columns providing the numerator
coefficients and the last three providing the denominator
coefficients.
worN : {None, int, array_like}, optional
If a single integer, then compute at that many frequencies (default is
N=512).  Using a number that is fast for FFT computations can result
in faster computations (see Notes of <code>freqz</code>).</p>
<p>If an array_like, compute the response at the frequencies given (must
be 1D).  These are in the same units as <code>fs</code>.
whole : bool, optional
Normally, frequencies are computed from 0 to the Nyquist frequency,
fs/2 (upper-half of unit-circle).  If <code>whole</code> is True, compute
frequencies from 0 to fs.
fs : float, optional
The sampling frequency of the digital system.  Defaults to 2*pi
radians/sample (so w is from 0 to pi).</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_578">Returns<a class="headerlink" href="#returns_578" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The frequencies at which <code>h</code> was computed, in the same units as <code>fs</code>.
By default, <code>w</code> is normalized to the range [0, pi) (radians/sample).
h : ndarray
The frequency response, as complex numbers.</p>
<h2 id="see-also_395">See Also<a class="headerlink" href="#see-also_395" title="Permanent link">&para;</a></h2>
<p>freqz, sosfilt</p>
<h2 id="notes_396">Notes<a class="headerlink" href="#notes_396" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_497">Examples<a class="headerlink" href="#examples_497" title="Permanent link">&para;</a></h2>
<p>Design a 15th-order bandpass filter in SOS format.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
sos = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='sos')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute the frequency response at 1500 points from DC to Nyquist.</p>
<blockquote>
<blockquote>
<blockquote>
<p>w, h = signal.sosfreqz(sos, worN=1500)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the response.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.subplot(2, 1, 1)
db = 20<em>np.log10(np.maximum(np.abs(h), 1e-5))
plt.plot(w/np.pi, db)
plt.ylim(-75, 5)
plt.grid(True)
plt.yticks([0, -20, -40, -60])
plt.ylabel('Gain [dB]')
plt.title('Frequency Response')
plt.subplot(2, 1, 2)
plt.plot(w/np.pi, np.angle(h))
plt.grid(True)
plt.yticks([-np.pi, -0.5</em>np.pi, 0, 0.5*np.pi, np.pi],
...            [r'<span><span class="MathJax_Preview">-\pi</span><script type="math/tex">-\pi</script></span>', r'<span><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span>', '0', r'<span><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>', r'<span><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>'])
plt.ylabel('Phase [rad]')
plt.xlabel('Normalized frequency (1.0 = Nyquist)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the same filter is implemented as a single transfer function,
numerical error corrupts the frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b, a = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass',
...                    output='ba')
w, h = signal.freqz(b, a, worN=1500)
plt.subplot(2, 1, 1)
db = 20<em>np.log10(np.maximum(np.abs(h), 1e-5))
plt.plot(w/np.pi, db)
plt.ylim(-75, 5)
plt.grid(True)
plt.yticks([0, -20, -40, -60])
plt.ylabel('Gain [dB]')
plt.title('Frequency Response')
plt.subplot(2, 1, 2)
plt.plot(w/np.pi, np.angle(h))
plt.grid(True)
plt.yticks([-np.pi, -0.5</em>np.pi, 0, 0.5*np.pi, np.pi],
...            [r'<span><span class="MathJax_Preview">-\pi</span><script type="math/tex">-\pi</script></span>', r'<span><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span>', '0', r'<span><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>', r'<span><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span>'])
plt.ylabel('Phase [rad]')
plt.xlabel('Normalized frequency (1.0 = Nyquist)')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spectrogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a spectrogram with consecutive Fourier transforms.</p>
<p>Spectrograms can be used as a way of visualizing the change of a
nonstationary signal's frequency content over time.</p>
<h2 id="parameters_602">Parameters<a class="headerlink" href="#parameters_602" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg.
Defaults to a Tukey window with shape parameter of 0.25.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 8</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Sxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Sxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'.
axis : int, optional
Axis along which the spectrogram is computed; the default is over
the last axis (i.e. <code>axis=-1</code>).
mode : str, optional
Defines what kind of return values are expected. Options are
['psd', 'complex', 'magnitude', 'angle', 'phase']. 'complex' is
equivalent to the output of <code>stft</code> with no padding or boundary
extension. 'magnitude' returns the absolute magnitude of the
STFT. 'angle' and 'phase' return the complex angle of the STFT,
with and without unwrapping, respectively.</p>
<h2 id="returns_579">Returns<a class="headerlink" href="#returns_579" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Sxx : ndarray
Spectrogram of x. By default, the last axis of Sxx corresponds
to the segment times.</p>
<h2 id="see-also_396">See Also<a class="headerlink" href="#see-also_396" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data
welch: Power spectral density by Welch's method.
csd: Cross spectral density by Welch's method.</p>
<h2 id="notes_397">Notes<a class="headerlink" href="#notes_397" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. In contrast to welch's method, where the
entire data stream is averaged over, one may wish to use a smaller
overlap (or perhaps none at all) when computing a spectrogram, to
maintain some statistical independence between individual segments.
It is for this reason that the default window is a Tukey window with
1/8th of a window's length overlap at each end.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_139">References<a class="headerlink" href="#references_139" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.</p>
<h2 id="examples_498">Examples<a class="headerlink" href="#examples_498" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fftshift
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2 * np.sqrt(2)
noise_power = 0.01 * fs / 2
time = np.arange(N) / float(fs)
mod = 500<em>np.cos(2</em>np.pi<em>0.25</em>time)
carrier = amp * np.sin(2<em>np.pi</em>3e3<em>time + mod)
noise = np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
noise </em>= np.exp(-time/5)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the spectrogram.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Sxx = signal.spectrogram(x, fs)
plt.pcolormesh(t, f, Sxx)
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note, if using output that is not one sided, then use the following:</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Sxx = signal.spectrogram(x, fs, return_onesided=False)
plt.pcolormesh(t, fftshift(f), fftshift(Sxx, axes=0))
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">spline_filter</span> <span class="o">:</span> <span class="o">?</span><span class="n">lmbda</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">iin</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Smoothing spline (cubic) filtering of a rank-2 array.</p>
<p>Filter an input data set, <code>Iin</code>, using a (cubic) smoothing spline of
fall-off <code>lmbda</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">square</span> <span class="o">:</span> <span class="o">?</span><span class="n">duty</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a periodic square-wave waveform.</p>
<p>The square wave has a period <code>2*pi</code>, has value +1 from 0 to
<code>2*pi*duty</code> and -1 from <code>2*pi*duty</code> to <code>2*pi</code>. <code>duty</code> must be in
the interval [0,1].</p>
<p>Note that this is not band-limited.  It produces an infinite number
of harmonics, which are aliased back and forth across the frequency
spectrum.</p>
<h2 id="parameters_603">Parameters<a class="headerlink" href="#parameters_603" title="Permanent link">&para;</a></h2>
<p>t : array_like
The input time array.
duty : array_like, optional
Duty cycle.  Default is 0.5 (50% duty cycle).
If an array, causes wave shape to change over time, and must be the
same length as t.</p>
<h2 id="returns_580">Returns<a class="headerlink" href="#returns_580" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing the square waveform.</p>
<h2 id="examples_499">Examples<a class="headerlink" href="#examples_499" title="Permanent link">&para;</a></h2>
<p>A 5 Hz waveform sampled at 500 Hz for 1 second:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
t = np.linspace(0, 1, 500, endpoint=False)
plt.plot(t, signal.square(2 * np.pi * 5 * t))
plt.ylim(-2, 2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>A pulse-width modulated sine wave:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.figure()
sig = np.sin(2 * np.pi * t)
pwm = signal.square(2 * np.pi * 30 * t, duty=(sig + 1)/2)
plt.subplot(2, 1, 1)
plt.plot(t, sig)
plt.subplot(2, 1, 2)
plt.plot(t, pwm)
plt.ylim(-1.5, 1.5)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2tf</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>State-space to transfer function.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_604">Parameters<a class="headerlink" href="#parameters_604" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_581">Returns<a class="headerlink" href="#returns_581" title="Permanent link">&para;</a></h2>
<p>num : 2-D ndarray
Numerator(s) of the resulting transfer function(s).  <code>num</code> has one row
for each of the system's outputs. Each row is a sequence representation
of the numerator polynomial.
den : 1-D ndarray
Denominator of the resulting transfer function(s).  <code>den</code> is a sequence
representation of the denominator polynomial.</p>
<h2 id="examples_500">Examples<a class="headerlink" href="#examples_500" title="Permanent link">&para;</a></h2>
<p>Convert the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>A = [[-2, -1], [1, 0]]
B = [[1], [0]]  # 2-dimensional column vector
C = [[1, 2]]    # 2-dimensional row vector
D = 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import ss2tf
ss2tf(A, B, C, D)
(array([[1, 3, 3]]), array([ 1.,  2.,  1.]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ss2zpk</span> <span class="o">:</span> <span class="o">?</span><span class="n">input</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>State-space representation to zero-pole-gain representation.</p>
<p>A, B, C, D defines a linear state-space system with <code>p</code> inputs,
<code>q</code> outputs, and <code>n</code> state variables.</p>
<h2 id="parameters_605">Parameters<a class="headerlink" href="#parameters_605" title="Permanent link">&para;</a></h2>
<p>A : array_like
State (or system) matrix of shape <code>(n, n)</code>
B : array_like
Input matrix of shape <code>(n, p)</code>
C : array_like
Output matrix of shape <code>(q, n)</code>
D : array_like
Feedthrough (or feedforward) matrix of shape <code>(q, p)</code>
input : int, optional
For multiple-input systems, the index of the input to use.</p>
<h2 id="returns_582">Returns<a class="headerlink" href="#returns_582" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of continuous-time system.</p>
<h2 id="parameters_606">Parameters<a class="headerlink" href="#parameters_606" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector (default is zero).
T : array_like, optional
Time points (computed if not given).
N : int, optional
Number of time points to compute if <code>T</code> is not given.</p>
<h2 id="returns_583">Returns<a class="headerlink" href="#returns_583" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Output time points.
yout : 1D ndarray
Step response of system.</p>
<h2 id="see-also_397">See also<a class="headerlink" href="#see-also_397" title="Permanent link">&para;</a></h2>
<p>scipy.signal.step2</p>
<h2 id="notes_398">Notes<a class="headerlink" href="#notes_398" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<h2 id="examples_501">Examples<a class="headerlink" href="#examples_501" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
lti = signal.lti([1.0], [1.0, 1.0])
t, y = signal.step(lti)
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.title('Step response for 1. Order Lowpass')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">step2</span> <span class="o">:</span> <span class="o">?</span><span class="n">x0</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">system</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Step response of continuous-time system.</p>
<p>This function is functionally the same as <code>scipy.signal.step</code>, but
it uses the function <code>scipy.signal.lsim2</code> to compute the step
response.</p>
<h2 id="parameters_607">Parameters<a class="headerlink" href="#parameters_607" title="Permanent link">&para;</a></h2>
<p>system : an instance of the LTI class or a tuple of array_like
describing the system.
The following gives the number of elements in the tuple and
the interpretation:</p>
<ul>
<li>1 (instance of <code>lti</code>)</li>
<li>2 (num, den)</li>
<li>3 (zeros, poles, gain)</li>
<li>4 (A, B, C, D)</li>
</ul>
<p>X0 : array_like, optional
Initial state-vector (default is zero).
T : array_like, optional
Time points (computed if not given).
N : int, optional
Number of time points to compute if <code>T</code> is not given.
kwargs : various types
Additional keyword arguments are passed on the function
<code>scipy.signal.lsim2</code>, which in turn passes them on to
<code>scipy.integrate.odeint</code>.  See the documentation for
<code>scipy.integrate.odeint</code> for information about these arguments.</p>
<h2 id="returns_584">Returns<a class="headerlink" href="#returns_584" title="Permanent link">&para;</a></h2>
<p>T : 1D ndarray
Output time points.
yout : 1D ndarray
Step response of system.</p>
<h2 id="see-also_398">See also<a class="headerlink" href="#see-also_398" title="Permanent link">&para;</a></h2>
<p>scipy.signal.step</p>
<h2 id="notes_399">Notes<a class="headerlink" href="#notes_399" title="Permanent link">&para;</a></h2>
<p>If (num, den) is passed in for <code>system</code>, coefficients for both the
numerator and denominator should be specified in descending exponent
order (e.g. <code>s^2 + 3s + 5</code> would be represented as <code>[1, 3, 5]</code>).</p>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_502">Examples<a class="headerlink" href="#examples_502" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
lti = signal.lti([1.0], [1.0, 1.0])
t, y = signal.step2(lti)
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.title('Step response for 1. Order Lowpass')
plt.grid()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">stft</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boundary</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">padded</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Short Time Fourier Transform (STFT).</p>
<p>STFTs can be used as a way of quantifying the change of a
nonstationary signal's frequency and phase content over time.</p>
<h2 id="parameters_608">Parameters<a class="headerlink" href="#parameters_608" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to 256.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>. When
specified, the COLA constraint must be met (see Notes below).
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to <code>False</code>.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
boundary : str or None, optional
Specifies whether the input signal is extended at both ends, and
how to generate the new values, in order to center the first
windowed segment on the first input point. This has the benefit
of enabling reconstruction of the first input point when the
employed window function starts at zero. Valid options are
<code>['even', 'odd', 'constant', 'zeros', None]</code>. Defaults to
'zeros', for zero padding extension. I.e. <code>[1, 2, 3, 4]</code> is
extended to <code>[0, 1, 2, 3, 4, 0]</code> for <code>nperseg=3</code>.
padded : bool, optional
Specifies whether the input signal is zero-padded at the end to
make the signal fit exactly into an integer number of window
segments, so that all of the signal is included in the output.
Defaults to <code>True</code>. Padding occurs after boundary extension, if
<code>boundary</code> is not <code>None</code>, and <code>padded</code> is <code>True</code>, as is the
default.
axis : int, optional
Axis along which the STFT is computed; the default is over the
last axis (i.e. <code>axis=-1</code>).</p>
<h2 id="returns_585">Returns<a class="headerlink" href="#returns_585" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
t : ndarray
Array of segment times.
Zxx : ndarray
STFT of <code>x</code>. By default, the last axis of <code>Zxx</code> corresponds
to the segment times.</p>
<h2 id="see-also_399">See Also<a class="headerlink" href="#see-also_399" title="Permanent link">&para;</a></h2>
<p>istft: Inverse Short Time Fourier Transform
check_COLA: Check whether the Constant OverLap Add (COLA) constraint
is met
check_NOLA: Check whether the Nonzero Overlap Add (NOLA) constraint is met
welch: Power spectral density by Welch's method.
spectrogram: Spectrogram by Welch's method.
csd: Cross spectral density by Welch's method.
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="notes_400">Notes<a class="headerlink" href="#notes_400" title="Permanent link">&para;</a></h2>
<p>In order to enable inversion of an STFT via the inverse STFT in
<code>istft</code>, the signal windowing must obey the constraint of 'Nonzero
OverLap Add' (NOLA), and the input signal must have complete
windowing coverage (i.e. <code>(x.shape[axis] - nperseg) %
(nperseg-noverlap) == 0</code>). The <code>padded</code> argument may be used to
accomplish this.</p>
<p>Given a time-domain signal :math:<code>x[n]</code>, a window :math:<code>w[n]</code>, and a hop
size :math:<code>H</code> = <code>nperseg - noverlap</code>, the windowed frame at time index
:math:<code>t</code> is given by</p>
<p>.. math:: x_{t}[n]=x[n]w[n-tH]</p>
<p>The overlap-add (OLA) reconstruction equation is given by</p>
<p>.. math:: x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}</p>
<p>The NOLA constraint ensures that every normalization term that appears
in the denomimator of the OLA reconstruction equation is nonzero. Whether a
choice of <code>window</code>, <code>nperseg</code>, and <code>noverlap</code> satisfy this constraint can
be tested with <code>check_NOLA</code>.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_140">References<a class="headerlink" href="#references_140" title="Permanent link">&para;</a></h2>
<p>.. [1] Oppenheim, Alan V., Ronald W. Schafer, John R. Buck
'Discrete-Time Signal Processing', Prentice Hall, 1999.
.. [2] Daniel W. Griffin, Jae S. Lim 'Signal Estimation from
Modified Short-Time Fourier Transform', IEEE 1984,
10.1109/TASSP.1984.1164317</p>
<h2 id="examples_503">Examples<a class="headerlink" href="#examples_503" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave whose frequency is slowly
modulated around 3kHz, corrupted by white noise of exponentially
decreasing magnitude sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2 * np.sqrt(2)
noise_power = 0.01 * fs / 2
time = np.arange(N) / float(fs)
mod = 500<em>np.cos(2</em>np.pi<em>0.25</em>time)
carrier = amp * np.sin(2<em>np.pi</em>3e3<em>time + mod)
noise = np.random.normal(scale=np.sqrt(noise_power),
...                          size=time.shape)
noise </em>= np.exp(-time/5)
x = carrier + noise</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the STFT's magnitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, t, Zxx = signal.stft(x, fs, nperseg=1000)
plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp)
plt.title('STFT Magnitude')
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sweep_poly</span> <span class="o">:</span> <span class="o">?</span><span class="n">phi</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">poly</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Frequency-swept cosine generator, with a time-dependent frequency.</p>
<p>This function generates a sinusoidal function whose instantaneous
frequency varies with time.  The frequency at time <code>t</code> is given by
the polynomial <code>poly</code>.</p>
<h2 id="parameters_609">Parameters<a class="headerlink" href="#parameters_609" title="Permanent link">&para;</a></h2>
<p>t : ndarray
Times at which to evaluate the waveform.
poly : 1-D array_like or instance of numpy.poly1d
The desired frequency expressed as a polynomial.  If <code>poly</code> is
a list or ndarray of length n, then the elements of <code>poly</code> are
the coefficients of the polynomial, and the instantaneous
frequency is</p>
<p><code>f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]</code></p>
<p>If <code>poly</code> is an instance of numpy.poly1d, then the
instantaneous frequency is</p>
<p><code>f(t) = poly(t)</code></p>
<p>phi : float, optional
Phase offset, in degrees, Default: 0.</p>
<h2 id="returns_586">Returns<a class="headerlink" href="#returns_586" title="Permanent link">&para;</a></h2>
<p>sweep_poly : ndarray
A numpy array containing the signal evaluated at <code>t</code> with the
requested time-varying frequency.  More precisely, the function
returns <code>cos(phase + (pi/180)*phi)</code>, where <code>phase</code> is the integral
(from 0 to t) of <code>2 * pi * f(t)</code>; <code>f(t)</code> is defined above.</p>
<h2 id="see-also_400">See Also<a class="headerlink" href="#see-also_400" title="Permanent link">&para;</a></h2>
<p>chirp</p>
<h2 id="notes_401">Notes<a class="headerlink" href="#notes_401" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<p>If <code>poly</code> is a list or ndarray of length <code>n</code>, then the elements of
<code>poly</code> are the coefficients of the polynomial, and the instantaneous
frequency is:</p>
<p><code>f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]</code></p>
<p>If <code>poly</code> is an instance of <code>numpy.poly1d</code>, then the instantaneous
frequency is:</p>
<p><code>f(t) = poly(t)</code></p>
<p>Finally, the output <code>s</code> is:</p>
<p><code>cos(phase + (pi/180)*phi)</code></p>
<p>where <code>phase</code> is the integral from 0 to <code>t</code> of <code>2 * pi * f(t)</code>,
<code>f(t)</code> as defined above.</p>
<h2 id="examples_504">Examples<a class="headerlink" href="#examples_504" title="Permanent link">&para;</a></h2>
<p>Compute the waveform with instantaneous frequency::</p>
<p>f(t) = 0.025<em>t</em><em>3 - 0.36</em>t*<em>2 + 1.25</em>t + 2</p>
<p>over the interval 0 &lt;= t &lt;= 10.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import sweep_poly
p = np.poly1d([0.025, -0.36, 1.25, 2.0])
t = np.linspace(0, 10, 5001)
w = sweep_poly(t, p)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.subplot(2, 1, 1)
plt.plot(t, w)
plt.title('Sweep Poly\nwith frequency ' +
...           '<span><span class="MathJax_Preview">f(t) = 0.025t^3 - 0.36t^2 + 1.25t + 2</span><script type="math/tex">f(t) = 0.025t^3 - 0.36t^2 + 1.25t + 2</script></span>')
plt.subplot(2, 1, 2)
plt.plot(t, p(t), 'r', label='f(t)')
plt.legend()
plt.xlabel('t')
plt.tight_layout()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2sos</span> <span class="o">:</span> <span class="o">?</span><span class="n">pairing</span><span class="o">:[`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Keep_odd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return second-order sections from transfer function representation</p>
<h2 id="parameters_610">Parameters<a class="headerlink" href="#parameters_610" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.
pairing : {'nearest', 'keep_odd'}, optional
The method to use to combine pairs of poles and zeros into sections.
See <code>zpk2sos</code>.</p>
<h2 id="returns_587">Returns<a class="headerlink" href="#returns_587" title="Permanent link">&para;</a></h2>
<p>sos : ndarray
Array of second-order filter coefficients, with shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="see-also_401">See Also<a class="headerlink" href="#see-also_401" title="Permanent link">&para;</a></h2>
<p>zpk2sos, sosfilt</p>
<h2 id="notes_402">Notes<a class="headerlink" href="#notes_402" title="Permanent link">&para;</a></h2>
<p>It is generally discouraged to convert from TF to SOS format, since doing
so usually will not improve numerical precision errors. Instead, consider
designing filters in ZPK format and converting directly to SOS. TF is
converted to SOS by first converting to ZPK format, then converting
ZPK to SOS.</p>
<p>.. versionadded:: 0.16.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2ss</span> <span class="o">:</span> <span class="n">num</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">den</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Transfer function to state-space representation.</p>
<h2 id="parameters_611">Parameters<a class="headerlink" href="#parameters_611" title="Permanent link">&para;</a></h2>
<p>num, den : array_like
Sequences representing the coefficients of the numerator and
denominator polynomials, in order of descending degree. The
denominator needs to be at least as long as the numerator.</p>
<h2 id="returns_588">Returns<a class="headerlink" href="#returns_588" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<h2 id="examples_505">Examples<a class="headerlink" href="#examples_505" title="Permanent link">&para;</a></h2>
<p>Convert the transfer function:</p>
<p>.. math:: H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}</p>
<blockquote>
<blockquote>
<blockquote>
<p>num = [1, 3, 3]
den = [1, 2, 1]</p>
</blockquote>
</blockquote>
</blockquote>
<p>to the state-space representation:</p>
<p>.. math::</p>
<p>\dot{\textbf{x}}(t) =
\begin{bmatrix} -2 &amp; -1 \ 1 &amp; 0 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \ 0 \end{bmatrix} \textbf{u}(t) \</p>
<p>\textbf{y}(t) = \begin{bmatrix} 1 &amp; 2 \end{bmatrix} \textbf{x}(t) +
\begin{bmatrix} 1 \end{bmatrix} \textbf{u}(t)</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import tf2ss
A, B, C, D = tf2ss(num, den)
A
array([[-2., -1.],
[ 1.,  0.]])
B
array([[ 1.],
[ 0.]])
C
array([[ 1.,  2.]])
D
array([[ 1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tf2zpk</span> <span class="o">:</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Return zero, pole, gain (z, p, k) representation from a numerator,
denominator representation of a linear filter.</p>
<h2 id="parameters_612">Parameters<a class="headerlink" href="#parameters_612" title="Permanent link">&para;</a></h2>
<p>b : array_like
Numerator polynomial coefficients.
a : array_like
Denominator polynomial coefficients.</p>
<h2 id="returns_589">Returns<a class="headerlink" href="#returns_589" title="Permanent link">&para;</a></h2>
<p>z : ndarray
Zeros of the transfer function.
p : ndarray
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="notes_403">Notes<a class="headerlink" href="#notes_403" title="Permanent link">&para;</a></h2>
<p>If some values of <code>b</code> are too close to 0, they are removed. In that case,
a BadCoefficients warning is emitted.</p>
<p>The <code>b</code> and <code>a</code> arrays are interpreted as coefficients for positive,
descending powers of the transfer function variable.  So the inputs
:math:<code>b = [b_0, b_1, ..., b_M]</code> and :math:<code>a =[a_0, a_1, ..., a_N]</code>
can represent an analog filter of the form:</p>
<p>.. math::</p>
<p>H(s) = \frac
{b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M}
{a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}</p>
<p>or a discrete-time filter of the form:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M}
{a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}</p>
<p>This 'positive powers' form is found more commonly in controls
engineering.  If <code>M</code> and <code>N</code> are equal (which is true for all filters
generated by the bilinear transform), then this happens to be equivalent
to the 'negative powers' discrete-time form preferred in DSP:</p>
<p>.. math::</p>
<p>H(z) = \frac
{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}
{a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}</p>
<p>Although this is true for common filters, remember that this is not true
in the general case.  If <code>M</code> and <code>N</code> are not equal, the discrete-time
transfer function coefficients must first be converted to the 'positive
powers' form before finding the poles and zeros.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triang</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a triangular window.</p>
<p>.. warning:: scipy.signal.triang is deprecated,
use scipy.signal.windows.triang instead.</p>
<h2 id="parameters_613">Parameters<a class="headerlink" href="#parameters_613" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_590">Returns<a class="headerlink" href="#returns_590" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="see-also_402">See Also<a class="headerlink" href="#see-also_402" title="Permanent link">&para;</a></h2>
<p>bartlett : A triangular window that touches zero</p>
<h2 id="examples_506">Examples<a class="headerlink" href="#examples_506" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.triang(51)
plt.plot(window)
plt.title('Triangular window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = np.abs(fftshift(A / abs(A).max()))
response = 20 * np.log10(np.maximum(response, 1e-10))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the triangular window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tukey</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a Tukey window, also known as a tapered cosine window.</p>
<p>.. warning:: scipy.signal.tukey is deprecated,
use scipy.signal.windows.tukey instead.</p>
<h2 id="parameters_614">Parameters<a class="headerlink" href="#parameters_614" title="Permanent link">&para;</a></h2>
<p>M : int
Number of points in the output window. If zero or less, an empty
array is returned.
alpha : float, optional
Shape parameter of the Tukey window, representing the fraction of the
window inside the cosine tapered region.
If zero, the Tukey window is equivalent to a rectangular window.
If one, the Tukey window is equivalent to a Hann window.
sym : bool, optional
When True (default), generates a symmetric window, for use in filter
design.
When False, generates a periodic window, for use in spectral analysis.</p>
<h2 id="returns_591">Returns<a class="headerlink" href="#returns_591" title="Permanent link">&para;</a></h2>
<p>w : ndarray
The window, with the maximum value normalized to 1 (though the value 1
does not appear if <code>M</code> is even and <code>sym</code> is True).</p>
<h2 id="references_141">References<a class="headerlink" href="#references_141" title="Permanent link">&para;</a></h2>
<p>.. [1] Harris, Fredric J. (Jan 1978). 'On the use of Windows for Harmonic
Analysis with the Discrete Fourier Transform'. Proceedings of the
IEEE 66 (1): 51-83. :doi:<code>10.1109/PROC.1978.10837</code>
.. [2] Wikipedia, 'Window function',
https://en.wikipedia.org/wiki/Window_function#Tukey_window</p>
<h2 id="examples_507">Examples<a class="headerlink" href="#examples_507" title="Permanent link">&para;</a></h2>
<p>Plot the window and its frequency response:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
from scipy.fft import fft, fftshift
import matplotlib.pyplot as plt</p>
<p>window = signal.tukey(51)
plt.plot(window)
plt.title('Tukey window')
plt.ylabel('Amplitude')
plt.xlabel('Sample')
plt.ylim([0, 1.1])</p>
<p>plt.figure()
A = fft(window, 2048) / (len(window)/2.0)
freq = np.linspace(-0.5, 0.5, len(A))
response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))
plt.plot(freq, response)
plt.axis([-0.5, 0.5, -120, 0])
plt.title('Frequency response of the Tukey window')
plt.ylabel('Normalized magnitude [dB]')
plt.xlabel('Normalized frequency [cycles per sample]')</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">unique_roots</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rtype</span><span class="o">:[`</span><span class="nc">Max</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Maximum</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Min</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Minimum</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Avg</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mean</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Determine unique roots and their multiplicities from a list of roots.</p>
<h2 id="parameters_615">Parameters<a class="headerlink" href="#parameters_615" title="Permanent link">&para;</a></h2>
<p>p : array_like
The list of roots.
tol : float, optional
The tolerance for two roots to be considered equal in terms of
the distance between them. Default is 1e-3. Refer to Notes about
the details on roots grouping.
rtype : {'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}, optional
How to determine the returned root if multiple roots are within
<code>tol</code> of each other.</p>
<ul>
<li>'max', 'maximum': pick the maximum of those roots</li>
<li>'min', 'minimum': pick the minimum of those roots</li>
<li>'avg', 'mean': take the average of those roots</li>
</ul>
<p>When finding minimum or maximum among complex roots they are compared
first by the real part and then by the imaginary part.</p>
<h2 id="returns_592">Returns<a class="headerlink" href="#returns_592" title="Permanent link">&para;</a></h2>
<p>unique : ndarray
The list of unique roots.
multiplicity : ndarray
The multiplicity of each root.</p>
<h2 id="notes_404">Notes<a class="headerlink" href="#notes_404" title="Permanent link">&para;</a></h2>
<p>If we have 3 roots <code>a</code>, <code>b</code> and <code>c</code>, such that <code>a</code> is close to
<code>b</code> and <code>b</code> is close to <code>c</code> (distance is less than <code>tol</code>), then it
doesn't necessarily mean that <code>a</code> is close to <code>c</code>. It means that roots
grouping is not unique. In this function we use 'greedy' grouping going
through the roots in the order they are given in the input <code>p</code>.</p>
<p>This utility function is not specific to roots but can be used for any
sequence of values for which uniqueness and multiplicity has to be
determined. For a more general routine, see <code>numpy.unique</code>.</p>
<h2 id="examples_508">Examples<a class="headerlink" href="#examples_508" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]
uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check which roots have multiplicity larger than 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>uniq[mult &gt; 1]
array([ 1.305])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">unit_impulse</span> <span class="o">:</span> <span class="o">?</span><span class="n">idx</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mid</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Unit impulse signal (discrete delta function) or unit basis vector.</p>
<h2 id="parameters_616">Parameters<a class="headerlink" href="#parameters_616" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of int
Number of samples in the output (1-D), or a tuple that represents the
shape of the output (N-D).
idx : None or int or tuple of int or 'mid', optional
Index at which the value is 1.  If None, defaults to the 0th element.
If <code>idx='mid'</code>, the impulse will be centered at <code>shape // 2</code> in
all dimensions.  If an int, the impulse will be at <code>idx</code> in all
dimensions.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.</p>
<h2 id="returns_593">Returns<a class="headerlink" href="#returns_593" title="Permanent link">&para;</a></h2>
<p>y : ndarray
Output array containing an impulse signal.</p>
<h2 id="notes_405">Notes<a class="headerlink" href="#notes_405" title="Permanent link">&para;</a></h2>
<p>The 1D case is also known as the Kronecker delta.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_509">Examples<a class="headerlink" href="#examples_509" title="Permanent link">&para;</a></h2>
<p>An impulse at the 0th element (:math:<code>\delta[n]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
signal.unit_impulse(8)
array([ 1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Impulse offset by 2 samples (:math:<code>\delta[n-2]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse(7, 2)
array([ 0.,  0.,  1.,  0.,  0.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>2-dimensional impulse, centered:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse((3, 3), 'mid')
array([[ 0.,  0.,  0.],
[ 0.,  1.,  0.],
[ 0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Impulse at (2, 2), using broadcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.unit_impulse((4, 4), 2)
array([[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.],
[ 0.,  0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the impulse response of a 4th-order Butterworth lowpass filter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>imp = signal.unit_impulse(100, 'mid')
b, a = signal.butter(4, 0.2)
response = signal.lfilter(b, a, imp)</p>
<p>import matplotlib.pyplot as plt
plt.plot(np.arange(-50, 50), imp)
plt.plot(np.arange(-50, 50), response)
plt.margins(0.1, 0.1)
plt.xlabel('Time [samples]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">upfirdn</span> <span class="o">:</span> <span class="o">?</span><span class="n">up</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">down</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cval</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Upsample, FIR filter, and downsample</p>
<h2 id="parameters_617">Parameters<a class="headerlink" href="#parameters_617" title="Permanent link">&para;</a></h2>
<p>h : array_like
1-dimensional FIR (finite-impulse response) filter coefficients.
x : array_like
Input signal array.
up : int, optional
Upsampling rate. Default is 1.
down : int, optional
Downsampling rate. Default is 1.
axis : int, optional
The axis of the input data array along which to apply the
linear filter. The filter is applied to each subarray along
this axis. Default is -1.
mode : str, optional
The signal extension mode to use. The set
<code>{'constant', 'symmetric', 'reflect', 'edge', 'wrap'}</code> correspond to
modes provided by <code>numpy.pad</code>. <code>'smooth'</code> implements a smooth
extension by extending based on the slope of the last 2 points at each
end of the array. <code>'antireflect'</code> and <code>'antisymmetric'</code> are
anti-symmetric versions of <code>'reflect'</code> and <code>'symmetric'</code>. The mode
<code>'line'</code> extends the signal based on a linear trend defined by the
first and last points along the <code>axis</code>.</p>
<p>.. versionadded:: 1.4.0
cval : float, optional
The constant value to use when <code>mode == 'constant'</code>.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="returns_594">Returns<a class="headerlink" href="#returns_594" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The output signal array. Dimensions will be the same as <code>x</code> except
for along <code>axis</code>, which will change size according to the <code>h</code>,
<code>up</code>,  and <code>down</code> parameters.</p>
<h2 id="notes_406">Notes<a class="headerlink" href="#notes_406" title="Permanent link">&para;</a></h2>
<p>The algorithm is an implementation of the block diagram shown on page 129
of the Vaidyanathan text [1]_ (Figure 4.3-8d).</p>
<p>.. [1] P. P. Vaidyanathan, Multirate Systems and Filter Banks,
Prentice Hall, 1993.</p>
<p>The direct approach of upsampling by factor of P with zero insertion,
FIR filtering of length <code>N</code>, and downsampling by factor of Q is
O(N*Q) per output sample. The polyphase implementation used here is
O(N/P).</p>
<p>.. versionadded:: 0.18</p>
<h2 id="examples_510">Examples<a class="headerlink" href="#examples_510" title="Permanent link">&para;</a></h2>
<p>Simple operations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.signal import upfirdn
upfirdn([1, 1, 1], [1, 1, 1])   # FIR filter
array([ 1.,  2.,  3.,  2.,  1.])
upfirdn([1], [1, 2, 3], 3)  # upsampling with zeros insertion
array([ 1.,  0.,  0.,  2.,  0.,  0.,  3.,  0.,  0.])
upfirdn([1, 1, 1], [1, 2, 3], 3)  # upsampling with sample-and-hold
array([ 1.,  1.,  1.,  2.,  2.,  2.,  3.,  3.,  3.])
upfirdn([.5, 1, .5], [1, 1, 1], 2)  # linear interpolation
array([ 0.5,  1. ,  1. ,  1. ,  1. ,  1. ,  0.5,  0. ])
upfirdn([1], np.arange(10), 1, 3)  # decimation by 3
array([ 0.,  3.,  6.,  9.])
upfirdn([.5, 1, .5], np.arange(10), 2, 3)  # linear interp, rate 2/3
array([ 0. ,  1. ,  2.5,  4. ,  5.5,  7. ,  8.5,  0. ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply a single filter to multiple signals:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.reshape(np.arange(8), (4, 2))
x
array([[0, 1],
[2, 3],
[4, 5],
[6, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply along the last dimension of <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>h = [1, 1]
upfirdn(h, x, 2)
array([[ 0.,  0.,  1.,  1.],
[ 2.,  2.,  3.,  3.],
[ 4.,  4.,  5.,  5.],
[ 6.,  6.,  7.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Apply along the 0th dimension of <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>upfirdn(h, x, 2, axis=0)
array([[ 0.,  1.],
[ 0.,  1.],
[ 2.,  3.],
[ 2.,  3.],
[ 4.,  5.],
[ 4.,  5.],
[ 6.,  7.],
[ 6.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vectorstrength</span> <span class="o">:</span> <span class="n">events</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">period</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Determine the vector strength of the events corresponding to the given
period.</p>
<p>The vector strength is a measure of phase synchrony, how well the
timing of the events is synchronized to a single period of a periodic
signal.</p>
<p>If multiple periods are used, calculate the vector strength of each.
This is called the 'resonating vector strength'.</p>
<h2 id="parameters_618">Parameters<a class="headerlink" href="#parameters_618" title="Permanent link">&para;</a></h2>
<p>events : 1D array_like
An array of time points containing the timing of the events.
period : float or array_like
The period of the signal that the events should synchronize to.
The period is in the same units as <code>events</code>.  It can also be an array
of periods, in which case the outputs are arrays of the same length.</p>
<h2 id="returns_595">Returns<a class="headerlink" href="#returns_595" title="Permanent link">&para;</a></h2>
<p>strength : float or 1D array
The strength of the synchronization.  1.0 is perfect synchronization
and 0.0 is no synchronization.  If <code>period</code> is an array, this is also
an array with each element containing the vector strength at the
corresponding period.
phase : float or array
The phase that the events are most strongly synchronized to in radians.
If <code>period</code> is an array, this is also an array with each element
containing the phase for the corresponding period.</p>
<h2 id="references_142">References<a class="headerlink" href="#references_142" title="Permanent link">&para;</a></h2>
<p>van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector
strength: Auditory system, electric fish, and noise.
Chaos 21, 047508 (2011);
:doi:<code>10.1063/1.3670512</code>.
van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:
biological and mathematical perspectives.  Biol Cybern.
2013 Aug;107(4):385-96. :doi:<code>10.1007/s00422-013-0561-7</code>.
van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens
when we vary the 'probing' frequency while keeping the spike times
fixed.  Biol Cybern. 2013 Aug;107(4):491-94.
:doi:<code>10.1007/s00422-013-0560-8</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">welch</span> <span class="o">:</span> <span class="o">?</span><span class="n">fs</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">window</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nperseg</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noverlap</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">nfft</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">detrend</span><span class="o">:[`</span><span class="nc">T_False_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_onesided</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scaling</span><span class="o">:[`</span><span class="nc">Density</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Spectrum</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">average</span><span class="o">:[`</span><span class="nc">Mean</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Median</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate power spectral density using Welch's method.</p>
<p>Welch's method [1]_ computes an estimate of the power spectral
density by dividing the data into overlapping segments, computing a
modified periodogram for each segment and averaging the
periodograms.</p>
<h2 id="parameters_619">Parameters<a class="headerlink" href="#parameters_619" title="Permanent link">&para;</a></h2>
<p>x : array_like
Time series of measurement values
fs : float, optional
Sampling frequency of the <code>x</code> time series. Defaults to 1.0.
window : str or tuple or array_like, optional
Desired window to use. If <code>window</code> is a string or tuple, it is
passed to <code>get_window</code> to generate the window values, which are
DFT-even by default. See <code>get_window</code> for a list of windows and
required parameters. If <code>window</code> is array_like it will be used
directly as the window and its length must be nperseg. Defaults
to a Hann window.
nperseg : int, optional
Length of each segment. Defaults to None, but if window is str or
tuple, is set to 256, and if window is array_like, is set to the
length of the window.
noverlap : int, optional
Number of points to overlap between segments. If <code>None</code>,
<code>noverlap = nperseg // 2</code>. Defaults to <code>None</code>.
nfft : int, optional
Length of the FFT used, if a zero padded FFT is desired. If
<code>None</code>, the FFT length is <code>nperseg</code>. Defaults to <code>None</code>.
detrend : str or function or <code>False</code>, optional
Specifies how to detrend each segment. If <code>detrend</code> is a
string, it is passed as the <code>type</code> argument to the <code>detrend</code>
function. If it is a function, it takes a segment and returns a
detrended segment. If <code>detrend</code> is <code>False</code>, no detrending is
done. Defaults to 'constant'.
return_onesided : bool, optional
If <code>True</code>, return a one-sided spectrum for real data. If
<code>False</code> return a two-sided spectrum. Defaults to <code>True</code>, but for
complex data, a two-sided spectrum is always returned.
scaling : { 'density', 'spectrum' }, optional
Selects between computing the power spectral density ('density')
where <code>Pxx</code> has units of V<strong>2/Hz and computing the power
spectrum ('spectrum') where <code>Pxx</code> has units of V</strong>2, if <code>x</code>
is measured in V and <code>fs</code> is measured in Hz. Defaults to
'density'
axis : int, optional
Axis along which the periodogram is computed; the default is
over the last axis (i.e. <code>axis=-1</code>).
average : { 'mean', 'median' }, optional
Method to use when averaging periodograms. Defaults to 'mean'.</p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="returns_596">Returns<a class="headerlink" href="#returns_596" title="Permanent link">&para;</a></h2>
<p>f : ndarray
Array of sample frequencies.
Pxx : ndarray
Power spectral density or power spectrum of x.</p>
<h2 id="see-also_403">See Also<a class="headerlink" href="#see-also_403" title="Permanent link">&para;</a></h2>
<p>periodogram: Simple, optionally modified periodogram
lombscargle: Lomb-Scargle periodogram for unevenly sampled data</p>
<h2 id="notes_407">Notes<a class="headerlink" href="#notes_407" title="Permanent link">&para;</a></h2>
<p>An appropriate amount of overlap will depend on the choice of window
and on your requirements. For the default Hann window an overlap of
50% is a reasonable trade off between accurately estimating the
signal power, while not over counting any of the data. Narrower
windows may require a larger overlap.</p>
<p>If <code>noverlap</code> is 0, this method is equivalent to Bartlett's method
[2]_.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="references_143">References<a class="headerlink" href="#references_143" title="Permanent link">&para;</a></h2>
<p>.. [1] P. Welch, 'The use of the fast Fourier transform for the
estimation of power spectra: A method based on time averaging
over short, modified periodograms', IEEE Trans. Audio
Electroacoust. vol. 15, pp. 70-73, 1967.
.. [2] M.S. Bartlett, 'Periodogram Analysis and Continuous Spectra',
Biometrika, vol. 37, pp. 1-16, 1950.</p>
<h2 id="examples_511">Examples<a class="headerlink" href="#examples_511" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
import matplotlib.pyplot as plt
np.random.seed(1234)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
0.001 V**2/Hz of white noise sampled at 10 kHz.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fs = 10e3
N = 1e5
amp = 2<em>np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp</em>np.sin(2<em>np.pi</em>freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute and plot the power spectral density.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_den = signal.welch(x, fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we average the last half of the spectral density, to exclude the
peak, we can recover the noise power on the signal.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.mean(Pxx_den[256:])
0.0009924865443739191</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now compute and plot the power spectrum.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f, Pxx_spec = signal.welch(x, fs, 'flattop', 1024, scaling='spectrum')
plt.figure()
plt.semilogy(f, np.sqrt(Pxx_spec))
plt.xlabel('frequency [Hz]')
plt.ylabel('Linear spectrum [V RMS]')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The peak height in the power spectrum is an estimate of the RMS
amplitude.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.sqrt(Pxx_spec.max())
2.0077340678640727</p>
</blockquote>
</blockquote>
</blockquote>
<p>If we now introduce a discontinuity in the signal, by increasing the
amplitude of a small portion of the signal by 50, we can see the
corruption of the mean average power spectral density, but using a
median average better estimates the normal behaviour.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x[int(N//2):int(N//2)+10] <em>= 50.
f, Pxx_den = signal.welch(x, fs, nperseg=1024)
f_med, Pxx_den_med = signal.welch(x, fs, nperseg=1024, average='median')
plt.semilogy(f, Pxx_den, label='mean')
plt.semilogy(f_med, Pxx_den_med, label='median')
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V</em>*2/Hz]')
plt.legend()
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wiener</span> <span class="o">:</span> <span class="o">?</span><span class="n">mysize</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">noise</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">im</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform a Wiener filter on an N-dimensional array.</p>
<p>Apply a Wiener filter to the N-dimensional array <code>im</code>.</p>
<h2 id="parameters_620">Parameters<a class="headerlink" href="#parameters_620" title="Permanent link">&para;</a></h2>
<p>im : ndarray
An N-dimensional array.
mysize : int or array_like, optional
A scalar or an N-length list giving the size of the Wiener filter
window in each dimension.  Elements of mysize should be odd.
If mysize is a scalar, then this scalar is used as the size
in each dimension.
noise : float, optional
The noise-power to use. If None, then noise is estimated as the
average of the local variance of the input.</p>
<h2 id="returns_597">Returns<a class="headerlink" href="#returns_597" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Wiener filtered result with the same shape as <code>im</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2sos</span> <span class="o">:</span> <span class="o">?</span><span class="n">pairing</span><span class="o">:[`</span><span class="nc">Nearest</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Keep_odd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return second-order sections from zeros, poles, and gain of a system</p>
<h2 id="parameters_621">Parameters<a class="headerlink" href="#parameters_621" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.
pairing : {'nearest', 'keep_odd'}, optional
The method to use to combine pairs of poles and zeros into sections.
See Notes below.</p>
<h2 id="returns_598">Returns<a class="headerlink" href="#returns_598" title="Permanent link">&para;</a></h2>
<p>sos : ndarray
Array of second-order filter coefficients, with shape
<code>(n_sections, 6)</code>. See <code>sosfilt</code> for the SOS filter format
specification.</p>
<h2 id="see-also_404">See Also<a class="headerlink" href="#see-also_404" title="Permanent link">&para;</a></h2>
<p>sosfilt</p>
<h2 id="notes_408">Notes<a class="headerlink" href="#notes_408" title="Permanent link">&para;</a></h2>
<p>The algorithm used to convert ZPK to SOS format is designed to
minimize errors due to numerical precision issues. The pairing
algorithm attempts to minimize the peak gain of each biquadratic
section. This is done by pairing poles with the nearest zeros, starting
with the poles closest to the unit circle.</p>
<p><em>Algorithms</em></p>
<p>The current algorithms are designed specifically for use with digital
filters. (The output coefficients are not correct for analog filters.)</p>
<p>The steps in the <code>pairing='nearest'</code> and <code>pairing='keep_odd'</code>
algorithms are mostly shared. The <code>nearest</code> algorithm attempts to
minimize the peak gain, while <code>'keep_odd'</code> minimizes peak gain under
the constraint that odd-order systems should retain one section
as first order. The algorithm steps and are as follows:</p>
<p>As a pre-processing step, add poles or zeros to the origin as
necessary to obtain the same number of poles and zeros for pairing.
If <code>pairing == 'nearest'</code> and there are an odd number of poles,
add an additional pole and a zero at the origin.</p>
<p>The following steps are then iterated over until no more poles or
zeros remain:</p>
<ol>
<li>
<p>Take the (next remaining) pole (complex or real) closest to the
unit circle to begin a new filter section.</p>
</li>
<li>
<p>If the pole is real and there are no other remaining real poles [#]_,
add the closest real zero to the section and leave it as a first
order section. Note that after this step we are guaranteed to be
left with an even number of real poles, complex poles, real zeros,
and complex zeros for subsequent pairing iterations.</p>
</li>
<li>
<p>Else:</p>
</li>
<li>
<p>If the pole is complex and the zero is the only remaining real
zero<em>, then pair the pole with the </em>next* closest zero
(guaranteed to be complex). This is necessary to ensure that
there will be a real zero remaining to eventually create a
first-order section (thus keeping the odd order).</p>
</li>
<li>
<p>Else pair the pole with the closest remaining zero (complex or
real).</p>
</li>
<li>
<p>Proceed to complete the second-order section by adding another
pole and zero to the current pole and zero in the section:</p>
</li>
<li>
<p>If the current pole and zero are both complex, add their
conjugates.</p>
</li>
<li>
<p>Else if the pole is complex and the zero is real, add the
conjugate pole and the next closest real zero.</p>
</li>
<li>
<p>Else if the pole is real and the zero is complex, add the
conjugate zero and the real pole closest to those zeros.</p>
</li>
<li>
<p>Else (we must have a real pole and real zero) add the next
real pole closest to the unit circle, and then add the real
zero closest to that pole.</p>
</li>
</ol>
<p>.. [#] This conditional can only be met for specific odd-order inputs
with the <code>pairing == 'keep_odd'</code> method.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_512">Examples<a class="headerlink" href="#examples_512" title="Permanent link">&para;</a></h2>
<p>Design a 6th order low-pass elliptic digital filter for a system with a
sampling rate of 8000 Hz that has a pass-band corner frequency of
1000 Hz.  The ripple in the pass-band should not exceed 0.087 dB, and
the attenuation in the stop-band should be at least 90 dB.</p>
<p>In the following call to <code>signal.ellip</code>, we could use <code>output='sos'</code>,
but for this example, we'll use <code>output='zpk'</code>, and then convert to SOS
format with <code>zpk2sos</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import signal
z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now convert to SOS format.</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos = signal.zpk2sos(z, p, k)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The coefficients of the numerators of the sections:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos[:, :3]
array([[ 0.0014154 ,  0.00248707,  0.0014154 ],
[ 1.        ,  0.72965193,  1.        ],
[ 1.        ,  0.17594966,  1.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The symmetry in the coefficients occurs because all the zeros are on the
unit circle.</p>
<p>The coefficients of the denominators of the sections:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sos[:, 3:]
array([[ 1.        , -1.32543251,  0.46989499],
[ 1.        , -1.26117915,  0.6262586 ],
[ 1.        , -1.25707217,  0.86199667]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The next example shows the effect of the <code>pairing</code> option.  We have a
system with three poles and three zeros, so the SOS array will have
shape (2, 6).  The means there is, in effect, an extra pole and an extra
zero at the origin in the SOS representation.</p>
<blockquote>
<blockquote>
<blockquote>
<p>z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j])
p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>With <code>pairing='nearest'</code> (the default), we obtain</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.zpk2sos(z1, p1, 1)
array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ],
[ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles
{0, 0.75}, and the second section has the zeros {-1, 0} and poles
{0.8+0.1j, 0.8-0.1j}.  Note that the extra pole and zero at the origin
have been assigned to different sections.</p>
<p>With <code>pairing='keep_odd'</code>, we obtain:</p>
<blockquote>
<blockquote>
<blockquote>
<p>signal.zpk2sos(z1, p1, 1, pairing='keep_odd')
array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ],
[ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The extra pole and zero at the origin are in the same section.
The first section is, in effect, a first-order section.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2ss</span> <span class="o">:</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Zero-pole-gain representation to state-space representation</p>
<h2 id="parameters_622">Parameters<a class="headerlink" href="#parameters_622" title="Permanent link">&para;</a></h2>
<p>z, p : sequence
Zeros and poles.
k : float
System gain.</p>
<h2 id="returns_599">Returns<a class="headerlink" href="#returns_599" title="Permanent link">&para;</a></h2>
<p>A, B, C, D : ndarray
State space representation of the system, in controller canonical
form.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zpk2tf</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return polynomial transfer function representation from zeros and poles</p>
<h2 id="parameters_623">Parameters<a class="headerlink" href="#parameters_623" title="Permanent link">&para;</a></h2>
<p>z : array_like
Zeros of the transfer function.
p : array_like
Poles of the transfer function.
k : float
System gain.</p>
<h2 id="returns_600">Returns<a class="headerlink" href="#returns_600" title="Permanent link">&para;</a></h2>
<p>b : ndarray
Numerator polynomial coefficients.
a : ndarray
Denominator polynomial coefficients.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Setup/" title="Setup" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Setup
              </div>
            </div>
          </a>
        
        
          <a href="../Sparse/" title="Sparse" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Sparse
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>