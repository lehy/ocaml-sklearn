


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Spatial - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Spatial
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Spatial" class="md-nav__link md-nav__link--active">
      Spatial
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Spatial.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">ConvexHull</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ConvexHull</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ConvexHull</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">incremental</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">qhull_options</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>ConvexHull(points, incremental=False, qhull_options=None)</p>
<p>Convex hulls in N dimensions.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>points : ndarray of floats, shape (npoints, ndim)
Coordinates of points to construct a convex hull from
incremental : bool, optional
Allow adding new points incrementally. This takes up some additional
resources.
qhull_options : str, optional
Additional options to pass to Qhull. See Qhull manual
for details. (Default: 'Qx' for ndim &gt; 4 and '' otherwise)
Option 'Qt' is always enabled.</p>
<h2 id="attributes">Attributes<a class="headerlink" href="#attributes" title="Permanent link">&para;</a></h2>
<p>points : ndarray of double, shape (npoints, ndim)
Coordinates of input points.
vertices : ndarray of ints, shape (nvertices,)
Indices of points forming the vertices of the convex hull.
For 2-D convex hulls, the vertices are in counterclockwise order.
For other dimensions, they are in input order.
simplices : ndarray of ints, shape (nfacet, ndim)
Indices of points forming the simplical facets of the convex hull.
neighbors : ndarray of ints, shape (nfacet, ndim)
Indices of neighbor facets for each facet.
The kth neighbor is opposite to the kth vertex.
-1 denotes no neighbor.
equations : ndarray of double, shape (nfacet, ndim+1)
[normal, offset] forming the hyperplane equation of the facet
(see <code>Qhull documentation &lt;http://www.qhull.org/&gt;</code>__  for more).
coplanar : ndarray of int, shape (ncoplanar, 3)
Indices of coplanar points and the corresponding indices of
the nearest facets and nearest vertex indices.  Coplanar
points are input points which were <em>not</em> included in the
triangulation due to numerical precision issues.</p>
<p>If option 'Qc' is not specified, this list is not computed.
good : ndarray of bool or None
A one-dimensional Boolean array indicating which facets are
good. Used with options that compute good facets, e.g. QGn
and QG-n. Good facets are defined as those that are
visible (n) or invisible (-n) from point n, where
n is the nth point in 'points'. The 'good' attribute may be
used as an index into 'simplices' to return the good (visible)
facets: simplices[good]. A facet is visible from the outside
of the hull only, and neither coplanarity nor degeneracy count
as cases of visibility.</p>
<p>If a 'QGn' or 'QG-n' option is not specified, None is returned.</p>
<p>.. versionadded:: 1.3.0
area : float
Area of the convex hull.</p>
<p>.. versionadded:: 0.17.0
volume : float
Volume of the convex hull.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.
ValueError
Raised if an incompatible array is given as input.</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>The convex hull is computed using the
<code>Qhull library &lt;http://www.qhull.org/&gt;</code>__.</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<p>Convex hull of a random set of points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import ConvexHull, convex_hull_plot_2d
points = np.random.rand(30, 2)   # 30 random points in 2-D
hull = ConvexHull(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.plot(points[:,0], points[:,1], 'o')
for simplex in hull.simplices:
...     plt.plot(points[simplex, 0], points[simplex, 1], 'k-')</p>
</blockquote>
</blockquote>
</blockquote>
<p>We could also have directly used the vertices of the hull, which
for 2-D are guaranteed to be in counterclockwise order:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(points[hull.vertices,0], points[hull.vertices,1], 'r--', lw=2)
plt.plot(points[hull.vertices[0],0], points[hull.vertices[0],1], 'ro')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Facets visible from a point:</p>
<p>Create a square and add a point above the square.</p>
<blockquote>
<blockquote>
<blockquote>
<p>generators = np.array([[0.2, 0.2],
...                        [0.2, 0.4],
...                        [0.4, 0.4],
...                        [0.4, 0.2],
...                        [0.3, 0.6]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Call ConvexHull with the QG option. QG4 means
compute the portions of the hull not including
point 4, indicating the facets that are visible
from point 4.</p>
<blockquote>
<blockquote>
<blockquote>
<p>hull = ConvexHull(points=generators,
...                   qhull_options='QG4')</p>
</blockquote>
</blockquote>
</blockquote>
<p>The 'good' array indicates which facets are
visible from point 4.</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(hull.simplices)
[[1 0]
[1 2]
[3 0]
[3 2]]
print(hull.good)
[False  True False False]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now plot it, highlighting the visible facets.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fig = plt.figure()
ax = fig.add_subplot(1,1,1)
for visible_facet in hull.simplices[hull.good]:
...     ax.plot(hull.points[visible_facet, 0],
...             hull.points[visible_facet, 1],
...             color='violet',
...             lw=6)
convex_hull_plot_2d(hull, ax=ax)
<Figure size 640x480 with 1 Axes> # may vary
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [Qhull] http://www.qhull.org/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">add_points</span> <span class="o">:</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>add_points(points, restart=False)</p>
<p>Process a set of additional new points.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>points : ndarray
New points to add. The dimensionality should match that of the
initial points.
restart : bool, optional
Whether to restart processing from scratch, rather than
adding points incrementally.</p>
<h2 id="raises_1">Raises<a class="headerlink" href="#raises_1" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>close</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>You need to specify <code>incremental=True</code> when constructing the
object to be able to add points incrementally. Incremental addition
of points is also not possible after <code>close</code> has been called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>close()</p>
<p>Finish incremental processing.</p>
<p>Call this to free resources taken up by Qhull, when using the
incremental mode. After calling this, adding more points is no
longer possible.</p>
<p>Attribute points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute simplices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">simplices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute simplices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">simplices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute neighbors: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">neighbors</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute neighbors: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">neighbors_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute equations: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">equations</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute equations: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">equations_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute coplanar: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coplanar</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute coplanar: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coplanar_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute good: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">good</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute good: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">good_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute area: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">area</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute area: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">area_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute volume: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">volume</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute volume: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">volume_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Delaunay</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Delaunay</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Delaunay</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">furthest_site</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">incremental</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">qhull_options</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)</p>
<p>Delaunay tessellation in N dimensions.</p>
<p>.. versionadded:: 0.9</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>points : ndarray of floats, shape (npoints, ndim)
Coordinates of points to triangulate
furthest_site : bool, optional
Whether to compute a furthest-site Delaunay triangulation.
Default: False</p>
<p>.. versionadded:: 0.12.0
incremental : bool, optional
Allow adding new points incrementally. This takes up some additional
resources.
qhull_options : str, optional
Additional options to pass to Qhull. See Qhull manual for
details. Option 'Qt' is always enabled.
Default:'Qbb Qc Qz Qx Q12' for ndim &gt; 4 and 'Qbb Qc Qz Q12' otherwise.
Incremental mode omits 'Qz'.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="attributes_1">Attributes<a class="headerlink" href="#attributes_1" title="Permanent link">&para;</a></h2>
<p>points : ndarray of double, shape (npoints, ndim)
Coordinates of input points.
simplices : ndarray of ints, shape (nsimplex, ndim+1)
Indices of the points forming the simplices in the triangulation.
For 2-D, the points are oriented counterclockwise.
neighbors : ndarray of ints, shape (nsimplex, ndim+1)
Indices of neighbor simplices for each simplex.
The kth neighbor is opposite to the kth vertex.
For simplices at the boundary, -1 denotes no neighbor.
equations : ndarray of double, shape (nsimplex, ndim+2)
[normal, offset] forming the hyperplane equation of the facet
on the paraboloid
(see <code>Qhull documentation &lt;http://www.qhull.org/&gt;</code><strong> for more).
paraboloid_scale, paraboloid_shift : float
Scale and shift for the extra paraboloid dimension
(see <code>Qhull documentation &lt;http://www.qhull.org/&gt;</code></strong> for more).
transform : ndarray of double, shape (nsimplex, ndim+1, ndim)
Affine transform from <code>x</code> to the barycentric coordinates <code>c</code>.
This is defined by::</p>
<p>T c = x - r</p>
<p>At vertex <code>j</code>, <code>c_j = 1</code> and the other coordinates zero.</p>
<p>For simplex <code>i</code>, <code>transform[i,:ndim,:ndim]</code> contains
inverse of the matrix <code>T</code>, and <code>transform[i,ndim,:]</code>
contains the vector <code>r</code>.</p>
<p>If the simplex is degenerate or nearly degenerate, its
barycentric transform contains NaNs.
vertex_to_simplex : ndarray of int, shape (npoints,)
Lookup array, from a vertex, to some simplex which it is a part of.
If qhull option 'Qc' was not specified, the list will contain -1
for points that are not vertices of the tessellation.
convex_hull : ndarray of int, shape (nfaces, ndim)
Vertices of facets forming the convex hull of the point set.
The array contains the indices of the points belonging to
the (N-1)-dimensional facets that form the convex hull
of the triangulation.</p>
<p>.. note::</p>
<p>Computing convex hulls via the Delaunay triangulation is
inefficient and subject to increased numerical instability.
Use <code>ConvexHull</code> instead.
coplanar : ndarray of int, shape (ncoplanar, 3)
Indices of coplanar points and the corresponding indices of
the nearest facet and the nearest vertex.  Coplanar
points are input points which were <em>not</em> included in the
triangulation due to numerical precision issues.</p>
<p>If option 'Qc' is not specified, this list is not computed.</p>
<p>.. versionadded:: 0.12.0
vertices
Same as <code>simplices</code>, but deprecated.
vertex_neighbor_vertices : tuple of two ndarrays of int; (indptr, indices)
Neighboring vertices of vertices. The indices of neighboring
vertices of vertex <code>k</code> are <code>indices[indptr[k]:indptr[k+1]]</code>.
furthest_site
True if this was a furthest site triangulation and False if not.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="raises_2">Raises<a class="headerlink" href="#raises_2" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.
ValueError
Raised if an incompatible array is given as input.</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>The tessellation is computed using the Qhull library
<code>Qhull library &lt;http://www.qhull.org/&gt;</code>__.</p>
<p>.. note::</p>
<p>Unless you pass in the Qhull option 'QJ', Qhull does not
guarantee that each input point appears as a vertex in the
Delaunay triangulation. Omitted points are listed in the
<code>coplanar</code> attribute.</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<p>Triangulation of a set of points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]])
from scipy.spatial import Delaunay
tri = Delaunay(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.triplot(points[:,0], points[:,1], tri.simplices)
plt.plot(points[:,0], points[:,1], 'o')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Point indices and coordinates for the two triangles forming the
triangulation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>tri.simplices
array([[2, 3, 0],                 # may vary
[3, 1, 0]], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that depending on how rounding errors go, the simplices may
be in a different order than above.</p>
<blockquote>
<blockquote>
<blockquote>
<p>points[tri.simplices]
array([[[ 1. ,  0. ],            # may vary
[ 1. ,  1. ],
[ 0. ,  0. ]],
[[ 1. ,  1. ],
[ 0. ,  1.1],
[ 0. ,  0. ]]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Triangle 0 is the only neighbor of triangle 1, and it's opposite to
vertex 1 of triangle 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>tri.neighbors[1]
array([-1,  0, -1], dtype=int32)
points[tri.simplices[1,1]]
array([ 0. ,  1.1])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can find out which triangle points are in:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = np.array([(0.1, 0.2), (1.5, 0.5), (0.5, 1.05)])
tri.find_simplex(p)
array([ 1, -1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The returned integers in the array are the indices of the simplex the
corresponding point is in. If -1 is returned, the point is in no simplex.
Be aware that the shortcut in the following example only works corretcly
for valid points as invalid points result in -1 which is itself a valid
index for the last simplex in the list.</p>
<blockquote>
<blockquote>
<blockquote>
<p>p_valids = np.array([(0.1, 0.2), (0.5, 1.05)])
tri.simplices[tri.find_simplex(p_valids)]
array([[3, 1, 0],                 # may vary
[3, 1, 0]], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can also compute barycentric coordinates in triangle 1 for
these points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = tri.transform[1,:2].dot(np.transpose(p - tri.transform[1,2]))
np.c_[np.transpose(b), 1 - b.sum(axis=0)]
array([[ 0.1       ,  0.09090909,  0.80909091],
[ 1.5       , -0.90909091,  0.40909091],
[ 0.5       ,  0.5       ,  0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The coordinates for the first point are all positive, meaning it
is indeed inside the triangle. The third point is on a vertex,
hence its null third coordinate.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">add_points</span> <span class="o">:</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>add_points(points, restart=False)</p>
<p>Process a set of additional new points.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>points : ndarray
New points to add. The dimensionality should match that of the
initial points.
restart : bool, optional
Whether to restart processing from scratch, rather than
adding points incrementally.</p>
<h2 id="raises_3">Raises<a class="headerlink" href="#raises_3" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>close</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>You need to specify <code>incremental=True</code> when constructing the
object to be able to add points incrementally. Incremental addition
of points is also not possible after <code>close</code> has been called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>close()</p>
<p>Finish incremental processing.</p>
<p>Call this to free resources taken up by Qhull, when using the
incremental mode. After calling this, adding more points is no
longer possible.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_simplex</span> <span class="o">:</span> <span class="o">?</span><span class="n">bruteforce</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">xi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>find_simplex(self, xi, bruteforce=False, tol=None)</p>
<p>Find the simplices containing the given points.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>tri : DelaunayInfo
Delaunay triangulation
xi : ndarray of double, shape (..., ndim)
Points to locate
bruteforce : bool, optional
Whether to only perform a brute-force search
tol : float, optional
Tolerance allowed in the inside-triangle check.
Default is <code>100*eps</code>.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>i : ndarray of int, same shape as <code>xi</code>
Indices of simplices containing each point.
Points outside the triangulation get the value -1.</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>This uses an algorithm adapted from Qhull's <code>qh_findbestfacet</code>,
which makes use of the connection between a convex hull and a
Delaunay triangulation. After finding the simplex closest to
the point in N+1 dimensions, the algorithm falls back to
directed search in N dimensions.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lift_points</span> <span class="o">:</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>lift_points(self, x)</p>
<p>Lift points to the Qhull paraboloid.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">plane_distance</span> <span class="o">:</span> <span class="n">xi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>plane_distance(self, xi)</p>
<p>Compute hyperplane distances to the point <code>xi</code> from all simplices.</p>
<p>Attribute points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute simplices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">simplices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute simplices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">simplices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute neighbors: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">neighbors</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute neighbors: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">neighbors_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute equations: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">equations</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute equations: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">equations_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute transform: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute transform: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transform_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertex_to_simplex: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertex_to_simplex</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertex_to_simplex: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertex_to_simplex_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute convex_hull: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convex_hull</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute convex_hull: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convex_hull_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute coplanar: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coplanar</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute coplanar: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coplanar_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertex_neighbor_vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertex_neighbor_vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertex_neighbor_vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertex_neighbor_vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute furthest_site: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">furthest_site</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute furthest_site: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">furthest_site_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">HalfspaceIntersection</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">HalfspaceIntersection</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">HalfspaceIntersection</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">incremental</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">qhull_options</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">halfspaces</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">interior_point</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>HalfspaceIntersection(halfspaces, interior_point, incremental=False, qhull_options=None)</p>
<p>Halfspace intersections in N dimensions.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>halfspaces : ndarray of floats, shape (nineq, ndim+1)
Stacked Inequalities of the form Ax + b &lt;= 0 in format [A; b]
interior_point : ndarray of floats, shape (ndim,)
Point clearly inside the region defined by halfspaces. Also called a feasible
point, it can be obtained by linear programming.
incremental : bool, optional
Allow adding new halfspaces incrementally. This takes up some additional
resources.
qhull_options : str, optional
Additional options to pass to Qhull. See Qhull manual
for details. (Default: 'Qx' for ndim &gt; 4 and '' otherwise)
Option 'H' is always enabled.</p>
<h2 id="attributes_2">Attributes<a class="headerlink" href="#attributes_2" title="Permanent link">&para;</a></h2>
<p>halfspaces : ndarray of double, shape (nineq, ndim+1)
Input halfspaces.
interior_point :ndarray of floats, shape (ndim,)
Input interior point.
intersections : ndarray of double, shape (ninter, ndim)
Intersections of all halfspaces.
dual_points : ndarray of double, shape (nineq, ndim)
Dual points of the input halfspaces.
dual_facets : list of lists of ints
Indices of points forming the (non necessarily simplicial) facets of
the dual convex hull.
dual_vertices : ndarray of ints, shape (nvertices,)
Indices of halfspaces forming the vertices of the dual convex hull.
For 2-D convex hulls, the vertices are in counterclockwise order.
For other dimensions, they are in input order.
dual_equations : ndarray of double, shape (nfacet, ndim+1)
[normal, offset] forming the hyperplane equation of the dual facet
(see <code>Qhull documentation &lt;http://www.qhull.org/&gt;</code>__  for more).
dual_area : float
Area of the dual convex hull
dual_volume : float
Volume of the dual convex hull</p>
<h2 id="raises_4">Raises<a class="headerlink" href="#raises_4" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.
ValueError
Raised if an incompatible array is given as input.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>The intersections are computed using the
<code>Qhull library &lt;http://www.qhull.org/&gt;</code>__.
This reproduces the 'qhalf' functionality of Qhull.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<p>Halfspace intersection of planes forming some polygon</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import HalfspaceIntersection
halfspaces = np.array([[-1, 0., 0.],
...                        [0., -1., 0.],
...                        [2., 1., -4.],
...                        [-0.5, 1., -2.]])
feasible_point = np.array([0.5, 0.5])
hs = HalfspaceIntersection(halfspaces, feasible_point)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot halfspaces as filled regions and intersection points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_subplot('111', aspect='equal')
xlim, ylim = (-1, 3), (-1, 3)
ax.set_xlim(xlim)
ax.set_ylim(ylim)
x = np.linspace(-1, 3, 100)
symbols = ['-', '+', 'x', '<em>']
signs = [0, 0, -1, -1]
fmt = {'color': None, 'edgecolor': 'b', 'alpha': 0.5}
for h, sym, sign in zip(halfspaces, symbols, signs):
...     hlist = h.tolist()
...     fmt['hatch'] = sym
...     if h[1]== 0:
...         ax.axvline(-h[2]/h[0], label='{}x+{}y+{}=0'.format( </em>hlist))
...         xi = np.linspace(xlim[sign], -h[2]/h[0], 100)
...         ax.fill_between(xi, ylim[0], ylim[1], <strong>fmt)
...     else:
...         ax.plot(x, (-h[2]-h[0]<em>x)/h[1], label='{}x+{}y+{}=0'.format( </em>hlist))
...         ax.fill_between(x, (-h[2]-h[0]*x)/h[1], ylim[sign], </strong>fmt)
x, y = zip( *hs.intersections)
ax.plot(x, y, 'o', markersize=8)</p>
</blockquote>
</blockquote>
</blockquote>
<p>By default, qhull does not provide with a way to compute an interior point.
This can easily be computed using linear programming. Considering halfspaces
of the form :math:<code>Ax + b \leq 0</code>, solving the linear program:</p>
<p>.. math::</p>
<p>max \: y</p>
<p>s.t. Ax + y ||A_i|| \leq -b</p>
<p>With :math:<code>A_i</code> being the rows of A, i.e. the normals to each plane.</p>
<p>Will yield a point x that is furthest inside the convex polyhedron. To
be precise, it is the center of the largest hypersphere of radius y
inscribed in the polyhedron. This point is called the Chebyshev center
of the polyhedron (see [1]_ 4.3.1, pp148-149). The
equations outputted by Qhull are always normalized.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.optimize import linprog
from matplotlib.patches import Circle
norm_vector = np.reshape(np.linalg.norm(halfspaces[:, :-1], axis=1),
...     (halfspaces.shape[0], 1))
c = np.zeros((halfspaces.shape[1],))
c[-1] = -1
A = np.hstack((halfspaces[:, :-1], norm_vector))
b = - halfspaces[:, -1:]
res = linprog(c, A_ub=A, b_ub=b)
x = res.x[:-1]
y = res.x[-1]
circle = Circle(x, radius=y, alpha=0.3)
ax.add_patch(circle)
plt.legend(bbox_to_anchor=(1.6, 1.0))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [Qhull] http://www.qhull.org/
.. [1] S. Boyd, L. Vandenberghe, Convex Optimization, available
at http://stanford.edu/~boyd/cvxbook/</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">add_halfspaces</span> <span class="o">:</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">halfspaces</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>add_halfspaces(halfspaces, restart=False)</p>
<p>Process a set of additional new halfspaces.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>halfspaces : ndarray
New halfspaces to add. The dimensionality should match that of the
initial halfspaces.
restart : bool, optional
Whether to restart processing from scratch, rather than
adding halfspaces incrementally.</p>
<h2 id="raises_5">Raises<a class="headerlink" href="#raises_5" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>close</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>You need to specify <code>incremental=True</code> when constructing the
object to be able to add halfspaces incrementally. Incremental addition
of halfspaces is also not possible after <code>close</code> has been called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>close()</p>
<p>Finish incremental processing.</p>
<p>Call this to free resources taken up by Qhull, when using the
incremental mode. After calling this, adding more points is no
longer possible.</p>
<p>Attribute halfspaces: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">halfspaces</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute halfspaces: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">halfspaces_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute interior_point: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">interior_point</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute interior_point: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">interior_point_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute intersections: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">intersections</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute intersections: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">intersections_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dual_points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_facets: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_facets</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dual_facets: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_facets_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dual_vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_equations: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_equations</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute dual_equations: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_equations_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_area: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_area</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute dual_area: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_area_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute dual_volume: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_volume</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute dual_volume: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dual_volume_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">KDTree</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">KDTree</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">KDTree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">leafsize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>kd-tree for quick nearest-neighbor lookup</p>
<p>This class provides an index into a set of k-dimensional points which
can be used to rapidly look up the nearest neighbors of any point.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>data : (N,K) array_like
The data points to be indexed. This array is not copied, and
so modifying this data will result in bogus results.
leafsize : int, optional
The number of points at which the algorithm switches over to
brute-force.  Has to be positive.</p>
<h2 id="raises_6">Raises<a class="headerlink" href="#raises_6" title="Permanent link">&para;</a></h2>
<p>RuntimeError
The maximum recursion limit can be exceeded for large data
sets.  If this happens, either increase the value for the <code>leafsize</code>
parameter or increase the recursion limit by::</p>
<blockquote>
<blockquote>
<blockquote>
<p>import sys
sys.setrecursionlimit(10000)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>cKDTree : Implementation of <code>KDTree</code> in Cython</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary tree, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.</p>
<p>During construction, the axis and splitting point are chosen by the
'sliding midpoint' rule, which ensures that the cells do not all
become long and thin.</p>
<p>The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.</p>
<p>For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.</p>
<p>The tree also supports all-neighbors queries, both with arrays of points
and with other kd-trees. These do use a reasonably efficient algorithm,
but the kd-tree is not necessarily the best data structure for this
sort of calculation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_neighbors</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Count how many nearby pairs can be formed.</p>
<p>Count the number of pairs (x1,x2) can be formed, with x1 drawn
from self and x2 drawn from <code>other</code>, and where
<code>distance(x1, x2, p) &lt;= r</code>.
This is the 'two-point correlation' described in Gray and Moore 2000,
'N-body problems in statistical learning', and the code here is based
on their algorithm.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>other : KDTree instance
The other tree to draw points from.
r : float or one-dimensional array of floats
The radius to produce a count for. Multiple radii are searched with
a single tree traversal.
p : float, 1&lt;=p&lt;=infinity, optional
Which Minkowski p-norm to use</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>result : int or 1-D array of ints
The number of pairs. Note that this is internally stored in a numpy
int, and so may overflow if very large (2e9).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distance_upper_bound</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Last_dimension_self_m</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Query the kd-tree for nearest neighbors</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>x : array_like, last dimension self.m
An array of points to query.
k : int, optional
The number of nearest neighbors to return.
eps : nonnegative float, optional
Return approximate nearest neighbors; the kth returned value
is guaranteed to be no further than (1+eps) times the
distance to the real kth nearest neighbor.
p : float, 1&lt;=p&lt;=infinity, optional
Which Minkowski p-norm to use.
1 is the sum-of-absolute-values 'Manhattan' distance
2 is the usual Euclidean distance
infinity is the maximum-coordinate-difference distance
distance_upper_bound : nonnegative float, optional
Return only neighbors within this distance. This is used to prune
tree searches, so if you are doing a series of nearest-neighbor
queries, it may help to supply the distance to the nearest neighbor
of the most recent point.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>d : float or array of floats
The distances to the nearest neighbors.
If x has shape tuple+(self.m,), then d has shape tuple if
k is one, or tuple+(k,) if k is larger than one. Missing
neighbors (e.g. when k &gt; n or distance_upper_bound is
given) are indicated with infinite distances.  If k is None,
then d is an object array of shape tuple, containing lists
of distances. In either case the hits are sorted by distance
(nearest first).
i : integer or array of integers
The locations of the neighbors in self.data. i is the same
shape as d.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import spatial
x, y = np.mgrid[0:5, 2:8]
tree = spatial.KDTree(list(zip(x.ravel(), y.ravel())))
tree.data
array([[0, 2],
[0, 3],
[0, 4],
[0, 5],
[0, 6],
[0, 7],
[1, 2],
[1, 3],
[1, 4],
[1, 5],
[1, 6],
[1, 7],
[2, 2],
[2, 3],
[2, 4],
[2, 5],
[2, 6],
[2, 7],
[3, 2],
[3, 3],
[3, 4],
[3, 5],
[3, 6],
[3, 7],
[4, 2],
[4, 3],
[4, 4],
[4, 5],
[4, 6],
[4, 7]])
pts = np.array([[0, 0], [2.1, 2.9]])
tree.query(pts)
(array([ 2.        ,  0.14142136]), array([ 0, 13]))
tree.query(pts[0])
(2.0, 0)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Shape_tuple_self_m_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find all points within distance r of point(s) x.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>x : array_like, shape tuple + (self.m,)
The point or points to search for neighbors of.
r : positive float
The radius of points to return.
p : float, optional
Which Minkowski p-norm to use.  Should be in the range [1, inf].
eps : nonnegative float, optional
Approximate search. Branches of the tree are not explored if their
nearest points are further than <code>r / (1 + eps)</code>, and branches are
added in bulk if their furthest points are nearer than
<code>r * (1 + eps)</code>.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>results : list or array of lists
If <code>x</code> is a single point, returns a list of the indices of the
neighbors of <code>x</code>. If <code>x</code> is an array of points, returns an object
array of shape tuple containing lists of neighbors.</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a KDTree and using
query_ball_tree.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import spatial
x, y = np.mgrid[0:5, 0:5]
points = np.c_[x.ravel(), y.ravel()]
tree = spatial.KDTree(points)
tree.query_ball_point([2, 0], 1)
[5, 10, 11, 15]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Query multiple points and plot the results:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
points = np.asarray(points)
plt.plot(points[:,0], points[:,1], '.')
for results in tree.query_ball_point(([2, 0], [3, 3]), 1):
...     nearby_points = points[results]
...     plt.plot(nearby_points[:,0], nearby_points[:,1], 'o')
plt.margins(0.1, 0.1)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find all pairs of points whose distance is at most r</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>other : KDTree instance
The tree containing points to search against.
r : float
The maximum distance, has to be positive.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>results : list of lists
For each element <code>self.data[i]</code> of this tree, <code>results[i]</code> is a
list of the indices of its neighbors in <code>other.data</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_pairs</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find all pairs of points within a distance.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>r : positive float
The maximum distance.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>results : set
Set of pairs <code>(i,j)</code>, with <code>i &lt; j</code>, for which the corresponding
positions are close.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sparse_distance_matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">max_distance</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute a sparse distance matrix</p>
<p>Computes a distance matrix between two KDTrees, leaving as zero
any distance greater than max_distance.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>other : KDTree</p>
<p>max_distance : positive float</p>
<p>p : float, optional</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>result : dok_matrix
Sparse matrix representing the results in 'dictionary of keys' format.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Rectangle</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rectangle</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">maxes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">mins</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Hyperrectangle class.</p>
<p>Represents a Cartesian product of intervals.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max_distance_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum distance between input and points in the hyperrectangle.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
p : float, optional
Input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">max_distance_rectangle</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the maximum distance between points in the two hyperrectangles.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>other : hyperrectangle
Input.
p : float, optional
Input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min_distance_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the minimum distance between input and points in the hyperrectangle.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input.
p : float, optional
Input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">min_distance_rectangle</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the minimum distance between points in the two hyperrectangles.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>other : hyperrectangle
Input.
p : float
Input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">split</span> <span class="o">:</span> <span class="n">d</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">split</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Produce two hyperrectangles by splitting.</p>
<p>In general, if you need to compute maximum and minimum
distances to the children, it can be done more efficiently
by updating the maximum and minimum distances to the parent.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>d : int
Axis to split hyperrectangle along.
split : float
Position along axis <code>d</code> to split at.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">volume</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Total volume.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">SphericalVoronoi</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">SphericalVoronoi</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">SphericalVoronoi</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">radius</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">center</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">threshold</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Voronoi diagrams on the surface of a sphere.</p>
<p>.. versionadded:: 0.18.0</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>points : ndarray of floats, shape (npoints, ndim)
Coordinates of points from which to construct a spherical
Voronoi diagram.
radius : float, optional
Radius of the sphere (Default: 1)
center : ndarray of floats, shape (ndim,)
Center of sphere (Default: origin)
threshold : float
Threshold for detecting duplicate points and
mismatches between points and sphere parameters.
(Default: 1e-06)</p>
<h2 id="attributes_3">Attributes<a class="headerlink" href="#attributes_3" title="Permanent link">&para;</a></h2>
<p>points : double array of shape (npoints, ndim)
the points in <code>ndim</code> dimensions to generate the Voronoi diagram from
radius : double
radius of the sphere
center : double array of shape (ndim,)
center of the sphere
vertices : double array of shape (nvertices, ndim)
Voronoi vertices corresponding to points
regions : list of list of integers of shape (npoints, _ )
the n-th entry is a list consisting of the indices
of the vertices belonging to the n-th point in points</p>
<h2 id="raises_7">Raises<a class="headerlink" href="#raises_7" title="Permanent link">&para;</a></h2>
<p>ValueError
If there are duplicates in <code>points</code>.
If the provided <code>radius</code> is not consistent with <code>points</code>.</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>The spherical Voronoi diagram algorithm proceeds as follows. The Convex
Hull of the input points (generators) is calculated, and is equivalent to
their Delaunay triangulation on the surface of the sphere [Caroli]_.
The Convex Hull neighbour information is then used to
order the Voronoi region vertices around each generator. The latter
approach is substantially less sensitive to floating point issues than
angle-based methods of Voronoi region vertex sorting.</p>
<p>Empirical assessment of spherical Voronoi algorithm performance suggests
quadratic time complexity (loglinear is optimal, but algorithms are more
challenging to implement).</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [Caroli] Caroli et al. Robust and Efficient Delaunay triangulations of
points on or close to a sphere. Research Report RR-7004, 2009.</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>Voronoi : Conventional Voronoi diagrams in N dimensions.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<p>Do some imports and take some points on a cube:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from matplotlib import colors
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import matplotlib.pyplot as plt
from scipy.spatial import SphericalVoronoi
from mpl_toolkits.mplot3d import proj3d</p>
<h1 id="set-input-data">set input data<a class="headerlink" href="#set-input-data" title="Permanent link">&para;</a></h1>
<p>points = np.array([[0, 0, 1], [0, 0, -1], [1, 0, 0],
...                    [0, 1, 0], [0, -1, 0], [-1, 0, 0], ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calculate the spherical Voronoi diagram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>radius = 1
center = np.array([0, 0, 0])
sv = SphericalVoronoi(points, radius, center)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Generate plot:</p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="sort-vertices-optional-helpful-for-plotting">sort vertices (optional, helpful for plotting)<a class="headerlink" href="#sort-vertices-optional-helpful-for-plotting" title="Permanent link">&para;</a></h1>
<p>sv.sort_vertices_of_regions()
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')</p>
<h1 id="plot-the-unit-sphere-for-reference-optional">plot the unit sphere for reference (optional)<a class="headerlink" href="#plot-the-unit-sphere-for-reference-optional" title="Permanent link">&para;</a></h1>
<p>u = np.linspace(0, 2 * np.pi, 100)
v = np.linspace(0, np.pi, 100)
x = np.outer(np.cos(u), np.sin(v))
y = np.outer(np.sin(u), np.sin(v))
z = np.outer(np.ones(np.size(u)), np.cos(v))
ax.plot_surface(x, y, z, color='y', alpha=0.1)</p>
<h1 id="plot-generator-points">plot generator points<a class="headerlink" href="#plot-generator-points" title="Permanent link">&para;</a></h1>
<p>ax.scatter(points[:, 0], points[:, 1], points[:, 2], c='b')</p>
<h1 id="plot-voronoi-vertices">plot Voronoi vertices<a class="headerlink" href="#plot-voronoi-vertices" title="Permanent link">&para;</a></h1>
<p>ax.scatter(sv.vertices[:, 0], sv.vertices[:, 1], sv.vertices[:, 2],
...                    c='g')</p>
<h1 id="indicate-voronoi-regions-as-euclidean-polygons">indicate Voronoi regions (as Euclidean polygons)<a class="headerlink" href="#indicate-voronoi-regions-as-euclidean-polygons" title="Permanent link">&para;</a></h1>
<p>for region in sv.regions:
...    random_color = colors.rgb2hex(np.random.rand(3))
...    polygon = Poly3DCollection([sv.vertices[region]], alpha=1.0)
...    polygon.set_color(random_color)
...    ax.add_collection3d(polygon)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sort_vertices_of_regions</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Sort indices of the vertices to be (counter-)clockwise ordered.</p>
<h2 id="raises_8">Raises<a class="headerlink" href="#raises_8" title="Permanent link">&para;</a></h2>
<p>TypeError
If the points are not three-dimensional.</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>For each region in regions, it sorts the indices of the Voronoi
vertices such that the resulting points are in a clockwise or
counterclockwise order around the generator point.</p>
<p>This is done as follows: Recall that the n-th region in regions
surrounds the n-th generator in points and that the k-th
Voronoi vertex in vertices is the circumcenter of the k-th triangle
in _tri.simplices.  For each region n, we choose the first triangle
(=Voronoi vertex) in _tri.simplices and a vertex of that triangle
not equal to the center n. These determine a unique neighbor of that
triangle, which is then chosen as the second triangle. The second
triangle will have a unique vertex not equal to the current vertex or
the center. This determines a unique neighbor of the second triangle,
which is then chosen as the third triangle and so forth. We proceed
through all the triangles (=Voronoi vertices) belonging to the
generator in points and obtain a sorted version of the vertices
of its surrounding region.</p>
<p>Attribute points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute radius: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">radius</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute radius: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">radius_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute center: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">center</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute center: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">center_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute regions: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">regions</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute regions: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">regions_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Voronoi</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Voronoi</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Voronoi</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">furthest_site</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">incremental</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">qhull_options</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)</p>
<p>Voronoi diagrams in N dimensions.</p>
<p>.. versionadded:: 0.12.0</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>points : ndarray of floats, shape (npoints, ndim)
Coordinates of points to construct a convex hull from
furthest_site : bool, optional
Whether to compute a furthest-site Voronoi diagram. Default: False
incremental : bool, optional
Allow adding new points incrementally. This takes up some additional
resources.
qhull_options : str, optional
Additional options to pass to Qhull. See Qhull manual
for details. (Default: 'Qbb Qc Qz Qx' for ndim &gt; 4 and
'Qbb Qc Qz' otherwise. Incremental mode omits 'Qz'.)</p>
<h2 id="attributes_4">Attributes<a class="headerlink" href="#attributes_4" title="Permanent link">&para;</a></h2>
<p>points : ndarray of double, shape (npoints, ndim)
Coordinates of input points.
vertices : ndarray of double, shape (nvertices, ndim)
Coordinates of the Voronoi vertices.
ridge_points : ndarray of ints, shape <code>(nridges, 2)</code>
Indices of the points between which each Voronoi ridge lies.
ridge_vertices : list of list of ints, shape <code>(nridges, * )</code>
Indices of the Voronoi vertices forming each Voronoi ridge.
regions : list of list of ints, shape <code>(nregions, * )</code>
Indices of the Voronoi vertices forming each Voronoi region.
-1 indicates vertex outside the Voronoi diagram.
point_region : list of ints, shape (npoints)
Index of the Voronoi region for each input point.
If qhull option 'Qc' was not specified, the list will contain -1
for points that are not associated with a Voronoi region.
furthest_site
True if this was a furthest site triangulation and False if not.</p>
<p>.. versionadded:: 1.4.0</p>
<h2 id="raises_9">Raises<a class="headerlink" href="#raises_9" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.
ValueError
Raised if an incompatible array is given as input.</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p>The Voronoi diagram is computed using the
<code>Qhull library &lt;http://www.qhull.org/&gt;</code>__.</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<p>Voronoi diagram for a set of point:</p>
<blockquote>
<blockquote>
<blockquote>
<p>points = np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2],
...                    [2, 0], [2, 1], [2, 2]])
from scipy.spatial import Voronoi, voronoi_plot_2d
vor = Voronoi(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
fig = voronoi_plot_2d(vor)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Voronoi vertices:</p>
<blockquote>
<blockquote>
<blockquote>
<p>vor.vertices
array([[0.5, 0.5],
[0.5, 1.5],
[1.5, 0.5],
[1.5, 1.5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>There is a single finite Voronoi region, and four finite Voronoi
ridges:</p>
<blockquote>
<blockquote>
<blockquote>
<p>vor.regions
[[], [-1, 0], [-1, 1], [1, -1, 0], [3, -1, 2], [-1, 3], [-1, 2], [0, 1, 3, 2], [2, -1, 0], [3, -1, 1]]
vor.ridge_vertices
[[-1, 0], [-1, 0], [-1, 1], [-1, 1], [0, 1], [-1, 3], [-1, 2], [2, 3], [-1, 3], [-1, 2], [1, 3], [0, 2]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>The ridges are perpendicular between lines drawn between the following
input points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>vor.ridge_points
array([[0, 3],
[0, 1],
[2, 5],
[2, 1],
[1, 4],
[7, 8],
[7, 6],
[7, 4],
[8, 5],
[6, 3],
[4, 5],
[4, 3]], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">add_points</span> <span class="o">:</span> <span class="o">?</span><span class="n">restart</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">points</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>add_points(points, restart=False)</p>
<p>Process a set of additional new points.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>points : ndarray
New points to add. The dimensionality should match that of the
initial points.
restart : bool, optional
Whether to restart processing from scratch, rather than
adding points incrementally.</p>
<h2 id="raises_10">Raises<a class="headerlink" href="#raises_10" title="Permanent link">&para;</a></h2>
<p>QhullError
Raised when Qhull encounters an error condition, such as
geometrical degeneracy when options to resolve are not enabled.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>close</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>You need to specify <code>incremental=True</code> when constructing the
object to be able to add points incrementally. Incremental addition
of points is also not possible after <code>close</code> has been called.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">close</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>close()</p>
<p>Finish incremental processing.</p>
<p>Call this to free resources taken up by Qhull, when using the
incremental mode. After calling this, adding more points is no
longer possible.</p>
<p>Attribute points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ridge_points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridge_points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute ridge_points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridge_points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute ridge_vertices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridge_vertices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute ridge_vertices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ridge_vertices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute regions: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">regions</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute regions: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">regions_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute point_region: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">point_region</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute point_region: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">point_region_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute furthest_site: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">furthest_site</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute furthest_site: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">furthest_site_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">CKDTree</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTree</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTree</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">leafsize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compact_nodes</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy_data</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">balanced_tree</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">boxsize</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
balanced_tree=True, boxsize=None)</p>
<p>kd-tree for quick nearest-neighbor lookup</p>
<p>This class provides an index into a set of k-dimensional points
which can be used to rapidly look up the nearest neighbors of any
point.</p>
<p>The algorithm used is described in Maneewongvatana and Mount 1999.
The general idea is that the kd-tree is a binary trie, each of whose
nodes represents an axis-aligned hyperrectangle. Each node specifies
an axis and splits the set of points based on whether their coordinate
along that axis is greater than or less than a particular value.</p>
<p>During construction, the axis and splitting point are chosen by the
'sliding midpoint' rule, which ensures that the cells do not all
become long and thin.</p>
<p>The tree can be queried for the r closest neighbors of any given point
(optionally returning only those within some maximum distance of the
point). It can also be queried, with a substantial gain in efficiency,
for the r approximate closest neighbors.</p>
<p>For large dimensions (20 is already large) do not expect this to run
significantly faster than brute force. High-dimensional nearest-neighbor
queries are a substantial open problem in computer science.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>data : array_like, shape (n,m)
The n data points of dimension m to be indexed. This array is
not copied unless this is necessary to produce a contiguous
array of doubles, and so modifying this data will result in
bogus results. The data are also copied if the kd-tree is built
with copy_data=True.
leafsize : positive int, optional
The number of points at which the algorithm switches over to
brute-force. Default: 16.
compact_nodes : bool, optional
If True, the kd-tree is built to shrink the hyperrectangles to
the actual data range. This usually gives a more compact tree that
is robust against degenerated input data and gives faster queries
at the expense of longer build time. Default: True.
copy_data : bool, optional
If True the data is always copied to protect the kd-tree against
data corruption. Default: False.
balanced_tree : bool, optional
If True, the median is used to split the hyperrectangles instead of
the midpoint. This usually gives a more compact tree and
faster queries at the expense of longer build time. Default: True.
boxsize : array_like or scalar, optional
Apply a m-d toroidal topology to the KDTree.. The topology is generated
by :math:<code>x_i + n_i L_i</code> where :math:<code>n_i</code> are integers and :math:<code>L_i</code>
is the boxsize along i-th dimension. The input data shall be wrapped
into :math:<code>[0, L_i)</code>. A ValueError is raised if any of the data is
outside of this bound.</p>
<h2 id="attributes_5">Attributes<a class="headerlink" href="#attributes_5" title="Permanent link">&para;</a></h2>
<p>data : ndarray, shape (n,m)
The n data points of dimension m to be indexed. This array is
not copied unless this is necessary to produce a contiguous
array of doubles. The data are also copied if the kd-tree is built
with <code>copy_data=True</code>.
leafsize : positive int
The number of points at which the algorithm switches over to
brute-force.
m : int
The dimension of a single data-point.
n : int
The number of data points.
maxes : ndarray, shape (m,)
The maximum value in each dimension of the n data points.
mins : ndarray, shape (m,)
The minimum value in each dimension of the n data points.
tree : object, class cKDTreeNode
This class exposes a Python view of the root node in the cKDTree object.
size : int
The number of nodes in the tree.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>KDTree : Implementation of <code>cKDTree</code> in pure Python</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count_neighbors</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">weights</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">cumulative</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>count_neighbors(self, other, r, p=2., weights=None, cumulative=True)</p>
<p>Count how many nearby pairs can be formed. (pair-counting)</p>
<p>Count the number of pairs (x1,x2) can be formed, with x1 drawn
from self and x2 drawn from <code>other</code>, and where
<code>distance(x1, x2, p) &lt;= r</code>.</p>
<p>Data points on self and other are optionally weighted by the <code>weights</code>
argument. (See below)</p>
<p>The algorithm we implement here is based on [1]_. See notes for further discussion.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>other : cKDTree instance
The other tree to draw points from, can be the same tree as self.
r : float or one-dimensional array of floats
The radius to produce a count for. Multiple radii are searched with
a single tree traversal.
If the count is non-cumulative(<code>cumulative=False</code>), <code>r</code> defines
the edges of the bins, and must be non-decreasing.
p : float, optional
1&lt;=p&lt;=infinity.
Which Minkowski p-norm to use.
Default 2.0.
A finite large p may cause a ValueError if overflow can occur.
weights : tuple, array_like, or None, optional
If None, the pair-counting is unweighted.
If given as a tuple, weights[0] is the weights of points in <code>self</code>, and
weights[1] is the weights of points in <code>other</code>; either can be None to
indicate the points are unweighted.
If given as an array_like, weights is the weights of points in <code>self</code>
and <code>other</code>. For this to make sense, <code>self</code> and <code>other</code> must be the
same tree. If <code>self</code> and <code>other</code> are two different trees, a <code>ValueError</code>
is raised.
Default: None
cumulative : bool, optional
Whether the returned counts are cumulative. When cumulative is set to <code>False</code>
the algorithm is optimized to work with a large number of bins (&gt;10) specified
by <code>r</code>. When <code>cumulative</code> is set to True, the algorithm is optimized to work
with a small number of <code>r</code>. Default: True</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>result : scalar or 1-D array
The number of pairs. For unweighted counts, the result is integer.
For weighted counts, the result is float.
If cumulative is False, <code>result[i]</code> contains the counts with
<code>(-inf if i == 0 else r[i-1]) &lt; R &lt;= r[i]</code></p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p>Pair-counting is the basic operation used to calculate the two point
correlation functions from a data set composed of position of objects.</p>
<p>Two point correlation function measures the clustering of objects and
is widely used in cosmology to quantify the large scale structure
in our Universe, but it may be useful for data analysis in other fields
where self-similar assembly of objects also occur.</p>
<p>The Landy-Szalay estimator for the two point correlation function of
<code>D</code> measures the clustering signal in <code>D</code>. [2]_</p>
<p>For example, given the position of two sets of objects,</p>
<ul>
<li>
<p>objects <code>D</code> (data) contains the clustering signal, and</p>
</li>
<li>
<p>objects <code>R</code> (random) that contains no signal,</p>
</li>
</ul>
<p>.. math::</p>
<p>\xi(r) = \frac{<D, D> - 2 f <D, R> + f^2<R, R>}{f^2<R, R>},</p>
<p>where the brackets represents counting pairs between two data sets
in a finite bin around <code>r</code> (distance), corresponding to setting
<code>cumulative=False</code>, and <code>f = float(len(D)) / float(len(R))</code> is the
ratio between number of objects from data and random.</p>
<p>The algorithm implemented here is loosely based on the dual-tree
algorithm described in [1]<em>. We switch between two different
pair-cumulation scheme depending on the setting of <code>cumulative</code>.
The computing time of the method we use when for
<code>cumulative == False</code> does not scale with the total number of bins.
The algorithm for <code>cumulative == True</code> scales linearly with the
number of bins, though it is slightly faster when only
1 or 2 bins are used. [5]</em>.</p>
<p>As an extension to the naive pair-counting,
weighted pair-counting counts the product of weights instead
of number of pairs.
Weighted pair-counting is used to estimate marked correlation functions
([3]<em>, section 2.2),
or to properly calculate the average of data per distance bin
(e.g. [4]</em>, section 2.1 on redshift).</p>
<p>.. [1] Gray and Moore,
'N-body problems in statistical learning',
Mining the sky, 2000,
https://arxiv.org/abs/astro-ph/0012333</p>
<p>.. [2] Landy and Szalay,
'Bias and variance of angular correlation functions',
The Astrophysical Journal, 1993,
http://adsabs.harvard.edu/abs/1993ApJ...412...64L</p>
<p>.. [3] Sheth, Connolly and Skibba,
'Marked correlations in galaxy formation models',
Arxiv e-print, 2005,
https://arxiv.org/abs/astro-ph/0511773</p>
<p>.. [4] Hawkins, et al.,
'The 2dF Galaxy Redshift Survey: correlation functions,
peculiar velocities and the matter density of the Universe',
Monthly Notices of the Royal Astronomical Society, 2002,
http://adsabs.harvard.edu/abs/2003MNRAS.346...78H</p>
<p>.. [5] https://github.com/scipy/scipy/pull/5647#issuecomment-168474926</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_point</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Shape_tuple_self_m_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_ball_point(self, x, r, p=2., eps=0)</p>
<p>Find all points within distance r of point(s) x.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>x : array_like, shape tuple + (self.m,)
The point or points to search for neighbors of.
r : array_like, float
The radius of points to return, shall broadcast to the length of x.
p : float, optional
Which Minkowski p-norm to use.  Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
eps : nonnegative float, optional
Approximate search. Branches of the tree are not explored if their
nearest points are further than <code>r / (1 + eps)</code>, and branches are
added in bulk if their furthest points are nearer than
<code>r * (1 + eps)</code>.
n_jobs : int, optional
Number of jobs to schedule for parallel processing. If -1 is given
all processors are used. Default: 1.
return_sorted : bool, optional
Sorts returned indicies if True and does not sort them if False. If
None, does not sort single point queries, but does sort
multi-point queries which was the behavior before this option
was added.</p>
<p>.. versionadded:: 1.2.0
return_length: bool, optional
Return the number of points inside the radius instead of a list
of the indices.
.. versionadded:: 1.3.0</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>results : list or array of lists
If <code>x</code> is a single point, returns a list of the indices of the
neighbors of <code>x</code>. If <code>x</code> is an array of points, returns an object
array of shape tuple containing lists of neighbors.</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p>If you have many points whose neighbors you want to find, you may save
substantial amounts of time by putting them in a cKDTree and using
query_ball_tree.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import spatial
x, y = np.mgrid[0:4, 0:4]
points = np.c_[x.ravel(), y.ravel()]
tree = spatial.cKDTree(points)
tree.query_ball_point([2, 0], 1)
[4, 8, 9, 12]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_ball_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_ball_tree(self, other, r, p=2., eps=0)</p>
<p>Find all pairs of points whose distance is at most r</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>other : cKDTree instance
The tree containing points to search against.
r : float
The maximum distance, has to be positive.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
A finite large p may cause a ValueError if overflow can occur.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>results : list of lists
For each element <code>self.data[i]</code> of this tree, <code>results[i]</code> is a
list of the indices of its neighbors in <code>other.data</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">query_pairs</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eps</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>query_pairs(self, r, p=2., eps=0)</p>
<p>Find all pairs of points whose distance is at most r.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>r : positive float
The maximum distance.
p : float, optional
Which Minkowski norm to use.  <code>p</code> has to meet the condition
<code>1 &lt;= p &lt;= infinity</code>.
A finite large p may cause a ValueError if overflow can occur.
eps : float, optional
Approximate search.  Branches of the tree are not explored
if their nearest points are further than <code>r/(1+eps)</code>, and
branches are added in bulk if their furthest points are nearer
than <code>r * (1+eps)</code>.  <code>eps</code> has to be non-negative.
output_type : string, optional
Choose the output container, 'set' or 'ndarray'. Default: 'set'</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>results : set or ndarray
Set of pairs <code>(i,j)</code>, with <code>i &lt; j</code>, for which the corresponding
positions are close. If output_type is 'ndarray', an ndarry is
returned instead of a set.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sparse_distance_matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">other</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">max_distance</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sparse_distance_matrix(self, other, max_distance, p=2.)</p>
<p>Compute a sparse distance matrix</p>
<p>Computes a distance matrix between two cKDTrees, leaving as zero
any distance greater than max_distance.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>other : cKDTree</p>
<p>max_distance : positive float</p>
<p>p : float, 1&lt;=p&lt;=infinity
Which Minkowski p-norm to use.
A finite large p may cause a ValueError if overflow can occur.</p>
<p>output_type : string, optional
Which container to use for output data. Options: 'dok_matrix',
'coo_matrix', 'dict', or 'ndarray'. Default: 'dok_matrix'.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>result : dok_matrix, coo_matrix, dict or ndarray
Sparse matrix representing the results in 'dictionary of keys'
format. If a dict is returned the keys are (i,j) tuples of indices.
If output_type is 'ndarray' a record array with fields 'i', 'j',
and 'v' is returned,</p>
<p>Attribute data: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute leafsize: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leafsize</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute leafsize: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leafsize_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute m: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">m</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute m: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">m_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute n: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute n: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">n_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute maxes: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxes</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute maxes: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxes_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute mins: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mins</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute mins: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mins_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute tree: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tree</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute tree: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tree_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute size: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">size</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute size: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">size_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Ckdtree</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">CKDTreeNode</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTreeNode</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">CKDTreeNode</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute level: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">level</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute level: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">level_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute split_dim: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">split_dim</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute split_dim: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">split_dim_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute split: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">split</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Attribute split: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">split_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute children: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">children</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Attribute children: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">children_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute data_points: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_points</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute data_points: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">data_points_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute indices: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute indices: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">indices_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute lesser: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lesser</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute lesser: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lesser_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Attribute greater: get value or raise Not_found if None.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">greater</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Attribute greater: get value as an option.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">greater_opt</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">option</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Coo_entries</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Coo_entries</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Coo_entries</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Ordered_pairs</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Ordered_pairs</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ordered_pairs</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">cpu_count</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the number of CPUs in the system</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Distance</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">MetricInfo</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MetricInfo</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">MetricInfo</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">types</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">validator</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">aka</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>MetricInfo(aka, types, validator)</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return number of occurrences of value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="o">?</span><span class="n">start</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stop</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return first index of value.</p>
<p>Raises ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Partial</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Partial</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Partial</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">keywords</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>partial(func, <em>args, </em>*keywords) - new function with partial application
of the given arguments and keywords.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">braycurtis</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Bray-Curtis distance between two 1-D arrays.</p>
<p>Bray-Curtis distance is defined as</p>
<p>.. math::</p>
<p>\sum{ |u_i-v_i| } / \sum{ |u_i+v_i| }</p>
<p>The Bray-Curtis distance is in the range [0, 1] if all coordinates are
positive, and is undefined if the inputs are of length zero.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>braycurtis : double
The Bray-Curtis distance between 1-D arrays <code>u</code> and <code>v</code>.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.braycurtis([1, 0, 0], [0, 1, 0])
1.0
distance.braycurtis([1, 1, 0], [0, 1, 0])
0.33333333333333331</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">canberra</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Canberra distance between two 1-D arrays.</p>
<p>The Canberra distance is defined as</p>
<p>.. math::</p>
<p>d(u,v) = \sum_i \frac{ |u_i-v_i| }
{ |u_i|+|v_i| }.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>canberra : double
The Canberra distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>When <code>u[i]</code> and <code>v[i]</code> are 0 for given i, then the fraction 0/0 = 0 is
used in the calculation.</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.canberra([1, 0, 0], [0, 1, 0])
2.0
distance.canberra([1, 1, 0], [0, 1, 0])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cdist</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">xa</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute distance between each pair of the two collections of inputs.</p>
<p>See Notes for common calling conventions.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>XA : ndarray
An :math:<code>m_A</code> by :math:<code>n</code> array of :math:<code>m_A</code>
original observations in an :math:<code>n</code>-dimensional space.
Inputs are converted to float type.
XB : ndarray
An :math:<code>m_B</code> by :math:<code>n</code> array of :math:<code>m_B</code>
original observations in an :math:<code>n</code>-dimensional space.
Inputs are converted to float type.
metric : str or callable, optional
The distance metric to use.  If a string, the distance function can be
'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
'wminkowski', 'yule'.
<em>args : tuple. Deprecated.
Additional arguments should be passed as keyword arguments
</em>*kwargs : dict, optional
Extra arguments to <code>metric</code>: refer to each metric documentation for a
list of all possible arguments.</p>
<p>Some possible arguments:</p>
<p>p : scalar
The p-norm to apply for Minkowski, weighted and unweighted.
Default: 2.</p>
<p>w : ndarray
The weight vector for metrics that support weights (e.g., Minkowski).</p>
<p>V : ndarray
The variance vector for standardized Euclidean.
Default: var(vstack([XA, XB]), axis=0, ddof=1)</p>
<p>VI : ndarray
The inverse of the covariance matrix for Mahalanobis.
Default: inv(cov(vstack([XA, XB].T))).T</p>
<p>out : ndarray
The output array
If not None, the distance matrix Y is stored in this array.
Note: metric independent, it will become a regular keyword arg in a
future scipy version</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
A :math:<code>m_A</code> by :math:<code>m_B</code> distance matrix is returned.
For each :math:<code>i</code> and :math:<code>j</code>, the metric
<code>dist(u=XA[i], v=XB[j])</code> is computed and stored in the
:math:<code>ij</code> th entry.</p>
<h2 id="raises_11">Raises<a class="headerlink" href="#raises_11" title="Permanent link">&para;</a></h2>
<p>ValueError
An exception is thrown if <code>XA</code> and <code>XB</code> do not have
the same number of columns.</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>The following are common calling conventions:</p>
<ol>
<li><code>Y = cdist(XA, XB, 'euclidean')</code></li>
</ol>
<p>Computes the distance between :math:<code>m</code> points using
Euclidean distance (2-norm) as the distance metric between the
points. The points are arranged as :math:<code>m</code>
:math:<code>n</code>-dimensional row vectors in the matrix X.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'minkowski', p=2.)</code></li>
</ol>
<p>Computes the distances using the Minkowski distance
:math:<code>||u-v||_p</code> (:math:<code>p</code>-norm) where :math:<code>p \geq 1</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'cityblock')</code></li>
</ol>
<p>Computes the city block or Manhattan distance between the
points.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'seuclidean', V=None)</code></li>
</ol>
<p>Computes the standardized Euclidean distance. The standardized
Euclidean distance between two n-vectors <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>\sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}.</p>
<p>V is the variance vector; V[i] is the variance computed over all
the i'th components of the points. If not passed, it is
automatically computed.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sqeuclidean')</code></li>
</ol>
<p>Computes the squared Euclidean distance :math:<code>||u-v||_2^2</code> between
the vectors.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'cosine')</code></li>
</ol>
<p>Computes the cosine distance between vectors u and v,</p>
<p>.. math::</p>
<p>1 - \frac{u \cdot v}
{{ ||u|| }_2 { ||v|| }_2}</p>
<p>where :math:<code>||*||_2</code> is the 2-norm of its argument <code>*</code>, and
:math:<code>u \cdot v</code> is the dot product of :math:<code>u</code> and :math:<code>v</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'correlation')</code></li>
</ol>
<p>Computes the correlation distance between vectors u and v. This is</p>
<p>.. math::</p>
<p>1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
{{ ||(u - \bar{u})|| }_2 { ||(v - \bar{v})|| }_2}</p>
<p>where :math:<code>\bar{v}</code> is the mean of the elements of vector v,
and :math:<code>x \cdot y</code> is the dot product of :math:<code>x</code> and :math:<code>y</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'hamming')</code></li>
</ol>
<p>Computes the normalized Hamming distance, or the proportion of
those vector elements between two n-vectors <code>u</code> and <code>v</code>
which disagree. To save memory, the matrix <code>X</code> can be of type
boolean.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'jaccard')</code></li>
</ol>
<p>Computes the Jaccard distance between the points. Given two
vectors, <code>u</code> and <code>v</code>, the Jaccard distance is the
proportion of those elements <code>u[i]</code> and <code>v[i]</code> that
disagree where at least one of them is non-zero.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'chebyshev')</code></li>
</ol>
<p>Computes the Chebyshev distance between the points. The
Chebyshev distance between two n-vectors <code>u</code> and <code>v</code> is the
maximum norm-1 distance between their respective elements. More
precisely, the distance is given by</p>
<p>.. math::</p>
<p>d(u,v) = \max_i { |u_i-v_i| }.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'canberra')</code></li>
</ol>
<p>Computes the Canberra distance between the points. The
Canberra distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \sum_i \frac{ |u_i-v_i| }
{ |u_i|+|v_i| }.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'braycurtis')</code></li>
</ol>
<p>Computes the Bray-Curtis distance between the points. The
Bray-Curtis distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \frac{\sum_i (|u_i-v_i|)}
{\sum_i (|u_i+v_i|)}</p>
<ol>
<li><code>Y = cdist(XA, XB, 'mahalanobis', VI=None)</code></li>
</ol>
<p>Computes the Mahalanobis distance between the points. The
Mahalanobis distance between two points <code>u</code> and <code>v</code> is
:math:<code>\sqrt{(u-v)(1/V)(u-v)^T}</code> where :math:<code>(1/V)</code> (the <code>VI</code>
variable) is the inverse covariance. If <code>VI</code> is not None,
<code>VI</code> will be used as the inverse covariance matrix.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'yule')</code></li>
</ol>
<p>Computes the Yule distance between the boolean
vectors. (see <code>yule</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'matching')</code></li>
</ol>
<p>Synonym for 'hamming'.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'dice')</code></li>
</ol>
<p>Computes the Dice distance between the boolean vectors. (see
<code>dice</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'kulsinski')</code></li>
</ol>
<p>Computes the Kulsinski distance between the boolean
vectors. (see <code>kulsinski</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'rogerstanimoto')</code></li>
</ol>
<p>Computes the Rogers-Tanimoto distance between the boolean
vectors. (see <code>rogerstanimoto</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'russellrao')</code></li>
</ol>
<p>Computes the Russell-Rao distance between the boolean
vectors. (see <code>russellrao</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sokalmichener')</code></li>
</ol>
<p>Computes the Sokal-Michener distance between the boolean
vectors. (see <code>sokalmichener</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sokalsneath')</code></li>
</ol>
<p>Computes the Sokal-Sneath distance between the vectors. (see
<code>sokalsneath</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'wminkowski', p=2., w=w)</code></li>
</ol>
<p>Computes the weighted Minkowski distance between the
vectors. (see <code>wminkowski</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, f)</code></li>
</ol>
<p>Computes the distance between all pairs of vectors in X
using the user supplied 2-arity function f. For example,
Euclidean distance between the vectors could be computed
as follows::</p>
<p>dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</p>
<p>Note that you should avoid passing a reference to one of
the distance functions defined in this library. For example,::</p>
<p>dm = cdist(XA, XB, sokalsneath)</p>
<p>would calculate the pair-wise distances between the vectors in
X using the Python function <code>sokalsneath</code>. This would result in
sokalsneath being called :math:<code>{n \choose 2}</code> times, which
is inefficient. Instead, the optimized C version is more
efficient, and we call it using the following syntax::</p>
<p>dm = cdist(XA, XB, 'sokalsneath')</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<p>Find the Euclidean distances between four 2-D coordinates:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
coords = [(35.0456, -85.2672),
...           (35.1174, -89.9711),
...           (35.9728, -83.9422),
...           (36.1667, -86.7833)]
distance.cdist(coords, coords, 'euclidean')
array([[ 0.    ,  4.7044,  1.6172,  1.8856],
[ 4.7044,  0.    ,  6.0893,  3.3561],
[ 1.6172,  6.0893,  0.    ,  2.8477],
[ 1.8856,  3.3561,  2.8477,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the Manhattan distance from a 3-D point to the corners of the unit
cube:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[0, 0, 0],
...               [0, 0, 1],
...               [0, 1, 0],
...               [0, 1, 1],
...               [1, 0, 0],
...               [1, 0, 1],
...               [1, 1, 0],
...               [1, 1, 1]])
b = np.array([[ 0.1,  0.2,  0.4]])
distance.cdist(a, b, 'cityblock')
array([[ 0.7],
[ 0.9],
[ 1.3],
[ 1.5],
[ 1.5],
[ 1.7],
[ 2.1],
[ 2.3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">chebyshev</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Chebyshev distance.</p>
<p>Computes the Chebyshev distance between two 1-D arrays <code>u</code> and <code>v</code>,
which is defined as</p>
<p>.. math::</p>
<p>\max_i { |u_i-v_i| }.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input vector.
v : (N,) array_like
Input vector.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>chebyshev : double
The Chebyshev distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.chebyshev([1, 0, 0], [0, 1, 0])
1
distance.chebyshev([1, 1, 0], [0, 1, 0])
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cityblock</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the City Block (Manhattan) distance.</p>
<p>Computes the Manhattan distance between two 1-D arrays <code>u</code> and <code>v</code>,
which is defined as</p>
<p>.. math::</p>
<p>\sum_i {\left| u_i - v_i \right| }.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>cityblock : double
The City Block (Manhattan) distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.cityblock([1, 0, 0], [0, 1, 0])
2
distance.cityblock([1, 0, 0], [0, 2, 0])
3
distance.cityblock([1, 0, 0], [1, 1, 0])
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correlation</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">centered</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the correlation distance between two 1-D arrays.</p>
<p>The correlation distance between <code>u</code> and <code>v</code>, is
defined as</p>
<p>.. math::</p>
<p>1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
{{ ||(u - \bar{u})|| }_2 { ||(v - \bar{v})|| }_2}</p>
<p>where :math:<code>\bar{u}</code> is the mean of the elements of <code>u</code>
and :math:<code>x \cdot y</code> is the dot product of :math:<code>x</code> and :math:<code>y</code>.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>correlation : double
The correlation distance between 1-D array <code>u</code> and <code>v</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosine</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Cosine distance between 1-D arrays.</p>
<p>The Cosine distance between <code>u</code> and <code>v</code>, is defined as</p>
<p>.. math::</p>
<p>1 - \frac{u \cdot v}
{ ||u||_2 ||v||_2}.</p>
<p>where :math:<code>u \cdot v</code> is the dot product of :math:<code>u</code> and
:math:<code>v</code>.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>cosine : double
The Cosine distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.cosine([1, 0, 0], [0, 1, 0])
1.0
distance.cosine([100, 0, 0], [0, 1, 0])
1.0
distance.cosine([1, 1, 0], [0, 1, 0])
0.29289321881345254</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dice</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Dice dissimilarity between two boolean 1-D arrays.</p>
<p>The Dice dissimilarity between <code>u</code> and <code>v</code>, is</p>
<p>.. math::</p>
<p>\frac{c_{TF} + c_{FT}}
{2c_{TT} + c_{FT} + c_{TF}}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>u : (N,) ndarray, bool
Input 1-D array.
v : (N,) ndarray, bool
Input 1-D array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>dice : double
The Dice dissimilarity between 1-D arrays <code>u</code> and <code>v</code>.</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.dice([1, 0, 0], [0, 1, 0])
1.0
distance.dice([1, 0, 0], [1, 1, 0])
0.3333333333333333
distance.dice([1, 0, 0], [2, 0, 0])
-0.3333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">directed_hausdorff</span> <span class="o">:</span> <span class="o">?</span><span class="n">seed</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">float</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the directed Hausdorff distance between two N-D arrays.</p>
<p>Distances between pairs are calculated using a Euclidean metric.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>u : (M,N) ndarray
Input array.
v : (O,N) ndarray
Input array.
seed : int or None
Local <code>numpy.random.mtrand.RandomState</code> seed. Default is 0, a random
shuffling of u and v that guarantees reproducibility.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>d : double
The directed Hausdorff distance between arrays <code>u</code> and <code>v</code>,</p>
<p>index_1 : int
index of point contributing to Hausdorff pair in <code>u</code></p>
<p>index_2 : int
index of point contributing to Hausdorff pair in <code>v</code></p>
<h2 id="raises_12">Raises<a class="headerlink" href="#raises_12" title="Permanent link">&para;</a></h2>
<p>ValueError
An exception is thrown if <code>u</code> and <code>v</code> do not have
the same number of columns.</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>Uses the early break technique and the random sampling approach
described by [1]_. Although worst-case performance is <code>O(m * o)</code>
(as with the brute force algorithm), this is unlikely in practice
as the input data would have to require the algorithm to explore
every single point interaction, and after the algorithm shuffles
the input points at that. The best case performance is O(m), which
is satisfied by selecting an inner loop distance that is less than
cmax and leads to an early break as often as possible. The authors
have formally shown that the average runtime is closer to O(m).</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>.. [1] A. A. Taha and A. Hanbury, 'An efficient algorithm for
calculating the exact Hausdorff distance.' IEEE Transactions On
Pattern Analysis And Machine Intelligence, vol. 37 pp. 2153-63,
2015.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>scipy.spatial.procrustes : Another similarity test for two data sets</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<p>Find the directed Hausdorff distance between two 2-D arrays of
coordinates:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.distance import directed_hausdorff
u = np.array([(1.0, 0.0),
...               (0.0, 1.0),
...               (-1.0, 0.0),
...               (0.0, -1.0)])
v = np.array([(2.0, 0.0),
...               (0.0, 2.0),
...               (-2.0, 0.0),
...               (0.0, -4.0)])</p>
<p>directed_hausdorff(u, v)[0]
2.23606797749979
directed_hausdorff(v, u)[0]
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the general (symmetric) Hausdorff distance between two 2-D
arrays of coordinates:</p>
<blockquote>
<blockquote>
<blockquote>
<p>max(directed_hausdorff(u, v)[0], directed_hausdorff(v, u)[0])
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the indices of the points that generate the Hausdorff distance
(the Hausdorff pair):</p>
<blockquote>
<blockquote>
<blockquote>
<p>directed_hausdorff(v, u)[1:]
(3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">euclidean</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Computes the Euclidean distance between two 1-D arrays.</p>
<p>The Euclidean distance between 1-D arrays <code>u</code> and <code>v</code>, is defined as</p>
<p>.. math::</p>
<p>{ ||u-v|| }_2</p>
<p>\left(\sum{(w_i |(u_i - v_i)|^2)}\right)^{1/2}</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>euclidean : double
The Euclidean distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.euclidean([1, 0, 0], [0, 1, 0])
1.4142135623730951
distance.euclidean([1, 1, 0], [0, 1, 0])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hamming</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Hamming distance between two 1-D arrays.</p>
<p>The Hamming distance between 1-D arrays <code>u</code> and <code>v</code>, is simply the
proportion of disagreeing components in <code>u</code> and <code>v</code>. If <code>u</code> and <code>v</code> are
boolean vectors, the Hamming distance is</p>
<p>.. math::</p>
<p>\frac{c_{01} + c_{10}}{n}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>hamming : double
The Hamming distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.hamming([1, 0, 0], [0, 1, 0])
0.66666666666666663
distance.hamming([1, 0, 0], [1, 1, 0])
0.33333333333333331
distance.hamming([1, 0, 0], [2, 0, 0])
0.33333333333333331
distance.hamming([1, 0, 0], [3, 0, 0])
0.33333333333333331</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_valid_dm</span> <span class="o">:</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">throw</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">warning</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Return True if input array is a valid distance matrix.</p>
<p>Distance matrices must be 2-dimensional numpy arrays.
They must have a zero-diagonal, and they must be symmetric.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>D : ndarray
The candidate object to test for validity.
tol : float, optional
The distance matrix should be symmetric. <code>tol</code> is the maximum
difference between entries <code>ij</code> and <code>ji</code> for the distance
metric to be considered symmetric.
throw : bool, optional
An exception is thrown if the distance matrix passed is not valid.
name : str, optional
The name of the variable to checked. This is useful if
throw is set to True so the offending variable can be identified
in the exception message when an exception is thrown.
warning : bool, optional
Instead of throwing an exception, a warning message is
raised.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>valid : bool
True if the variable <code>D</code> passed is a valid distance matrix.</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>Small numerical differences in <code>D</code> and <code>D.T</code> and non-zeroness of
the diagonal are ignored if they are within the tolerance specified
by <code>tol</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_valid_y</span> <span class="o">:</span> <span class="o">?</span><span class="n">warning</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">throw</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">name</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return True if the input array is a valid condensed distance matrix.</p>
<p>Condensed distance matrices must be 1-dimensional numpy arrays.
Their length must be a binomial coefficient :math:<code>{n \choose 2}</code>
for some positive integer n.</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The condensed distance matrix.
warning : bool, optional
Invokes a warning if the variable passed is not a valid
condensed distance matrix. The warning message explains why
the distance matrix is not valid.  <code>name</code> is used when
referencing the offending variable.
throw : bool, optional
Throws an exception if the variable passed is not a valid
condensed distance matrix.
name : bool, optional
Used when referencing the offending variable in the
warning or exception message.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jaccard</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Jaccard-Needham dissimilarity between two boolean 1-D arrays.</p>
<p>The Jaccard-Needham dissimilarity between 1-D boolean arrays <code>u</code> and <code>v</code>,
is defined as</p>
<p>.. math::</p>
<p>\frac{c_{TF} + c_{FT}}
{c_{TT} + c_{FT} + c_{TF}}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>jaccard : double
The Jaccard distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p>When both <code>u</code> and <code>v</code> lead to a <code>0/0</code> division i.e. there is no overlap
between the items in the vectors the returned distance is 0. See the
Wikipedia page on the Jaccard index [1]<em>, and this paper [2]</em>.</p>
<p>.. versionchanged:: 1.2.0
Previously, when <code>u</code> and <code>v</code> lead to a <code>0/0</code> division, the function
would return NaN. This was changed to return 0 instead.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Jaccard_index
.. [2] S. Kosub, 'A note on the triangle inequality for the Jaccard
distance', 2016, Available online: https://arxiv.org/pdf/1612.02696.pdf</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.jaccard([1, 0, 0], [0, 1, 0])
1.0
distance.jaccard([1, 0, 0], [1, 1, 0])
0.5
distance.jaccard([1, 0, 0], [1, 2, 0])
0.5
distance.jaccard([1, 0, 0], [1, 1, 1])
0.66666666666666663</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">jensenshannon</span> <span class="o">:</span> <span class="o">?</span><span class="n">base</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Jensen-Shannon distance (metric) between
two 1-D probability arrays. This is the square root
of the Jensen-Shannon divergence.</p>
<p>The Jensen-Shannon distance between two probability
vectors <code>p</code> and <code>q</code> is defined as,</p>
<p>.. math::</p>
<p>\sqrt{\frac{D(p \parallel m) + D(q \parallel m)}{2}}</p>
<p>where :math:<code>m</code> is the pointwise mean of :math:<code>p</code> and :math:<code>q</code>
and :math:<code>D</code> is the Kullback-Leibler divergence.</p>
<p>This routine will normalize <code>p</code> and <code>q</code> if they don't sum to 1.0.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>p : (N,) array_like
left probability vector
q : (N,) array_like
right probability vector
base : double, optional
the base of the logarithm used to compute the output
if not given, then the routine uses the default base of
scipy.stats.entropy.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>js : double
The Jensen-Shannon distance between <code>p</code> and <code>q</code></p>
<p>.. versionadded:: 1.2.0</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.jensenshannon([1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2.0)
1.0
distance.jensenshannon([1.0, 0.0], [0.5, 0.5])
0.46450140402245893
distance.jensenshannon([1.0, 0.0, 0.0], [1.0, 0.0, 0.0])
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kulsinski</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Kulsinski dissimilarity between two boolean 1-D arrays.</p>
<p>The Kulsinski dissimilarity between two boolean 1-D arrays <code>u</code> and <code>v</code>,
is defined as</p>
<p>.. math::</p>
<p>\frac{c_{TF} + c_{FT} - c_{TT} + n}
{c_{FT} + c_{TF} + n}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>kulsinski : double
The Kulsinski distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.kulsinski([1, 0, 0], [0, 1, 0])
1.0
distance.kulsinski([1, 0, 0], [1, 1, 0])
0.75
distance.kulsinski([1, 0, 0], [2, 1, 0])
0.33333333333333331
distance.kulsinski([1, 0, 0], [3, 1, 0])
-0.5</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mahalanobis</span> <span class="o">:</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">vi</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Mahalanobis distance between two 1-D arrays.</p>
<p>The Mahalanobis distance between 1-D arrays <code>u</code> and <code>v</code>, is defined as</p>
<p>.. math::</p>
<p>\sqrt{ (u-v) V^{-1} (u-v)^T }</p>
<p>where <code>V</code> is the covariance matrix.  Note that the argument <code>VI</code>
is the inverse of <code>V</code>.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
VI : ndarray
The inverse of the covariance matrix.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>mahalanobis : double
The Mahalanobis distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
iv = [[1, 0.5, 0.5], [0.5, 1, 0.5], [0.5, 0.5, 1]]
distance.mahalanobis([1, 0, 0], [0, 1, 0], iv)
1.0
distance.mahalanobis([0, 2, 0], [0, 1, 0], iv)
1.0
distance.mahalanobis([2, 0, 0], [0, 1, 0], iv)
1.7320508075688772</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matching</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>matching</code> is deprecated!
spatial.distance.matching is deprecated in scipy 1.0.0; use spatial.distance.hamming instead.</p>
<p>Compute the Hamming distance between two boolean 1-D arrays.</p>
<p>This is a deprecated synonym for :func:<code>hamming</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minkowski</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Minkowski distance between two 1-D arrays.</p>
<p>The Minkowski distance between 1-D arrays <code>u</code> and <code>v</code>,
is defined as</p>
<p>.. math::</p>
<p>{ ||u-v|| }_p = (\sum{ |u_i - v_i|^p})^{1/p}.</p>
<p>\left(\sum{w_i(|(u_i - v_i)|^p)}\right)^{1/p}.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
p : int
The order of the norm of the difference :math:<code>{ ||u-v|| }_p</code>.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>minkowski : double
The Minkowski distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.minkowski([1, 0, 0], [0, 1, 0], 1)
2.0
distance.minkowski([1, 0, 0], [0, 1, 0], 2)
1.4142135623730951
distance.minkowski([1, 0, 0], [0, 1, 0], 3)
1.2599210498948732
distance.minkowski([1, 1, 0], [0, 1, 0], 1)
1.0
distance.minkowski([1, 1, 0], [0, 1, 0], 2)
1.0
distance.minkowski([1, 1, 0], [0, 1, 0], 3)
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">namedtuple</span> <span class="o">:</span> <span class="o">?</span><span class="n">rename</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">defaults</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">module_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">typename</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">field_names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a new subclass of tuple with named fields.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Point = namedtuple('Point', ['x', 'y'])
Point.<strong>doc</strong>                   # docstring for the new class
'Point(x, y)'
p = Point(11, y=22)             # instantiate with positional args or keywords
p[0] + p[1]                     # indexable like a plain tuple
33
x, y = p                        # unpack like a regular tuple
x, y
(11, 22)
p.x + p.y                       # fields also accessible by name
33
d = p._asdict()                 # convert to a dictionary
d['x']
11
Point( **d)                      # convert from a dictionary
Point(x=11, y=22)
p._replace(x=100)               # _replace() is like str.replace() but targets named fields
Point(x=100, y=22)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">num_obs_dm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Return the number of original observations that correspond to a
square, redundant distance matrix.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>d : ndarray
The target distance matrix.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>num_obs_dm : int
The number of observations in the redundant distance matrix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">num_obs_y</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Return the number of original observations that correspond to a
condensed distance matrix.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Condensed distance matrix.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>n : int
The number of observations in the condensed distance matrix <code>Y</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pdist</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Pairwise distances between observations in n-dimensional space.</p>
<p>See Notes for common calling conventions.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>X : ndarray
An m by n array of m original observations in an
n-dimensional space.
metric : str or function, optional
The distance metric to use. The distance function can
be 'braycurtis', 'canberra', 'chebyshev', 'cityblock',
'correlation', 'cosine', 'dice', 'euclidean', 'hamming',
'jaccard', 'jensenshannon', 'kulsinski', 'mahalanobis', 'matching',
'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'.
<em>args : tuple. Deprecated.
Additional arguments should be passed as keyword arguments
</em>*kwargs : dict, optional
Extra arguments to <code>metric</code>: refer to each metric documentation for a
list of all possible arguments.</p>
<p>Some possible arguments:</p>
<p>p : scalar
The p-norm to apply for Minkowski, weighted and unweighted.
Default: 2.</p>
<p>w : ndarray
The weight vector for metrics that support weights (e.g., Minkowski).</p>
<p>V : ndarray
The variance vector for standardized Euclidean.
Default: var(X, axis=0, ddof=1)</p>
<p>VI : ndarray
The inverse of the covariance matrix for Mahalanobis.
Default: inv(cov(X.T)).T</p>
<p>out : ndarray.
The output array
If not None, condensed distance matrix Y is stored in this array.
Note: metric independent, it will become a regular keyword arg in a
future scipy version</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
Returns a condensed distance matrix Y.  For
each :math:<code>i</code> and :math:<code>j</code> (where :math:<code>i&lt;j&lt;m</code>),where m is the number
of original observations. The metric <code>dist(u=X[i], v=X[j])</code>
is computed and stored in entry <code>ij</code>.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>squareform : converts between condensed distance matrices and
square distance matrices.</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>See <code>squareform</code> for information on how to calculate the index of
this entry or to convert the condensed distance matrix to a
redundant square matrix.</p>
<p>The following are common calling conventions.</p>
<ol>
<li><code>Y = pdist(X, 'euclidean')</code></li>
</ol>
<p>Computes the distance between m points using Euclidean distance
(2-norm) as the distance metric between the points. The points
are arranged as m n-dimensional row vectors in the matrix X.</p>
<ol>
<li><code>Y = pdist(X, 'minkowski', p=2.)</code></li>
</ol>
<p>Computes the distances using the Minkowski distance
:math:<code>||u-v||_p</code> (p-norm) where :math:<code>p \geq 1</code>.</p>
<ol>
<li><code>Y = pdist(X, 'cityblock')</code></li>
</ol>
<p>Computes the city block or Manhattan distance between the
points.</p>
<ol>
<li><code>Y = pdist(X, 'seuclidean', V=None)</code></li>
</ol>
<p>Computes the standardized Euclidean distance. The standardized
Euclidean distance between two n-vectors <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>\sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}</p>
<p>V is the variance vector; V[i] is the variance computed over all
the i'th components of the points.  If not passed, it is
automatically computed.</p>
<ol>
<li><code>Y = pdist(X, 'sqeuclidean')</code></li>
</ol>
<p>Computes the squared Euclidean distance :math:<code>||u-v||_2^2</code> between
the vectors.</p>
<ol>
<li><code>Y = pdist(X, 'cosine')</code></li>
</ol>
<p>Computes the cosine distance between vectors u and v,</p>
<p>.. math::</p>
<p>1 - \frac{u \cdot v}
{{ ||u|| }_2 { ||v|| }_2}</p>
<p>where :math:<code>||*||_2</code> is the 2-norm of its argument <code>*</code>, and
:math:<code>u \cdot v</code> is the dot product of <code>u</code> and <code>v</code>.</p>
<ol>
<li><code>Y = pdist(X, 'correlation')</code></li>
</ol>
<p>Computes the correlation distance between vectors u and v. This is</p>
<p>.. math::</p>
<p>1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
{{ ||(u - \bar{u})|| }_2 { ||(v - \bar{v})|| }_2}</p>
<p>where :math:<code>\bar{v}</code> is the mean of the elements of vector v,
and :math:<code>x \cdot y</code> is the dot product of :math:<code>x</code> and :math:<code>y</code>.</p>
<ol>
<li><code>Y = pdist(X, 'hamming')</code></li>
</ol>
<p>Computes the normalized Hamming distance, or the proportion of
those vector elements between two n-vectors <code>u</code> and <code>v</code>
which disagree. To save memory, the matrix <code>X</code> can be of type
boolean.</p>
<ol>
<li><code>Y = pdist(X, 'jaccard')</code></li>
</ol>
<p>Computes the Jaccard distance between the points. Given two
vectors, <code>u</code> and <code>v</code>, the Jaccard distance is the
proportion of those elements <code>u[i]</code> and <code>v[i]</code> that
disagree.</p>
<ol>
<li><code>Y = pdist(X, 'chebyshev')</code></li>
</ol>
<p>Computes the Chebyshev distance between the points. The
Chebyshev distance between two n-vectors <code>u</code> and <code>v</code> is the
maximum norm-1 distance between their respective elements. More
precisely, the distance is given by</p>
<p>.. math::</p>
<p>d(u,v) = \max_i { |u_i-v_i| }</p>
<ol>
<li><code>Y = pdist(X, 'canberra')</code></li>
</ol>
<p>Computes the Canberra distance between the points. The
Canberra distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \sum_i \frac{ |u_i-v_i| }
{ |u_i|+|v_i| }</p>
<ol>
<li><code>Y = pdist(X, 'braycurtis')</code></li>
</ol>
<p>Computes the Bray-Curtis distance between the points. The
Bray-Curtis distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \frac{\sum_i { |u_i-v_i| }}
{\sum_i { |u_i+v_i| }}</p>
<ol>
<li><code>Y = pdist(X, 'mahalanobis', VI=None)</code></li>
</ol>
<p>Computes the Mahalanobis distance between the points. The
Mahalanobis distance between two points <code>u</code> and <code>v</code> is
:math:<code>\sqrt{(u-v)(1/V)(u-v)^T}</code> where :math:<code>(1/V)</code> (the <code>VI</code>
variable) is the inverse covariance. If <code>VI</code> is not None,
<code>VI</code> will be used as the inverse covariance matrix.</p>
<ol>
<li><code>Y = pdist(X, 'yule')</code></li>
</ol>
<p>Computes the Yule distance between each pair of boolean
vectors. (see yule function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'matching')</code></li>
</ol>
<p>Synonym for 'hamming'.</p>
<ol>
<li><code>Y = pdist(X, 'dice')</code></li>
</ol>
<p>Computes the Dice distance between each pair of boolean
vectors. (see dice function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'kulsinski')</code></li>
</ol>
<p>Computes the Kulsinski distance between each pair of
boolean vectors. (see kulsinski function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'rogerstanimoto')</code></li>
</ol>
<p>Computes the Rogers-Tanimoto distance between each pair of
boolean vectors. (see rogerstanimoto function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'russellrao')</code></li>
</ol>
<p>Computes the Russell-Rao distance between each pair of
boolean vectors. (see russellrao function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'sokalmichener')</code></li>
</ol>
<p>Computes the Sokal-Michener distance between each pair of
boolean vectors. (see sokalmichener function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'sokalsneath')</code></li>
</ol>
<p>Computes the Sokal-Sneath distance between each pair of
boolean vectors. (see sokalsneath function documentation)</p>
<ol>
<li><code>Y = pdist(X, 'wminkowski', p=2, w=w)</code></li>
</ol>
<p>Computes the weighted Minkowski distance between each pair of
vectors. (see wminkowski function documentation)</p>
<ol>
<li><code>Y = pdist(X, f)</code></li>
</ol>
<p>Computes the distance between all pairs of vectors in X
using the user supplied 2-arity function f. For example,
Euclidean distance between the vectors could be computed
as follows::</p>
<p>dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))</p>
<p>Note that you should avoid passing a reference to one of
the distance functions defined in this library. For example,::</p>
<p>dm = pdist(X, sokalsneath)</p>
<p>would calculate the pair-wise distances between the vectors in
X using the Python function sokalsneath. This would result in
sokalsneath being called :math:<code>{n \choose 2}</code> times, which
is inefficient. Instead, the optimized C version is more
efficient, and we call it using the following syntax.::</p>
<p>dm = pdist(X, 'sokalsneath')</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rel_entr</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rel_entr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>rel_entr(x, y, out=None)</p>
<p>Elementwise function for computing relative entropy.</p>
<p>.. math::</p>
<p>\mathrm{rel_entr}(x, y) =
\begin{cases}
x \log(x / y) &amp; x &gt; 0, y &gt; 0 \
0 &amp; x = 0, y \ge 0 \
\infty &amp; \text{otherwise}
\end{cases}</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>x, y : array_like
Input arrays
out : ndarray, optional
Optional output array for the function results</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>scalar or ndarray
Relative entropy of the inputs</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>entr, kl_div</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.15.0</p>
<p>This function is jointly convex in x and y.</p>
<p>The origin of this function is in convex programming; see
[1]_. Given two discrete probability distributions :math:<code>p_1,
\ldots, p_n</code> and :math:<code>q_1, \ldots, q_n</code>, to get the relative
entropy of statistics compute the sum</p>
<p>.. math::</p>
<p>\sum_{i = 1}^n \mathrm{rel_entr}(p_i, q_i).</p>
<p>See [2]_ for details.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] Grant, Boyd, and Ye, 'CVX: Matlab Software for Disciplined Convex
Programming', http://cvxr.com/cvx/
.. [2] Kullback-Leibler divergence,
https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rogerstanimoto</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.</p>
<p>The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays
<code>u</code> and <code>v</code>, is defined as</p>
<p>.. math::
\frac{R}
{c_{TT} + c_{FF} + R}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code> and :math:<code>R = 2(c_{TF} + c_{FT})</code>.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>rogerstanimoto : double
The Rogers-Tanimoto dissimilarity between vectors
<code>u</code> and <code>v</code>.</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.rogerstanimoto([1, 0, 0], [0, 1, 0])
0.8
distance.rogerstanimoto([1, 0, 0], [1, 1, 0])
0.5
distance.rogerstanimoto([1, 0, 0], [2, 0, 0])
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">russellrao</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Russell-Rao dissimilarity between two boolean 1-D arrays.</p>
<p>The Russell-Rao dissimilarity between two boolean 1-D arrays, <code>u</code> and
<code>v</code>, is defined as</p>
<p>.. math::</p>
<p>\frac{n - c_{TT}}
{n}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>russellrao : double
The Russell-Rao dissimilarity between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.russellrao([1, 0, 0], [0, 1, 0])
1.0
distance.russellrao([1, 0, 0], [1, 1, 0])
0.6666666666666666
distance.russellrao([1, 0, 0], [2, 0, 0])
0.3333333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">seuclidean</span> <span class="o">:</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v&#39;</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Return the standardized Euclidean distance between two 1-D arrays.</p>
<p>The standardized Euclidean distance between <code>u</code> and <code>v</code>.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
V : (N,) array_like
<code>V</code> is an 1-D array of component variances. It is usually computed
among a larger collection vectors.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>seuclidean : double
The standardized Euclidean distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.seuclidean([1, 0, 0], [0, 1, 0], [0.1, 0.1, 0.1])
4.4721359549995796
distance.seuclidean([1, 0, 0], [0, 1, 0], [1, 0.1, 0.1])
3.3166247903553998
distance.seuclidean([1, 0, 0], [0, 1, 0], [10, 0.1, 0.1])
3.1780497164141406</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sokalmichener</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Sokal-Michener dissimilarity between two boolean 1-D arrays.</p>
<p>The Sokal-Michener dissimilarity between boolean 1-D arrays <code>u</code> and <code>v</code>,
is defined as</p>
<p>.. math::</p>
<p>\frac{R}
{S + R}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code>, :math:<code>R = 2 * (c_{TF} + c_{FT})</code> and
:math:<code>S = c_{FF} + c_{TT}</code>.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>sokalmichener : double
The Sokal-Michener dissimilarity between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.sokalmichener([1, 0, 0], [0, 1, 0])
0.8
distance.sokalmichener([1, 0, 0], [1, 1, 0])
0.5
distance.sokalmichener([1, 0, 0], [2, 0, 0])
-1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sokalsneath</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Sokal-Sneath dissimilarity between two boolean 1-D arrays.</p>
<p>The Sokal-Sneath dissimilarity between <code>u</code> and <code>v</code>,</p>
<p>.. math::</p>
<p>\frac{R}
{c_{TT} + R}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code> and :math:<code>R = 2(c_{TF} + c_{FT})</code>.</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>sokalsneath : double
The Sokal-Sneath dissimilarity between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.sokalsneath([1, 0, 0], [0, 1, 0])
1.0
distance.sokalsneath([1, 0, 0], [1, 1, 0])
0.66666666666666663
distance.sokalsneath([1, 0, 0], [2, 1, 0])
0.0
distance.sokalsneath([1, 0, 0], [3, 1, 0])
-2.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqeuclidean</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the squared Euclidean distance between two 1-D arrays.</p>
<p>The squared Euclidean distance between <code>u</code> and <code>v</code> is defined as</p>
<p>.. math::</p>
<p>{ ||u-v|| }_2^2</p>
<p>\left(\sum{(w_i |(u_i - v_i)|^2)}\right)</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>sqeuclidean : double
The squared Euclidean distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.sqeuclidean([1, 0, 0], [0, 1, 0])
2.0
distance.sqeuclidean([1, 1, 0], [0, 1, 0])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">squareform</span> <span class="o">:</span> <span class="o">?</span><span class="n">force</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">checks</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a vector-form distance vector to a square-form distance
matrix, and vice-versa.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>X : ndarray
Either a condensed or redundant distance matrix.
force : str, optional
As with MATLAB(TM), if force is equal to <code>'tovector'</code> or
<code>'tomatrix'</code>, the input will be treated as a distance matrix or
distance vector respectively.
checks : bool, optional
If set to False, no checks will be made for matrix
symmetry nor zero diagonals. This is useful if it is known that
<code>X - X.T1</code> is small and <code>diag(X)</code> is close to zero.
These values are ignored any way so they do not disrupt the
squareform transformation.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
If a condensed distance matrix is passed, a redundant one is
returned, or if a redundant one is passed, a condensed distance
matrix is returned.</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<ol>
<li>v = squareform(X)</li>
</ol>
<p>Given a square d-by-d symmetric distance matrix X,
<code>v = squareform(X)</code> returns a <code>d * (d-1) / 2</code> (or
:math:<code>{n \choose 2}</code>) sized vector v.</p>
<p>:math:<code>v[{n \choose 2}-{n-i \choose 2} + (j-i-1)]</code> is the distance
between points i and j. If X is non-square or asymmetric, an error
is returned.</p>
<ol>
<li>X = squareform(v)</li>
</ol>
<p>Given a <code>d*(d-1)/2</code> sized v for some integer <code>d &gt;= 2</code> encoding
distances as described, <code>X = squareform(v)</code> returns a d by d distance
matrix X.  The <code>X[i, j]</code> and <code>X[j, i]</code> values are set to
:math:<code>v[{n \choose 2}-{n-i \choose 2} + (j-i-1)]</code> and all
diagonal elements are zero.</p>
<p>In SciPy 0.19.0, <code>squareform</code> stopped casting all input types to
float64, and started returning arrays of the same dtype as the input.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">wminkowski</span> <span class="o">:</span> <span class="n">u</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the weighted Minkowski distance between two 1-D arrays.</p>
<p>The weighted Minkowski distance between <code>u</code> and <code>v</code>, defined as</p>
<p>.. math::</p>
<p>\left(\sum{(|w_i (u_i - v_i)|^p)}\right)^{1/p}.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like
Input array.
v : (N,) array_like
Input array.
p : int
The order of the norm of the difference :math:<code>{ ||u-v|| }_p</code>.
w : (N,) array_like
The weight vector.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>wminkowski : double
The weighted Minkowski distance between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p><code>wminkowski</code> is DEPRECATED. It implements a definition where weights
are powered. It is recommended to use the weighted version of <code>minkowski</code>
instead. This function will be removed in a future version of scipy.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.wminkowski([1, 0, 0], [0, 1, 0], 1, np.ones(3))
2.0
distance.wminkowski([1, 0, 0], [0, 1, 0], 2, np.ones(3))
1.4142135623730951
distance.wminkowski([1, 0, 0], [0, 1, 0], 3, np.ones(3))
1.2599210498948732
distance.wminkowski([1, 1, 0], [0, 1, 0], 1, np.ones(3))
1.0
distance.wminkowski([1, 1, 0], [0, 1, 0], 2, np.ones(3))
1.0
distance.wminkowski([1, 1, 0], [0, 1, 0], 3, np.ones(3))
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">yule</span> <span class="o">:</span> <span class="o">?</span><span class="n">w</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Compute the Yule dissimilarity between two boolean 1-D arrays.</p>
<p>The Yule dissimilarity is defined as</p>
<p>.. math::</p>
<p>\frac{R}{c_{TT} * c_{FF} + \frac{R}{2}}</p>
<p>where :math:<code>c_{ij}</code> is the number of occurrences of
:math:<code>\mathtt{u[k]} = i</code> and :math:<code>\mathtt{v[k]} = j</code> for
:math:<code>k &lt; n</code> and :math:<code>R = 2.0 * c_{TF} * c_{FT}</code>.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>u : (N,) array_like, bool
Input array.
v : (N,) array_like, bool
Input array.
w : (N,) array_like, optional
The weights for each value in <code>u</code> and <code>v</code>. Default is None,
which gives each value a weight of 1.0</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>yule : double
The Yule dissimilarity between vectors <code>u</code> and <code>v</code>.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
distance.yule([1, 0, 0], [0, 1, 0])
2.0
distance.yule([1, 1, 0], [0, 1, 0])
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Kdtree</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">distance_matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">threshold</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the distance matrix.</p>
<p>Returns the matrix of all pair-wise distances.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Matrix of M vectors in K dimensions.
y : (N, K) array_like
Matrix of N vectors in K dimensions.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.
threshold : positive int
If <code>M * N * K</code> &gt; <code>threshold</code>, algorithm uses a Python loop instead
of large temporary arrays.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>result : (M, N) ndarray
Matrix containing the distance from every vector in <code>x</code> to every vector
in <code>y</code>.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance_matrix
distance_matrix([[0,0],[0,1]], [[1,0],[1,1]])
array([[ 1.        ,  1.41421356],
[ 1.41421356,  1.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">heappop</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Pop the smallest item off the heap, maintaining the heap invariant.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">heappush</span> <span class="o">:</span> <span class="n">heap</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">item</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Push item onto heap, maintaining the heap invariant.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minkowski_distance</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the L**p distance between two arrays.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Input array.
y : (N, K) array_like
Input array.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import minkowski_distance
minkowski_distance([[0,0],[0,0]], [[1,1],[0,1]])
array([ 1.41421356,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minkowski_distance_p</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the p-th power of the L**p distance between two arrays.</p>
<p>For efficiency, this function computes the L<strong>p distance but does
not extract the pth root. If <code>p</code> is 1 or infinity, this is equal to
the actual L</strong>p distance.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Input array.
y : (N, K) array_like
Input array.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import minkowski_distance_p
minkowski_distance_p([[0,0],[0,0]], [[1,1],[0,1]])
array([2, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Qhull</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">QhullError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">QhullError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">QhullError</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">asbytes</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tsearch</span> <span class="o">:</span> <span class="n">tri</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tsearch(tri, xi)</p>
<p>Find simplices containing the given points. This function does the
same thing as <code>Delaunay.find_simplex</code>.</p>
<p>.. versionadded:: 0.9</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>Delaunay.find_simplex</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay, delaunay_plot_2d, tsearch</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Delaunay triangulation of a set of random points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pts = np.random.rand(20, 2)
tri = Delaunay(pts)
_ = delaunay_plot_2d(tri)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the simplices containing a given set of points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>loc = np.random.uniform(0.2, 0.8, (5, 2))
s = tsearch(tri, loc)
plt.triplot(pts[:, 0], pts[:, 1], tri.simplices[s], 'b-', mask=s==-1)
plt.scatter(loc[:, 0], loc[:, 1], c='r', marker='x')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Transform</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Rotation</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Rotation</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rotation</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">normalize</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">quat</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Rotation in 3 dimensions.</p>
<p>This class provides an interface to initialize from and represent rotations
with:</p>
<ul>
<li>Quaternions</li>
<li>Rotation Matrices</li>
<li>Rotation Vectors</li>
<li>Euler Angles</li>
</ul>
<p>The following operations on rotations are supported:</p>
<ul>
<li>Application on vectors</li>
<li>Rotation Composition</li>
<li>Rotation Inversion</li>
<li>Rotation Indexing</li>
</ul>
<p>Indexing within a rotation is supported since multiple rotation transforms
can be stored within a single <code>Rotation</code> instance.</p>
<p>To create <code>Rotation</code> objects use <code>from_...</code> methods (see examples below).
<code>Rotation(...)</code> is not supposed to be instantiated directly.</p>
<h2 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h2>
<p><strong>len</strong>
from_quat
from_matrix
from_rotvec
from_euler
as_quat
as_matrix
as_rotvec
as_euler
apply
<strong>mul</strong>
inv
magnitude
mean
reduce
create_group
<strong>getitem</strong>
identity
random
align_vectors</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>Slerp</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p>.. versionadded: 1.2.0</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>A <code>Rotation</code> instance can be initialized in any of the above formats and
converted to any of the others. The underlying object is independent of the
representation used for initialization.</p>
<p>Consider a counter-clockwise rotation of 90 degrees about the z-axis. This
corresponds to the following quaternion (in scalar-last format):</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([0, 0, np.sin(np.pi/4), np.cos(np.pi/4)])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The rotation can be expressed in any of the other formats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
r.as_rotvec()
array([0.        , 0.        , 1.57079633])
r.as_euler('zyx', degrees=True)
array([90.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The same rotation can be initialized using a rotation matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_matrix([[0, -1, 0],
...                    [1, 0, 0],
...                    [0, 0, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Representation in other formats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_quat()
array([0.        , 0.        , 0.70710678, 0.70710678])
r.as_rotvec()
array([0.        , 0.        , 1.57079633])
r.as_euler('zyx', degrees=True)
array([90.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The rotation vector corresponding to this rotation is given by:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Representation in other formats:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_quat()
array([0.        , 0.        , 0.70710678, 0.70710678])
r.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
r.as_euler('zyx', degrees=True)
array([90.,  0.,  0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The <code>from_euler</code> method is quite flexible in the range of input formats
it supports. Here we initialize a single rotation about a single axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('z', 90, degrees=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Again, the object is representation independent and can be converted to any
other format:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_quat()
array([0.        , 0.        , 0.70710678, 0.70710678])
r.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
r.as_rotvec()
array([0.        , 0.        , 1.57079633])</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is also possible to initialize multiple rotations in a single instance
using any of the <code>from_...</code> functions. Here we initialize a stack of 3
rotations using the <code>from_euler</code> method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zyx', [
... [90, 0, 0],
... [0, 45, 0],
... [45, 60, 30]], degrees=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The other representations also now return a stack of 3 rotations. For
example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_quat()
array([[0.        , 0.        , 0.70710678, 0.70710678],
[0.        , 0.38268343, 0.        , 0.92387953],
[0.39190384, 0.36042341, 0.43967974, 0.72331741]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Applying the above rotations onto a vector:</p>
<blockquote>
<blockquote>
<blockquote>
<p>v = [1, 2, 3]
r.apply(v)
array([[-2.        ,  1.        ,  3.        ],
[ 2.82842712,  2.        ,  1.41421356],
[ 2.24452282,  0.78093109,  2.89002836]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A <code>Rotation</code> instance can be indexed and sliced as if it were a single
1D array or list:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r.as_quat()
array([[0.        , 0.        , 0.70710678, 0.70710678],
[0.        , 0.38268343, 0.        , 0.92387953],
[0.39190384, 0.36042341, 0.43967974, 0.72331741]])
p = r[0]
p.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
q = r[1:3]
q.as_quat()
array([[0.        , 0.38268343, 0.        , 0.92387953],
[0.39190384, 0.36042341, 0.43967974, 0.72331741]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multiple rotations can be composed using the <code>*</code> operator:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r1 = R.from_euler('z', 90, degrees=True)
r2 = R.from_rotvec([np.pi/4, 0, 0])
v = [1, 2, 3]
r2.apply(r1.apply(v))
array([-2.        , -1.41421356,  2.82842712])
r3 = r2 * r1 # Note the order
r3.apply(v)
array([-2.        , -1.41421356,  2.82842712])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, it is also possible to invert rotations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r1 = R.from_euler('z', [90, 45], degrees=True)
r2 = r1.inv()
r2.as_euler('zyx', degrees=True)
array([[-90.,   0.,   0.],
[-45.,   0.,   0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>These examples serve as an overview into the <code>Rotation</code> class and highlight
major functionalities. For more thorough examples of the range of input and
output formats supported, consult the individual method's examples.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">indexer</span><span class="o">:[`</span><span class="nc">Slice</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Wrap_utils</span><span class="p">.</span><span class="nn">Slice</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Extract rotation(s) at given index(es) from object.</p>
<p>Create a new <code>Rotation</code> instance containing a subset of rotations
stored in this object.</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>indexer : index, slice, or index array
Specifies which rotation(s) to extract. A single indexer must be
specified, i.e. as if indexing a 1 dimensional array or list.</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Contains
- a single rotation, if <code>indexer</code> is a single index
- a stack of rotation(s), if <code>indexer</code> is a slice, or and index
array.</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R
r = R.from_quat([
... [1, 1, 0, 0],
... [0, 1, 0, 1],
... [1, 1, -1, 0]])
r.as_quat()
array([[ 0.70710678,  0.70710678,  0.        ,  0.        ],
[ 0.        ,  0.70710678,  0.        ,  0.70710678],
[ 0.57735027,  0.57735027, -0.57735027,  0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Indexing using a single index:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = r[0]
p.as_quat()
array([0.70710678, 0.70710678, 0.        , 0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Array slicing:</p>
<blockquote>
<blockquote>
<blockquote>
<p>q = r[1:3]
q.as_quat()
array([[ 0.        ,  0.70710678,  0.        ,  0.70710678],
[ 0.57735027,  0.57735027, -0.57735027,  0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">align_vectors</span> <span class="o">:</span> <span class="o">?</span><span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_sensitivity</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Estimate a rotation to optimally align two sets of vectors.</p>
<p>Find a rotation between frames A and B which best aligns a set of
vectors <code>a</code> and <code>b</code> observed in these frames. The following loss
function is minimized to solve for the rotation matrix
:math:<code>C</code>:</p>
<p>.. math::</p>
<p>L(C) = \frac{1}{2} \sum_{i = 1}^{n} w_i \lVert \mathbf{a}_i -
C \mathbf{b}_i \rVert^2 ,</p>
<p>where :math:<code>w_i</code>'s are the <code>weights</code> corresponding to each vector.</p>
<p>The rotation is estimated with Kabsch algorithm [1]_.</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>a : array_like, shape (N, 3)
Vector components observed in initial frame A. Each row of <code>a</code>
denotes a vector.
b : array_like, shape (N, 3)
Vector components observed in another frame B. Each row of <code>b</code>
denotes a vector.
weights : array_like shape (N,), optional
Weights describing the relative importance of the vector
observations. If None (default), then all values in <code>weights</code> are
assumed to be 1.
return_sensitivity : bool, optional
Whether to return the sensitivity matrix. See Notes for details.
Default is False.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>estimated_rotation : <code>Rotation</code> instance
Best estimate of the rotation that transforms <code>b</code> to <code>a</code>.
rmsd : float
Root mean square distance (weighted) between the given set of
vectors after alignment. It is equal to <code>sqrt(2 * minimum_loss)</code>,
where <code>minimum_loss</code> is the loss function evaluated for the
found optimal rotation.
sensitivity_matrix : ndarray, shape (3, 3)
Sensitivity matrix of the estimated rotation estimate as explained
in Notes. Returned only when <code>return_sensitivity</code> is True.</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>This method can also compute the sensitivity of the estimated rotation
to small perturbations of the vector measurements. Specifically we
consider the rotation estimate error as a small rotation vector of
frame A. The sensitivity matrix is proportional to the covariance of
this rotation vector assuming that the vectors in <code>a</code> was measured with
errors significantly less than their lengths. To get the true
covariance matrix, the returned sensitivity matrix must be multiplied
by harmonic mean [3]_ of variance in each observation. Note that
<code>weights</code> are supposed to be inversely proportional to the observation
variances to get consistent results. For example, if all vectors are
measured with the same accuracy of 0.01 (<code>weights</code> must be all equal),
then you should multiple the sensitivity matrix by 0.01**2 to get the
covariance.</p>
<p>Refer to [2]_ for more rigorous discussion of the covariance
estimation.</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Kabsch_algorithm
.. [2] F. Landis Markley,
'Attitude determination using vector observations: a fast
optimal matrix algorithm', Journal of Astronautical Sciences,
Vol. 41, No.2, 1993, pp. 261-280.
.. [3] https://en.wikipedia.org/wiki/Harmonic_mean</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">apply</span> <span class="o">:</span> <span class="o">?</span><span class="n">inverse</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">vectors</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Apply this rotation to a set of vectors.</p>
<p>If the original frame rotates to the final frame by this rotation, then
its application to a vector can be seen in two ways:</p>
<ul>
<li>As a projection of vector components expressed in the final frame
to the original frame.</li>
<li>As the physical rotation of a vector being glued to the original
frame as it rotates. In this case the vector components are
expressed in the original frame before and after the rotation.</li>
</ul>
<p>In terms of rotation matricies, this application is the same as
<code>self.as_matrix().dot(vectors)</code>.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>vectors : array_like, shape (3,) or (N, 3)
Each <code>vectors[i]</code> represents a vector in 3D space. A single vector
can either be specified with shape <code>(3, )</code> or <code>(1, 3)</code>. The number
of rotations and number of vectors given must follow standard numpy
broadcasting rules: either one of them equals unity or they both
equal each other.
inverse : boolean, optional
If True then the inverse of the rotation(s) is applied to the input
vectors. Default is False.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>rotated_vectors : ndarray, shape (3,) or (N, 3)
Result of applying rotation on input vectors.
Shape depends on the following cases:</p>
<ul>
<li>If object contains a single rotation (as opposed to a stack
with a single rotation) and a single vector is specified with
shape <code>(3,)</code>, then <code>rotated_vectors</code> has shape <code>(3,)</code>.</li>
<li>In all other cases, <code>rotated_vectors</code> has shape <code>(N, 3)</code>,
where <code>N</code> is either the number of rotations or vectors.</li>
</ul>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Single rotation applied on a single vector:</p>
<blockquote>
<blockquote>
<blockquote>
<p>vector = np.array([1, 0, 0])
r = R.from_rotvec([0, 0, np.pi/2])
r.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
r.apply(vector)
array([2.22044605e-16, 1.00000000e+00, 0.00000000e+00])
r.apply(vector).shape
(3,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Single rotation applied on multiple vectors:</p>
<blockquote>
<blockquote>
<blockquote>
<p>vectors = np.array([
... [1, 0, 0],
... [1, 2, 3]])
r = R.from_rotvec([0, 0, np.pi/4])
r.as_matrix()
array([[ 0.70710678, -0.70710678,  0.        ],
[ 0.70710678,  0.70710678,  0.        ],
[ 0.        ,  0.        ,  1.        ]])
r.apply(vectors)
array([[ 0.70710678,  0.70710678,  0.        ],
[-0.70710678,  2.12132034,  3.        ]])
r.apply(vectors).shape
(2, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multiple rotations on a single vector:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([[0, 0, np.pi/4], [np.pi/2, 0, 0]])
vector = np.array([1,2,3])
r.as_matrix()
array([[[ 7.07106781e-01, -7.07106781e-01,  0.00000000e+00],
[ 7.07106781e-01,  7.07106781e-01,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],
[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],
[ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],
[ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]]])
r.apply(vector)
array([[-0.70710678,  2.12132034,  3.        ],
[ 1.        , -3.        ,  2.        ]])
r.apply(vector).shape
(2, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Multiple rotations on multiple vectors. Each rotation is applied on the
corresponding vector:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zxy', [
... [0, 0, 90],
... [45, 30, 60]], degrees=True)
vectors = [
... [1, 2, 3],
... [1, 0, -1]]
r.apply(vectors)
array([[ 3.        ,  2.        , -1.        ],
[-0.09026039,  1.11237244, -0.86860844]])
r.apply(vectors).shape
(2, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is also possible to apply the inverse rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zxy', [
... [0, 0, 90],
... [45, 30, 60]], degrees=True)
vectors = [
... [1, 2, 3],
... [1, 0, -1]]
r.apply(vectors, inverse=True)
array([[-3.        ,  2.        ,  1.        ],
[ 1.09533535, -0.8365163 ,  0.3169873 ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_euler</span> <span class="o">:</span> <span class="o">?</span><span class="n">degrees</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">seq</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Length_3</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Represent as Euler angles.</p>
<p>Any orientation can be expressed as a composition of 3 elementary
rotations. Once the axis sequence has been chosen, Euler angles define
the angle of rotation around each respective axis [1]_.</p>
<p>The algorithm from [2]_ has been used to calculate Euler angles for the
rotation about a given sequence of axes.</p>
<p>Euler angles suffer from the problem of gimbal lock [3]_, where the
representation loses a degree of freedom and it is not possible to
determine the first and third angles uniquely. In this case,
a warning is raised, and the third angle is set to zero. Note however
that the returned angles still represent the correct rotation.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>seq : string, length 3
3 characters belonging to the set {'X', 'Y', 'Z'} for intrinsic
rotations, or {'x', 'y', 'z'} for extrinsic rotations [1]_.
Adjacent axes cannot be the same.
Extrinsic and intrinsic rotations cannot be mixed in one function
call.
degrees : boolean, optional
Returned angles are in degrees if this flag is True, else they are
in radians. Default is False.</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>angles : ndarray, shape (3,) or (N, 3)
Shape depends on shape of inputs used to initialize object.
The returned angles are in the range:</p>
<ul>
<li>First angle belongs to [-180, 180] degrees (both inclusive)</li>
<li>Third angle belongs to [-180, 180] degrees (both inclusive)</li>
<li>
<p>Second angle belongs to:</p>
</li>
<li>
<p>[-90, 90] degrees if all axes are different (like xyz)</p>
</li>
<li>[0, 180] degrees if first and third axes are the same
(like zxz)</li>
</ul>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations
.. [2] Malcolm D. Shuster, F. Landis Markley, 'General formula for
extraction the Euler angles', Journal of guidance, control, and
dynamics, vol. 29.1, pp. 215-221. 2006
.. [3] https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([0, 0, np.pi/2])
r.as_euler('zxy', degrees=True)
array([90.,  0.,  0.])
r.as_euler('zxy', degrees=True).shape
(3,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a stack of single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([[0, 0, np.pi/2]])
r.as_euler('zxy', degrees=True)
array([[90.,  0.,  0.]])
r.as_euler('zxy', degrees=True).shape
(1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent multiple rotations in a single object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([
... [0, 0, np.pi/2],
... [0, -np.pi/3, 0],
... [np.pi/4, 0, 0]])
r.as_euler('zxy', degrees=True)
array([[ 90.,   0.,   0.],
[  0.,   0., -60.],
[  0.,  45.,   0.]])
r.as_euler('zxy', degrees=True).shape
(3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_matrix</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Represent as rotation matrix.</p>
<p>3D rotations can be represented using rotation matrices, which
are 3 x 3 real orthogonal matrices with determinant equal to +1 [1]_.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>matrix : ndarray, shape (3, 3) or (N, 3, 3)
Shape depends on shape of inputs used for initialization.</p>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([0, 0, np.pi/2])
r.as_matrix()
array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])
r.as_matrix().shape
(3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a stack with a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([[1, 1, 0, 0]])
r.as_matrix()
array([[[ 0.,  1.,  0.],
[ 1.,  0.,  0.],
[ 0.,  0., -1.]]])
r.as_matrix().shape
(1, 3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent multiple rotations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([[np.pi/2, 0, 0], [0, 0, np.pi/2]])
r.as_matrix()
array([[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],
[ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],
[ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]],
[[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],
[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]]])
r.as_matrix().shape
(2, 3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_quat</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Represent as quaternions.</p>
<p>Rotations in 3 dimensions can be represented using unit norm
quaternions [1]_. The mapping from quaternions to rotations is
two-to-one, i.e. quaternions <code>q</code> and <code>-q</code>, where <code>-q</code> simply
reverses the sign of each component, represent the same spatial
rotation.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>quat : <code>numpy.ndarray</code>, shape (4,) or (N, 4)
Shape depends on shape of inputs used for initialization.</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_matrix([[0, -1, 0],
...                    [1, 0, 0],
...                    [0, 0, 1]])
r.as_quat()
array([0.        , 0.        , 0.70710678, 0.70710678])
r.as_quat().shape
(4,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a stack with a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([[0, 0, 0, 1]])
r.as_quat().shape
(1, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent multiple rotations in a single object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([[np.pi, 0, 0], [0, 0, np.pi/2]])
r.as_quat().shape
(2, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_rotvec</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Represent as rotation vectors.</p>
<p>A rotation vector is a 3 dimensional vector which is co-directional to
the axis of rotation and whose norm gives the angle of rotation (in
radians) [1]_.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>rotvec : ndarray, shape (3,) or (N, 3)
Shape depends on shape of inputs used for initialization.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('z', 90, degrees=True)
r.as_rotvec()
array([0.        , 0.        , 1.57079633])
r.as_rotvec().shape
(3,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent a stack with a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([[0, 0, 1, 1]])
r.as_rotvec()
array([[0.        , 0.        , 1.57079633]])
r.as_rotvec().shape
(1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Represent multiple rotations in a single object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([[0, 0, 1, 1], [1, 1, 0, 1]])
r.as_rotvec()
array([[0.        , 0.        , 1.57079633],
[1.35102172, 1.35102172, 0.        ]])
r.as_rotvec().shape
(2, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create_group</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">group</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a 3D rotation group.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>group : string
The name of the group. Must be one of 'I', 'O', 'T', 'Dn', 'Cn',
where <code>n</code> is a positive integer. The groups are:</p>
<ul>
<li>I: Icosahedral group</li>
<li>O: Octahedral group</li>
<li>T: Tetrahedral group</li>
<li>D: Dicyclic group</li>
<li>C: Cyclic group</li>
</ul>
<p>axis : integer
The cyclic rotation axis. Must be one of ['X', 'Y', 'Z'] (or
lowercase). Default is 'Z'. Ignored for groups 'I', 'O', and 'T'.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Object containing the elements of the rotation group.</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>This method generates rotation groups only. The full 3-dimensional
point groups [PointGroups]_ also contain reflections.</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [PointGroups] <code>Point groups
&lt;https://en.wikipedia.org/wiki/Point_groups_in_three_dimensions&gt;</code>_
on Wikipedia.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_dcm</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>from_dcm</code> is deprecated!
from_dcm is renamed to from_matrix in scipy 1.4.0 and will be removed in scipy 1.6.0</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_euler</span> <span class="o">:</span> <span class="o">?</span><span class="n">degrees</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">seq</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">angles</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize from Euler angles.</p>
<p>Rotations in 3-D can be represented by a sequence of 3
rotations around a sequence of axes. In theory, any three axes spanning
the 3-D Euclidean space are enough. In practice, the axes of rotation are
chosen to be the basis vectors.</p>
<p>The three rotations can either be in a global frame of reference
(extrinsic) or in a body centred frame of reference (intrinsic), which
is attached to, and moves with, the object under rotation [1]_.</p>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>seq : string
Specifies sequence of axes for rotations. Up to 3 characters
belonging to the set {'X', 'Y', 'Z'} for intrinsic rotations, or
{'x', 'y', 'z'} for extrinsic rotations. Extrinsic and intrinsic
rotations cannot be mixed in one function call.
angles : float or array_like, shape (N,) or (N, [1 or 2 or 3])
Euler angles specified in radians (<code>degrees</code> is False) or degrees
(<code>degrees</code> is True).
For a single character <code>seq</code>, <code>angles</code> can be:</p>
<ul>
<li>a single value</li>
<li>array_like with shape (N,), where each <code>angle[i]</code>
corresponds to a single rotation</li>
<li>array_like with shape (N, 1), where each <code>angle[i, 0]</code>
corresponds to a single rotation</li>
</ul>
<p>For 2- and 3-character wide <code>seq</code>, <code>angles</code> can be:</p>
<ul>
<li>array_like with shape (W,) where <code>W</code> is the width of
<code>seq</code>, which corresponds to a single rotation with <code>W</code> axes</li>
<li>array_like with shape (N, W) where each <code>angle[i]</code>
corresponds to a sequence of Euler angles describing a single
rotation</li>
</ul>
<p>degrees : bool, optional
If True, then the given angles are assumed to be in degrees.
Default is False.</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Object containing the rotation represented by the sequence of
rotations around given axes with given angles.</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a single rotation along a single axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('x', 90, degrees=True)
r.as_quat().shape
(4,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a single rotation with a given axis sequence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zyx', [90, 45, 30], degrees=True)
r.as_quat().shape
(4,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a stack with a single rotation around a single axis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('x', [90], degrees=True)
r.as_quat().shape
(1, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a stack with a single rotation with an axis sequence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zyx', [[90, 45, 30]], degrees=True)
r.as_quat().shape
(1, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize multiple elementary rotations in one object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('x', [90, 45, 30], degrees=True)
r.as_quat().shape
(3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize multiple rotations in one object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_euler('zyx', [[90, 45, 30], [35, 45, 90]], degrees=True)
r.as_quat().shape
(2, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_matrix</span> <span class="o">:</span> <span class="n">matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize from rotation matrix.</p>
<p>Rotations in 3 dimensions can be represented with 3 x 3 proper
orthogonal matrices [1]<em>. If the input is not proper orthogonal,
an approximation is created using the method described in [2]</em>.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>matrix : array_like, shape (N, 3, 3) or (3, 3)
A single matrix or a stack of matrices, where <code>matrix[i]</code> is
the i-th matrix.</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Object containing the rotations represented by the rotation
matrices.</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions
.. [2] F. Landis Markley, 'Unit Quaternion from Rotation Matrix',
Journal of guidance, control, and dynamics vol. 31.2, pp.
440-442, 2008.</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_matrix([
... [0, -1, 0],
... [1, 0, 0],
... [0, 0, 1]])
r.as_matrix().shape
(3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize multiple rotations in a single object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_matrix([
... [
...     [0, -1, 0],
...     [1, 0, 0],
...     [0, 0, 1],
... ],
... [
...     [1, 0, 0],
...     [0, 0, -1],
...     [0, 1, 0],
... ]])
r.as_matrix().shape
(2, 3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>If input matrices are not special orthogonal (orthogonal with
determinant equal to +1), then a special orthogonal estimate is stored:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([
... [0, -0.5, 0],
... [0.5, 0, 0],
... [0, 0, 0.5]])
np.linalg.det(a)
0.12500000000000003
r = R.from_matrix(a)
matrix = r.as_matrix()
matrix
array([[-0.38461538, -0.92307692,  0.        ],
[ 0.92307692, -0.38461538,  0.        ],
[ 0.        ,  0.        ,  1.        ]])
np.linalg.det(matrix)
1.0000000000000002</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is also possible to have a stack containing a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_matrix([[
... [0, -1, 0],
... [1, 0, 0],
... [0, 0, 1]]])
r.as_matrix()
array([[[ 0., -1.,  0.],
[ 1.,  0.,  0.],
[ 0.,  0.,  1.]]])
r.as_matrix().shape
(1, 3, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_quat</span> <span class="o">:</span> <span class="o">?</span><span class="n">normalized</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">quat</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize from quaternions.</p>
<p>3D rotations can be represented using unit-norm quaternions [1]_.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>quat : array_like, shape (N, 4) or (4,)
Each row is a (possibly non-unit norm) quaternion in scalar-last
(x, y, z, w) format. Each quaternion will be normalized to unit
norm.
normalized
Deprecated argument. Has no effect, input <code>quat</code> is always
normalized.</p>
<p>.. deprecated:: 1.4.0</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Object containing the rotations represented by input quaternions.</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([1, 0, 0, 0])
r.as_quat()
array([1., 0., 0., 0.])
r.as_quat().shape
(4,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize multiple rotations in a single object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([
... [1, 0, 0, 0],
... [0, 0, 0, 1]
... ])
r.as_quat()
array([[1., 0., 0., 0.],
[0., 0., 0., 1.]])
r.as_quat().shape
(2, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is also possible to have a stack of a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([[0, 0, 0, 1]])
r.as_quat()
array([[0., 0., 0., 1.]])
r.as_quat().shape
(1, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Quaternions are normalized before initialization.</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_quat([0, 0, 1, 1])
r.as_quat()
array([0.        , 0.        , 0.70710678, 0.70710678])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_rotvec</span> <span class="o">:</span> <span class="n">rotvec</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Initialize from rotation vectors.</p>
<p>A rotation vector is a 3 dimensional vector which is co-directional to
the axis of rotation and whose norm gives the angle of rotation (in
radians) [1]_.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>rotvec : array_like, shape (N, 3) or (3,)
A single vector or a stack of vectors, where <code>rot_vec[i]</code> gives
the ith rotation vector.</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>rotation : <code>Rotation</code> instance
Object containing the rotations represented by input rotation
vectors.</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))
r.as_rotvec()
array([0.        , 0.        , 1.57079633])
r.as_rotvec().shape
(3,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Initialize multiple rotations in one object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([
... [0, 0, np.pi/2],
... [np.pi/2, 0, 0]])
r.as_rotvec()
array([[0.        , 0.        , 1.57079633],
[1.57079633, 0.        , 0.        ]])
r.as_rotvec().shape
(2, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>It is also possible to have a stack of a single rotaton:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r = R.from_rotvec([[0, 0, np.pi/2]])
r.as_rotvec().shape
(1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">identity</span> <span class="o">:</span> <span class="o">?</span><span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get identity rotation(s).</p>
<p>Composition with the identity rotation has no effect.</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>num : int or None, optional
Number of identity rotations to generate. If None (default), then a
single rotation is generated.</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>identity : Rotation object
The identity rotation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Invert this rotation.</p>
<p>Composition of a rotation with its inverse results in an identity
transformation.</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>inverse : <code>Rotation</code> instance
Object containing inverse of the rotations in the current instance.</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inverting a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = R.from_euler('z', 45, degrees=True)
q = p.inv()
q.as_euler('zyx', degrees=True)
array([-45.,   0.,   0.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inverting multiple rotations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = R.from_rotvec([[0, 0, np.pi/3], [-np.pi/4, 0, 0]])
q = p.inv()
q.as_rotvec()
array([[-0.        , -0.        , -1.04719755],
[ 0.78539816, -0.        , -0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">magnitude</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get the magnitude(s) of the rotation(s).</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>magnitude : ndarray or float
Angle(s) in radians, float if object contains a single rotation
and ndarray if object contains multiple rotations.</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R
r = R.from_quat(np.eye(4))
r.magnitude()
array([3.14159265, 3.14159265, 3.14159265, 0.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Magnitude of a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>r[0].magnitude()
3.141592653589793</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">match_vectors</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>match_vectors</code> is deprecated!
match_vectors is deprecated in favor of align_vectors in scipy 1.4.0 and will be removed in scipy 1.6.0</p>
<p>Deprecated in favor of <code>align_vectors</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">mean</span> <span class="o">:</span> <span class="o">?</span><span class="n">weights</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Get the mean of the rotations.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>weights : array_like shape (N,), optional
Weights describing the relative importance of the rotations. If
None (default), then all values in <code>weights</code> are assumed to be
equal.</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>mean : <code>Rotation</code> instance
Object containing the mean of the rotations in the current
instance.</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>The mean used is the chordal L2 mean (also called the projected or
induced arithmetic mean). If <code>p</code> is a set of rotations with mean
<code>m</code>, then <code>m</code> is the rotation which minimizes
<code>(weights[:, None, None] * (p.as_matrix() - m.as_matrix())**2).sum()</code>.</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R
r = R.from_euler('zyx', [[0, 0, 0],
...                          [1, 0, 0],
...                          [0, 1, 0],
...                          [0, 0, 1]], degrees=True)
r.mean().as_euler('zyx', degrees=True)
array([0.24945696, 0.25054542, 0.24945696])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">random</span> <span class="o">:</span> <span class="o">?</span><span class="n">num</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">random_state</span><span class="o">:[`</span><span class="nc">RandomState</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Generate uniformly distributed rotations.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>num : int or None, optional
Number of random rotations to generate. If None (default), then a
single rotation is generated.
random_state : int, RandomState instance or None, optional
Accepts an integer as a seed for the random generator or a
RandomState object. If None (default), uses global <code>numpy.random</code>
random state.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>random_rotation : <code>Rotation</code> instance
Contains a single rotation if <code>num</code> is None. Otherwise contains a
stack of <code>num</code> rotations.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R</p>
</blockquote>
</blockquote>
</blockquote>
<p>Sample a single rotation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>R.random(random_state=1234).as_euler('zxy', degrees=True)
array([-110.5976185 ,   55.32758512,   76.3289269 ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Sample a stack of rotations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>R.random(5, random_state=1234).as_euler('zxy', degrees=True)
array([[-110.5976185 ,   55.32758512,   76.3289269 ],
[ -91.59132005,  -14.3629884 ,  -93.91933182],
[  25.23835501,   45.02035145, -121.67867086],
[ -51.51414184,  -15.29022692, -172.46870023],
[ -81.63376847,  -27.39521579,    2.60408416]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">reduce</span> <span class="o">:</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_indices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reduce this rotation with the provided rotation groups.</p>
<p>Reduction of a rotation <code>p</code> is a transformation of the form
<code>q = l * p * r</code>, where <code>l</code> and <code>r</code> are chosen from <code>left</code> and
<code>right</code> respectively, such that rotation <code>q</code> has the smallest
magnitude.</p>
<p>If <code>left</code> and <code>right</code> are rotation groups representing symmetries of
two objects rotated by <code>p</code>, then <code>q</code> is the rotation of the
smallest magnitude to align these objects considering their symmetries.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>left : <code>Rotation</code> instance, optional
Object containing the left rotation(s). Default value (None)
corresponds to the identity rotation.
right : <code>Rotation</code> instance, optional
Object containing the right rotation(s). Default value (None)
corresponds to the identity rotation.
return_indices : bool, optional
Whether to return the indices of the rotations from <code>left</code> and
<code>right</code> used for reduction.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p>reduced : <code>Rotation</code> instance
Object containing reduced rotations.
left_best, right_best: integer ndarray
Indices of elements from <code>left</code> and <code>right</code> used for reduction.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">RotationSpline</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">RotationSpline</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">RotationSpline</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">times</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rotations</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Interpolate rotations with continuous angular rate and acceleration.</p>
<p>The rotation vectors between each consecutive orientation are cubic
functions of time and it is guaranteed that angular rate and acceleration
are continuous. Such interpolation are analogous to cubic spline
interpolation.</p>
<p>Refer to [1]_ for math and implementation details.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>times : array_like, shape (N,)
Times of the known rotations. At least 2 times must be specified.
rotations : <code>Rotation</code> instance
Rotations to perform the interpolation between. Must contain N
rotations.</p>
<h2 id="methods_1">Methods<a class="headerlink" href="#methods_1" title="Permanent link">&para;</a></h2>
<p><strong>call</strong></p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] <code>Smooth Attitude Interpolation
&lt;https://github.com/scipy/scipy/files/2932755/attitude_interpolation.pdf&gt;</code>_</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation, RotationSpline</p>
</blockquote>
</blockquote>
</blockquote>
<p>Define the sequence of times and rotations from the Euler angles:</p>
<blockquote>
<blockquote>
<blockquote>
<p>times = [0, 10, 20, 40]
angles = [[-10, 20, 30], [0, 15, 40], [-30, 45, 30], [20, 45, 90]]
rotations = Rotation.from_euler('XYZ', angles, degrees=True)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create the interpolator object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>spline = RotationSpline(times, rotations)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Interpolate the Euler angles, angular rate and acceleration:</p>
<blockquote>
<blockquote>
<blockquote>
<p>angular_rate = np.rad2deg(spline(times, 1))
angular_acceleration = np.rad2deg(spline(times, 2))
times_plot = np.linspace(times[0], times[-1], 100)
angles_plot = spline(times_plot).as_euler('XYZ', degrees=True)
angular_rate_plot = np.rad2deg(spline(times_plot, 1))
angular_acceleration_plot = np.rad2deg(spline(times_plot, 2))</p>
</blockquote>
</blockquote>
</blockquote>
<p>On this plot you see that Euler angles are continuous and smooth:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
plt.plot(times_plot, angles_plot)
plt.plot(times, angles, 'x')
plt.title('Euler angles')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The angular rate is also smooth:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(times_plot, angular_rate_plot)
plt.plot(times, angular_rate, 'x')
plt.title('Angular rate')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>The angular acceleration is continuous, but not smooth. Also note that
the angular acceleration is not a piecewise-linear function, because
it is different from the second derivative of the rotation vector (which
is a piecewise-linear function as in the cubic spline).</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(times_plot, angular_acceleration_plot)
plt.plot(times, angular_acceleration, 'x')
plt.title('Angular acceleration')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Slerp</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Slerp</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Slerp</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="n">times</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">rotations</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Spherical Linear Interpolation of Rotations.</p>
<p>The interpolation between consecutive rotations is performed as a rotation
around a fixed axis with a constant angular velocity [1]_. This ensures
that the interpolated rotations follow the shortest path between initial
and final orientations.</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>times : array_like, shape (N,)
Times of the known rotations. At least 2 times must be specified.
rotations : <code>Rotation</code> instance
Rotations to perform the interpolation between. Must contain N
rotations.</p>
<h2 id="methods_2">Methods<a class="headerlink" href="#methods_2" title="Permanent link">&para;</a></h2>
<p><strong>call</strong></p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>Rotation</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.2.0</p>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial.transform import Rotation as R
from scipy.spatial.transform import Slerp</p>
</blockquote>
</blockquote>
</blockquote>
<p>Setup the fixed keyframe rotations and times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>key_rots = R.random(5, random_state=2342345)
key_times = [0, 1, 2, 3, 4]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create the interpolator object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>slerp = Slerp(key_times, key_rots)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Interpolate the rotations at the given times:</p>
<blockquote>
<blockquote>
<blockquote>
<p>times = [0, 0.5, 0.25, 1, 1.5, 2, 2.75, 3, 3.25, 3.60, 4]
interp_rots = slerp(times)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The keyframe rotations expressed as Euler angles:</p>
<blockquote>
<blockquote>
<blockquote>
<p>key_rots.as_euler('xyz', degrees=True)
array([[ 14.31443779, -27.50095894,  -3.7275787 ],
[ -1.79924227, -24.69421529, 164.57701743],
[146.15020772,  43.22849451, -31.34891088],
[ 46.39959442,  11.62126073, -45.99719267],
[-88.94647804, -49.64400082, -65.80546984]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The interpolated rotations expressed as Euler angles. These agree with the
keyframe rotations at both endpoints of the range of keyframe times.</p>
<blockquote>
<blockquote>
<blockquote>
<p>interp_rots.as_euler('xyz', degrees=True)
array([[  14.31443779,  -27.50095894,   -3.7275787 ],
[   4.74588574,  -32.44683966,   81.25139984],
[  10.71094749,  -31.56690154,   38.06896408],
[  -1.79924227,  -24.69421529,  164.57701743],
[  11.72796022,   51.64207311, -171.7374683 ],
[ 146.15020772,   43.22849451,  -31.34891088],
[  68.10921869,   20.67625074,  -48.74886034],
[  46.39959442,   11.62126073,  -45.99719267],
[  12.35552615,    4.21525086,  -64.89288124],
[ -30.08117143,  -19.90769513,  -78.98121326],
[ -88.94647804,  -49.64400082,  -65.80546984]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Rotation&#39;</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">check_random_state</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Turn seed into a np.random.RandomState instance</p>
<p>If seed is None (or np.random), return the RandomState singleton used
by np.random.
If seed is an int, return a new RandomState instance seeded with seed.
If seed is already a RandomState instance, return it.
If seed is a new-style np.random.Generator, return it.
Otherwise raise ValueError.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create_group</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">cls</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">group</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convex_hull_plot_2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">ax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">hull</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Plot the given convex hull diagram in 2-D</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>hull : scipy.spatial.ConvexHull instance
Convex hull to plot
ax : matplotlib.axes.Axes instance, optional
Axes to plot on</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>fig : matplotlib.figure.Figure instance
Figure for the plot</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>ConvexHull</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>Requires Matplotlib.</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull, convex_hull_plot_2d</p>
</blockquote>
</blockquote>
</blockquote>
<p>The convex hull of a random set of points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>points = np.random.rand(30, 2)
hull = ConvexHull(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>_ = convex_hull_plot_2d(hull)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">delaunay_plot_2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">ax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">tri</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Plot the given Delaunay triangulation in 2-D</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>tri : scipy.spatial.Delaunay instance
Triangulation to plot
ax : matplotlib.axes.Axes instance, optional
Axes to plot on</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>fig : matplotlib.figure.Figure instance
Figure for the plot</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>Delaunay
matplotlib.pyplot.triplot</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>Requires Matplotlib.</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
from scipy.spatial import Delaunay, delaunay_plot_2d</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Delaunay triangulation of a set of random points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>points = np.random.rand(30, 2)
tri = Delaunay(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>_ = delaunay_plot_2d(tri)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">distance_matrix</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">threshold</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the distance matrix.</p>
<p>Returns the matrix of all pair-wise distances.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Matrix of M vectors in K dimensions.
y : (N, K) array_like
Matrix of N vectors in K dimensions.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.
threshold : positive int
If <code>M * N * K</code> &gt; <code>threshold</code>, algorithm uses a Python loop instead
of large temporary arrays.</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>result : (M, N) ndarray
Matrix containing the distance from every vector in <code>x</code> to every vector
in <code>y</code>.</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance_matrix
distance_matrix([[0,0],[0,1]], [[1,0],[1,1]])
array([[ 1.        ,  1.41421356],
[ 1.41421356,  1.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minkowski_distance</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the L**p distance between two arrays.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Input array.
y : (N, K) array_like
Input array.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import minkowski_distance
minkowski_distance([[0,0],[0,0]], [[1,1],[0,1]])
array([ 1.41421356,  1.        ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">minkowski_distance_p</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:[`</span><span class="nc">T1_p_infinity</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the p-th power of the L**p distance between two arrays.</p>
<p>For efficiency, this function computes the L<strong>p distance but does
not extract the pth root. If <code>p</code> is 1 or infinity, this is equal to
the actual L</strong>p distance.</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>x : (M, K) array_like
Input array.
y : (N, K) array_like
Input array.
p : float, 1 &lt;= p &lt;= infinity
Which Minkowski p-norm to use.</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import minkowski_distance_p
minkowski_distance_p([[0,0],[0,0]], [[1,1],[0,1]])
array([2, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">procrustes</span> <span class="o">:</span> <span class="n">data1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">data2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Procrustes analysis, a similarity test for two data sets.</p>
<p>Each input matrix is a set of points or vectors (the rows of the matrix).
The dimension of the space is the number of columns of each matrix. Given
two identically sized matrices, procrustes standardizes both such that:</p>
<ul>
<li>
<p>:math:<code>tr(AA^{T}) = 1</code>.</p>
</li>
<li>
<p>Both sets of points are centered around the origin.</p>
</li>
</ul>
<p>Procrustes ([1]<em>, [2]</em>) then applies the optimal transform to the second
matrix (including scaling/dilation, rotations, and reflections) to minimize
:math:<code>M^{2}=\sum(data1-data2)^{2}</code>, or the sum of the squares of the
pointwise differences between the two input datasets.</p>
<p>This function was not designed to handle datasets with different numbers of
datapoints (rows).  If two data sets have different dimensionality
(different number of columns), simply add columns of zeros to the smaller
of the two.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>data1 : array_like
Matrix, n rows represent points in k (columns) space <code>data1</code> is the
reference data, after it is standardised, the data from <code>data2</code> will be
transformed to fit the pattern in <code>data1</code> (must have &gt;1 unique points).
data2 : array_like
n rows of data in k space to be fit to <code>data1</code>.  Must be the  same
shape <code>(numrows, numcols)</code> as data1 (must have &gt;1 unique points).</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>mtx1 : array_like
A standardized version of <code>data1</code>.
mtx2 : array_like
The orientation of <code>data2</code> that best fits <code>data1</code>. Centered, but not
necessarily :math:<code>tr(AA^{T}) = 1</code>.
disparity : float
:math:<code>M^{2}</code> as defined above.</p>
<h2 id="raises_13">Raises<a class="headerlink" href="#raises_13" title="Permanent link">&para;</a></h2>
<p>ValueError
If the input arrays are not two-dimensional.
If the shape of the input arrays is different.
If the input arrays have zero columns or zero rows.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>scipy.linalg.orthogonal_procrustes
scipy.spatial.distance.directed_hausdorff : Another similarity test
for two data sets</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>The disparity should not depend on the order of the input matrices, but
the output matrices will, as only the first output matrix is guaranteed
to be scaled such that :math:<code>tr(AA^{T}) = 1</code>.</p>
</li>
<li>
<p>Duplicate data points are generally ok, duplicating a data point will
increase its effect on the procrustes fit.</p>
</li>
<li>
<p>The disparity scales as the number of points per input matrix.</p>
</li>
</ul>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] Krzanowski, W. J. (2000). 'Principles of Multivariate analysis'.
.. [2] Gower, J. C. (1975). 'Generalized procrustes analysis'.</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import procrustes</p>
</blockquote>
</blockquote>
</blockquote>
<p>The matrix <code>b</code> is a rotated, shifted, scaled and mirrored version of
<code>a</code> here:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 3], [1, 2], [1, 1], [2, 1]], 'd')
b = np.array([[4, -2], [4, -4], [4, -6], [2, -6]], 'd')
mtx1, mtx2, disparity = procrustes(a, b)
round(disparity)
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tsearch</span> <span class="o">:</span> <span class="n">tri</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xi</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>tsearch(tri, xi)</p>
<p>Find simplices containing the given points. This function does the
same thing as <code>Delaunay.find_simplex</code>.</p>
<p>.. versionadded:: 0.9</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>Delaunay.find_simplex</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay, delaunay_plot_2d, tsearch</p>
</blockquote>
</blockquote>
</blockquote>
<p>The Delaunay triangulation of a set of random points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pts = np.random.rand(20, 2)
tri = Delaunay(pts)
_ = delaunay_plot_2d(tri)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the simplices containing a given set of points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>loc = np.random.uniform(0.2, 0.8, (5, 2))
s = tsearch(tri, loc)
plt.triplot(pts[:, 0], pts[:, 1], tri.simplices[s], 'b-', mask=s==-1)
plt.scatter(loc[:, 0], loc[:, 1], c='r', marker='x')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">voronoi_plot_2d</span> <span class="o">:</span> <span class="o">?</span><span class="n">ax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kw</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">vor</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Plot the given Voronoi diagram in 2-D</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>vor : scipy.spatial.Voronoi instance
Diagram to plot
ax : matplotlib.axes.Axes instance, optional
Axes to plot on
show_points: bool, optional
Add the Voronoi points to the plot.
show_vertices : bool, optional
Add the Voronoi vertices to the plot.
line_colors : string, optional
Specifies the line color for polygon boundaries
line_width : float, optional
Specifies the line width for polygon boundaries
line_alpha: float, optional
Specifies the line alpha for polygon boundaries
point_size: float, optional
Specifies the size of points</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>fig : matplotlib.figure.Figure instance
Figure for the plot</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>Voronoi</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>Requires Matplotlib.</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<p>Set of point:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
points = np.random.rand(10,2) #random</p>
</blockquote>
</blockquote>
</blockquote>
<p>Voronoi diagram of the points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import Voronoi, voronoi_plot_2d
vor = Voronoi(points)</p>
</blockquote>
</blockquote>
</blockquote>
<p>using <code>voronoi_plot_2d</code> for visualisation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fig = voronoi_plot_2d(vor)</p>
</blockquote>
</blockquote>
</blockquote>
<p>using <code>voronoi_plot_2d</code> for visualisation with enhancements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fig = voronoi_plot_2d(vor, show_vertices=False, line_colors='orange',
...                 line_width=2, line_alpha=0.6, point_size=2)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Sparse/" title="Sparse" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Sparse
              </div>
            </div>
          </a>
        
        
          <a href="../Special/" title="Special" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Special
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>