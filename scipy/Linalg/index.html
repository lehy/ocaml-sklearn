


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Linalg - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Linalg
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Linalg" class="md-nav__link md-nav__link--active">
      Linalg
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Linalg.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">LinAlgError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinAlgError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinAlgError</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">LinAlgWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">LinAlgWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">LinAlgWarning</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Basic</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more input arrays.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>ret : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
Copies are made only if necessary.</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>atleast_2d, atleast_3d</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_1d(1.0)
array([1.])</p>
<p>x = np.arange(9.0).reshape(3,3)
np.atleast_1d(x)
array([[0., 1., 2.],
[3., 4., 5.],
[6., 7., 8.]])
np.atleast_1d(x) is x
True</p>
<p>np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>res, res2, ... : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>atleast_1d, atleast_3d</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_2d(3.0)
array([[3.]])</p>
<p>x = np.arange(3.0)
np.atleast_2d(x)
array([[0., 1., 2.]])
np.atleast_2d(x).base is x
True</p>
<p>np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">det</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the determinant of a matrix</p>
<p>The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.</p>
<p>The determinant for a 3x3 matrix, for example, is computed as follows::</p>
<p>a    b    c
d    e    f = A
g    h    i</p>
<p>det(A) = a<em>e</em>i + b<em>f</em>g + c<em>d</em>h - c<em>e</em>g - b<em>d</em>i - a<em>f</em>h</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A square matrix.
overwrite_a : bool, optional
Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>det : float or complex
Determinant of <code>a</code>.</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>The determinant is computed via LU factorization, LAPACK routine z/dgetrf.</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
linalg.det(a)
0.0
a = np.array([[0,2,3], [4,5,6], [7,8,9]])
linalg.det(a)
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. arrays are used to determine optimal prefix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>a : array_like
Square matrix to be inverted.
overwrite_a : bool, optional
Discard data in <code>a</code> (may improve performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>ainv : ndarray
Inverse of the matrix <code>a</code>.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular.
ValueError
If <code>a</code> is not square, or not 2-dimensional.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1., 2.], [3., 4.]])
linalg.inv(a)
array([[-2. ,  1. ],
[ 1.5, -0.5]])
np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">levinson</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve a linear Toeplitz system using Levinson recursion.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>a : array, dtype=double or complex128, shape=(2n-1,)
The first column of the matrix in reverse order (without the diagonal)
followed by the first (see below)
b : array, dtype=double  or complex128, shape=(n,)
The right hand side vector. Both a and b must have the same type
(double or complex128).</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>For example, the 5x5 toeplitz matrix below should be represented as
the linear array <code>a</code> on the right ::</p>
<p>[ a0    a1   a2  a3  a4 ]
[ a-1   a0   a1  a2  a3 ]
[ a-2  a-1   a0  a1  a2 ] -&gt; [a-4  a-3  a-2  a-1  a0  a1  a2  a3  a4]
[ a-3  a-2  a-1  a0  a1 ]
[ a-4  a-3  a-2  a-1 a0 ]</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>x : arrray, shape=(n,)
The solution vector
reflection_coeff : array, shape=(n+1,)
Toeplitz reflection coefficients. When a is symmetric Toeplitz and
<code>b</code> is <code>a[n:]</code>, as in the solution of autoregressive systems,
then <code>reflection_coeff</code> also correspond to the partial
autocorrelation function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lstsq</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Compute least-squares solution to equation Ax = b.</p>
<p>Compute a vector x such that the 2-norm <code>|b - A x|</code> is minimized.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Left hand side array
b : (M,) or (M, K) array_like
Right hand side array
cond : float, optional
Cutoff for 'small' singular values; used to determine effective
rank of a. Singular values smaller than
<code>rcond * largest_singular_value</code> are considered zero.
overwrite_a : bool, optional
Discard data in <code>a</code> (may enhance performance). Default is False.
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
Which LAPACK driver is used to solve the least-squares problem.
Options are <code>'gelsd'</code>, <code>'gelsy'</code>, <code>'gelss'</code>. Default
(<code>'gelsd'</code>) is a good choice.  However, <code>'gelsy'</code> can be slightly
faster on many problems.  <code>'gelss'</code> was used historically.  It is
generally slow but uses less memory.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>x : (N,) or (N, K) ndarray
Least-squares solution.  Return shape matches shape of <code>b</code>.
residues : (K,) ndarray or float
Square of the 2-norm for each column in <code>b - a x</code>, if <code>M &gt; N</code> and
<code>ndim(A) == n</code> (returns a scalar if b is 1-D). Otherwise a
(0,)-shaped array is returned.
rank : int
Effective rank of <code>a</code>.
s : (min(M, N),) ndarray or None
Singular values of <code>a</code>. The condition number of a is
<code>abs(s[0] / s[-1])</code>.</p>
<h2 id="raises_1">Raises<a class="headerlink" href="#raises_1" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If computation does not converge.</p>
<p>ValueError
When parameters are not compatible.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>scipy.optimize.nnls : linear least squares with non-negativity constraint</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<p>When <code>'gelsy'</code> is used as a driver, <code>residues</code> is set to a (0,)-shaped
array and <code>s</code> is always <code>None</code>.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lstsq
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Suppose we have the following data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to fit a quadratic polynomial of the form <code>y = a + b*x**2</code>
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing <code>x**2</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = x[:, np.newaxis]**[0, 2]
M
array([[  1.  ,   1.  ],
[  1.  ,   6.25],
[  1.  ,  12.25],
[  1.  ,  16.  ],
[  1.  ,  25.  ],
[  1.  ,  49.  ],
[  1.  ,  72.25]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to find the least-squares solution to <code>M.dot(p) = y</code>,
where <code>p</code> is a vector with length 2 that holds the parameters
<code>a</code> and <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>p, res, rnk, s = lstsq(M, y)
p
array([ 0.20925829,  0.12013861])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the data and the fitted curve.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(x, y, 'o', label='data')
xx = np.linspace(0, 9, 101)
yy = p[0] + p[1]<em>xx</em>*2
plt.plot(xx, yy, label='least squares fit, <span><span class="MathJax_Preview">y = a + bx^2</span><script type="math/tex">y = a + bx^2</script></span>')
plt.xlabel('x')
plt.ylabel('y')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix_balance</span> <span class="o">:</span> <span class="o">?</span><span class="n">permute</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">separate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a diagonal similarity transformation for row/column balancing.</p>
<p>The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.</p>
<p>Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.</p>
<p>The balanced matrix satisfies the following equality</p>
<p>.. math::</p>
<p>B = T^{-1} A T</p>
<p>The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>A : (n, n) array_like
Square data matrix for the balancing.
permute : bool, optional
The selector to define whether permutation of A is also performed
prior to scaling.
scale : bool, optional
The selector to turn on and off the scaling. If False, the matrix
will not be scaled.
separate : bool, optional
This switches from returning a full matrix of the transformation
to a tuple of two separate 1D permutation and scaling arrays.
overwrite_a : bool, optional
This is passed to xGEBAL directly. Essentially, overwrites the result
to the data. It might increase the space efficiency. See LAPACK manual
for details. This is False by default.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>B : (n, n) ndarray
Balanced matrix
T : (n, n) ndarray
A possibly permuted diagonal matrix whose nonzero entries are
integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
If <code>separate</code> keyword is set to True then instead of the array
<code>T</code> above, the scaling and the permutation vectors are given
separately as a tuple without allocating the full array <code>T</code>.</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.</p>
<p>The algorithm is based on the well-known technique of [1]<em> and has
been modified to account for special cases. See [2]</em> for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.</p>
<p>The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])</p>
<p>y, permscale = linalg.matrix_balance(x)
np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)
array([ 3.66666667,  0.4995005 ,  0.91312162])</p>
<p>np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)
array([ 1.2       ,  1.27041742,  0.92658316])  # may vary</p>
<p>permscale  # only powers of 2 (0.5 == 2^(-1))
array([[  0.5,   0. ,  0. ],  # may vary
[  0. ,   1. ,  0. ],
[  0. ,   0. ,  1. ]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] : B.N. Parlett and C. Reinsch, 'Balancing a Matrix for
Calculation of Eigenvalues and Eigenvectors', Numerische Mathematik,
Vol.13(4), 1969, DOI:10.1007/BF02165404</p>
<p>.. [2] : R. James, J. Langou, B.R. Lowery, 'On matrix balancing and
eigenvector computation', 2014, Available online:
https://arxiv.org/abs/1401.5766</p>
<p>.. [3] :  D.S. Watkins. A case where balancing is harmful.
Electron. Trans. Numer. Anal, Vol.23, 2006.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using a least-squares
solver.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be pseudo-inverted.
cond, rcond : float, optional
Cutoff factor for 'small' singular values. In <code>lstsq</code>,
singular values less than <code>cond*largest_singular_value</code> will be
considered as zero. If both are omitted, the default value
<code>max(M, N) * eps</code> is passed to <code>lstsq</code> where <code>eps</code> is the
corresponding machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps</code> without the
factor <code>max(M, N)</code>.</p>
<p>return_rank : bool, optional
if True, return the effective rank of the matrix
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>B : (N, M) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if return_rank == True</p>
<h2 id="raises_2">Raises<a class="headerlink" href="#raises_2" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If computation does not converge.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)
B = linalg.pinv(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv2</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be pseudo-inverted.
cond, rcond : float or None
Cutoff for 'small' singular values; singular values smaller than this
value are considered as zero. If both are omitted, the default value
<code>max(M,N)*largest_singular_value*eps</code> is used where <code>eps</code> is the
machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
<p>return_rank : bool, optional
If True, return the effective rank of the matrix.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>B : (N, M) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
<h2 id="raises_3">Raises<a class="headerlink" href="#raises_3" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)
B = linalg.pinv2(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinvh</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</p>
<p>Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
Cutoff for 'small' singular values; singular values smaller than this
value are considered as zero. If both are omitted, the default
<code>max(M,N)*largest_eigenvalue*eps</code> is used where <code>eps</code> is the
machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
<p>lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
return_rank : bool, optional
If True, return the effective rank of the matrix.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>B : (N, N) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
<h2 id="raises_4">Raises<a class="headerlink" href="#raises_4" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue does not converge</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import pinvh
a = np.random.randn(9, 6)
a = np.dot(a, a.T)
B = pinvh(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_5">Raises<a class="headerlink" href="#raises_5" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">l_and_u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation a x = b for x, assuming a is banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> using the matrix diagonal ordered form::</p>
<p>ab[u + i - j, j] == a[i,j]</p>
<p>Example of <code>ab</code> (shape of a is (6,6), <code>u</code> =1, <code>l</code> =2)::</p>
<ul>
<li>a01  a12  a23  a34  a45
a00  a11  a22  a33  a44  a55
a10  a21  a32  a43  a54   *
a20  a31  a42  a53   *    *</li>
</ul>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>(l, u) : (integer, integer)
Number of non-zero lower and upper diagonals
ab : (<code>l</code> + <code>u</code> + 1, M) array_like
Banded matrix
b : (M,) or (M, K) array_like
Right-hand side
overwrite_ab : bool, optional
Discard data in <code>ab</code> (may enhance performance)
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system a x = b.  Returned shape depends on the
shape of <code>b</code>.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<p>Solve the banded system a x = b, where::</p>
<p>[5  2 -1  0  0]       [0]
[1  4  2 -1  0]       [1]
a = [0  1  3  2 -1]   b = [2]
[0  0  1  2  2]       [2]
[0  0  0  1  1]       [3]</p>
<p>There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2).  The diagonal banded form of the matrix is::</p>
<p>[<em>  * -1 -1 -1]
ab = [</em>  2  2  2  2]
[5  4  3  2  1]
[1  1  1  1  *]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_banded
ab = np.array([[0,  0, -1, -1, -1],
...                [0,  2,  2,  2,  2],
...                [5,  4,  3,  2,  1],
...                [1,  1,  1,  1,  0]])
b = np.array([0, 1, 2, 2, 3])
x = solve_banded((1, 2), ab, b)
x
array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_circulant</span> <span class="o">:</span> <span class="o">?</span><span class="n">singular</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">caxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">baxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outaxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve C x = b for x, where C is a circulant matrix.</p>
<p><code>C</code> is the circulant matrix associated with the vector <code>c</code>.</p>
<p>The system is solved by doing division in Fourier space.  The
calculation is::</p>
<p>x = ifft(fft(b) / fft(c))</p>
<p>where <code>fft</code> and <code>ifft</code> are the fast Fourier transform and its inverse,
respectively.  For a large vector <code>c</code>, this is <em>much</em> faster than
solving the system with the full circulant matrix.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>c : array_like
The coefficients of the circulant matrix.
b : array_like
Right-hand side matrix in <code>a x = b</code>.
singular : str, optional
This argument controls how a near singular circulant matrix is
handled.  If <code>singular</code> is 'raise' and the circulant matrix is
near singular, a <code>LinAlgError</code> is raised.  If <code>singular</code> is
'lstsq', the least squares solution is returned.  Default is 'raise'.
tol : float, optional
If any eigenvalue of the circulant matrix has an absolute value
that is less than or equal to <code>tol</code>, the matrix is considered to be
near singular.  If not given, <code>tol</code> is set to::</p>
<p>tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps</p>
<p>where <code>abs_eigs</code> is the array of absolute values of the eigenvalues
of the circulant matrix.
caxis : int
When <code>c</code> has dimension greater than 1, it is viewed as a collection
of circulant vectors.  In this case, <code>caxis</code> is the axis of <code>c</code> that
holds the vectors of circulant coefficients.
baxis : int
When <code>b</code> has dimension greater than 1, it is viewed as a collection
of vectors.  In this case, <code>baxis</code> is the axis of <code>b</code> that holds the
right-hand side vectors.
outaxis : int
When <code>c</code> or <code>b</code> are multidimensional, the value returned by
<code>solve_circulant</code> is multidimensional.  In this case, <code>outaxis</code> is
the axis of the result that holds the solution vectors.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution to the system <code>C x = b</code>.</p>
<h2 id="raises_6">Raises<a class="headerlink" href="#raises_6" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If the circulant matrix associated with <code>c</code> is near singular.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>circulant : circulant matrix</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>For a one-dimensional vector <code>c</code> with length <code>m</code>, and an array <code>b</code>
with shape <code>(m, ...)</code>,</p>
<p>solve_circulant(c, b)</p>
<p>returns the same result as</p>
<p>solve(circulant(c), b)</p>
<p>where <code>solve</code> and <code>circulant</code> are from <code>scipy.linalg</code>.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_circulant, solve, circulant, lstsq</p>
<p>c = np.array([2, 2, 4])
b = np.array([1, 2, 3])
solve_circulant(c, b)
array([ 0.75, -0.25,  0.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that result to solving the system with <code>scipy.linalg.solve</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve(circulant(c), b)
array([ 0.75, -0.25,  0.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A singular example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([1, 1, 0, 0])
b = np.array([1, 2, 3, 4])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calling <code>solve_circulant(c, b)</code> will raise a <code>LinAlgError</code>.  For the
least square solution, use the option <code>singular='lstsq'</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve_circulant(c, b, singular='lstsq')
array([ 0.25,  1.25,  2.25,  1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare to <code>scipy.linalg.lstsq</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x, resid, rnk, s = lstsq(circulant(c), b)
x
array([ 0.25,  1.25,  2.25,  1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A broadcasting example:</p>
<p>Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three <code>b</code> vectors stored in an array with shape
(3, 5).  For example,</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])
b = np.arange(15).reshape(-1, 5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to solve all combinations of circulant matrices and <code>b</code> vectors,
with the result stored in an array with shape (2, 3, 5).  When we
disregard the axes of <code>c</code> and <code>b</code> that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting.  To have a broadcast result with shape
(2, 3), we add a trivial dimension to <code>c</code>: <code>c[:, np.newaxis, :]</code> has
shape (2, 1, 5).  The last dimension holds the coefficients of the
circulant matrices, so when we call <code>solve_circulant</code>, we can use the
default <code>caxis=-1</code>.  The coefficients of the <code>b</code> vectors are in the last
dimension of the array <code>b</code>, so we use <code>baxis=-1</code>.  If we use the
default <code>outaxis</code>, the result will have shape (5, 2, 3), so we'll use
<code>outaxis=-1</code> to put the solution vectors in the last dimension.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)
x.shape
(2, 3, 5)
np.set_printoptions(precision=3)  # For compact output of numbers.
x
array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
[ 0.651,  0.989,  2.046,  0.627,  1.072],
[ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
[[ 0.401,  0.304,  0.694, -0.867,  0.377],
[ 0.856,  0.758,  1.149, -0.412,  0.831],
[ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check by solving one pair of <code>c</code> and <code>b</code> vectors (cf. <code>x[1, 1, :]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve_circulant(c[1], b[1, :])
array([ 0.856,  0.758,  1.149, -0.412,  0.831])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_toeplitz</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">c_or_cr</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_array_like_array_like_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve a Toeplitz system using Levinson Recursion</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>c_or_cr : array_like or tuple of (array_like, array_like)
The vector <code>c</code>, or a tuple of arrays (<code>c</code>, <code>r</code>). Whatever the
actual shape of <code>c</code>, it will be converted to a 1-D array. If not
supplied, <code>r = conjugate(c)</code> is assumed; in this case, if c[0] is
real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
of the Toeplitz matrix is <code>[c[0], r[1:]]</code>.  Whatever the actual shape
of <code>r</code>, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
Right-hand side in <code>T x = b</code>.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(result entirely NaNs) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system <code>T x = b</code>.  Shape of return matches shape
of <code>b</code>.</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<p>Solve the Toeplitz system T x = b, where::</p>
<p>[ 1 -1 -2 -3]       [1]
T = [ 3  1 -1 -2]   b = [2]
[ 6  3  1 -1]       [2]
[10  6  3  1]       [5]</p>
<p>To specify the Toeplitz matrix, only the first column and the first
row are needed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([1, 3, 6, 10])    # First column of T
r = np.array([1, -1, -2, -3])  # First row of T
b = np.array([1, 2, 2, 5])</p>
<p>from scipy.linalg import solve_toeplitz, toeplitz
x = solve_toeplitz((c, r), b)
x
array([ 1.66666667, -1.        , -2.66666667,  2.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check the result by creating the full Toeplitz matrix and
multiplying it by <code>x</code>.  We should get <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>T = toeplitz(c, r)
T.dot(x)
array([ 1.,  2.,  2.,  5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A triangular matrix
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>a x = b</code>
lower : bool, optional
Use only data contained in the lower triangle of <code>a</code>.
Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and
will not be referenced.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</p>
<h2 id="raises_7">Raises<a class="headerlink" href="#raises_7" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular</p>
<h2 id="notes_8">Notes<a class="headerlink" href="#notes_8" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.9.0</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<p>Solve the lower triangular system a x = b, where::</p>
<p>[3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
[1  0  1  0]       [4]
[1  1  1  1]       [2]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_triangular
a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
b = np.array([4, 2, 4, 2])
x = solve_triangular(a, b, lower=True)
x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solveh_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve equation a x = b. a is Hermitian positive-definite banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> either in lower diagonal or upper
diagonal ordered form:</p>
<p>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>Example of <code>ab</code> (shape of a is (6, 6), <code>u</code> =2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>ab : (<code>u</code> + 1, M) array_like
Banded matrix
b : (M,) or (M, K) array_like
Right-hand side
overwrite_ab : bool, optional
Discard data in <code>ab</code> (may enhance performance)
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance)
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system a x = b.  Shape of return matches shape
of <code>b</code>.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<p>Solve the banded system A x = b, where::</p>
<p>[ 4  2 -1  0  0  0]       [1]
[ 2  5  2 -1  0  0]       [2]
A = [-1  2  6  2 -1  0]   b = [2]
[ 0 -1  2  7  2 -1]       [3]
[ 0  0 -1  2  8  2]       [3]
[ 0  0  0 -1  2  9]       [3]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solveh_banded</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>ab</code> contains the main diagonal and the nonzero diagonals below the
main diagonal.  That is, we use the lower form:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ab = np.array([[ 4,  5,  6,  7, 8, 9],
...                [ 2,  2,  2,  2, 2, 0],
...                [-1, -1, -1, -1, 0, 0]])
b = np.array([1, 2, 2, 3, 3, 3])
x = solveh_banded(ab, b, lower=True)
x
array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,
0.34733894])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Solve the Hermitian banded system H x = b, where::</p>
<p>[ 8   2-1j   0     0  ]        [ 1  ]
H = [2+1j  5     1j    0  ]    b = [1+1j]
[ 0   -1j    9   -2-1j]        [1-2j]
[ 0    0   -2+1j   6  ]        [ 0  ]</p>
<p>In this example, we put the upper diagonals in the array <code>hb</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hb = np.array([[0, 2-1j, 1j, -2-1j],
...                [8,  5,    9,   6  ]])
b = np.array([1, 1+1j, 1-2j, 0])
x = solveh_banded(hb, b)
x
array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,
0.10077984-0.23035393j, -0.00479904-0.09358128j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Blas</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">crotg</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>c,s = crotg(a,b)</p>
<p>Wrapper for <code>crotg</code>.</p>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>a : input complex
b : input complex</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>c : complex
s : complex</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">drotg</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>c,s = drotg(a,b)</p>
<p>Wrapper for <code>drotg</code>.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>a : input float
b : input float</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>c : float
s : float</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_best_blas_type</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Find best-matching BLAS/LAPACK type.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.
dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>prefix : str
BLAS/LAPACK prefix character.
dtype : dtype
Inferred Numpy data type.
prefer_fortran : bool
Whether to prefer Fortran order routines over C order.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg.blas as bla
a = np.random.rand(10,15)
b = np.asfortranarray(a)  # Change the memory layout order
bla.find_best_blas_type((a,))
('d', dtype('float64'), False)
bla.find_best_blas_type((a*1j,))
('z', dtype('complex128'), False)
bla.find_best_blas_type((b,))
('d', dtype('float64'), True)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of BLAS functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_9">Notes<a class="headerlink" href="#notes_9" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_gemv = LA.get_blas_funcs('gemv', (a,))
x_gemv.typecode
'd'
x_gemv = LA.get_blas_funcs('gemv',(a*1j,))
x_gemv.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">srotg</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>c,s = srotg(a,b)</p>
<p>Wrapper for <code>srotg</code>.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>a : input float
b : input float</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>c : float
s : float</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zrotg</span> <span class="o">:</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>c,s = zrotg(a,b)</p>
<p>Wrapper for <code>zrotg</code>.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>a : input complex
b : input complex</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>c : complex
s : complex</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Cython_blas</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Cython_lapack</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Decomp</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Inexact</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Inexact</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Inexact</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>Abstract base class of all numeric scalar types with a (potentially)
inexact representation of the values in its range, such as
floating-point numbers.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">argsort</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Stable</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Quicksort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Heapsort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mergesort</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <code>kind</code> keyword. It returns an array of indices of the same shape as
<code>a</code> that index data along the given axis in sorted order.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>a : array_like
Array to sort.
axis : int or None, optional
Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.
kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
and 'mergesort' use timsort under the covers and, in general, the
actual implementation will vary with data type. The 'mergesort' option
is retained for backwards compatibility.</p>
<p>.. versionchanged:: 1.15.0.
The 'stable' option was added.
order : str or list of str, optional
When <code>a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>index_array : ndarray, int
Array of indices that sort <code>a</code> along the specified <code>axis</code>.
If <code>a</code> is one-dimensional, <code>a[index_array]</code> yields a sorted <code>a</code>.
More generally, <code>np.take_along_axis(a, index_array, axis=axis)</code>
always yields the sorted <code>a</code>, irrespective of dimensionality.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.
take_along_axis : Apply <code>index_array</code> from argsort
to an array as if by calling sort.</p>
<h2 id="notes_10">Notes<a class="headerlink" href="#notes_10" title="Permanent link">&para;</a></h2>
<p>See <code>sort</code> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <code>argsort</code> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <code>sort</code>.</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<p>One dimensional array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([3, 1, 2])
np.argsort(x)
array([1, 2, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two-dimensional array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[0, 3], [2, 2]])
x
array([[0, 3],
[2, 2]])</p>
<p>ind = np.argsort(x, axis=0)  # sorts along first axis (down)
ind
array([[0, 1],
[1, 0]])
np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
array([[0, 2],
[2, 3]])</p>
<p>ind = np.argsort(x, axis=1)  # sorts along last axis (across)
ind
array([[0, 1],
[0, 1]])
np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
array([[0, 3],
[2, 2]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
ind
(array([0, 1, 1, 0]), array([0, 0, 1, 1]))
x[ind]  # same as np.sort(x, axis=None)
array([0, 2, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Sorting with keys:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])
x
array([(1, 0), (0, 1)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
<p>np.argsort(x, order=('x','y'))
array([1, 0])</p>
<p>np.argsort(x, order=('y','x'))
array([0, 1])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argwhere</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Find the indices of array elements that are non-zero, grouped by element.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>index_array : (N, a.ndim) ndarray
Indices of elements that are non-zero. Indices are grouped by element.
This array will have shape <code>(N, a.ndim)</code> where <code>N</code> is the number of
non-zero items.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>where, nonzero</p>
<h2 id="notes_11">Notes<a class="headerlink" href="#notes_11" title="Permanent link">&para;</a></h2>
<p><code>np.argwhere(a)</code> is almost the same as <code>np.transpose(np.nonzero(a))</code>,
but produces a result of the correct shape for a 0D array.</p>
<p>The output of <code>argwhere</code> is not suitable for indexing arrays.
For this purpose use <code>nonzero(a)</code> instead.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(6).reshape(2,3)
x
array([[0, 1, 2],
[3, 4, 5]])
np.argwhere(x&gt;1)
array([[0, 2],
[1, 0],
[1, 1],
[1, 2]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_12">Notes<a class="headerlink" href="#notes_12" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cdf2rdf</span> <span class="o">:</span> <span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Converts complex eigenvalues <code>w</code> and eigenvectors <code>v</code> to real
eigenvalues in a block diagonal form <code>wr</code> and the associated real
eigenvectors <code>vr</code>, such that::</p>
<p>vr @ wr = X @ vr</p>
<p>continues to hold, where <code>X</code> is the original array for which <code>w</code> and
<code>v</code> are the eigenvalues and eigenvectors.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>w : (..., M) array_like
Complex or real eigenvalues, an array or stack of arrays</p>
<p>Conjugate pairs must not be interleaved, else the wrong result
will be produced. So <code>[1+1j, 1, 1-1j]</code> will give a correct result, but
<code>[1+1j, 2+1j, 1-1j, 2-1j]</code> will not.</p>
<p>v : (..., M, M) array_like
Complex or real eigenvectors, a square array or stack of square arrays.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>wr : (..., M, M) ndarray
Real diagonal block form of eigenvalues
vr : (..., M, M) ndarray
Real eigenvectors associated with <code>wr</code></p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>eig : Eigenvalues and right eigenvectors for non-symmetric arrays
rsf2csf : Convert real Schur form to complex Schur form</p>
<h2 id="notes_13">Notes<a class="headerlink" href="#notes_13" title="Permanent link">&para;</a></h2>
<p><code>w</code>, <code>v</code> must be the eigenstructure for some <em>real</em> matrix <code>X</code>.
For example, obtained by <code>w, v = scipy.linalg.eig(X)</code> or
<code>w, v = numpy.linalg.eig(X)</code> in which case <code>X</code> can also represent
stacked arrays.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.array([[1, 2, 3], [0, 4, 5], [0, -5, 4]])
X
array([[ 1,  2,  3],
[ 0,  4,  5],
[ 0, -5,  4]])</p>
<p>from scipy import linalg
w, v = linalg.eig(X)
w
array([ 1.+0.j,  4.+5.j,  4.-5.j])
v
array([[ 1.00000+0.j     , -0.01906-0.40016j, -0.01906+0.40016j],
[ 0.00000+0.j     ,  0.00000-0.64788j,  0.00000+0.64788j],
[ 0.00000+0.j     ,  0.64788+0.j     ,  0.64788-0.j     ]])</p>
<p>wr, vr = linalg.cdf2rdf(w, v)
wr
array([[ 1.,  0.,  0.],
[ 0.,  4.,  5.],
[ 0., -5.,  4.]])
vr
array([[ 1.     ,  0.40016, -0.01906],
[ 0.     ,  0.64788,  0.     ],
[ 0.     ,  0.     ,  0.64788]])</p>
<p>vr @ wr
array([[ 1.     ,  1.69593,  1.9246 ],
[ 0.     ,  2.59153,  3.23942],
[ 0.     , -3.23942,  2.59153]])
X @ vr
array([[ 1.     ,  1.69593,  1.9246 ],
[ 0.     ,  2.59153,  3.23942],
[ 0.     , -3.23942,  2.59153]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input value.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_14">Notes<a class="headerlink" href="#notes_14" title="Permanent link">&para;</a></h2>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.conj is np.conjugate
True</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.conjugate(1+2j)
(1-2j)</p>
<p>x = np.eye(2) + 1j * np.eye(2)
np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
[ 0.-0.j,  1.-1.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]</p>
<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.
left : bool, optional
Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.  Default is False.
overwrite_b : bool, optional
Whether to overwrite <code>b</code>; may improve performance.  Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its
multiplicity. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.
vl : (M, M) double or complex ndarray
The normalized left eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.
vr : (M, M) double or complex ndarray
The normalized right eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
<h2 id="raises_8">Raises<a class="headerlink" href="#raises_8" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
<p>a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
[-0.        +0.70710678j, -0.        -0.70710678j]])
linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
[0.        -0.70710678j, 0.        +0.70710678j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_ev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w and optionally right eigenvectors v of a::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<p>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>a_band : (u+1, M) array_like
The bands of the M by M matrix a.
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
eigvals_only : bool, optional
Compute only the eigenvalues and no eigenvectors.
(Default: calculate also eigenvectors)
overwrite_a_band : bool, optional
Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
max_ev : int, optional
For select=='v', maximum number of eigenvalues expected.
For other values of select, has no meaning.</p>
<p>In doubt, leave this parameter untouched.</p>
<p>check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.
v : (M, M) float or complex ndarray
The normalized eigenvector corresponding to the eigenvalue w[i] is
the column v[:,i].</p>
<h2 id="raises_9">Raises<a class="headerlink" href="#raises_9" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eig : eigenvalues and right eigenvectors of general arrays.
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eig_banded
A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])
Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])
w, v = eig_banded(Ab, lower=True)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True
w = eig_banded(Ab, lower=True, eigvals_only=True)
w
array([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Request only the eigenvalues between <code>[-3, 4]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>w, v = eig_banded(Ab, lower=True, select='v', select_range=[-3, 4])
w
array([-2.22987175,  3.95222349])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w and optionally eigenvectors v of matrix <code>a</code>, where
<code>b</code> is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
eigvals_only : bool, optional
Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.
v : (M, N) complex ndarray
(if eigvals_only == False)</p>
<p>The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].</p>
<p>Normalization:</p>
<p>type 1 and 3: v.conj() a      v  = w</p>
<p>type 2: inv(v).conj() a  inv(v) = w</p>
<p>type = 1 or 2: v.conj() b      v  = I</p>
<p>type = 3: v.conj() inv(b) v  = I</p>
<h2 id="raises_10">Raises<a class="headerlink" href="#raises_10" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>eigvalsh : eigenvalues of symmetric or Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="notes_15">Notes<a class="headerlink" href="#notes_15" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w, v = eigh(A)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh_tridiagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> and optionally right eigenvectors <code>v</code> of <code>a</code>::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>d : ndarray, shape (ndim,)
The diagonal elements of the array.
e : ndarray, shape (ndim-1,)
The off-diagonal elements of the array.
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
tol : float
The absolute tolerance to which each eigenvalue is required
(only used when 'stebz' is the <code>lapack_driver</code>).
An eigenvalue (or cluster) is considered to have converged if it
lies in an interval of this width. If &lt;= 0. (default),
the value <code>eps*|a|</code> is used where eps is the machine precision,
and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.
lapack_driver : str
LAPACK function to use, can be 'auto', 'stemr', 'stebz', 'sterf',
or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
and 'stebz' otherwise. When 'stebz' is used to find the eigenvalues and
<code>eigvals_only=False</code>, then a second LAPACK call (to <code>?STEIN</code>) is
used to find the corresponding eigenvectors. 'sterf' can only be
used when <code>eigvals_only=True</code> and <code>select='a'</code>. 'stev' can only
be used when <code>select='a'</code>.</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.
v : (M, M) ndarray
The normalized eigenvector corresponding to the eigenvalue <code>w[i]</code> is
the column <code>v[:,i]</code>.</p>
<h2 id="raises_11">Raises<a class="headerlink" href="#raises_11" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices</p>
<h2 id="notes_16">Notes<a class="headerlink" href="#notes_16" title="Permanent link">&para;</a></h2>
<p>This function makes use of LAPACK <code>S/DSTEMR</code> routines.</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh_tridiagonal
d = 3<em>np.ones(4)
e = -1</em>np.ones(3)
w, v = eigh_tridiagonal(d, e)
A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
If omitted, identity matrix is assumed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities
or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its multiplicity
but not in any specific order. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.</p>
<h2 id="raises_12">Raises<a class="headerlink" href="#raises_12" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>eig : eigenvalues and right eigenvectors of general arrays.
eigvalsh : eigenvalues of symmetric or Hermitian arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w of a::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<p>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>a_band : (u+1, M) array_like
The bands of the M by M matrix a.
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
overwrite_a_band : bool, optional
Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.</p>
<h2 id="raises_13">Raises<a class="headerlink" href="#raises_13" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices
eigvals : eigenvalues of general arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvals_banded
A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])
Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])
w = eigvals_banded(Ab, lower=True)
w
array([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w of matrix a, where b is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt; hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.</p>
<h2 id="raises_14">Raises<a class="headerlink" href="#raises_14" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigvals : eigenvalues of general arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices</p>
<h2 id="notes_17">Notes<a class="headerlink" href="#notes_17" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvalsh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w = eigvalsh(A)
w
array([-3.74637491, -0.76263923,  6.08502336, 12.42399079])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh_tridiagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> of <code>a</code>::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>d : ndarray, shape (ndim,)
The diagonal elements of the array.
e : ndarray, shape (ndim-1,)
The off-diagonal elements of the array.
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
tol : float
The absolute tolerance to which each eigenvalue is required
(only used when <code>lapack_driver='stebz'</code>).
An eigenvalue (or cluster) is considered to have converged if it
lies in an interval of this width. If &lt;= 0. (default),
the value <code>eps*|a|</code> is used where eps is the machine precision,
and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.
lapack_driver : str
LAPACK function to use, can be 'auto', 'stemr', 'stebz',  'sterf',
or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
and 'stebz' otherwise. 'sterf' and 'stev' can only be used when
<code>select='a'</code>.</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.</p>
<h2 id="raises_15">Raises<a class="headerlink" href="#raises_15" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvalsh_tridiagonal, eigvalsh
d = 3<em>np.ones(4)
e = -1</em>np.ones(3)
w = eigvalsh_tridiagonal(d, e)
A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)
w2 = eigvalsh(A)  # Verify with other eigenvalue routines
np.allclose(w - w2, np.zeros(4))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">einsum</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>einsum(subscripts, *operands, out=None, dtype=None, order='K',
casting='safe', optimize=False)</p>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In <em>implicit</em> mode <code>einsum</code> computes these values.</p>
<p>In <em>explicit</em> mode, <code>einsum</code> provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.</p>
<p>See the notes and examples for clarification.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>subscripts : str
Specifies the subscripts for summation as comma separated list of
subscript labels. An implicit (classical Einstein summation)
calculation is performed unless the explicit indicator '-&gt;' is
included as well as subscript labels of the precise output form.
operands : list of array_like
These are the arrays for the operation.
out : ndarray, optional
If provided, the calculation is done into this array.
dtype : {data-type, None}, optional
If provided, forces the calculation to use the data type specified.
Note that you may have to also give a more liberal <code>casting</code>
parameter to allow the conversions. Default is None.
order : {'C', 'F', 'A', 'K'}, optional
Controls the memory layout of the output. 'C' means it should
be C contiguous. 'F' means it should be Fortran contiguous,
'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
'K' means it should be as close to the layout as the inputs as
is possible, including arbitrarily permuted axes.
Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
Controls what kind of data casting may occur.  Setting this to
'unsafe' is not recommended, as it can adversely affect accumulations.</p>
<ul>
<li>'no' means the data types should not be cast at all.</li>
<li>'equiv' means only byte-order changes are allowed.</li>
<li>'safe' means only casts which can preserve values are allowed.</li>
<li>'same_kind' means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>'unsafe' means any data conversions may be done.</li>
</ul>
<p>Default is 'safe'.
optimize : {False, True, 'greedy', 'optimal'}, optional
Controls if intermediate optimization should occur. No optimization
will occur if False and True will default to the 'greedy' algorithm.
Also accepts an explicit contraction list from the <code>np.einsum_path</code>
function. See <code>np.einsum_path</code> for more details. Defaults to False.</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>output : ndarray
The calculation based on the Einstein summation convention.</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</p>
<h2 id="notes_18">Notes<a class="headerlink" href="#notes_18" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.6.0</p>
<p>The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. <code>einsum</code>
provides a succinct way of representing these.</p>
<p>A non-exhaustive list of these operations,
which can be computed by <code>einsum</code>, is shown below along with examples:</p>
<ul>
<li>Trace of an array, :py:func:<code>numpy.trace</code>.</li>
<li>Return a diagonal, :py:func:<code>numpy.diag</code>.</li>
<li>Array axis summations, :py:func:<code>numpy.sum</code>.</li>
<li>Transpositions and permutations, :py:func:<code>numpy.transpose</code>.</li>
<li>Matrix multiplication and dot product, :py:func:<code>numpy.matmul</code> :py:func:<code>numpy.dot</code>.</li>
<li>Vector inner and outer products, :py:func:<code>numpy.inner</code> :py:func:<code>numpy.outer</code>.</li>
<li>Broadcasting, element-wise and scalar multiplication, :py:func:<code>numpy.multiply</code>.</li>
<li>Tensor contractions, :py:func:<code>numpy.tensordot</code>.</li>
<li>Chained array operations, in efficient calculation order, :py:func:<code>numpy.einsum_path</code>.</li>
</ul>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so <code>np.einsum('i,i', a, b)</code>
is equivalent to :py:func:<code>np.inner(a,b) &lt;numpy.inner&gt;</code>. If a label
appears only once, it is not summed, so <code>np.einsum('i', a)</code> produces a
view of <code>a</code> with no changes. A further example <code>np.einsum('ij,jk', a, b)</code>
describes traditional matrix multiplication and is equivalent to
:py:func:<code>np.matmul(a,b) &lt;numpy.matmul&gt;</code>. Repeated subscript labels in one
operand take the diagonal. For example, <code>np.einsum('ii', a)</code> is equivalent
to :py:func:<code>np.trace(a) &lt;numpy.trace&gt;</code>.</p>
<p>In <em>implicit mode</em>, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that <code>np.einsum('ij', a)</code> doesn't affect a 2D array, while
<code>np.einsum('ji', a)</code> takes its transpose. Additionally,
<code>np.einsum('ij,jk', a, b)</code> returns a matrix multiplication, while,
<code>np.einsum('ij,jh', a, b)</code> returns the transpose of the
multiplication since subscript 'h' precedes subscript 'i'.</p>
<p>In <em>explicit mode</em> the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier '-&gt;' as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
<code>np.einsum('i-&gt;', a)</code> is like :py:func:<code>np.sum(a, axis=-1) &lt;numpy.sum&gt;</code>,
and <code>np.einsum('ii-&gt;i', a)</code> is like :py:func:<code>np.diag(a) &lt;numpy.diag&gt;</code>.
The difference is that <code>einsum</code> does not allow broadcasting by default.
Additionally <code>np.einsum('ij,jh-&gt;ih', a, b)</code> directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code>np.einsum('...ii-&gt;...i', a)</code>.
To take the trace along the first and last axes,
you can do <code>np.einsum('i...i', a)</code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
<code>np.einsum('ij...,jk...-&gt;ik...', a, b)</code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code>np.einsum('ii-&gt;i', a)</code>
produces a view (changed in version 1.10.0).</p>
<p><code>einsum</code> also provides an alternative way to provide the subscripts
and operands as <code>einsum(op0, sublist0, op1, sublist1, ..., [sublistout])</code>.
If the output shape is not provided in this format <code>einsum</code> will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding <code>einsum</code> calls with the two
parameter methods.</p>
<p>.. versionadded:: 1.10.0</p>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code>np.einsum('ijk...-&gt;kji...', a)</code> will now
have the same effect as :py:func:<code>np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;</code>
and <code>np.einsum('ii-&gt;i', a)</code> will return a writeable view of the diagonal
of a 2D array.</p>
<p>.. versionadded:: 1.12.0</p>
<p>Added the <code>optimize</code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>Typically a 'greedy' algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases 'optimal'
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.</p>
<p>See :py:func:<code>numpy.einsum_path</code> for more details.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(25).reshape(5,5)
b = np.arange(5)
c = np.arange(6).reshape(2,3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Trace of a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('ii', a)
60
np.einsum(a, [0,0])
60
np.trace(a)
60</p>
</blockquote>
</blockquote>
</blockquote>
<p>Extract the diagonal (requires explicit form):</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('ii-&gt;i', a)
array([ 0,  6, 12, 18, 24])
np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
np.diag(a)
array([ 0,  6, 12, 18, 24])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Sum over an axis (requires explicit form):</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('ij-&gt;i', a)
array([ 10,  35,  60,  85, 110])
np.einsum(a, [0,1], [0])
array([ 10,  35,  60,  85, 110])
np.sum(a, axis=1)
array([ 10,  35,  60,  85, 110])</p>
</blockquote>
</blockquote>
</blockquote>
<p>For higher dimensional arrays summing a single axis can be done with ellipsis:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('...j-&gt;...', a)
array([ 10,  35,  60,  85, 110])
np.einsum(a, [Ellipsis,1], [Ellipsis])
array([ 10,  35,  60,  85, 110])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute a matrix transpose, or reorder any number of axes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('ji', c)
array([[0, 3],
[1, 4],
[2, 5]])
np.einsum('ij-&gt;ji', c)
array([[0, 3],
[1, 4],
[2, 5]])
np.einsum(c, [1,0])
array([[0, 3],
[1, 4],
[2, 5]])
np.transpose(c)
array([[0, 3],
[1, 4],
[2, 5]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Vector inner products:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('i,i', b, b)
30
np.einsum(b, [0], b, [0])
30
np.inner(b,b)
30</p>
</blockquote>
</blockquote>
</blockquote>
<p>Matrix vector multiplication:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
np.dot(a, b)
array([ 30,  80, 130, 180, 230])
np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Broadcasting and scalar multiplication:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
[ 9, 12, 15]])
np.einsum(',ij', 3, c)
array([[ 0,  3,  6],
[ 9, 12, 15]])
np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
[ 9, 12, 15]])
np.multiply(3, c)
array([[ 0,  3,  6],
[ 9, 12, 15]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Vector outer product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8]])
np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8]])
np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
[0, 2, 4, 6, 8]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Tensor contraction:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(60.).reshape(3,4,5)
b = np.arange(24.).reshape(4,3,2)
np.einsum('ijk,jil-&gt;kl', a, b)
array([[4400., 4730.],
[4532., 4874.],
[4664., 5018.],
[4796., 5162.],
[4928., 5306.]])
np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[4400., 4730.],
[4532., 4874.],
[4664., 5018.],
[4796., 5162.],
[4928., 5306.]])
np.tensordot(a,b, axes=([1,0],[0,1]))
array([[4400., 4730.],
[4532., 4874.],
[4664., 5018.],
[4796., 5162.],
[4928., 5306.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Writeable returned arrays (since version 1.10.0):</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.zeros((3, 3))
np.einsum('ii-&gt;i', a)[:] = 1
a
array([[1., 0., 0.],
[0., 1., 0.],
[0., 0., 1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Example of ellipsis use:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(6).reshape((3,2))
b = np.arange(12).reshape((4,3))
np.einsum('ki,jk-&gt;ij', a, b)
array([[10, 28, 46, 64],
[13, 40, 67, 94]])
np.einsum('ki,...k-&gt;i...', a, b)
array([[10, 28, 46, 64],
[13, 40, 67, 94]])
np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
[13, 40, 67, 94]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a 'greedy' path or pre-computing the
'optimal' path and repeatedly applying it, using an
<code>einsum_path</code> insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.ones(64).reshape(2,4,8)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Basic <code>einsum</code>: ~1520ms  (benchmarked on 3.1GHz Intel i5.)</p>
<blockquote>
<blockquote>
<blockquote>
<p>for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Sub-optimal <code>einsum</code> (due to repeated path calculation time): ~330ms</p>
<blockquote>
<blockquote>
<blockquote>
<p>for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Greedy <code>einsum</code> (faster optimal path approximation): ~160ms</p>
<blockquote>
<blockquote>
<blockquote>
<p>for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Optimal <code>einsum</code> (best usage pattern in some use cases): ~110ms</p>
<blockquote>
<blockquote>
<blockquote>
<p>path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0]
for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>empty(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, without initializing entries.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of int
Shape of the empty array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
Desired output data-type for the array, e.g, <code>numpy.int8</code>. Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of uninitialized (arbitrary) data of the given shape, dtype, and
order.  Object arrays will be initialized to None.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_19">Notes<a class="headerlink" href="#notes_19" title="Permanent link">&para;</a></h2>
<p><code>empty</code>, unlike <code>zeros</code>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
[  2.13182611e-314,   3.06959433e-309]])         #uninitialized</p>
<p>np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],
[  496041986,    19249760]])                     #uninitialized</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h2 id="parameters_39">Parameters<a class="headerlink" href="#parameters_39" title="Permanent link">&para;</a></h2>
<p>N : int
Number of rows in the output.
M : int, optional
Number of columns in the output. If None, defaults to <code>N</code>.
k : int, optional
Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.
dtype : data-type, optional
Data-type of the returned array.
order : {'C', 'F'}, optional
Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<p>.. versionadded:: 1.14.0</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>I : ndarray of shape (N,M)
An array where all elements are equal to zero, except for the <code>k</code>-th
diagonal, whose values are equal to one.</p>
<h2 id="see-also_20">See Also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.eye(2, dtype=int)
array([[1, 0],
[0, 1]])
np.eye(3, k=1)
array([[0.,  1.,  0.],
[0.,  0.,  1.],
[0.,  0.,  0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flatnonzero</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices that are non-zero in the flattened version of a.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<h2 id="parameters_40">Parameters<a class="headerlink" href="#parameters_40" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>res : ndarray
Output array, containing the indices of the elements of <code>a.ravel()</code>
that are non-zero.</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.</p>
<h2 id="examples_35">Examples<a class="headerlink" href="#examples_35" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(-2, 3)
x
array([-2, -1,  0,  1,  2])
np.flatnonzero(x)
array([0, 1, 3, 4])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Use the indices of the non-zero elements as an index array to extract
these elements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_41">Parameters<a class="headerlink" href="#parameters_41" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_20">Notes<a class="headerlink" href="#notes_20" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_36">Examples<a class="headerlink" href="#examples_36" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_1">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_1" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hessenberg</span> <span class="o">:</span> <span class="o">?</span><span class="n">calc_q</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Hessenberg form of a matrix.</p>
<p>The Hessenberg decomposition is::</p>
<p>A = Q H Q^H</p>
<p>where <code>Q</code> is unitary/orthogonal and <code>H</code> has only zero elements below
the first sub-diagonal.</p>
<h2 id="parameters_42">Parameters<a class="headerlink" href="#parameters_42" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to bring into Hessenberg form.
calc_q : bool, optional
Whether to compute the transformation matrix.  Default is False.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>H : (M, M) ndarray
Hessenberg form of <code>a</code>.
Q : (M, M) ndarray
Unitary/orthogonal similarity transformation matrix <code>A = Q H Q^H</code>.
Only returned if <code>calc_q=True</code>.</p>
<h2 id="examples_37">Examples<a class="headerlink" href="#examples_37" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hessenberg
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
H, Q = hessenberg(A, calc_q=True)
H
array([[  2.        , -11.65843866,   1.42005301,   0.25349066],
[ -9.94987437,  14.53535354,  -5.31022304,   2.43081618],
[  0.        ,  -1.83299243,   0.38969961,  -0.51527034],
[  0.        ,   0.        ,  -3.83189513,   1.07494686]])
np.allclose(Q @ H @ Q.conj().T - A, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iscomplex</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a bool array, where True if input element is complex.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<h2 id="parameters_43">Parameters<a class="headerlink" href="#parameters_43" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.</p>
<h2 id="returns_43">Returns<a class="headerlink" href="#returns_43" title="Permanent link">&para;</a></h2>
<p>out : ndarray of bools
Output array.</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>isreal
iscomplexobj : Return True if x is a complex type or an array of complex
numbers.</p>
<h2 id="examples_38">Examples<a class="headerlink" href="#examples_38" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iscomplexobj</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, <code>iscomplexobj</code> evaluates to True.</p>
<h2 id="parameters_44">Parameters<a class="headerlink" href="#parameters_44" title="Permanent link">&para;</a></h2>
<p>x : any
The input can be of any type and shape.</p>
<h2 id="returns_44">Returns<a class="headerlink" href="#returns_44" title="Permanent link">&para;</a></h2>
<p>iscomplexobj : bool
The return value, True if <code>x</code> is of a complex type or has at least
one complex element.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>isrealobj, iscomplex</p>
<h2 id="examples_39">Examples<a class="headerlink" href="#examples_39" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.iscomplexobj(1)
False
np.iscomplexobj(1+0j)
True
np.iscomplexobj([3, 1+0j, True])
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h2 id="parameters_45">Parameters<a class="headerlink" href="#parameters_45" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_45">Returns<a class="headerlink" href="#returns_45" title="Permanent link">&para;</a></h2>
<p>y : ndarray, bool
True where <code>x</code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>isinf, isneginf, isposinf, isnan</p>
<h2 id="notes_21">Notes<a class="headerlink" href="#notes_21" title="Permanent link">&para;</a></h2>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <code>x</code> is a scalar input, or if
first and second arguments have different shapes.</p>
<h2 id="examples_40">Examples<a class="headerlink" href="#examples_40" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.isfinite(1)
True
np.isfinite(0)
True
np.isfinite(np.nan)
False
np.isfinite(np.inf)
False
np.isfinite(np.NINF)
False
np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])</p>
<p>x = np.array([-np.inf, 0., np.inf])
y = np.array([2, 2, 2])
np.isfinite(x, y)
array([0, 1, 0])
y
array([0, 1, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <code>a</code>,
containing the indices of the non-zero elements in that
dimension. The values in <code>a</code> are always tested and returned in
row-major, C-style order.</p>
<p>To group the indices by element, rather than dimension, use <code>argwhere</code>,
which returns a row for each non-zero element.</p>
<p>.. note::</p>
<p>When called on a zero-d array or scalar, <code>nonzero(a)</code> is treated
as <code>nonzero(atleast1d(a))</code>.</p>
<p>.. deprecated:: 1.17.0</p>
<p>Use <code>atleast1d</code> explicitly if this behavior is deliberate.</p>
<h2 id="parameters_46">Parameters<a class="headerlink" href="#parameters_46" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.</p>
<h2 id="returns_46">Returns<a class="headerlink" href="#returns_46" title="Permanent link">&para;</a></h2>
<p>tuple_of_arrays : tuple
Indices of elements that are non-zero.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>flatnonzero :
Return indices that are non-zero in the flattened version of the input
array.
ndarray.nonzero :
Equivalent ndarray method.
count_nonzero :
Counts the number of non-zero elements in the input array.</p>
<h2 id="notes_22">Notes<a class="headerlink" href="#notes_22" title="Permanent link">&para;</a></h2>
<p>While the nonzero values can be obtained with <code>a[nonzero(a)]</code>, it is
recommended to use <code>x[x.astype(bool)]</code> or <code>x[x != 0]</code> instead, which
will correctly handle 0-d arrays.</p>
<h2 id="examples_41">Examples<a class="headerlink" href="#examples_41" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
x
array([[3, 0, 0],
[0, 4, 0],
[5, 6, 0]])
np.nonzero(x)
(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</p>
<p>x[np.nonzero(x)]
array([3, 4, 5, 6])
np.transpose(np.nonzero(x))
array([[0, 0],
[1, 1],
[2, 0],
[2, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A common use for <code>nonzero</code> is to find the indices of an array, where
a condition is True.  Given an array <code>a</code>, the condition <code>a</code> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <code>a</code> where the condition is true.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
a &gt; 3
array([[False, False, False],
[ True,  True,  True],
[ True,  True,  True]])
np.nonzero(a &gt; 3)
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using this result to index <code>a</code> is equivalent to using the mask directly:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a[np.nonzero(a &gt; 3)]
array([4, 5, 6, 7, 8, 9])
a[a &gt; 3]  # prefer this spelling
array([4, 5, 6, 7, 8, 9])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>nonzero</code> can also be called as a method of the array.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(a &gt; 3).nonzero()
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_47">Parameters<a class="headerlink" href="#parameters_47" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_47">Returns<a class="headerlink" href="#returns_47" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_23">Notes<a class="headerlink" href="#notes_23" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_42">Examples<a class="headerlink" href="#examples_42" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_48">Parameters<a class="headerlink" href="#parameters_48" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_48">Returns<a class="headerlink" href="#returns_48" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_43">Examples<a class="headerlink" href="#examples_43" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Decomp_cholesky</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_49">Parameters<a class="headerlink" href="#parameters_49" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_49">Returns<a class="headerlink" href="#returns_49" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_44">Examples<a class="headerlink" href="#examples_44" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h2 id="parameters_50">Parameters<a class="headerlink" href="#parameters_50" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_50">Returns<a class="headerlink" href="#returns_50" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
class ndarray is returned.</p>
<h2 id="raises_16">Raises<a class="headerlink" href="#raises_16" title="Permanent link">&para;</a></h2>
<p>ValueError
Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_45">Examples<a class="headerlink" href="#examples_45" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray_chkfinite(a, dtype=float)
array([1., 2.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2, np.inf]
try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h2 id="parameters_51">Parameters<a class="headerlink" href="#parameters_51" title="Permanent link">&para;</a></h2>
<p>arys1, arys2, ... : array_like
One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</p>
<h2 id="returns_51">Returns<a class="headerlink" href="#returns_51" title="Permanent link">&para;</a></h2>
<p>res, res2, ... : ndarray
An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
<h2 id="see-also_29">See Also<a class="headerlink" href="#see-also_29" title="Permanent link">&para;</a></h2>
<p>atleast_1d, atleast_3d</p>
<h2 id="examples_46">Examples<a class="headerlink" href="#examples_46" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.atleast_2d(3.0)
array([[3.]])</p>
<p>x = np.arange(3.0)
np.atleast_2d(x)
array([[0., 1., 2.]])
np.atleast_2d(x).base is x
True</p>
<p>np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix, to use in cho_solve</p>
<p>Returns a matrix containing the Cholesky decomposition,
<code>A = L L*</code> or <code>A = U* U</code> of a Hermitian positive-definite matrix <code>a</code>.
The return value can be directly used as the first parameter to cho_solve.</p>
<p>.. warning::
The returned matrix also contains random data in the entries not
used by the Cholesky decomposition. If you need to zero these
entries, use the function <code>cholesky</code> instead.</p>
<h2 id="parameters_52">Parameters<a class="headerlink" href="#parameters_52" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to be decomposed
lower : bool, optional
Whether to compute the upper or lower triangular Cholesky factorization
(Default: upper-triangular)
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_52">Returns<a class="headerlink" href="#returns_52" title="Permanent link">&para;</a></h2>
<p>c : (M, M) ndarray
Matrix whose upper or lower triangle contains the Cholesky factor
of <code>a</code>. Other parts of the matrix contain random data.
lower : bool
Flag indicating whether the factor is in the lower or upper triangle</p>
<h2 id="raises_17">Raises<a class="headerlink" href="#raises_17" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails.</p>
<h2 id="see-also_30">See also<a class="headerlink" href="#see-also_30" title="Permanent link">&para;</a></h2>
<p>cho_solve : Solve a linear set equations using the Cholesky factorization
of a matrix.</p>
<h2 id="examples_47">Examples<a class="headerlink" href="#examples_47" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cho_factor
A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])
c, low = cho_factor(A)
c
array([[3.        , 1.        , 0.33333333, 1.66666667],
[3.        , 2.44948974, 1.90515869, -0.27216553],
[1.        , 5.        , 2.29330749, 0.8559528 ],
[5.        , 1.        , 2.        , 1.55418563]])
np.allclose(np.triu(c).T @ np. triu(c) - A, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">c_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p>
<h2 id="parameters_53">Parameters<a class="headerlink" href="#parameters_53" title="Permanent link">&para;</a></h2>
<p>(c, lower) : tuple, (array, bool)
Cholesky factorization of a, as given by cho_factor
b : array
Right-hand side
overwrite_b : bool, optional
Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_53">Returns<a class="headerlink" href="#returns_53" title="Permanent link">&para;</a></h2>
<p>x : array
The solution to the system A x = b</p>
<h2 id="see-also_31">See also<a class="headerlink" href="#see-also_31" title="Permanent link">&para;</a></h2>
<p>cho_factor : Cholesky factorization of a matrix</p>
<h2 id="examples_48">Examples<a class="headerlink" href="#examples_48" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cho_factor, cho_solve
A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])
c, low = cho_factor(A)
x = cho_solve((c, low), [1, 1, 1, 1])
np.allclose(A @ x - [1, 1, 1, 1], np.zeros(4))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">cb_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations <code>A x = b</code>, given the Cholesky factorization of
the banded hermitian <code>A</code>.</p>
<h2 id="parameters_54">Parameters<a class="headerlink" href="#parameters_54" title="Permanent link">&para;</a></h2>
<p>(cb, lower) : tuple, (ndarray, bool)
<code>cb</code> is the Cholesky factorization of A, as given by cholesky_banded.
<code>lower</code> must be the same value that was given to cholesky_banded.
b : array_like
Right-hand side
overwrite_b : bool, optional
If True, the function will overwrite the values in <code>b</code>.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_54">Returns<a class="headerlink" href="#returns_54" title="Permanent link">&para;</a></h2>
<p>x : array
The solution to the system A x = b</p>
<h2 id="see-also_32">See also<a class="headerlink" href="#see-also_32" title="Permanent link">&para;</a></h2>
<p>cholesky_banded : Cholesky factorization of a banded matrix</p>
<h2 id="notes_24">Notes<a class="headerlink" href="#notes_24" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_49">Examples<a class="headerlink" href="#examples_49" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky_banded, cho_solve_banded
Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])
A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)
A = A + A.conj().T + np.diag(Ab[2, :])
c = cholesky_banded(Ab)
x = cho_solve_banded((c, False), np.ones(5))
np.allclose(A @ x - np.ones(5), np.zeros(5))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix.</p>
<p>Returns the Cholesky decomposition, :math:<code>A = L L^*</code> or
:math:<code>A = U^* U</code> of a Hermitian positive-definite matrix A.</p>
<h2 id="parameters_55">Parameters<a class="headerlink" href="#parameters_55" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to be decomposed
lower : bool, optional
Whether to compute the upper or lower triangular Cholesky
factorization.  Default is upper-triangular.
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_55">Returns<a class="headerlink" href="#returns_55" title="Permanent link">&para;</a></h2>
<p>c : (M, M) ndarray
Upper- or lower-triangular Cholesky factor of <code>a</code>.</p>
<h2 id="raises_18">Raises<a class="headerlink" href="#raises_18" title="Permanent link">&para;</a></h2>
<p>LinAlgError : if decomposition fails.</p>
<h2 id="examples_50">Examples<a class="headerlink" href="#examples_50" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky
a = np.array([[1,-2j],[2j,5]])
L = cholesky(a, lower=True)
L
array([[ 1.+0.j,  0.+0.j],
[ 0.+2.j,  1.+0.j]])
L @ L.T.conj()
array([[ 1.+0.j,  0.-2.j],
[ 0.+2.j,  5.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cholesky decompose a banded Hermitian positive-definite matrix</p>
<p>The matrix a is stored in ab either in lower diagonal or upper
diagonal ordered form::</p>
<p>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>Example of ab (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<h2 id="parameters_56">Parameters<a class="headerlink" href="#parameters_56" title="Permanent link">&para;</a></h2>
<p>ab : (u + 1, M) array_like
Banded matrix
overwrite_ab : bool, optional
Discard data in ab (may enhance performance)
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_56">Returns<a class="headerlink" href="#returns_56" title="Permanent link">&para;</a></h2>
<p>c : (u + 1, M) ndarray
Cholesky factorization of a, in the same banded format as ab</p>
<h2 id="see-also_33">See also<a class="headerlink" href="#see-also_33" title="Permanent link">&para;</a></h2>
<p>cho_solve_banded : Solve a linear set equations, given the Cholesky factorization
of a banded hermitian.</p>
<h2 id="examples_51">Examples<a class="headerlink" href="#examples_51" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky_banded
from numpy import allclose, zeros, diag
Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])
A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)
A = A + A.conj().T + np.diag(Ab[2, :])
c = cholesky_banded(Ab)
C = np.diag(c[0, 2:], k=2) + np.diag(c[1, 1:], k=1) + np.diag(c[2, :])
np.allclose(C.conj().T @ C - A, np.zeros((5, 5)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_57">Parameters<a class="headerlink" href="#parameters_57" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_57">Returns<a class="headerlink" href="#returns_57" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_25">Notes<a class="headerlink" href="#notes_25" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_52">Examples<a class="headerlink" href="#examples_52" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_2">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_2" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Decomp_lu</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_58">Parameters<a class="headerlink" href="#parameters_58" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_58">Returns<a class="headerlink" href="#returns_58" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_34">See Also<a class="headerlink" href="#see-also_34" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_53">Examples<a class="headerlink" href="#examples_53" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h2 id="parameters_59">Parameters<a class="headerlink" href="#parameters_59" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_59">Returns<a class="headerlink" href="#returns_59" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
class ndarray is returned.</p>
<h2 id="raises_19">Raises<a class="headerlink" href="#raises_19" title="Permanent link">&para;</a></h2>
<p>ValueError
Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h2 id="see-also_35">See Also<a class="headerlink" href="#see-also_35" title="Permanent link">&para;</a></h2>
<p>asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_54">Examples<a class="headerlink" href="#examples_54" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray_chkfinite(a, dtype=float)
array([1., 2.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2, np.inf]
try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. arrays are used to determine optimal prefix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_60">Parameters<a class="headerlink" href="#parameters_60" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_60">Returns<a class="headerlink" href="#returns_60" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_26">Notes<a class="headerlink" href="#notes_26" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_55">Examples<a class="headerlink" href="#examples_55" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_3">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_3" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permute_l</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_61">Parameters<a class="headerlink" href="#parameters_61" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Array to decompose
permute_l : bool, optional
Perform the multiplication P*L  (Default: do not permute)
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_61">Returns<a class="headerlink" href="#returns_61" title="Permanent link">&para;</a></h2>
<p><strong>(If permute_l == False)</strong></p>
<p>p : (M, M) ndarray
Permutation matrix
l : (M, K) ndarray
Lower triangular or trapezoidal matrix with unit diagonal.
K = min(M, N)
u : (K, N) ndarray
Upper triangular or trapezoidal matrix</p>
<p><strong>(If permute_l == True)</strong></p>
<p>pl : (M, K) ndarray
Permuted L matrix.
K = min(M, N)
u : (K, N) ndarray
Upper triangular or trapezoidal matrix</p>
<h2 id="notes_27">Notes<a class="headerlink" href="#notes_27" title="Permanent link">&para;</a></h2>
<p>This is a LU factorization routine written for SciPy.</p>
<h2 id="examples_56">Examples<a class="headerlink" href="#examples_56" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
p, l, u = lu(A)
np.allclose(A - p @ l @ u, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_62">Parameters<a class="headerlink" href="#parameters_62" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
overwrite_a : bool, optional
Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_62">Returns<a class="headerlink" href="#returns_62" title="Permanent link">&para;</a></h2>
<p>lu : (N, N) ndarray
Matrix containing U in its upper triangle, and L in its lower triangle.
The unit diagonal elements of L are not stored.
piv : (N,) ndarray
Pivot indices representing the permutation matrix P:
row i of matrix was interchanged with row piv[i].</p>
<h2 id="see-also_36">See also<a class="headerlink" href="#see-also_36" title="Permanent link">&para;</a></h2>
<p>lu_solve : solve an equation system using the LU factorization of a matrix</p>
<h2 id="notes_28">Notes<a class="headerlink" href="#notes_28" title="Permanent link">&para;</a></h2>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h2 id="examples_57">Examples<a class="headerlink" href="#examples_57" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
lu, piv = lu_factor(A)
piv
array([2, 2, 3, 3], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<blockquote>
<blockquote>
<blockquote>
<p>piv_py = [2, 0, 3, 1]
L, U = np.tril(lu, k=-1) + np.eye(4), np.triu(lu)
np.allclose(A[piv_py] - L @ U, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h2 id="parameters_63">Parameters<a class="headerlink" href="#parameters_63" title="Permanent link">&para;</a></h2>
<p>(lu, piv)
Factorization of the coefficient matrix a, as given by lu_factor
b : array
Right-hand side
trans : {0, 1, 2}, optional
Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========
overwrite_b : bool, optional
Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_63">Returns<a class="headerlink" href="#returns_63" title="Permanent link">&para;</a></h2>
<p>x : array
Solution to the system</p>
<h2 id="see-also_37">See also<a class="headerlink" href="#see-also_37" title="Permanent link">&para;</a></h2>
<p>lu_factor : LU factorize a matrix</p>
<h2 id="examples_58">Examples<a class="headerlink" href="#examples_58" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor, lu_solve
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
b = np.array([1, 1, 1, 1])
lu, piv = lu_factor(A)
x = lu_solve((lu, piv), b)
np.allclose(A @ x - b, np.zeros((4,)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span> <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Decomp_qr</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_64">Parameters<a class="headerlink" href="#parameters_64" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_64">Returns<a class="headerlink" href="#returns_64" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_29">Notes<a class="headerlink" href="#notes_29" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_59">Examples<a class="headerlink" href="#examples_59" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_4">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_4" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_65">Parameters<a class="headerlink" href="#parameters_65" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic', 'raw'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes). The final option 'raw'
(added in SciPy 0.11) makes the function return two matrices
(Q, TAU) in the internal format used by LAPACK.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition. If pivoting, compute the decomposition
<code>A P = Q R</code> as above, but where P is chosen such that the diagonal
of R is non-increasing.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_65">Returns<a class="headerlink" href="#returns_65" title="Permanent link">&para;</a></h2>
<p>Q : float or complex ndarray
Of shape (M, M), or (M, K) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.
R : float or complex ndarray
Of shape (M, N), or (K, N) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
P : int ndarray
Of shape (N,) for <code>pivoting=True</code>. Not returned if
<code>pivoting=False</code>.</p>
<h2 id="raises_20">Raises<a class="headerlink" href="#raises_20" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails</p>
<h2 id="notes_30">Notes<a class="headerlink" href="#notes_30" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_60">Examples<a class="headerlink" href="#examples_60" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)</p>
<p>q, r = linalg.qr(a)
np.allclose(a, np.dot(q, r))
True
q.shape, r.shape
((9, 9), (9, 6))</p>
<p>r2 = linalg.qr(a, mode='r')
np.allclose(r, r2)
True</p>
<p>q3, r3 = linalg.qr(a, mode='economic')
q3.shape, r3.shape
((9, 6), (6, 6))</p>
<p>q4, r4, p4 = linalg.qr(a, pivoting=True)
d = np.abs(np.diag(r4))
np.all(d[1:] &lt;= d[:-1])
True
np.allclose(a[:, p4], np.dot(q4, r4))
True
q4.shape, r4.shape, p4.shape
((9, 9), (9, 6), (6,))</p>
<p>q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)
q5.shape, r5.shape, p5.shape
((9, 6), (6, 6), (6,))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_multiply</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conjugate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_c</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the QR decomposition and multiply Q with a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular. Multiply Q with a vector or a matrix c.</p>
<h2 id="parameters_66">Parameters<a class="headerlink" href="#parameters_66" title="Permanent link">&para;</a></h2>
<p>a : (M, N), array_like
Input array
c : array_like
Input array to be multiplied by <code>q</code>.
mode : {'left', 'right'}, optional
<code>Q @ c</code> is returned if mode is 'left', <code>c @ Q</code> is returned if
mode is 'right'.
The shape of c must be appropriate for the matrix multiplications,
if mode is 'left', <code>min(a.shape) == c.shape[0]</code>,
if mode is 'right', <code>a.shape[0] == c.shape[1]</code>.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition, see the documentation of qr.
conjugate : bool, optional
Whether Q should be complex-conjugated. This might be faster
than explicit conjugation.
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
overwrite_c : bool, optional
Whether data in c is overwritten (may improve performance).
If this is used, c must be big enough to keep the result,
i.e. <code>c.shape[0]</code> = <code>a.shape[0]</code> if mode is 'left'.</p>
<h2 id="returns_66">Returns<a class="headerlink" href="#returns_66" title="Permanent link">&para;</a></h2>
<p>CQ : ndarray
The product of <code>Q</code> and <code>c</code>.
R : (K, N), ndarray
R array of the resulting QR factorization where <code>K = min(M, N)</code>.
P : (N,) ndarray
Integer pivot array. Only returned when <code>pivoting=True</code>.</p>
<h2 id="raises_21">Raises<a class="headerlink" href="#raises_21" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if QR decomposition fails.</p>
<h2 id="notes_31">Notes<a class="headerlink" href="#notes_31" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines <code>?GEQRF</code>, <code>?ORMQR</code>,
<code>?UNMQR</code>, and <code>?GEQP3</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_61">Examples<a class="headerlink" href="#examples_61" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import qr_multiply, qr
A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])
qc, r1, piv1 = qr_multiply(A, 2<em>np.eye(4), pivoting=1)
qc
array([[-1.,  1., -1.],
[-1., -1.,  1.],
[-1., -1., -1.],
[-1.,  1.,  1.]])
r1
array([[-6., -3., -5.            ],
[ 0., -1., -1.11022302e-16],
[ 0.,  0., -1.            ]])
piv1
array([1, 0, 2], dtype=int32)
q2, r2, piv2 = qr(A, mode='economic', pivoting=1)
np.allclose(2</em>q2 - qc, np.zeros((4, 3)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rq</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute RQ decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = R Q</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_67">Parameters<a class="headerlink" href="#parameters_67" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_67">Returns<a class="headerlink" href="#returns_67" title="Permanent link">&para;</a></h2>
<p>R : float or complex ndarray
Of shape (M, N) or (M, K) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
Q : float or complex ndarray
Of shape (N, N) or (K, N) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.</p>
<h2 id="raises_22">Raises<a class="headerlink" href="#raises_22" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If decomposition fails.</p>
<h2 id="notes_32">Notes<a class="headerlink" href="#notes_32" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,
sorgrq, dorgrq, cungrq and zungrq.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (K, N) and (M, K) instead
of (N,N) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_62">Examples<a class="headerlink" href="#examples_62" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(6, 9)
r, q = linalg.rq(a)
np.allclose(a, r @ q)
True
r.shape, q.shape
((6, 9), (9, 9))
r2 = linalg.rq(a, mode='r')
np.allclose(r, r2)
True
r3, q3 = linalg.rq(a, mode='economic')
r3.shape, q3.shape
((6, 6), (6, 9))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">safecall</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Call a LAPACK routine, determining lwork automatically and handling
error return values</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Decomp_schur</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Single</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float32</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float32</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h2 id="parameters_68">Parameters<a class="headerlink" href="#parameters_68" title="Permanent link">&para;</a></h2>
<p>new_order : str, optional
Byte order to force; a value from the byte order specifications
above.  The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_68">Returns<a class="headerlink" href="#returns_68" title="Permanent link">&para;</a></h2>
<p>new_dtype : dtype
New <code>dtype</code> object with the given change to the byte order.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="kt">array</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2 id="parameters_69">Parameters<a class="headerlink" href="#parameters_69" title="Permanent link">&para;</a></h2>
<p>object : array_like
An array, any object exposing the array interface, an object whose
<strong>array</strong> method returns an array, or any (nested) sequence.
dtype : data-type, optional
The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.
copy : bool, optional
If true (default), then the object is copied.  Otherwise, a copy will
only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<code>dtype</code>, <code>order</code>, etc.).
order : {'K', 'A', 'C', 'F'}, optional
Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless 'F' is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.
subok : bool, optional
If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).
ndmin : int, optional
Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</p>
<h2 id="returns_69">Returns<a class="headerlink" href="#returns_69" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array object satisfying the specified requirements.</p>
<h2 id="see-also_38">See Also<a class="headerlink" href="#see-also_38" title="Permanent link">&para;</a></h2>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<h2 id="notes_33">Notes<a class="headerlink" href="#notes_33" title="Permanent link">&para;</a></h2>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h2 id="examples_63">Examples<a class="headerlink" href="#examples_63" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3])
array([1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([[1, 2], [3, 4]])
array([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
x['a']
array([1, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.array(np.mat('1 2; 3 4'))
array([[1, 2],
[3, 4]])</p>
<p>np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h2 id="parameters_70">Parameters<a class="headerlink" href="#parameters_70" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_70">Returns<a class="headerlink" href="#returns_70" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <code>a</code> is a
subclass of ndarray, a base class ndarray is returned.</p>
<h2 id="see-also_39">See Also<a class="headerlink" href="#see-also_39" title="Permanent link">&para;</a></h2>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_64">Examples<a class="headerlink" href="#examples_64" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray(a)
array([1, 2])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2])
np.asarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([1, 2], dtype=np.float32)
np.asarray(a, dtype=np.float32) is a
True
np.asarray(a, dtype=np.float64) is a
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
<blockquote>
<blockquote>
<p>issubclass(np.recarray, np.ndarray)
True
a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
np.asarray(a) is a
False
np.asanyarray(a) is a
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h2 id="parameters_71">Parameters<a class="headerlink" href="#parameters_71" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to 'C'.</p>
<h2 id="returns_71">Returns<a class="headerlink" href="#returns_71" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array interpretation of <code>a</code>.  No copy is performed if the input
is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
class ndarray is returned.</p>
<h2 id="raises_23">Raises<a class="headerlink" href="#raises_23" title="Permanent link">&para;</a></h2>
<p>ValueError
Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h2 id="see-also_40">See Also<a class="headerlink" href="#see-also_40" title="Permanent link">&para;</a></h2>
<p>asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
positions.</p>
<h2 id="examples_65">Examples<a class="headerlink" href="#examples_65" title="Permanent link">&para;</a></h2>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2]
np.asarray_chkfinite(a, dtype=float)
array([1., 2.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2, np.inf]
try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print('ValueError')
...
ValueError</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">callable</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]</p>
<h2 id="parameters_72">Parameters<a class="headerlink" href="#parameters_72" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
If omitted, identity matrix is assumed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities
or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_72">Returns<a class="headerlink" href="#returns_72" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its multiplicity
but not in any specific order. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.</p>
<h2 id="raises_24">Raises<a class="headerlink" href="#raises_24" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge</p>
<h2 id="see-also_41">See Also<a class="headerlink" href="#see-also_41" title="Permanent link">&para;</a></h2>
<p>eig : eigenvalues and right eigenvectors of general arrays.
eigvalsh : eigenvalues of symmetric or Hermitian arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices</p>
<h2 id="examples_66">Examples<a class="headerlink" href="#examples_66" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_73">Parameters<a class="headerlink" href="#parameters_73" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_73">Returns<a class="headerlink" href="#returns_73" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_34">Notes<a class="headerlink" href="#notes_34" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_67">Examples<a class="headerlink" href="#examples_67" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_5">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_5" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Nuc</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_74">Parameters<a class="headerlink" href="#parameters_74" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.  If <code>axis</code> is None, <code>x</code> must be 1-D or 2-D, unless <code>ord</code>
is None. If both <code>axis</code> and <code>ord</code> are None, the 2-norm of
<code>x.ravel</code> will be returned.
ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object. The default is None.
axis : {None, int, 2-tuple of ints}, optional.
If <code>axis</code> is an integer, it specifies the axis of <code>x</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>x</code>
is 1-D) or a matrix norm (when <code>x</code> is 2-D) is returned. The default
is None.</p>
<p>.. versionadded:: 1.8.0</p>
<p>keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>x</code>.</p>
<p>.. versionadded:: 1.10.0</p>
<h2 id="returns_74">Returns<a class="headerlink" href="#returns_74" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_35">Notes<a class="headerlink" href="#notes_35" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The nuclear norm is the sum of the singular values.</p>
<h2 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_68">Examples<a class="headerlink" href="#examples_68" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import linalg as LA
a = np.arange(9) - 4
a
array([-4, -3, -2, ...,  2,  3,  4])
b = a.reshape((3, 3))
b
array([[-4, -3, -2],
[-1,  0,  1],
[ 2,  3,  4]])</p>
<p>LA.norm(a)
7.745966692414834
LA.norm(b)
7.745966692414834
LA.norm(b, 'fro')
7.745966692414834
LA.norm(a, np.inf)
4.0
LA.norm(b, np.inf)
9.0
LA.norm(a, -np.inf)
0.0
LA.norm(b, -np.inf)
2.0</p>
<p>LA.norm(a, 1)
20.0
LA.norm(b, 1)
7.0
LA.norm(a, -1)
-4.6566128774142013e-010
LA.norm(b, -1)
6.0
LA.norm(a, 2)
7.745966692414834
LA.norm(b, 2)
7.3484692283495345</p>
<p>LA.norm(a, -2)
0.0
LA.norm(b, -2)
1.8570331885190563e-016 # may vary
LA.norm(a, 3)
5.8480354764257312 # may vary
LA.norm(a, -3)
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the <code>axis</code> argument to compute vector norms:</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([[ 1, 2, 3],
...               [-1, 1, 4]])
LA.norm(c, axis=0)
array([ 1.41421356,  2.23606798,  5.        ])
LA.norm(c, axis=1)
array([ 3.74165739,  4.24264069])
LA.norm(c, ord=1, axis=1)
array([ 6.,  6.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the <code>axis</code> argument to compute matrix norms:</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = np.arange(8).reshape(2,2,2)
LA.norm(m, axis=(1,2))
array([  3.74165739,  11.22497216])
LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
(3.7416573867739413, 11.224972160321824)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper triangular
complex-valued Schur form.</p>
<h2 id="parameters_75">Parameters<a class="headerlink" href="#parameters_75" title="Permanent link">&para;</a></h2>
<p>T : (M, M) array_like
Real Schur form of the original array
Z : (M, M) array_like
Schur transformation matrix
check_finite : bool, optional
Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_75">Returns<a class="headerlink" href="#returns_75" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Complex Schur form of the original array
Z : (M, M) ndarray
Schur transformation matrix corresponding to the complex form</p>
<h2 id="see-also_42">See Also<a class="headerlink" href="#see-also_42" title="Permanent link">&para;</a></h2>
<p>schur : Schur decomposition of an array</p>
<h2 id="examples_69">Examples<a class="headerlink" href="#examples_69" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, rsf2csf
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])
T2 , Z2 = rsf2csf(T, Z)
T2
array([[2.65896708+0.j, -1.64592781+0.743164187j, -1.21516887+1.00660462j],
[0.+0.j , -0.32948354+8.02254558e-01j, -0.82115218-2.77555756e-17j],
[0.+0.j , 0.+0.j, -0.32948354-0.802254558j]])
Z2
array([[0.72711591+0.j,  0.28220393-0.31385693j,  0.51319638-0.17258824j],
[0.52839428+0.j,  0.24720268+0.41635578j, -0.68079517-0.15118243j],
[0.43829436+0.j, -0.76618703+0.01873251j, -0.03063006+0.46857912j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<p>A = Z T Z^H</p>
<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular.  In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h2 id="parameters_76">Parameters<a class="headerlink" href="#parameters_76" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
output : {'real', 'complex'}, optional
Construct the real or complex Schur decomposition (for real matrices).
lwork : int, optional
Work array size. If None or -1, it is automatically computed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance).
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True).
Alternatively, string parameters may be used::</p>
<p>'lhp'   Left-hand plane (x.real &lt; 0.0)
'rhp'   Right-hand plane (x.real &gt; 0.0)
'iuc'   Inside the unit circle (x<em>x.conjugate() &lt;= 1.0)
'ouc'   Outside the unit circle (x</em>x.conjugate() &gt; 1.0)</p>
<p>Defaults to None (no sorting).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_76">Returns<a class="headerlink" href="#returns_76" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Schur form of A. It is real-valued for the real Schur decomposition.
Z : (M, M) ndarray
An unitary Schur transformation matrix for A.
It is real-valued for the real Schur decomposition.
sdim : int
If and only if sorting was requested, a third return value will
contain the number of eigenvalues satisfying the sort condition.</p>
<h2 id="raises_25">Raises<a class="headerlink" href="#raises_25" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Error raised under three conditions:</p>
<ol>
<li>The algorithm failed due to a failure of the QR algorithm to
compute all eigenvalues</li>
<li>If eigenvalue sorting was requested, the eigenvalues could not be
reordered due to a failure to separate eigenvalues, usually because
of poor conditioning</li>
<li>If eigenvalue sorting was requested, roundoff errors caused the
leading eigenvalues to no longer satisfy the sorting condition</li>
</ol>
<h2 id="see-also_43">See also<a class="headerlink" href="#see-also_43" title="Permanent link">&para;</a></h2>
<p>rsf2csf : Convert real Schur form to complex Schur form</p>
<h2 id="examples_70">Examples<a class="headerlink" href="#examples_70" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, eigvals
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])</p>
<p>T2, Z2 = schur(A, output='complex')
T2
array([[ 2.65896708, -1.22839825+1.32378589j,  0.42590089+1.51937378j],
[ 0.        , -0.32948354+0.80225456j, -0.59877807+0.56192146j],
[ 0.        ,  0.                    , -0.32948354-0.80225456j]])
eigvals(T2)
array([2.65896708, -0.32948354+0.80225456j, -0.32948354-0.80225456j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<blockquote>
<blockquote>
<blockquote>
<p>T3, Z3, sdim = schur(A, output='complex', sort=lambda x: x.imag &gt; 0)
sdim
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Decomp_svd</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">arccos</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of <code>cos</code> so that, if <code>y = cos(x)</code>, then <code>x = arccos(y)</code>.</p>
<h2 id="parameters_77">Parameters<a class="headerlink" href="#parameters_77" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>x</code>-coordinate on the unit circle.
For real arguments, the domain is [-1, 1].
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_77">Returns<a class="headerlink" href="#returns_77" title="Permanent link">&para;</a></h2>
<p>angle : ndarray
The angle of the ray intersecting the unit circle at the given
<code>x</code>-coordinate in radians [0, pi].
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_44">See Also<a class="headerlink" href="#see-also_44" title="Permanent link">&para;</a></h2>
<p>cos, arctan, arcsin, emath.arccos</p>
<h2 id="notes_36">Notes<a class="headerlink" href="#notes_36" title="Permanent link">&para;</a></h2>
<p><code>arccos</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that <code>cos(z) = x</code>. The convention is to return
the angle <code>z</code> whose real part lies in <code>[0, pi]</code>.</p>
<p>For real-valued input data types, <code>arccos</code> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytic function that
has branch cuts <code>[-inf, -1]</code> and <code>[1, inf]</code> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse <code>cos</code> is also known as <code>acos</code> or cos^-1.</p>
<h2 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h2>
<p>M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/</p>
<h2 id="examples_71">Examples<a class="headerlink" href="#examples_71" title="Permanent link">&para;</a></h2>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.arccos([1, -1])
array([ 0.        ,  3.14159265])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot arccos:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt
x = np.linspace(-1, 1, num=100)
plt.plot(x, np.arccos(x))
plt.axis('tight')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse sine, element-wise.</p>
<h2 id="parameters_78">Parameters<a class="headerlink" href="#parameters_78" title="Permanent link">&para;</a></h2>
<p>x : array_like
<code>y</code>-coordinate on the unit circle.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_78">Returns<a class="headerlink" href="#returns_78" title="Permanent link">&para;</a></h2>
<p>angle : ndarray
The inverse sine of each element in <code>x</code>, in radians and in the
closed interval <code>[-pi/2, pi/2]</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_45">See Also<a class="headerlink" href="#see-also_45" title="Permanent link">&para;</a></h2>
<p>sin, cos, arccos, tan, arctan, arctan2, emath.arcsin</p>
<h2 id="notes_37">Notes<a class="headerlink" href="#notes_37" title="Permanent link">&para;</a></h2>
<p><code>arcsin</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that :math:<code>sin(z) = x</code>.  The convention is to
return the angle <code>z</code> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <em>arcsin</em> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arcsin</code> is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.</p>
<p>The inverse sine is also known as <code>asin</code> or sin^{-1}.</p>
<h2 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h2>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79ff.
http://www.math.sfu.ca/~cbm/aands/</p>
<h2 id="examples_72">Examples<a class="headerlink" href="#examples_72" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.arcsin(1)     # pi/2
1.5707963267948966
np.arcsin(-1)    # -pi/2
-1.5707963267948966
np.arcsin(0)
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clip</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a_min</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a_max</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code>[0, 1]</code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<p>Equivalent to but faster than <code>np.maximum(a_min, np.minimum(a, a_max))</code>.
No check is performed to ensure <code>a_min &lt; a_max</code>.</p>
<h2 id="parameters_79">Parameters<a class="headerlink" href="#parameters_79" title="Permanent link">&para;</a></h2>
<p>a : array_like
Array containing elements to clip.
a_min : scalar or array_like or None
Minimum value. If None, clipping is not performed on lower
interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be
None.
a_max : scalar or array_like or None
Maximum value. If None, clipping is not performed on upper
interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be
None. If <code>a_min</code> or <code>a_max</code> are array_like, then the three
arrays will be broadcasted to match their shapes.
out : ndarray, optional
The results will be placed in this array. It may be the input
array for in-place clipping.  <code>out</code> must be of the right shape
to hold the output.  Its type is preserved.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_79">Returns<a class="headerlink" href="#returns_79" title="Permanent link">&para;</a></h2>
<p>clipped_array : ndarray
An array with the elements of <code>a</code>, but where values
&lt; <code>a_min</code> are replaced with <code>a_min</code>, and those &gt; <code>a_max</code>
with <code>a_max</code>.</p>
<h2 id="see-also_46">See Also<a class="headerlink" href="#see-also_46" title="Permanent link">&para;</a></h2>
<p>ufuncs-output-type</p>
<h2 id="examples_73">Examples<a class="headerlink" href="#examples_73" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(10)
np.clip(a, 1, 8)
array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.clip(a, 3, 6, out=a)
array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
a = np.arange(10)
a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code>numpy.diagonal</code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<h2 id="parameters_80">Parameters<a class="headerlink" href="#parameters_80" title="Permanent link">&para;</a></h2>
<p>v : array_like
If <code>v</code> is a 2-D array, return a copy of its <code>k</code>-th diagonal.
If <code>v</code> is a 1-D array, return a 2-D array with <code>v</code> on the <code>k</code>-th
diagonal.
k : int, optional
Diagonal in question. The default is 0. Use <code>k&gt;0</code> for diagonals
above the main diagonal, and <code>k&lt;0</code> for diagonals below the main
diagonal.</p>
<h2 id="returns_80">Returns<a class="headerlink" href="#returns_80" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The extracted diagonal or constructed diagonal array.</p>
<h2 id="see-also_47">See Also<a class="headerlink" href="#see-also_47" title="Permanent link">&para;</a></h2>
<p>diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.</p>
<h2 id="examples_74">Examples<a class="headerlink" href="#examples_74" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(9).reshape((3,3))
x
array([[0, 1, 2],
[3, 4, 5],
[6, 7, 8]])</p>
<p>np.diag(x)
array([0, 4, 8])
np.diag(x, k=1)
array([1, 5])
np.diag(x, k=-1)
array([3, 7])</p>
<p>np.diag(np.diag(x))
array([[0, 0, 0],
[0, 4, 0],
[0, 0, 8]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagsvd</span> <span class="o">:</span> <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct the sigma matrix in SVD from singular values and size M, N.</p>
<h2 id="parameters_81">Parameters<a class="headerlink" href="#parameters_81" title="Permanent link">&para;</a></h2>
<p>s : (M,) or (N,) array_like
Singular values
M : int
Size of the matrix whose singular values are <code>s</code>.
N : int
Size of the matrix whose singular values are <code>s</code>.</p>
<h2 id="returns_81">Returns<a class="headerlink" href="#returns_81" title="Permanent link">&para;</a></h2>
<p>S : (M, N) ndarray
The S-matrix in the singular value decomposition</p>
<h2 id="see-also_48">See Also<a class="headerlink" href="#see-also_48" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
svdvals : Compute singular values of a matrix.</p>
<h2 id="examples_75">Examples<a class="headerlink" href="#examples_75" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import diagsvd
vals = np.array([1, 2, 3])  # The array representing the computed svd
diagsvd(vals, 3, 4)
array([[1, 0, 0, 0],
[0, 2, 0, 0],
[0, 0, 3, 0]])
diagsvd(vals, 4, 3)
array([[1, 0, 0],
[0, 2, 0],
[0, 0, 3],
[0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_82">Parameters<a class="headerlink" href="#parameters_82" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_82">Returns<a class="headerlink" href="#returns_82" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_26">Raises<a class="headerlink" href="#raises_26" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_49">See Also<a class="headerlink" href="#see-also_49" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_76">Examples<a class="headerlink" href="#examples_76" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_83">Parameters<a class="headerlink" href="#parameters_83" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_83">Returns<a class="headerlink" href="#returns_83" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_38">Notes<a class="headerlink" href="#notes_38" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_77">Examples<a class="headerlink" href="#examples_77" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_6">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_6" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">null_space</span> <span class="o">:</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the null space of A using SVD</p>
<h2 id="parameters_84">Parameters<a class="headerlink" href="#parameters_84" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
Input array
rcond : float, optional
Relative condition number. Singular values <code>s</code> smaller than
<code>rcond * max(s)</code> are considered zero.
Default: floating point eps * max(M,N).</p>
<h2 id="returns_84">Returns<a class="headerlink" href="#returns_84" title="Permanent link">&para;</a></h2>
<p>Z : (N, K) ndarray
Orthonormal basis for the null space of A.
K = dimension of effective null space, as determined by rcond</p>
<h2 id="see-also_50">See also<a class="headerlink" href="#see-also_50" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
orth : Matrix range</p>
<h2 id="examples_78">Examples<a class="headerlink" href="#examples_78" title="Permanent link">&para;</a></h2>
<p>One-dimensional null space:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import null_space
A = np.array([[1, 1], [1, 1]])
ns = null_space(A)
ns * np.sign(ns[0,0])  # Remove the sign ambiguity of the vector
array([[ 0.70710678],
[-0.70710678]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two-dimensional null space:</p>
<blockquote>
<blockquote>
<blockquote>
<p>B = np.random.rand(3, 5)
Z = null_space(B)
Z.shape
(5, 2)
np.allclose(B.dot(Z), 0)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>The basis vectors are orthonormal (up to rounding error):</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z.T.dot(Z)
array([[  1.00000000e+00,   6.92087741e-17],
[  6.92087741e-17,   1.00000000e+00]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orth</span> <span class="o">:</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the range of A using SVD</p>
<h2 id="parameters_85">Parameters<a class="headerlink" href="#parameters_85" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
Input array
rcond : float, optional
Relative condition number. Singular values <code>s</code> smaller than
<code>rcond * max(s)</code> are considered zero.
Default: floating point eps * max(M,N).</p>
<h2 id="returns_85">Returns<a class="headerlink" href="#returns_85" title="Permanent link">&para;</a></h2>
<p>Q : (M, K) ndarray
Orthonormal basis for the range of A.
K = effective rank of A, as determined by rcond</p>
<h2 id="see-also_51">See also<a class="headerlink" href="#see-also_51" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
null_space : Matrix null space</p>
<h2 id="examples_79">Examples<a class="headerlink" href="#examples_79" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import orth
A = np.array([[2, 0, 0], [0, 5, 0]])  # rank 2 array
orth(A)
array([[0., 1.],
[1., 0.]])
orth(A.T)
array([[0., 1.],
[1., 0.],
[0., 0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subspace_angles</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the subspace angles between two matrices.</p>
<h2 id="parameters_86">Parameters<a class="headerlink" href="#parameters_86" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
The first input array.
B : (M, K) array_like
The second input array.</p>
<h2 id="returns_86">Returns<a class="headerlink" href="#returns_86" title="Permanent link">&para;</a></h2>
<p>angles : ndarray, shape (min(N, K),)
The subspace angles between the column spaces of <code>A</code> and <code>B</code> in
descending order.</p>
<h2 id="see-also_52">See Also<a class="headerlink" href="#see-also_52" title="Permanent link">&para;</a></h2>
<p>orth
svd</p>
<h2 id="notes_39">Notes<a class="headerlink" href="#notes_39" title="Permanent link">&para;</a></h2>
<p>This computes the subspace angles according to the formula
provided in [1]_. For equivalence with MATLAB and Octave behavior,
use <code>angles[0]</code>.</p>
<p>.. versionadded:: 1.0</p>
<h2 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h2>
<p>.. [1] Knyazev A, Argentati M (2002) Principal Angles between Subspaces
in an A-Based Scalar Product: Algorithms and Perturbation
Estimates. SIAM J. Sci. Comput. 23:2008-2040.</p>
<h2 id="examples_80">Examples<a class="headerlink" href="#examples_80" title="Permanent link">&para;</a></h2>
<p>A Hadamard matrix, which has orthogonal columns, so we expect that
the suspace angle to be :math:<code>\frac{\pi}{2}</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hadamard, subspace_angles
H = hadamard(4)
print(H)
[[ 1  1  1  1]
[ 1 -1  1 -1]
[ 1  1 -1 -1]
[ 1 -1 -1  1]]
np.rad2deg(subspace_angles(H[:, :2], H[:, 2:]))
array([ 90.,  90.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>And the subspace angle of a matrix to itself should be zero:</p>
<blockquote>
<blockquote>
<blockquote>
<p>subspace_angles(H[:, :2], H[:, :2]) &lt;= 2 * np.finfo(float).eps
array([ True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The angles between non-orthogonal subspaces are in between these extremes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.random.RandomState(0).randn(4, 3)
np.rad2deg(subspace_angles(x[:, :2], x[:, [2]]))
array([ 55.832])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h2 id="parameters_87">Parameters<a class="headerlink" href="#parameters_87" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
full_matrices : bool, optional
If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
<code>K = min(M, N)</code>.
compute_uv : bool, optional
Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
Whether to use the more efficient divide-and-conquer approach
(<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
<h2 id="returns_87">Returns<a class="headerlink" href="#returns_87" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Unitary matrix having left singular vectors as columns.
Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.
s : ndarray
The singular values, sorted in non-increasing order.
Of shape (K,), with <code>K = min(M, N)</code>.
Vh : ndarray
Unitary matrix having right singular vectors as rows.
Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h2 id="raises_27">Raises<a class="headerlink" href="#raises_27" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="see-also_53">See also<a class="headerlink" href="#see-also_53" title="Permanent link">&para;</a></h2>
<p>svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_81">Examples<a class="headerlink" href="#examples_81" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
m, n = 9, 6
a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
U, s, Vh = linalg.svd(a)
U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Reconstruct the original matrix from the decomposition:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sigma = np.zeros((m, n))
for i in range(min(m, n)):
...     sigma[i, i] = s[i]
a1 = np.dot(U, np.dot(sigma, Vh))
np.allclose(a, a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>U, s, Vh = linalg.svd(a, full_matrices=False)
U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
S = np.diag(s)
np.allclose(a, np.dot(U, np.dot(S, Vh)))
True</p>
<p>s2 = linalg.svd(a, compute_uv=False)
np.allclose(s, s2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svdvals</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute singular values of a matrix.</p>
<h2 id="parameters_88">Parameters<a class="headerlink" href="#parameters_88" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_88">Returns<a class="headerlink" href="#returns_88" title="Permanent link">&para;</a></h2>
<p>s : (min(M, N),) ndarray
The singular values, sorted in decreasing order.</p>
<h2 id="raises_28">Raises<a class="headerlink" href="#raises_28" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="notes_40">Notes<a class="headerlink" href="#notes_40" title="Permanent link">&para;</a></h2>
<p><code>svdvals(a)</code> only differs from <code>svd(a, compute_uv=False)</code> by its
handling of the edge case of empty <code>a</code>, where it returns an
empty sequence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.empty((0, 2))
from scipy.linalg import svdvals
svdvals(a)
array([], dtype=float64)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_54">See Also<a class="headerlink" href="#see-also_54" title="Permanent link">&para;</a></h2>
<p>svd : Compute the full singular value decomposition of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_82">Examples<a class="headerlink" href="#examples_82" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import svdvals
m = np.array([[1.0, 0.0],
...               [2.0, 3.0],
...               [1.0, 1.0],
...               [0.0, 2.0],
...               [1.0, 0.0]])
svdvals(m)
array([ 4.28091555,  1.63516424])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can verify the maximum singular value of <code>m</code> by computing the maximum
length of <code>m.dot(u)</code> over all the unit vectors <code>u</code> in the (x,y) plane.
We approximate 'all' the unit vectors with a large sample.  Because
of linearity, we only need the unit vectors with angles in [0, pi].</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, np.pi, 2000)
u = np.array([np.cos(t), np.sin(t)])
np.linalg.norm(m.dot(u), axis=0).max()
4.2809152422538475</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>p</code> is a projection matrix with rank 1.  With exact arithmetic,
its singular values would be [1, 0, 0, 0].</p>
<blockquote>
<blockquote>
<blockquote>
<p>v = np.array([0.1, 0.3, 0.9, 0.3])
p = np.outer(v, v)
svdvals(p)
array([  1.00000000e+00,   2.02021698e-17,   1.56692500e-17,
8.15115104e-34])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The singular values of an orthogonal matrix are all 1.  Here we
create a random orthogonal matrix by using the <code>rvs()</code> method of
<code>scipy.stats.ortho_group</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import ortho_group
np.random.seed(123)
orth = ortho_group.rvs(4)
svdvals(orth)
array([ 1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">where</span> <span class="o">:</span> <span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">condition</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>where(condition, [x, y])</p>
<p>Return elements chosen from <code>x</code> or <code>y</code> depending on <code>condition</code>.</p>
<p>.. note::
When only <code>condition</code> is provided, this function is a shorthand for
<code>np.asarray(condition).nonzero()</code>. Using <code>nonzero</code> directly should be
preferred, as it behaves correctly for subclasses. The rest of this
documentation covers only the case where all three arguments are
provided.</p>
<h2 id="parameters_89">Parameters<a class="headerlink" href="#parameters_89" title="Permanent link">&para;</a></h2>
<p>condition : array_like, bool
Where True, yield <code>x</code>, otherwise yield <code>y</code>.
x, y : array_like
Values from which to choose. <code>x</code>, <code>y</code> and <code>condition</code> need to be
broadcastable to some shape.</p>
<h2 id="returns_89">Returns<a class="headerlink" href="#returns_89" title="Permanent link">&para;</a></h2>
<p>out : ndarray
An array with elements from <code>x</code> where <code>condition</code> is True, and elements
from <code>y</code> elsewhere.</p>
<h2 id="see-also_55">See Also<a class="headerlink" href="#see-also_55" title="Permanent link">&para;</a></h2>
<p>choose
nonzero : The function that is called when x and y are omitted</p>
<h2 id="notes_41">Notes<a class="headerlink" href="#notes_41" title="Permanent link">&para;</a></h2>
<p>If all the arrays are 1-D, <code>where</code> is equivalent to::</p>
<p>[xv if c else yv
for c, xv, yv in zip(condition, x, y)]</p>
<h2 id="examples_83">Examples<a class="headerlink" href="#examples_83" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(10)
a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.where(a &lt; 5, a, 10*a)
array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This can be used on multidimensional arrays too:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
[3, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The shapes of x, y, and the condition are broadcast together:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x, y = np.ogrid[:3, :4]
np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast
array([[10,  0,  0,  0],
[10, 11,  1,  1],
[10, 11, 12,  2]])</p>
<p>a = np.array([[0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6]])
np.where(a &lt; 4, a, -1)  # -1 is broadcast
array([[ 0,  1,  2],
[ 0,  2, -1],
[ 0,  3, -1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2 id="parameters_90">Parameters<a class="headerlink" href="#parameters_90" title="Permanent link">&para;</a></h2>
<p>shape : int or tuple of ints
Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.
dtype : data-type, optional
The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
<code>numpy.float64</code>.
order : {'C', 'F'}, optional, default: 'C'
Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
<h2 id="returns_90">Returns<a class="headerlink" href="#returns_90" title="Permanent link">&para;</a></h2>
<p>out : ndarray
Array of zeros with the given shape, dtype, and order.</p>
<h2 id="see-also_56">See Also<a class="headerlink" href="#see-also_56" title="Permanent link">&para;</a></h2>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<h2 id="examples_84">Examples<a class="headerlink" href="#examples_84" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])</p>
<p>np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])</p>
<p>np.zeros((2, 1))
array([[ 0.],
[ 0.]])</p>
<p>s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
[ 0.,  0.]])</p>
<p>np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
array([(0, 0), (0, 0)],
dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Flinalg</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. arrays are used to determine optimal prefix.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_column_major_storage</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>None</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Lapack</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">cgegv</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>cgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alpha,beta,vl,vr,info = cgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>cgegv</code>.</p>
<h2 id="parameters_91">Parameters<a class="headerlink" href="#parameters_91" title="Permanent link">&para;</a></h2>
<p>a : input rank-2 array('F') with bounds (n,n)
b : input rank-2 array('F') with bounds (n,n)</p>
<h2 id="other-parameters">Other Parameters<a class="headerlink" href="#other-parameters" title="Permanent link">&para;</a></h2>
<p>compute_vl : input int, optional
Default: 1
compute_vr : input int, optional
Default: 1
overwrite_a : input int, optional
Default: 0
overwrite_b : input int, optional
Default: 0
lwork : input int, optional
Default: max(2*n,1)</p>
<h2 id="returns_91">Returns<a class="headerlink" href="#returns_91" title="Permanent link">&para;</a></h2>
<p>alpha : rank-1 array('F') with bounds (n)
beta : rank-1 array('F') with bounds (n)
vl : rank-2 array('F') with bounds (ldvl,n)
vr : rank-2 array('F') with bounds (ldvr,n)
info : int</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dgegv</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>dgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alphar,alphai,beta,vl,vr,info = dgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>dgegv</code>.</p>
<h2 id="parameters_92">Parameters<a class="headerlink" href="#parameters_92" title="Permanent link">&para;</a></h2>
<p>a : input rank-2 array('d') with bounds (n,n)
b : input rank-2 array('d') with bounds (n,n)</p>
<h2 id="other-parameters_1">Other Parameters<a class="headerlink" href="#other-parameters_1" title="Permanent link">&para;</a></h2>
<p>compute_vl : input int, optional
Default: 1
compute_vr : input int, optional
Default: 1
overwrite_a : input int, optional
Default: 0
overwrite_b : input int, optional
Default: 0
lwork : input int, optional
Default: max(8*n,1)</p>
<h2 id="returns_92">Returns<a class="headerlink" href="#returns_92" title="Permanent link">&para;</a></h2>
<p>alphar : rank-1 array('d') with bounds (n)
alphai : rank-1 array('d') with bounds (n)
beta : rank-1 array('d') with bounds (n)
vl : rank-2 array('d') with bounds (ldvl,n)
vr : rank-2 array('d') with bounds (ldvr,n)
info : int</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_best_lapack_type</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Find best-matching BLAS/LAPACK type.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_93">Parameters<a class="headerlink" href="#parameters_93" title="Permanent link">&para;</a></h2>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.
dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_93">Returns<a class="headerlink" href="#returns_93" title="Permanent link">&para;</a></h2>
<p>prefix : str
BLAS/LAPACK prefix character.
dtype : dtype
Inferred Numpy data type.
prefer_fortran : bool
Whether to prefer Fortran order routines over C order.</p>
<h2 id="examples_85">Examples<a class="headerlink" href="#examples_85" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg.blas as bla
a = np.random.rand(10,15)
b = np.asfortranarray(a)  # Change the memory layout order
bla.find_best_blas_type((a,))
('d', dtype('float64'), False)
bla.find_best_blas_type((a*1j,))
('z', dtype('complex128'), False)
bla.find_best_blas_type((b,))
('d', dtype('float64'), True)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_94">Parameters<a class="headerlink" href="#parameters_94" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_94">Returns<a class="headerlink" href="#returns_94" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_42">Notes<a class="headerlink" href="#notes_42" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_86">Examples<a class="headerlink" href="#examples_86" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_7">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_7" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sgegv</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>sgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alphar,alphai,beta,vl,vr,info = sgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>sgegv</code>.</p>
<h2 id="parameters_95">Parameters<a class="headerlink" href="#parameters_95" title="Permanent link">&para;</a></h2>
<p>a : input rank-2 array('f') with bounds (n,n)
b : input rank-2 array('f') with bounds (n,n)</p>
<h2 id="other-parameters_2">Other Parameters<a class="headerlink" href="#other-parameters_2" title="Permanent link">&para;</a></h2>
<p>compute_vl : input int, optional
Default: 1
compute_vr : input int, optional
Default: 1
overwrite_a : input int, optional
Default: 0
overwrite_b : input int, optional
Default: 0
lwork : input int, optional
Default: max(8*n,1)</p>
<h2 id="returns_95">Returns<a class="headerlink" href="#returns_95" title="Permanent link">&para;</a></h2>
<p>alphar : rank-1 array('f') with bounds (n)
alphai : rank-1 array('f') with bounds (n)
beta : rank-1 array('f') with bounds (n)
vl : rank-2 array('f') with bounds (ldvl,n)
vr : rank-2 array('f') with bounds (ldvr,n)
info : int</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zgegv</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>zgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alpha,beta,vl,vr,info = zgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>zgegv</code>.</p>
<h2 id="parameters_96">Parameters<a class="headerlink" href="#parameters_96" title="Permanent link">&para;</a></h2>
<p>a : input rank-2 array('D') with bounds (n,n)
b : input rank-2 array('D') with bounds (n,n)</p>
<h2 id="other-parameters_3">Other Parameters<a class="headerlink" href="#other-parameters_3" title="Permanent link">&para;</a></h2>
<p>compute_vl : input int, optional
Default: 1
compute_vr : input int, optional
Default: 1
overwrite_a : input int, optional
Default: 0
overwrite_b : input int, optional
Default: 0
lwork : input int, optional
Default: max(2*n,1)</p>
<h2 id="returns_96">Returns<a class="headerlink" href="#returns_96" title="Permanent link">&para;</a></h2>
<p>alpha : rank-1 array('D') with bounds (n)
beta : rank-1 array('D') with bounds (n)
vl : rank-2 array('D') with bounds (ldvl,n)
vr : rank-2 array('D') with bounds (ldvr,n)
info : int</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Linalg_version</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>



<span class="k">module</span> <span class="nc">Matfuncs</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Single</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float32</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Float32</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span> <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h2 id="parameters_97">Parameters<a class="headerlink" href="#parameters_97" title="Permanent link">&para;</a></h2>
<p>new_order : str, optional
Byte order to force; a value from the byte order specifications
above.  The default value ('S') results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <code>new_order</code> for the alternatives above.  For example,
any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</p>
<h2 id="returns_97">Returns<a class="headerlink" href="#returns_97" title="Permanent link">&para;</a></h2>
<p>new_dtype : dtype
New <code>dtype</code> object with the given change to the byte order.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">absolute</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2 id="parameters_98">Parameters<a class="headerlink" href="#parameters_98" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input array.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_98">Returns<a class="headerlink" href="#returns_98" title="Permanent link">&para;</a></h2>
<p>absolute : ndarray
An ndarray containing the absolute value of
each element in <code>x</code>.  For complex input, <code>a + ib</code>, the
absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="examples_87">Examples<a class="headerlink" href="#examples_87" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([-1.2, 1.2])
np.absolute(x)
array([ 1.2,  1.2])
np.absolute(1.2 + 1j)
1.5620499351813308</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import matplotlib.pyplot as plt</p>
<p>x = np.linspace(start=-10, stop=10, num=101)
plt.plot(x, np.absolute(x))
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
<blockquote>
<blockquote>
<p>xx = x + 1j * x[:, np.newaxis]
plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">amax</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of an array or maximum along an axis.</p>
<h2 id="parameters_99">Parameters<a class="headerlink" href="#parameters_99" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
Axis or axes along which to operate.  By default, flattened input is
used.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.
out : ndarray, optional
Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional
If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>amax</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.</p>
<p>initial : scalar, optional
The minimum value of an output element. Must be present to allow
computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
<p>where : array_like of bool, optional
Elements to compare for the maximum. See <code>~numpy.ufunc.reduce</code>
for details.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_99">Returns<a class="headerlink" href="#returns_99" title="Permanent link">&para;</a></h2>
<p>amax : ndarray or scalar
Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
If <code>axis</code> is given, the result is an array of dimension
<code>a.ndim - 1</code>.</p>
<h2 id="see-also_57">See Also<a class="headerlink" href="#see-also_57" title="Permanent link">&para;</a></h2>
<p>amin :
The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
Element-wise maximum of two arrays, propagating any NaNs.
fmax :
Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
Return the indices of the maximum values.</p>
<p>nanmin, minimum, fmin</p>
<h2 id="notes_43">Notes<a class="headerlink" href="#notes_43" title="Permanent link">&para;</a></h2>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don't use <code>amax</code> for element-wise comparison of 2 arrays; when
<code>a.shape[0]</code> is 2, <code>maximum(a[0], a[1])</code> is faster than
<code>amax(a, axis=0)</code>.</p>
<h2 id="examples_88">Examples<a class="headerlink" href="#examples_88" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(4).reshape((2,2))
a
array([[0, 1],
[2, 3]])
np.amax(a)           # Maximum of the flattened array
3
np.amax(a, axis=0)   # Maxima along the first axis
array([2, 3])
np.amax(a, axis=1)   # Maxima along the second axis
array([1, 3])
np.amax(a, where=[False, True], initial=-1, axis=0)
array([-1,  3])
b = np.arange(5, dtype=float)
b[2] = np.NaN
np.amax(b)
nan
np.amax(b, where=~np.isnan(b), initial=-1)
4.0
np.nanmax(b)
4.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.max([[-50], [10]], axis=-1, initial=0)
array([ 0, 10])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.max([5], initial=6)
6
max([5], default=6)
5</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<h2 id="parameters_100">Parameters<a class="headerlink" href="#parameters_100" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input value.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_100">Returns<a class="headerlink" href="#returns_100" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_44">Notes<a class="headerlink" href="#notes_44" title="Permanent link">&para;</a></h2>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.conj is np.conjugate
True</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_89">Examples<a class="headerlink" href="#examples_89" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.conjugate(1+2j)
(1-2j)</p>
<p>x = np.eye(2) + 1j * np.eye(2)
np.conjugate(x)
array([[ 1.-1.j,  0.-0.j],
[ 0.-0.j,  1.-1.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coshm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_101">Parameters<a class="headerlink" href="#parameters_101" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_101">Returns<a class="headerlink" href="#returns_101" title="Permanent link">&para;</a></h2>
<p>coshm : (N, N) ndarray
Hyperbolic matrix cosine of <code>A</code></p>
<h2 id="examples_90">Examples<a class="headerlink" href="#examples_90" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
c = coshm(a)
c
array([[ 11.24592233,  38.76236492],
[ 12.92078831,  50.00828725]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = tanhm(a)
s = sinhm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_102">Parameters<a class="headerlink" href="#parameters_102" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array</p>
<h2 id="returns_102">Returns<a class="headerlink" href="#returns_102" title="Permanent link">&para;</a></h2>
<p>cosm : (N, N) ndarray
Matrix cosine of A</p>
<h2 id="examples_91">Examples<a class="headerlink" href="#examples_91" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diag</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code>numpy.diagonal</code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<h2 id="parameters_103">Parameters<a class="headerlink" href="#parameters_103" title="Permanent link">&para;</a></h2>
<p>v : array_like
If <code>v</code> is a 2-D array, return a copy of its <code>k</code>-th diagonal.
If <code>v</code> is a 1-D array, return a 2-D array with <code>v</code> on the <code>k</code>-th
diagonal.
k : int, optional
Diagonal in question. The default is 0. Use <code>k&gt;0</code> for diagonals
above the main diagonal, and <code>k&lt;0</code> for diagonals below the main
diagonal.</p>
<h2 id="returns_103">Returns<a class="headerlink" href="#returns_103" title="Permanent link">&para;</a></h2>
<p>out : ndarray
The extracted diagonal or constructed diagonal array.</p>
<h2 id="see-also_58">See Also<a class="headerlink" href="#see-also_58" title="Permanent link">&para;</a></h2>
<p>diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.</p>
<h2 id="examples_92">Examples<a class="headerlink" href="#examples_92" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(9).reshape((3,3))
x
array([[0, 1, 2],
[3, 4, 5],
[6, 7, 8]])</p>
<p>np.diag(x)
array([0, 4, 8])
np.diag(x, k=1)
array([1, 5])
np.diag(x, k=-1)
array([3, 7])</p>
<p>np.diag(np.diag(x))
array([[0, 0, 0],
[0, 4, 0],
[0, 0, 8]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
</li>
</ul>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
<h2 id="parameters_104">Parameters<a class="headerlink" href="#parameters_104" title="Permanent link">&para;</a></h2>
<p>a : array_like
First argument.
b : array_like
Second argument.
out : ndarray, optional
Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<h2 id="returns_104">Returns<a class="headerlink" href="#returns_104" title="Permanent link">&para;</a></h2>
<p>output : ndarray
Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <code>out</code> is given, then it is returned.</p>
<h2 id="raises_29">Raises<a class="headerlink" href="#raises_29" title="Permanent link">&para;</a></h2>
<p>ValueError
If the last dimension of <code>a</code> is not the same size as
the second-to-last dimension of <code>b</code>.</p>
<h2 id="see-also_59">See Also<a class="headerlink" href="#see-also_59" title="Permanent link">&para;</a></h2>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : '@' operator as method with out parameter.</p>
<h2 id="examples_93">Examples<a class="headerlink" href="#examples_93" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(3, 4)
12</p>
</blockquote>
</blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot([2j, 3j], [2j, 3j])
(-13+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
[2, 2]])</p>
<p>a = np.arange(3<em>4</em>5<em>6).reshape((3,4,5,6))
b = np.arange(3</em>4<em>5</em>6)[::-1].reshape((5,4,6,3))
np.dot(a, b)[2,3,2,1,2,2]
499128
sum(a[2,3,2,:] * b[1,2,:,2])
499128</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h2 id="parameters_105">Parameters<a class="headerlink" href="#parameters_105" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like or sparse matrix
Matrix to be exponentiated.</p>
<h2 id="returns_105">Returns<a class="headerlink" href="#returns_105" title="Permanent link">&para;</a></h2>
<p>expm : (N, N) ndarray
Matrix exponential of <code>A</code>.</p>
<h2 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
SIAM Journal on Matrix Analysis and Applications.
31 (3). pp. 970-989. ISSN 1095-7162</p>
<h2 id="examples_94">Examples<a class="headerlink" href="#examples_94" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Matrix version of the formula exp(0) = 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expm(np.zeros((2,2)))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_cond</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Relative condition number of the matrix exponential in the Frobenius norm.</p>
<h2 id="parameters_106">Parameters<a class="headerlink" href="#parameters_106" title="Permanent link">&para;</a></h2>
<p>A : 2d array_like
Square input matrix with shape (N, N).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_106">Returns<a class="headerlink" href="#returns_106" title="Permanent link">&para;</a></h2>
<p>kappa : float
The relative condition number of the matrix exponential
in the Frobenius norm</p>
<h2 id="notes_45">Notes<a class="headerlink" href="#notes_45" title="Permanent link">&para;</a></h2>
<p>A faster estimate for the condition number in the 1-norm
has been published but is not yet implemented in scipy.</p>
<p>.. versionadded:: 0.14.0</p>
<h2 id="see-also_60">See also<a class="headerlink" href="#see-also_60" title="Permanent link">&para;</a></h2>
<p>expm : Compute the exponential of a matrix.
expm_frechet : Compute the Frechet derivative of the matrix exponential.</p>
<h2 id="examples_95">Examples<a class="headerlink" href="#examples_95" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm_cond
A = np.array([[-0.3, 0.2, 0.6], [0.6, 0.3, -0.1], [-0.7, 1.2, 0.9]])
k = expm_cond(A)
k
1.7787805864469866</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_frechet</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_expm</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Frechet derivative of the matrix exponential of A in the direction E.</p>
<h2 id="parameters_107">Parameters<a class="headerlink" href="#parameters_107" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix of which to take the matrix exponential.
E : (N, N) array_like
Matrix direction in which to take the Frechet derivative.
method : str, optional
Choice of algorithm.  Should be one of</p>
<ul>
<li><code>SPS</code> (default)</li>
<li><code>blockEnlarge</code></li>
</ul>
<p>compute_expm : bool, optional
Whether to compute also <code>expm_A</code> in addition to <code>expm_frechet_AE</code>.
Default is True.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_107">Returns<a class="headerlink" href="#returns_107" title="Permanent link">&para;</a></h2>
<p>expm_A : ndarray
Matrix exponential of A.
expm_frechet_AE : ndarray
Frechet derivative of the matrix exponential of A in the direction E.</p>
<p>For <code>compute_expm = False</code>, only <code>expm_frechet_AE</code> is returned.</p>
<h2 id="see-also_61">See also<a class="headerlink" href="#see-also_61" title="Permanent link">&para;</a></h2>
<p>expm : Compute the exponential of a matrix.</p>
<h2 id="notes_46">Notes<a class="headerlink" href="#notes_46" title="Permanent link">&para;</a></h2>
<p>This section describes the available implementations that can be selected
by the <code>method</code> parameter. The default method is <em>SPS</em>.</p>
<p>Method <em>blockEnlarge</em> is a naive algorithm.</p>
<p>Method <em>SPS</em> is Scaling-Pade-Squaring [1]_.
It is a sophisticated implementation which should take
only about 3/8 as much time as the naive implementation.
The asymptotics are the same.</p>
<p>.. versionadded:: 0.13.0</p>
<h2 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
Computing the Frechet Derivative of the Matrix Exponential,
with an application to Condition Number Estimation.
SIAM Journal On Matrix Analysis and Applications.,
30 (4). pp. 1639-1657. ISSN 1095-7162</p>
<h2 id="examples_96">Examples<a class="headerlink" href="#examples_96" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg
A = np.random.randn(3, 3)
E = np.random.randn(3, 3)
expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
expm_A.shape, expm_frechet_AE.shape
((3, 3), (3, 3))</p>
<p>import scipy.linalg
A = np.random.randn(3, 3)
E = np.random.randn(3, 3)
expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
M = np.zeros((6, 6))
M[:3, :3] = A; M[:3, 3:] = E; M[3:, 3:] = A
expm_M = scipy.linalg.expm(M)
np.allclose(expm_A, expm_M[:3, :3])
True
np.allclose(expm_frechet_AE, expm_M[:3, 3:])
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fractional_matrix_power</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the fractional power of a matrix.</p>
<p>Proceeds according to the discussion in section (6) of [1]_.</p>
<h2 id="parameters_108">Parameters<a class="headerlink" href="#parameters_108" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose fractional power to evaluate.
t : float
Fractional power.</p>
<h2 id="returns_108">Returns<a class="headerlink" href="#returns_108" title="Permanent link">&para;</a></h2>
<p>X : (N, N) array_like
The fractional power of the matrix.</p>
<h2 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h2>
<p>.. [1] Nicholas J. Higham and Lijing lin (2011)
'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
SIAM Journal on Matrix Analysis and Applications,
32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h2 id="examples_97">Examples<a class="headerlink" href="#examples_97" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import fractional_matrix_power
a = np.array([[1.0, 3.0], [1.0, 4.0]])
b = fractional_matrix_power(a, 0.5)
b
array([[ 0.75592895,  1.13389342],
[ 0.37796447,  1.88982237]])
np.dot(b, b)      # Verify square root
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">funm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Evaluate a matrix function specified by a callable.</p>
<p>Returns the value of matrix-valued function <code>f</code> at <code>A</code>. The
function <code>f</code> is an extension of the scalar-valued function <code>func</code>
to matrices.</p>
<h2 id="parameters_109">Parameters<a class="headerlink" href="#parameters_109" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix at which to evaluate the function
func : callable
Callable object that evaluates a scalar function f.
Must be vectorized (eg. using vectorize).
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_109">Returns<a class="headerlink" href="#returns_109" title="Permanent link">&para;</a></h2>
<p>funm : (N, N) ndarray
Value of the matrix function specified by func evaluated at <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="examples_98">Examples<a class="headerlink" href="#examples_98" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import funm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
funm(a, lambda x: x*x)
array([[  4.,  15.],
[  5.,  19.]])
a.dot(a)
array([[  4.,  15.],
[  5.,  19.]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_47">Notes<a class="headerlink" href="#notes_47" title="Permanent link">&para;</a></h2>
<p>This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).</p>
<p>If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h2>
<p>.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h2 id="parameters_110">Parameters<a class="headerlink" href="#parameters_110" title="Permanent link">&para;</a></h2>
<p>a : array_like
Square matrix to be inverted.
overwrite_a : bool, optional
Discard data in <code>a</code> (may improve performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_110">Returns<a class="headerlink" href="#returns_110" title="Permanent link">&para;</a></h2>
<p>ainv : ndarray
Inverse of the matrix <code>a</code>.</p>
<h2 id="raises_30">Raises<a class="headerlink" href="#raises_30" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular.
ValueError
If <code>a</code> is not square, or not 2-dimensional.</p>
<h2 id="examples_99">Examples<a class="headerlink" href="#examples_99" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1., 2.], [3., 4.]])
linalg.inv(a)
array([[-2. ,  1. ],
[ 1.5, -0.5]])
np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isfinite</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h2 id="parameters_111">Parameters<a class="headerlink" href="#parameters_111" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_111">Returns<a class="headerlink" href="#returns_111" title="Permanent link">&para;</a></h2>
<p>y : ndarray, bool
True where <code>x</code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_62">See Also<a class="headerlink" href="#see-also_62" title="Permanent link">&para;</a></h2>
<p>isinf, isneginf, isposinf, isnan</p>
<h2 id="notes_48">Notes<a class="headerlink" href="#notes_48" title="Permanent link">&para;</a></h2>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <code>x</code> is a scalar input, or if
first and second arguments have different shapes.</p>
<h2 id="examples_100">Examples<a class="headerlink" href="#examples_100" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.isfinite(1)
True
np.isfinite(0)
True
np.isfinite(np.nan)
False
np.isfinite(np.inf)
False
np.isfinite(np.NINF)
False
np.isfinite([np.log(-1.),1.,np.log(0)])
array([False,  True, False])</p>
<p>x = np.array([-np.inf, 0., np.inf])
y = np.array([2, 2, 2])
np.isfinite(x, y)
array([0, 1, 0])
y
array([0, 1, 0])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logical_not</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of NOT x element-wise.</p>
<h2 id="parameters_112">Parameters<a class="headerlink" href="#parameters_112" title="Permanent link">&para;</a></h2>
<p>x : array_like
Logical NOT is applied to the elements of <code>x</code>.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_112">Returns<a class="headerlink" href="#returns_112" title="Permanent link">&para;</a></h2>
<p>y : bool or ndarray of bool
Boolean result with the same shape as <code>x</code> of the NOT operation
on elements of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="see-also_63">See Also<a class="headerlink" href="#see-also_63" title="Permanent link">&para;</a></h2>
<p>logical_and, logical_or, logical_xor</p>
<h2 id="examples_101">Examples<a class="headerlink" href="#examples_101" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.logical_not(3)
False
np.logical_not([True, False, 0, 1])
array([False,  True,  True, False])</p>
<p>x = np.arange(5)
np.logical_not(x&lt;3)
array([False, False, False,  True,  True])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute matrix logarithm.</p>
<p>The matrix logarithm is the inverse of
expm: expm(logm(<code>A</code>)) == <code>A</code></p>
<h2 id="parameters_113">Parameters<a class="headerlink" href="#parameters_113" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose logarithm to evaluate
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_113">Returns<a class="headerlink" href="#returns_113" title="Permanent link">&para;</a></h2>
<p>logm : (N, N) ndarray
Matrix logarithm of <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
'Improved Inverse Scaling and Squaring Algorithms
for the Matrix Logarithm.'
SIAM Journal on Scientific Computing, 34 (4). C152-C169.
ISSN 1095-7197</p>
<p>.. [2] Nicholas J. Higham (2008)
'Functions of Matrices: Theory and Computation'
ISBN 978-0-898716-46-7</p>
<p>.. [3] Nicholas J. Higham and Lijing lin (2011)
'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
SIAM Journal on Matrix Analysis and Applications,
32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h2 id="examples_102">Examples<a class="headerlink" href="#examples_102" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import logm, expm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
b = logm(a)
b
array([[-1.02571087,  2.05142174],
[ 0.68380725,  1.02571087]])
expm(b)         # Verify expm(logm(a)) returns a
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_114">Parameters<a class="headerlink" href="#parameters_114" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_114">Returns<a class="headerlink" href="#returns_114" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_49">Notes<a class="headerlink" href="#notes_49" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_103">Examples<a class="headerlink" href="#examples_103" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span> <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of array elements over a given axis.</p>
<h2 id="parameters_115">Parameters<a class="headerlink" href="#parameters_115" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input data.
axis : None or int or tuple of ints, optional
Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.
dtype : dtype, optional
The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <code>a</code> is used by
default unless <code>a</code> has an integer dtype of less precision than the
default platform integer.  In that case, if <code>a</code> is signed then the
platform integer is used while if <code>a</code> is unsigned then an unsigned
integer of the same precision as the platform integer is used.
out : ndarray, optional
Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.
keepdims : bool, optional
If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>prod</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.
initial : scalar, optional
The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
<p>where : array_like of bool, optional
Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.17.0</p>
<h2 id="returns_115">Returns<a class="headerlink" href="#returns_115" title="Permanent link">&para;</a></h2>
<p>product_along_axis : ndarray, see <code>dtype</code> parameter above.
An array shaped as <code>a</code> but with the specified axis removed.
Returns a reference to <code>out</code> if specified.</p>
<h2 id="see-also_64">See Also<a class="headerlink" href="#see-also_64" title="Permanent link">&para;</a></h2>
<p>ndarray.prod : equivalent method
ufuncs-output-type</p>
<h2 id="notes_50">Notes<a class="headerlink" href="#notes_50" title="Permanent link">&para;</a></h2>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([536870910, 536870910, 536870910, 536870910])
np.prod(x)
16 # may vary</p>
</blockquote>
</blockquote>
</blockquote>
<p>The product of an empty array is the neutral element 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([])
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="examples_104">Examples<a class="headerlink" href="#examples_104" title="Permanent link">&para;</a></h2>
<p>By default, calculate the product of all elements:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1.,2.])
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Even when the input array is two-dimensional:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]])
24.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>But we can also specify the axis over which to multiply:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Or select specific elements to include:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1., np.nan, 3.], where=[True, False, True])
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the type of <code>x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.uint8)
np.prod(x).dtype == np.uint
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If <code>x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2, 3], dtype=np.int8)
np.prod(x).dtype == int
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can also start the product with a value other than one:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.prod([1, 2], initial=5)
10</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ravel</span> <span class="o">:</span> <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<h2 id="parameters_116">Parameters<a class="headerlink" href="#parameters_116" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.  The elements in <code>a</code> are read in the order specified by
<code>order</code>, and packed as a 1-D array.
order : {'C','F', 'A', 'K'}, optional</p>
<p>The elements of <code>a</code> are read using this index order. 'C' means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  'F' means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  'A' means to read the elements in
Fortran-like index order if <code>a</code> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  'K' means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, 'C'
index order is used.</p>
<h2 id="returns_116">Returns<a class="headerlink" href="#returns_116" title="Permanent link">&para;</a></h2>
<p>y : array_like
y is an array of the same subtype as <code>a</code>, with shape <code>(a.size,)</code>.
Note that matrices are special cased for backward compatibility, if <code>a</code>
is a matrix, then y is a 1-D ndarray.</p>
<h2 id="see-also_65">See Also<a class="headerlink" href="#see-also_65" title="Permanent link">&para;</a></h2>
<p>ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
in row-major order.
ndarray.reshape : Change the shape of an array without changing its data.</p>
<h2 id="notes_51">Notes<a class="headerlink" href="#notes_51" title="Permanent link">&para;</a></h2>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code>arr.reshape(-1)</code>
may be preferable.</p>
<h2 id="examples_105">Examples<a class="headerlink" href="#examples_105" title="Permanent link">&para;</a></h2>
<p>It is equivalent to <code>reshape(-1, order=order)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([[1, 2, 3], [4, 5, 6]])
np.ravel(x)
array([1, 2, 3, 4, 5, 6])</p>
<p>x.reshape(-1)
array([1, 2, 3, 4, 5, 6])</p>
<p>np.ravel(x, order='F')
array([1, 4, 2, 5, 3, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>order</code> is 'A', it will preserve the array's 'C' or 'F' ordering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.ravel(x.T)
array([1, 4, 2, 5, 3, 6])
np.ravel(x.T, order='A')
array([1, 2, 3, 4, 5, 6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>When <code>order</code> is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.arange(3)[::-1]; a
array([2, 1, 0])
a.ravel(order='C')
array([2, 1, 0])
a.ravel(order='K')
array([2, 1, 0])</p>
<p>a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
array([[[ 0,  2,  4],
[ 1,  3,  5]],
[[ 6,  8, 10],
[ 7,  9, 11]]])
a.ravel(order='C')
array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
a.ravel(order='K')
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper triangular
complex-valued Schur form.</p>
<h2 id="parameters_117">Parameters<a class="headerlink" href="#parameters_117" title="Permanent link">&para;</a></h2>
<p>T : (M, M) array_like
Real Schur form of the original array
Z : (M, M) array_like
Schur transformation matrix
check_finite : bool, optional
Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_117">Returns<a class="headerlink" href="#returns_117" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Complex Schur form of the original array
Z : (M, M) ndarray
Schur transformation matrix corresponding to the complex form</p>
<h2 id="see-also_66">See Also<a class="headerlink" href="#see-also_66" title="Permanent link">&para;</a></h2>
<p>schur : Schur decomposition of an array</p>
<h2 id="examples_106">Examples<a class="headerlink" href="#examples_106" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, rsf2csf
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])
T2 , Z2 = rsf2csf(T, Z)
T2
array([[2.65896708+0.j, -1.64592781+0.743164187j, -1.21516887+1.00660462j],
[0.+0.j , -0.32948354+8.02254558e-01j, -0.82115218-2.77555756e-17j],
[0.+0.j , 0.+0.j, -0.32948354-0.802254558j]])
Z2
array([[0.72711591+0.j,  0.28220393-0.31385693j,  0.51319638-0.17258824j],
[0.52839428+0.j,  0.24720268+0.41635578j, -0.68079517-0.15118243j],
[0.43829436+0.j, -0.76618703+0.01873251j, -0.03063006+0.46857912j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<p>A = Z T Z^H</p>
<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular.  In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h2 id="parameters_118">Parameters<a class="headerlink" href="#parameters_118" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
output : {'real', 'complex'}, optional
Construct the real or complex Schur decomposition (for real matrices).
lwork : int, optional
Work array size. If None or -1, it is automatically computed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance).
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True).
Alternatively, string parameters may be used::</p>
<p>'lhp'   Left-hand plane (x.real &lt; 0.0)
'rhp'   Right-hand plane (x.real &gt; 0.0)
'iuc'   Inside the unit circle (x<em>x.conjugate() &lt;= 1.0)
'ouc'   Outside the unit circle (x</em>x.conjugate() &gt; 1.0)</p>
<p>Defaults to None (no sorting).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_118">Returns<a class="headerlink" href="#returns_118" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Schur form of A. It is real-valued for the real Schur decomposition.
Z : (M, M) ndarray
An unitary Schur transformation matrix for A.
It is real-valued for the real Schur decomposition.
sdim : int
If and only if sorting was requested, a third return value will
contain the number of eigenvalues satisfying the sort condition.</p>
<h2 id="raises_31">Raises<a class="headerlink" href="#raises_31" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Error raised under three conditions:</p>
<ol>
<li>The algorithm failed due to a failure of the QR algorithm to
compute all eigenvalues</li>
<li>If eigenvalue sorting was requested, the eigenvalues could not be
reordered due to a failure to separate eigenvalues, usually because
of poor conditioning</li>
<li>If eigenvalue sorting was requested, roundoff errors caused the
leading eigenvalues to no longer satisfy the sorting condition</li>
</ol>
<h2 id="see-also_67">See also<a class="headerlink" href="#see-also_67" title="Permanent link">&para;</a></h2>
<p>rsf2csf : Convert real Schur form to complex Schur form</p>
<h2 id="examples_107">Examples<a class="headerlink" href="#examples_107" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, eigvals
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])</p>
<p>T2, Z2 = schur(A, output='complex')
T2
array([[ 2.65896708, -1.22839825+1.32378589j,  0.42590089+1.51937378j],
[ 0.        , -0.32948354+0.80225456j, -0.59877807+0.56192146j],
[ 0.        ,  0.                    , -0.32948354-0.80225456j]])
eigvals(T2)
array([2.65896708, -0.32948354+0.80225456j, -0.32948354-0.80225456j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<blockquote>
<blockquote>
<blockquote>
<p>T3, Z3, sdim = schur(A, output='complex', sort=lambda x: x.imag &gt; 0)
sdim
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span> <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Returns an element-wise indication of the sign of a number.</p>
<p>The <code>sign</code> function returns <code>-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0</code>.  nan
is returned for nan inputs.</p>
<p>For complex inputs, the <code>sign</code> function returns
<code>sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j</code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<h2 id="parameters_119">Parameters<a class="headerlink" href="#parameters_119" title="Permanent link">&para;</a></h2>
<p>x : array_like
Input values.
out : ndarray, None, or tuple of ndarray and None, optional
A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.
where : array_like, optional
This condition is broadcast over the input. At locations where the
condition is True, the <code>out</code> array will be set to the ufunc result.
Elsewhere, the <code>out</code> array will retain its original value.
Note that if an uninitialized <code>out</code> array is created via the default
<code>out=None</code>, locations within it where the condition is False will
remain uninitialized.
**kwargs
For other keyword-only arguments, see the
:ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2 id="returns_119">Returns<a class="headerlink" href="#returns_119" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The sign of <code>x</code>.
This is a scalar if <code>x</code> is a scalar.</p>
<h2 id="notes_52">Notes<a class="headerlink" href="#notes_52" title="Permanent link">&para;</a></h2>
<p>There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to :math:<code>x/\sqrt{x*x}</code>
which is different from a common alternative, :math:<code>x/|x|</code>.</p>
<h2 id="examples_108">Examples<a class="headerlink" href="#examples_108" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>np.sign([-5., 4.5])
array([-1.,  1.])
np.sign(0)
0
np.sign(5-2j)
(1+0j)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">signm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix sign function.</p>
<p>Extension of the scalar sign(x) to matrices.</p>
<h2 id="parameters_120">Parameters<a class="headerlink" href="#parameters_120" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix at which to evaluate the sign function
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_120">Returns<a class="headerlink" href="#returns_120" title="Permanent link">&para;</a></h2>
<p>signm : (N, N) ndarray
Value of the sign function at <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="examples_109">Examples<a class="headerlink" href="#examples_109" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import signm, eigvals
a = [[1,2,3], [1,2,1], [1,1,1]]
eigvals(a)
array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])
eigvals(signm(a))
array([-1.+0.j,  1.+0.j,  1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinhm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_121">Parameters<a class="headerlink" href="#parameters_121" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_121">Returns<a class="headerlink" href="#returns_121" title="Permanent link">&para;</a></h2>
<p>sinhm : (N, N) ndarray
Hyperbolic matrix sine of <code>A</code></p>
<h2 id="examples_110">Examples<a class="headerlink" href="#examples_110" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
s = sinhm(a)
s
array([[ 10.57300653,  39.28826594],
[ 13.09608865,  49.86127247]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = tanhm(a)
c = coshm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_122">Parameters<a class="headerlink" href="#parameters_122" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_122">Returns<a class="headerlink" href="#returns_122" title="Permanent link">&para;</a></h2>
<p>sinm : (N, N) ndarray
Matrix sine of <code>A</code></p>
<h2 id="examples_111">Examples<a class="headerlink" href="#examples_111" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_123">Parameters<a class="headerlink" href="#parameters_123" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_123">Returns<a class="headerlink" href="#returns_123" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_32">Raises<a class="headerlink" href="#raises_32" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_112">Examples<a class="headerlink" href="#examples_112" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_53">Notes<a class="headerlink" href="#notes_53" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrtm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix square root.</p>
<h2 id="parameters_124">Parameters<a class="headerlink" href="#parameters_124" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose square root to evaluate
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)
blocksize : integer, optional
If the blocksize is not degenerate with respect to the
size of the input array, then use a blocked algorithm. (Default: 64)</p>
<h2 id="returns_124">Returns<a class="headerlink" href="#returns_124" title="Permanent link">&para;</a></h2>
<p>sqrtm : (N, N) ndarray
Value of the sqrt function at <code>A</code></p>
<p>errest : float
(if disp == False)</p>
<p>Frobenius norm of the estimated error, ||err||_F / ||A||_F</p>
<h2 id="references_12">References<a class="headerlink" href="#references_12" title="Permanent link">&para;</a></h2>
<p>.. [1] Edvin Deadman, Nicholas J. Higham, Rui Ralha (2013)
'Blocked Schur Algorithms for Computing the Matrix Square Root,
Lecture Notes in Computer Science, 7782. pp. 171-182.</p>
<h2 id="examples_113">Examples<a class="headerlink" href="#examples_113" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import sqrtm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
r = sqrtm(a)
r
array([[ 0.75592895,  1.13389342],
[ 0.37796447,  1.88982237]])
r.dot(r)
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h2 id="parameters_125">Parameters<a class="headerlink" href="#parameters_125" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
full_matrices : bool, optional
If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
<code>K = min(M, N)</code>.
compute_uv : bool, optional
Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
Whether to use the more efficient divide-and-conquer approach
(<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
<h2 id="returns_125">Returns<a class="headerlink" href="#returns_125" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Unitary matrix having left singular vectors as columns.
Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.
s : ndarray
The singular values, sorted in non-increasing order.
Of shape (K,), with <code>K = min(M, N)</code>.
Vh : ndarray
Unitary matrix having right singular vectors as rows.
Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h2 id="raises_33">Raises<a class="headerlink" href="#raises_33" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="see-also_68">See also<a class="headerlink" href="#see-also_68" title="Permanent link">&para;</a></h2>
<p>svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_114">Examples<a class="headerlink" href="#examples_114" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
m, n = 9, 6
a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
U, s, Vh = linalg.svd(a)
U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Reconstruct the original matrix from the decomposition:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sigma = np.zeros((m, n))
for i in range(min(m, n)):
...     sigma[i, i] = s[i]
a1 = np.dot(U, np.dot(sigma, Vh))
np.allclose(a, a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>U, s, Vh = linalg.svd(a, full_matrices=False)
U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
S = np.diag(s)
np.allclose(a, np.dot(U, np.dot(S, Vh)))
True</p>
<p>s2 = linalg.svd(a, compute_uv=False)
np.allclose(s, s2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanhm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_126">Parameters<a class="headerlink" href="#parameters_126" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array</p>
<h2 id="returns_126">Returns<a class="headerlink" href="#returns_126" title="Permanent link">&para;</a></h2>
<p>tanhm : (N, N) ndarray
Hyperbolic matrix tangent of <code>A</code></p>
<h2 id="examples_115">Examples<a class="headerlink" href="#examples_115" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
t = tanhm(a)
t
array([[ 0.3428582 ,  0.51987926],
[ 0.17329309,  0.86273746]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = sinhm(a)
c = coshm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_127">Parameters<a class="headerlink" href="#parameters_127" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_127">Returns<a class="headerlink" href="#returns_127" title="Permanent link">&para;</a></h2>
<p>tanm : (N, N) ndarray
Matrix tangent of <code>A</code></p>
<h2 id="examples_116">Examples<a class="headerlink" href="#examples_116" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanm, sinm, cosm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
t = tanm(a)
t
array([[ -2.00876993,  -8.41880636],
[ -2.80626879, -10.42757629]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanm(a) = sinm(a).dot(inv(cosm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = sinm(a)
c = cosm(a)
s.dot(np.linalg.inv(c))
array([[ -2.00876993,  -8.41880636],
[ -2.80626879, -10.42757629]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span> <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Permute the dimensions of an array.</p>
<h2 id="parameters_128">Parameters<a class="headerlink" href="#parameters_128" title="Permanent link">&para;</a></h2>
<p>a : array_like
Input array.
axes : list of ints, optional
By default, reverse the dimensions, otherwise permute the axes
according to the values given.</p>
<h2 id="returns_128">Returns<a class="headerlink" href="#returns_128" title="Permanent link">&para;</a></h2>
<p>p : ndarray
<code>a</code> with its axes permuted.  A view is returned whenever
possible.</p>
<h2 id="see-also_69">See Also<a class="headerlink" href="#see-also_69" title="Permanent link">&para;</a></h2>
<p>moveaxis
argsort</p>
<h2 id="notes_54">Notes<a class="headerlink" href="#notes_54" title="Permanent link">&para;</a></h2>
<p>Use <code>transpose(a, argsort(axes))</code> to invert the transposition of tensors
when using the <code>axes</code> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<h2 id="examples_117">Examples<a class="headerlink" href="#examples_117" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.arange(4).reshape((2,2))
x
array([[0, 1],
[2, 3]])</p>
<p>np.transpose(x)
array([[0, 2],
[1, 3]])</p>
<p>x = np.ones((1, 2, 3))
np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the k-th diagonal zeroed.</p>
<h2 id="parameters_129">Parameters<a class="headerlink" href="#parameters_129" title="Permanent link">&para;</a></h2>
<p>m : array_like
Matrix whose elements to return
k : int, optional
Diagonal below which to zero elements.
<code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
<code>k</code> &gt; 0 superdiagonal.</p>
<h2 id="returns_129">Returns<a class="headerlink" href="#returns_129" title="Permanent link">&para;</a></h2>
<p>triu : ndarray
Return matrix with zeroed elements below the k-th diagonal and has
same shape and type as <code>m</code>.</p>
<h2 id="examples_118">Examples<a class="headerlink" href="#examples_118" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import triu
triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
[ 4,  5,  6],
[ 0,  8,  9],
[ 0,  0, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Misc</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_130">Parameters<a class="headerlink" href="#parameters_130" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of BLAS functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_130">Returns<a class="headerlink" href="#returns_130" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_55">Notes<a class="headerlink" href="#notes_55" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h2 id="examples_119">Examples<a class="headerlink" href="#examples_119" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_gemv = LA.get_blas_funcs('gemv', (a,))
x_gemv.typecode
'd'
x_gemv = LA.get_blas_funcs('gemv',(a*1j,))
x_gemv.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_131">Parameters<a class="headerlink" href="#parameters_131" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_131">Returns<a class="headerlink" href="#returns_131" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_56">Notes<a class="headerlink" href="#notes_56" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_120">Examples<a class="headerlink" href="#examples_120" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_8">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_8" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_132">Parameters<a class="headerlink" href="#parameters_132" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_132">Returns<a class="headerlink" href="#returns_132" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_57">Notes<a class="headerlink" href="#notes_57" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_13">References<a class="headerlink" href="#references_13" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_121">Examples<a class="headerlink" href="#examples_121" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Special_matrices</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_strided</span> <span class="o">:</span> <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">strides</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">writeable</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a view into the array with the given shape and strides.</p>
<p>.. warning:: This function has to be used with extreme care, see notes.</p>
<h2 id="parameters_133">Parameters<a class="headerlink" href="#parameters_133" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Array to create a new.
shape : sequence of int, optional
The shape of the new array. Defaults to <code>x.shape</code>.
strides : sequence of int, optional
The strides of the new array. Defaults to <code>x.strides</code>.
subok : bool, optional
.. versionadded:: 1.10</p>
<p>If True, subclasses are preserved.
writeable : bool, optional
.. versionadded:: 1.12</p>
<p>If set to False, the returned array will always be readonly.
Otherwise it will be writable if the original array was. It
is advisable to set this to False if possible (see Notes).</p>
<h2 id="returns_133">Returns<a class="headerlink" href="#returns_133" title="Permanent link">&para;</a></h2>
<p>view : ndarray</p>
<h2 id="see-also_70">See also<a class="headerlink" href="#see-also_70" title="Permanent link">&para;</a></h2>
<p>broadcast_to: broadcast an array to a given shape.
reshape : reshape an array.</p>
<h2 id="notes_58">Notes<a class="headerlink" href="#notes_58" title="Permanent link">&para;</a></h2>
<p><code>as_strided</code> creates a view into the array given the exact strides
and shape. This means it manipulates the internal data structure of
ndarray and, if done incorrectly, the array elements can point to
invalid memory and can corrupt results or crash your program.
It is advisable to always use the original <code>x.strides</code> when
calculating new strides to avoid reliance on a contiguous memory
layout.</p>
<p>Furthermore, arrays created with this function often contain self
overlapping memory, so that two elements are identical.
Vectorized write operations on such arrays will typically be
unpredictable. They may even give different results for small, large,
or transposed arrays.
Since writing to these arrays has to be tested and done with great
care, you may want to use <code>writeable=False</code> to avoid accidental write
operations.</p>
<p>For these reasons it is advisable to avoid <code>as_strided</code> when
possible.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a block diagonal matrix from provided arrays.</p>
<p>Given the inputs <code>A</code>, <code>B</code> and <code>C</code>, the output will have these
arrays arranged on the diagonal::</p>
<p>[[A, 0, 0],
[0, B, 0],
[0, 0, C]]</p>
<h2 id="parameters_134">Parameters<a class="headerlink" href="#parameters_134" title="Permanent link">&para;</a></h2>
<p>A, B, C, ... : array_like, up to 2-D
Input arrays.  A 1-D array or array_like sequence of length <code>n</code> is
treated as a 2-D array with shape <code>(1,n)</code>.</p>
<h2 id="returns_134">Returns<a class="headerlink" href="#returns_134" title="Permanent link">&para;</a></h2>
<p>D : ndarray
Array with <code>A</code>, <code>B</code>, <code>C</code>, ... on the diagonal.  <code>D</code> has the
same dtype as <code>A</code>.</p>
<h2 id="notes_59">Notes<a class="headerlink" href="#notes_59" title="Permanent link">&para;</a></h2>
<p>If all the input arrays are square, the output is known as a
block diagonal matrix.</p>
<p>Empty sequences (i.e., array-likes of zero size) will not be ignored.
Noteworthy, both [] and [[]] are treated as matrices with shape <code>(1,0)</code>.</p>
<h2 id="examples_122">Examples<a class="headerlink" href="#examples_122" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import block_diag
A = [[1, 0],
...      [0, 1]]
B = [[3, 4, 5],
...      [6, 7, 8]]
C = [[7]]
P = np.zeros((2, 0), dtype='int32')
block_diag(A, B, C)
array([[1, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0],
[0, 0, 3, 4, 5, 0],
[0, 0, 6, 7, 8, 0],
[0, 0, 0, 0, 0, 7]])
block_diag(A, P, B, C)
array([[1, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 3, 4, 5, 0],
[0, 0, 6, 7, 8, 0],
[0, 0, 0, 0, 0, 7]])
block_diag(1.0, [2, 3], [[4, 5], [6, 7]])
array([[ 1.,  0.,  0.,  0.,  0.],
[ 0.,  2.,  3.,  0.,  0.],
[ 0.,  0.,  0.,  4.,  5.],
[ 0.,  0.,  0.,  6.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">circulant</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a circulant matrix.</p>
<h2 id="parameters_135">Parameters<a class="headerlink" href="#parameters_135" title="Permanent link">&para;</a></h2>
<p>c : (N,) array_like
1-D array, the first column of the matrix.</p>
<h2 id="returns_135">Returns<a class="headerlink" href="#returns_135" title="Permanent link">&para;</a></h2>
<p>A : (N, N) ndarray
A circulant matrix whose first column is <code>c</code>.</p>
<h2 id="see-also_71">See Also<a class="headerlink" href="#see-also_71" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix
hankel : Hankel matrix
solve_circulant : Solve a circulant system.</p>
<h2 id="notes_60">Notes<a class="headerlink" href="#notes_60" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_123">Examples<a class="headerlink" href="#examples_123" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import circulant
circulant([1, 2, 3])
array([[1, 3, 2],
[2, 1, 3],
[3, 2, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">companion</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a companion matrix.</p>
<p>Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in <code>a</code>.</p>
<h2 id="parameters_136">Parameters<a class="headerlink" href="#parameters_136" title="Permanent link">&para;</a></h2>
<p>a : (N,) array_like
1-D array of polynomial coefficients.  The length of <code>a</code> must be
at least two, and <code>a[0]</code> must not be zero.</p>
<h2 id="returns_136">Returns<a class="headerlink" href="#returns_136" title="Permanent link">&para;</a></h2>
<p>c : (N-1, N-1) ndarray
The first row of <code>c</code> is <code>-a[1:]/a[0]</code>, and the first
sub-diagonal is all ones.  The data-type of the array is the same
as the data-type of <code>1.0*a[0]</code>.</p>
<h2 id="raises_34">Raises<a class="headerlink" href="#raises_34" title="Permanent link">&para;</a></h2>
<p>ValueError
If any of the following are true: a) <code>a.ndim != 1</code>;
b) <code>a.size &lt; 2</code>; c) <code>a[0] == 0</code>.</p>
<h2 id="notes_61">Notes<a class="headerlink" href="#notes_61" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="references_14">References<a class="headerlink" href="#references_14" title="Permanent link">&para;</a></h2>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
Cambridge University Press, 1999, pp. 146-7.</p>
<h2 id="examples_124">Examples<a class="headerlink" href="#examples_124" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import companion
companion([1, -10, 31, -30])
array([[ 10., -31.,  30.],
[  1.,   0.,   0.],
[  0.,   1.,   0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dft</span> <span class="o">:</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Discrete Fourier transform matrix.</p>
<p>Create the matrix that computes the discrete Fourier transform of a
sequence [1]_.  The n-th primitive root of unity used to generate the
matrix is exp(-2<em>pi</em>i/n), where i = sqrt(-1).</p>
<h2 id="parameters_137">Parameters<a class="headerlink" href="#parameters_137" title="Permanent link">&para;</a></h2>
<p>n : int
Size the matrix to create.
scale : str, optional
Must be None, 'sqrtn', or 'n'.
If <code>scale</code> is 'sqrtn', the matrix is divided by <code>sqrt(n)</code>.
If <code>scale</code> is 'n', the matrix is divided by <code>n</code>.
If <code>scale</code> is None (the default), the matrix is not normalized, and the
return value is simply the Vandermonde matrix of the roots of unity.</p>
<h2 id="returns_137">Returns<a class="headerlink" href="#returns_137" title="Permanent link">&para;</a></h2>
<p>m : (n, n) ndarray
The DFT matrix.</p>
<h2 id="notes_62">Notes<a class="headerlink" href="#notes_62" title="Permanent link">&para;</a></h2>
<p>When <code>scale</code> is None, multiplying a vector by the matrix returned by
<code>dft</code> is mathematically equivalent to (but much less efficient than)
the calculation performed by <code>scipy.fft.fft</code>.</p>
<p>.. versionadded:: 0.14.0</p>
<h2 id="references_15">References<a class="headerlink" href="#references_15" title="Permanent link">&para;</a></h2>
<p>.. [1] 'DFT matrix', https://en.wikipedia.org/wiki/DFT_matrix</p>
<h2 id="examples_125">Examples<a class="headerlink" href="#examples_125" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import dft
np.set_printoptions(precision=2, suppress=True)  # for compact output
m = dft(5)
m
array([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ],
[ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j],
[ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j],
[ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j],
[ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]])
x = np.array([1, 2, 3, 0, 3])
m @ x  # Compute the DFT of x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify that <code>m @ x</code> is the same as <code>fft(x)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft
fft(x)     # Same result as m @ x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a symmetric Fiedler matrix</p>
<p>Given an sequence of numbers <code>a</code>, Fiedler matrices have the structure
<code>F[i, j] = np.abs(a[i] - a[j])</code>, and hence zero diagonals and nonnegative
entries. A Fiedler matrix has a dominant positive eigenvalue and other
eigenvalues are negative. Although not valid generally, for certain inputs,
the inverse and the determinant can be derived explicitly as given in [1]_.</p>
<h2 id="parameters_138">Parameters<a class="headerlink" href="#parameters_138" title="Permanent link">&para;</a></h2>
<p>a : (n,) array_like
coefficient array</p>
<h2 id="returns_138">Returns<a class="headerlink" href="#returns_138" title="Permanent link">&para;</a></h2>
<p>F : (n, n) ndarray</p>
<h2 id="see-also_72">See Also<a class="headerlink" href="#see-also_72" title="Permanent link">&para;</a></h2>
<p>circulant, toeplitz</p>
<h2 id="notes_63">Notes<a class="headerlink" href="#notes_63" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.3.0</p>
<h2 id="references_16">References<a class="headerlink" href="#references_16" title="Permanent link">&para;</a></h2>
<p>.. [1] J. Todd, 'Basic Numerical Mathematics: Vol.2 : Numerical Algebra',
1977, Birkhauser, :doi:<code>10.1007/978-3-0348-7286-7</code></p>
<h2 id="examples_126">Examples<a class="headerlink" href="#examples_126" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import det, inv, fiedler
a = [1, 4, 12, 45, 77]
n = len(a)
A = fiedler(a)
A
array([[ 0,  3, 11, 44, 76],
[ 3,  0,  8, 41, 73],
[11,  8,  0, 33, 65],
[44, 41, 33,  0, 32],
[76, 73, 65, 32,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The explicit formulas for determinant and inverse seem to hold only for
monotonically increasing/decreasing arrays. Note the tridiagonal structure
and the corners.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Ai = inv(A)
Ai[np.abs(Ai) &lt; 1e-12] = 0.  # cleanup the numerical noise for display
Ai
array([[-0.16008772,  0.16666667,  0.        ,  0.        ,  0.00657895],
[ 0.16666667, -0.22916667,  0.0625    ,  0.        ,  0.        ],
[ 0.        ,  0.0625    , -0.07765152,  0.01515152,  0.        ],
[ 0.        ,  0.        ,  0.01515152, -0.03077652,  0.015625  ],
[ 0.00657895,  0.        ,  0.        ,  0.015625  , -0.00904605]])
det(A)
15409151.999999998
(-1)<strong>(n-1) * 2</strong>(n-2) * np.diff(a).prod() * (a[-1] - a[0])
15409152</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler_companion</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a Fiedler companion matrix</p>
<p>Given a polynomial coefficient array <code>a</code>, this function forms a
pentadiagonal matrix with a special structure whose eigenvalues coincides
with the roots of <code>a</code>.</p>
<h2 id="parameters_139">Parameters<a class="headerlink" href="#parameters_139" title="Permanent link">&para;</a></h2>
<p>a : (N,) array_like
1-D array of polynomial coefficients in descending order with a nonzero
leading coefficient. For <code>N &lt; 2</code>, an empty array is returned.</p>
<h2 id="returns_139">Returns<a class="headerlink" href="#returns_139" title="Permanent link">&para;</a></h2>
<p>c : (N-1, N-1) ndarray
Resulting companion matrix</p>
<h2 id="notes_64">Notes<a class="headerlink" href="#notes_64" title="Permanent link">&para;</a></h2>
<p>Similar to <code>companion</code> the leading coefficient should be nonzero. In case
the leading coefficient is not 1., other coefficients are rescaled before
the array generation. To avoid numerical issues, it is best to provide a
monic polynomial.</p>
<p>.. versionadded:: 1.3.0</p>
<h2 id="see-also_73">See Also<a class="headerlink" href="#see-also_73" title="Permanent link">&para;</a></h2>
<p>companion</p>
<h2 id="references_17">References<a class="headerlink" href="#references_17" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Fiedler, ' A note on companion matrices', Linear Algebra and its
Applications, 2003, :doi:<code>10.1016/S0024-3795(03)00548-2</code></p>
<h2 id="examples_127">Examples<a class="headerlink" href="#examples_127" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import fiedler_companion, eigvals
p = np.poly(np.arange(1, 9, 2))  # [1., -16., 86., -176., 105.]
fc = fiedler_companion(p)
fc
array([[  16.,  -86.,    1.,    0.],
[   1.,    0.,    0.,    0.],
[   0.,  176.,    0., -105.],
[   0.,    1.,    0.,    0.]])
eigvals(fc)
array([7.+0.j, 5.+0.j, 3.+0.j, 1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hadamard</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hadamard matrix.</p>
<p>Constructs an n-by-n Hadamard matrix, using Sylvester's
construction.  <code>n</code> must be a power of 2.</p>
<h2 id="parameters_140">Parameters<a class="headerlink" href="#parameters_140" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the matrix.  <code>n</code> must be a power of 2.
dtype : dtype, optional
The data type of the array to be constructed.</p>
<h2 id="returns_140">Returns<a class="headerlink" href="#returns_140" title="Permanent link">&para;</a></h2>
<p>H : (n, n) ndarray
The Hadamard matrix.</p>
<h2 id="notes_65">Notes<a class="headerlink" href="#notes_65" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_128">Examples<a class="headerlink" href="#examples_128" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hadamard
hadamard(2, dtype=complex)
array([[ 1.+0.j,  1.+0.j],
[ 1.+0.j, -1.-0.j]])
hadamard(4)
array([[ 1,  1,  1,  1],
[ 1, -1,  1, -1],
[ 1,  1, -1, -1],
[ 1, -1, -1,  1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hankel matrix.</p>
<p>The Hankel matrix has constant anti-diagonals, with <code>c</code> as its
first column and <code>r</code> as its last row.  If <code>r</code> is not given, then
<code>r = zeros_like(c)</code> is assumed.</p>
<h2 id="parameters_141">Parameters<a class="headerlink" href="#parameters_141" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
Last row of the matrix. If None, <code>r = zeros_like(c)</code> is assumed.
r[0] is ignored; the last row of the returned matrix is
<code>[c[-1], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_141">Returns<a class="headerlink" href="#returns_141" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Hankel matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_74">See Also<a class="headerlink" href="#see-also_74" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix
circulant : circulant matrix</p>
<h2 id="examples_129">Examples<a class="headerlink" href="#examples_129" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hankel
hankel([1, 17, 99])
array([[ 1, 17, 99],
[17, 99,  0],
[99,  0,  0]])
hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
[2, 3, 4, 7, 7],
[3, 4, 7, 7, 8],
[4, 7, 7, 8, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">helmert</span> <span class="o">:</span> <span class="o">?</span><span class="n">full</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Helmert matrix of order <code>n</code>.</p>
<p>This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.</p>
<h2 id="parameters_142">Parameters<a class="headerlink" href="#parameters_142" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the array to create.
full : bool, optional
If True the (n, n) ndarray will be returned.
Otherwise the submatrix that does not include the first
row will be returned.
Default: False.</p>
<h2 id="returns_142">Returns<a class="headerlink" href="#returns_142" title="Permanent link">&para;</a></h2>
<p>M : ndarray
The Helmert matrix.
The shape is (n, n) or (n-1, n) depending on the <code>full</code> argument.</p>
<h2 id="examples_130">Examples<a class="headerlink" href="#examples_130" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import helmert
helmert(5, full=True)
array([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ],
[ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ],
[ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ],
[ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ],
[ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Hilbert matrix of order <code>n</code>.</p>
<p>Returns the <code>n</code> by <code>n</code> array with entries <code>h[i,j] = 1 / (i + j + 1)</code>.</p>
<h2 id="parameters_143">Parameters<a class="headerlink" href="#parameters_143" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the array to create.</p>
<h2 id="returns_143">Returns<a class="headerlink" href="#returns_143" title="Permanent link">&para;</a></h2>
<p>h : (n, n) ndarray
The Hilbert matrix.</p>
<h2 id="see-also_75">See Also<a class="headerlink" href="#see-also_75" title="Permanent link">&para;</a></h2>
<p>invhilbert : Compute the inverse of a Hilbert matrix.</p>
<h2 id="notes_66">Notes<a class="headerlink" href="#notes_66" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_131">Examples<a class="headerlink" href="#examples_131" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hilbert
hilbert(3)
array([[ 1.        ,  0.5       ,  0.33333333],
[ 0.5       ,  0.33333333,  0.25      ],
[ 0.33333333,  0.25      ,  0.2       ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invhilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the Hilbert matrix of order <code>n</code>.</p>
<p>The entries in the inverse of a Hilbert matrix are integers.  When <code>n</code>
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers.  The <code>exact</code> argument provides two options for
dealing with these large integers.</p>
<h2 id="parameters_144">Parameters<a class="headerlink" href="#parameters_144" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the Hilbert matrix.
exact : bool, optional
If False, the data type of the array that is returned is np.float64,
and the array is an approximation of the inverse.
If True, the array is the exact integer inverse array.  To represent
the exact inverse when n &gt; 14, the returned array is an object array
of long integers.  For n &lt;= 14, the exact inverse is returned as an
array with data type np.int64.</p>
<h2 id="returns_144">Returns<a class="headerlink" href="#returns_144" title="Permanent link">&para;</a></h2>
<p>invh : (n, n) ndarray
The data type of the array is np.float64 if <code>exact</code> is False.
If <code>exact</code> is True, the data type is either np.int64 (for n &lt;= 14)
or object (for n &gt; 14).  In the latter case, the objects in the
array will be long integers.</p>
<h2 id="see-also_76">See Also<a class="headerlink" href="#see-also_76" title="Permanent link">&para;</a></h2>
<p>hilbert : Create a Hilbert matrix.</p>
<h2 id="notes_67">Notes<a class="headerlink" href="#notes_67" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_132">Examples<a class="headerlink" href="#examples_132" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import invhilbert
invhilbert(4)
array([[   16.,  -120.,   240.,  -140.],
[ -120.,  1200., -2700.,  1680.],
[  240., -2700.,  6480., -4200.],
[ -140.,  1680., -4200.,  2800.]])
invhilbert(4, exact=True)
array([[   16,  -120,   240,  -140],
[ -120,  1200, -2700,  1680],
[  240, -2700,  6480, -4200],
[ -140,  1680, -4200,  2800]], dtype=int64)
invhilbert(16)[7,7]
4.2475099528537506e+19
invhilbert(16, exact=True)[7,7]
42475099528537378560L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invpascal</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the inverse of the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h2 id="parameters_145">Parameters<a class="headerlink" href="#parameters_145" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the matrix to create; that is, the result is an n x n
matrix.
kind : str, optional
Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.
exact : bool, optional
If <code>exact</code> is True, the result is either an array of type
<code>numpy.int64</code> (if <code>n</code> &lt;= 35) or an object array of Python integers.
If <code>exact</code> is False, the coefficients in the matrix are computed using
<code>scipy.special.comb</code> with <code>exact=False</code>.  The result will be a floating
point array, and for large <code>n</code>, the values in the array will not be the
exact coefficients.</p>
<h2 id="returns_145">Returns<a class="headerlink" href="#returns_145" title="Permanent link">&para;</a></h2>
<p>invp : (n, n) ndarray
The inverse of the Pascal matrix.</p>
<h2 id="see-also_77">See Also<a class="headerlink" href="#see-also_77" title="Permanent link">&para;</a></h2>
<p>pascal</p>
<h2 id="notes_68">Notes<a class="headerlink" href="#notes_68" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_18">References<a class="headerlink" href="#references_18" title="Permanent link">&para;</a></h2>
<p>.. [1] 'Pascal matrix', https://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., 'The inverse of a Pascal matrix', Mathematical
Gazette, 59(408), pp. 111-112, 1975.</p>
<h2 id="examples_133">Examples<a class="headerlink" href="#examples_133" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import invpascal, pascal
invp = invpascal(5)
invp
array([[  5, -10,  10,  -5,   1],
[-10,  30, -35,  19,  -4],
[ 10, -35,  46, -27,   6],
[ -5,  19, -27,  17,  -4],
[  1,  -4,   6,  -4,   1]])</p>
<p>p = pascal(5)
p.dot(invp)
array([[ 1.,  0.,  0.,  0.,  0.],
[ 0.,  1.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  1.,  0.],
[ 0.,  0.,  0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An example of the use of <code>kind</code> and <code>exact</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invpascal(5, kind='lower', exact=False)
array([[ 1., -0.,  0., -0.,  0.],
[-1.,  1., -0.,  0., -0.],
[ 1., -2.,  1., -0.,  0.],
[-1.,  3., -3.,  1., -0.],
[ 1., -4.,  6., -4.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Kronecker product.</p>
<p>The result is the block matrix::</p>
<p>a[0,0]<em>b    a[0,1]</em>b  ... a[0,-1]<em>b
a[1,0]</em>b    a[1,1]<em>b  ... a[1,-1]</em>b
...
a[-1,0]<em>b   a[-1,1]</em>b ... a[-1,-1]*b</p>
<h2 id="parameters_146">Parameters<a class="headerlink" href="#parameters_146" title="Permanent link">&para;</a></h2>
<p>a : (M, N) ndarray
Input array
b : (P, Q) ndarray
Input array</p>
<h2 id="returns_146">Returns<a class="headerlink" href="#returns_146" title="Permanent link">&para;</a></h2>
<p>A : (M<em>P, N</em>Q) ndarray
Kronecker product of <code>a</code> and <code>b</code>.</p>
<h2 id="examples_134">Examples<a class="headerlink" href="#examples_134" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.linalg import kron
kron(array([[1,2],[3,4]]), array([[1,1,1]]))
array([[1, 1, 1, 2, 2, 2],
[3, 3, 3, 4, 4, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leslie</span> <span class="o">:</span> <span class="n">f</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Leslie matrix.</p>
<p>Given the length n array of fecundity coefficients <code>f</code> and the length
n-1 array of survival coefficients <code>s</code>, return the associated Leslie
matrix.</p>
<h2 id="parameters_147">Parameters<a class="headerlink" href="#parameters_147" title="Permanent link">&para;</a></h2>
<p>f : (N,) array_like
The 'fecundity' coefficients.
s : (N-1,) array_like
The 'survival' coefficients, has to be 1-D.  The length of <code>s</code>
must be one less than the length of <code>f</code>, and it must be at least 1.</p>
<h2 id="returns_147">Returns<a class="headerlink" href="#returns_147" title="Permanent link">&para;</a></h2>
<p>L : (N, N) ndarray
The array is zero except for the first row,
which is <code>f</code>, and the first sub-diagonal, which is <code>s</code>.
The data-type of the array will be the data-type of <code>f[0]+s[0]</code>.</p>
<h2 id="notes_69">Notes<a class="headerlink" href="#notes_69" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<p>The Leslie matrix is used to model discrete-time, age-structured
population growth [1]<em> [2]</em>. In a population with <code>n</code> age classes, two sets
of parameters define a Leslie matrix: the <code>n</code> 'fecundity coefficients',
which give the number of offspring per-capita produced by each age
class, and the <code>n</code> - 1 'survival coefficients', which give the
per-capita survival rate of each age class.</p>
<h2 id="references_19">References<a class="headerlink" href="#references_19" title="Permanent link">&para;</a></h2>
<p>.. [1] P. H. Leslie, On the use of matrices in certain population
mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
(Dec. 1948)</p>
<h2 id="examples_135">Examples<a class="headerlink" href="#examples_135" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import leslie
leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])
array([[ 0.1,  2. ,  1. ,  0.1],
[ 0.2,  0. ,  0. ,  0. ],
[ 0. ,  0.8,  0. ,  0. ],
[ 0. ,  0. ,  0.7,  0. ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pascal</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h2 id="parameters_148">Parameters<a class="headerlink" href="#parameters_148" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the matrix to create; that is, the result is an n x n
matrix.
kind : str, optional
Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.
exact : bool, optional
If <code>exact</code> is True, the result is either an array of type
numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
If <code>exact</code> is False, the coefficients in the matrix are computed using
<code>scipy.special.comb</code> with <code>exact=False</code>.  The result will be a floating
point array, and the values in the array will not be the exact
coefficients, but this version is much faster than <code>exact=True</code>.</p>
<h2 id="returns_148">Returns<a class="headerlink" href="#returns_148" title="Permanent link">&para;</a></h2>
<p>p : (n, n) ndarray
The Pascal matrix.</p>
<h2 id="see-also_78">See Also<a class="headerlink" href="#see-also_78" title="Permanent link">&para;</a></h2>
<p>invpascal</p>
<h2 id="notes_70">Notes<a class="headerlink" href="#notes_70" title="Permanent link">&para;</a></h2>
<p>See https://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_136">Examples<a class="headerlink" href="#examples_136" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import pascal
pascal(4)
array([[ 1,  1,  1,  1],
[ 1,  2,  3,  4],
[ 1,  3,  6, 10],
[ 1,  4, 10, 20]], dtype=uint64)
pascal(4, kind='lower')
array([[1, 0, 0, 0],
[1, 1, 0, 0],
[1, 2, 1, 0],
[1, 3, 3, 1]], dtype=uint64)
pascal(50)[-1, -1]
25477612258980856902730428600L
from scipy.special import comb
comb(98, 49, exact=True)
25477612258980856902730428600L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toeplitz</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Toeplitz matrix.</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h2 id="parameters_149">Parameters<a class="headerlink" href="#parameters_149" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
First row of the matrix. If None, <code>r = conjugate(c)</code> is assumed;
in this case, if c[0] is real, the result is a Hermitian matrix.
r[0] is ignored; the first row of the returned matrix is
<code>[c[0], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_149">Returns<a class="headerlink" href="#returns_149" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Toeplitz matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_79">See Also<a class="headerlink" href="#see-also_79" title="Permanent link">&para;</a></h2>
<p>circulant : circulant matrix
hankel : Hankel matrix
solve_toeplitz : Solve a Toeplitz system.</p>
<h2 id="notes_71">Notes<a class="headerlink" href="#notes_71" title="Permanent link">&para;</a></h2>
<p>The behavior when <code>c</code> or <code>r</code> is a scalar, or when <code>c</code> is complex and
<code>r</code> is None, was changed in version 0.8.0.  The behavior in previous
versions was undocumented and is no longer supported.</p>
<h2 id="examples_137">Examples<a class="headerlink" href="#examples_137" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import toeplitz
toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
[2, 1, 4, 5],
[3, 2, 1, 4]])
toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
[ 2.+3.j,  1.+0.j,  2.-3.j],
[ 4.-1.j,  2.+3.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tri</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct (N, M) matrix filled with ones at and below the k-th diagonal.</p>
<p>The matrix has A[i,j] == 1 for i &lt;= j + k</p>
<h2 id="parameters_150">Parameters<a class="headerlink" href="#parameters_150" title="Permanent link">&para;</a></h2>
<p>N : int
The size of the first dimension of the matrix.
M : int or None, optional
The size of the second dimension of the matrix. If <code>M</code> is None,
<code>M = N</code> is assumed.
k : int, optional
Number of subdiagonal below which matrix is filled with ones.
<code>k</code> = 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and <code>k</code> &gt; 0
superdiagonal.
dtype : dtype, optional
Data type of the matrix.</p>
<h2 id="returns_150">Returns<a class="headerlink" href="#returns_150" title="Permanent link">&para;</a></h2>
<p>tri : (N, M) ndarray
Tri matrix.</p>
<h2 id="examples_138">Examples<a class="headerlink" href="#examples_138" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tri
tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
[1, 1, 1, 1, 0],
[1, 1, 1, 1, 1]])
tri(3, 5, -1, dtype=int)
array([[0, 0, 0, 0, 0],
[1, 0, 0, 0, 0],
[1, 1, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements above the k-th diagonal zeroed.</p>
<h2 id="parameters_151">Parameters<a class="headerlink" href="#parameters_151" title="Permanent link">&para;</a></h2>
<p>m : array_like
Matrix whose elements to return
k : int, optional
Diagonal above which to zero elements.
<code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
<code>k</code> &gt; 0 superdiagonal.</p>
<h2 id="returns_151">Returns<a class="headerlink" href="#returns_151" title="Permanent link">&para;</a></h2>
<p>tril : ndarray
Return is the same shape and type as <code>m</code>.</p>
<h2 id="examples_139">Examples<a class="headerlink" href="#examples_139" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tril
tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
[ 4,  0,  0],
[ 7,  8,  0],
[10, 11, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the k-th diagonal zeroed.</p>
<h2 id="parameters_152">Parameters<a class="headerlink" href="#parameters_152" title="Permanent link">&para;</a></h2>
<p>m : array_like
Matrix whose elements to return
k : int, optional
Diagonal below which to zero elements.
<code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
<code>k</code> &gt; 0 superdiagonal.</p>
<h2 id="returns_152">Returns<a class="headerlink" href="#returns_152" title="Permanent link">&para;</a></h2>
<p>triu : ndarray
Return matrix with zeroed elements below the k-th diagonal and has
same shape and type as <code>m</code>.</p>
<h2 id="examples_140">Examples<a class="headerlink" href="#examples_140" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import triu
triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
[ 4,  5,  6],
[ 0,  8,  9],
[ 0,  0, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a block diagonal matrix from provided arrays.</p>
<p>Given the inputs <code>A</code>, <code>B</code> and <code>C</code>, the output will have these
arrays arranged on the diagonal::</p>
<p>[[A, 0, 0],
[0, B, 0],
[0, 0, C]]</p>
<h2 id="parameters_153">Parameters<a class="headerlink" href="#parameters_153" title="Permanent link">&para;</a></h2>
<p>A, B, C, ... : array_like, up to 2-D
Input arrays.  A 1-D array or array_like sequence of length <code>n</code> is
treated as a 2-D array with shape <code>(1,n)</code>.</p>
<h2 id="returns_153">Returns<a class="headerlink" href="#returns_153" title="Permanent link">&para;</a></h2>
<p>D : ndarray
Array with <code>A</code>, <code>B</code>, <code>C</code>, ... on the diagonal.  <code>D</code> has the
same dtype as <code>A</code>.</p>
<h2 id="notes_72">Notes<a class="headerlink" href="#notes_72" title="Permanent link">&para;</a></h2>
<p>If all the input arrays are square, the output is known as a
block diagonal matrix.</p>
<p>Empty sequences (i.e., array-likes of zero size) will not be ignored.
Noteworthy, both [] and [[]] are treated as matrices with shape <code>(1,0)</code>.</p>
<h2 id="examples_141">Examples<a class="headerlink" href="#examples_141" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import block_diag
A = [[1, 0],
...      [0, 1]]
B = [[3, 4, 5],
...      [6, 7, 8]]
C = [[7]]
P = np.zeros((2, 0), dtype='int32')
block_diag(A, B, C)
array([[1, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0],
[0, 0, 3, 4, 5, 0],
[0, 0, 6, 7, 8, 0],
[0, 0, 0, 0, 0, 7]])
block_diag(A, P, B, C)
array([[1, 0, 0, 0, 0, 0],
[0, 1, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0],
[0, 0, 3, 4, 5, 0],
[0, 0, 6, 7, 8, 0],
[0, 0, 0, 0, 0, 7]])
block_diag(1.0, [2, 3], [[4, 5], [6, 7]])
array([[ 1.,  0.,  0.,  0.,  0.],
[ 0.,  2.,  3.,  0.,  0.],
[ 0.,  0.,  0.,  4.,  5.],
[ 0.,  0.,  0.,  6.,  7.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cdf2rdf</span> <span class="o">:</span> <span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Converts complex eigenvalues <code>w</code> and eigenvectors <code>v</code> to real
eigenvalues in a block diagonal form <code>wr</code> and the associated real
eigenvectors <code>vr</code>, such that::</p>
<p>vr @ wr = X @ vr</p>
<p>continues to hold, where <code>X</code> is the original array for which <code>w</code> and
<code>v</code> are the eigenvalues and eigenvectors.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="parameters_154">Parameters<a class="headerlink" href="#parameters_154" title="Permanent link">&para;</a></h2>
<p>w : (..., M) array_like
Complex or real eigenvalues, an array or stack of arrays</p>
<p>Conjugate pairs must not be interleaved, else the wrong result
will be produced. So <code>[1+1j, 1, 1-1j]</code> will give a correct result, but
<code>[1+1j, 2+1j, 1-1j, 2-1j]</code> will not.</p>
<p>v : (..., M, M) array_like
Complex or real eigenvectors, a square array or stack of square arrays.</p>
<h2 id="returns_154">Returns<a class="headerlink" href="#returns_154" title="Permanent link">&para;</a></h2>
<p>wr : (..., M, M) ndarray
Real diagonal block form of eigenvalues
vr : (..., M, M) ndarray
Real eigenvectors associated with <code>wr</code></p>
<h2 id="see-also_80">See Also<a class="headerlink" href="#see-also_80" title="Permanent link">&para;</a></h2>
<p>eig : Eigenvalues and right eigenvectors for non-symmetric arrays
rsf2csf : Convert real Schur form to complex Schur form</p>
<h2 id="notes_73">Notes<a class="headerlink" href="#notes_73" title="Permanent link">&para;</a></h2>
<p><code>w</code>, <code>v</code> must be the eigenstructure for some <em>real</em> matrix <code>X</code>.
For example, obtained by <code>w, v = scipy.linalg.eig(X)</code> or
<code>w, v = numpy.linalg.eig(X)</code> in which case <code>X</code> can also represent
stacked arrays.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="examples_142">Examples<a class="headerlink" href="#examples_142" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>X = np.array([[1, 2, 3], [0, 4, 5], [0, -5, 4]])
X
array([[ 1,  2,  3],
[ 0,  4,  5],
[ 0, -5,  4]])</p>
<p>from scipy import linalg
w, v = linalg.eig(X)
w
array([ 1.+0.j,  4.+5.j,  4.-5.j])
v
array([[ 1.00000+0.j     , -0.01906-0.40016j, -0.01906+0.40016j],
[ 0.00000+0.j     ,  0.00000-0.64788j,  0.00000+0.64788j],
[ 0.00000+0.j     ,  0.64788+0.j     ,  0.64788-0.j     ]])</p>
<p>wr, vr = linalg.cdf2rdf(w, v)
wr
array([[ 1.,  0.,  0.],
[ 0.,  4.,  5.],
[ 0., -5.,  4.]])
vr
array([[ 1.     ,  0.40016, -0.01906],
[ 0.     ,  0.64788,  0.     ],
[ 0.     ,  0.     ,  0.64788]])</p>
<p>vr @ wr
array([[ 1.     ,  1.69593,  1.9246 ],
[ 0.     ,  2.59153,  3.23942],
[ 0.     , -3.23942,  2.59153]])
X @ vr
array([[ 1.     ,  1.69593,  1.9246 ],
[ 0.     ,  2.59153,  3.23942],
[ 0.     , -3.23942,  2.59153]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix, to use in cho_solve</p>
<p>Returns a matrix containing the Cholesky decomposition,
<code>A = L L*</code> or <code>A = U* U</code> of a Hermitian positive-definite matrix <code>a</code>.
The return value can be directly used as the first parameter to cho_solve.</p>
<p>.. warning::
The returned matrix also contains random data in the entries not
used by the Cholesky decomposition. If you need to zero these
entries, use the function <code>cholesky</code> instead.</p>
<h2 id="parameters_155">Parameters<a class="headerlink" href="#parameters_155" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to be decomposed
lower : bool, optional
Whether to compute the upper or lower triangular Cholesky factorization
(Default: upper-triangular)
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_155">Returns<a class="headerlink" href="#returns_155" title="Permanent link">&para;</a></h2>
<p>c : (M, M) ndarray
Matrix whose upper or lower triangle contains the Cholesky factor
of <code>a</code>. Other parts of the matrix contain random data.
lower : bool
Flag indicating whether the factor is in the lower or upper triangle</p>
<h2 id="raises_35">Raises<a class="headerlink" href="#raises_35" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails.</p>
<h2 id="see-also_81">See also<a class="headerlink" href="#see-also_81" title="Permanent link">&para;</a></h2>
<p>cho_solve : Solve a linear set equations using the Cholesky factorization
of a matrix.</p>
<h2 id="examples_143">Examples<a class="headerlink" href="#examples_143" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cho_factor
A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])
c, low = cho_factor(A)
c
array([[3.        , 1.        , 0.33333333, 1.66666667],
[3.        , 2.44948974, 1.90515869, -0.27216553],
[1.        , 5.        , 2.29330749, 0.8559528 ],
[5.        , 1.        , 2.        , 1.55418563]])
np.allclose(np.triu(c).T @ np. triu(c) - A, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">c_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p>
<h2 id="parameters_156">Parameters<a class="headerlink" href="#parameters_156" title="Permanent link">&para;</a></h2>
<p>(c, lower) : tuple, (array, bool)
Cholesky factorization of a, as given by cho_factor
b : array
Right-hand side
overwrite_b : bool, optional
Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_156">Returns<a class="headerlink" href="#returns_156" title="Permanent link">&para;</a></h2>
<p>x : array
The solution to the system A x = b</p>
<h2 id="see-also_82">See also<a class="headerlink" href="#see-also_82" title="Permanent link">&para;</a></h2>
<p>cho_factor : Cholesky factorization of a matrix</p>
<h2 id="examples_144">Examples<a class="headerlink" href="#examples_144" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cho_factor, cho_solve
A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])
c, low = cho_factor(A)
x = cho_solve((c, low), [1, 1, 1, 1])
np.allclose(A @ x - [1, 1, 1, 1], np.zeros(4))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">cb_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations <code>A x = b</code>, given the Cholesky factorization of
the banded hermitian <code>A</code>.</p>
<h2 id="parameters_157">Parameters<a class="headerlink" href="#parameters_157" title="Permanent link">&para;</a></h2>
<p>(cb, lower) : tuple, (ndarray, bool)
<code>cb</code> is the Cholesky factorization of A, as given by cholesky_banded.
<code>lower</code> must be the same value that was given to cholesky_banded.
b : array_like
Right-hand side
overwrite_b : bool, optional
If True, the function will overwrite the values in <code>b</code>.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_157">Returns<a class="headerlink" href="#returns_157" title="Permanent link">&para;</a></h2>
<p>x : array
The solution to the system A x = b</p>
<h2 id="see-also_83">See also<a class="headerlink" href="#see-also_83" title="Permanent link">&para;</a></h2>
<p>cholesky_banded : Cholesky factorization of a banded matrix</p>
<h2 id="notes_74">Notes<a class="headerlink" href="#notes_74" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_145">Examples<a class="headerlink" href="#examples_145" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky_banded, cho_solve_banded
Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])
A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)
A = A + A.conj().T + np.diag(Ab[2, :])
c = cholesky_banded(Ab)
x = cho_solve_banded((c, False), np.ones(5))
np.allclose(A @ x - np.ones(5), np.zeros(5))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix.</p>
<p>Returns the Cholesky decomposition, :math:<code>A = L L^*</code> or
:math:<code>A = U^* U</code> of a Hermitian positive-definite matrix A.</p>
<h2 id="parameters_158">Parameters<a class="headerlink" href="#parameters_158" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to be decomposed
lower : bool, optional
Whether to compute the upper or lower triangular Cholesky
factorization.  Default is upper-triangular.
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_158">Returns<a class="headerlink" href="#returns_158" title="Permanent link">&para;</a></h2>
<p>c : (M, M) ndarray
Upper- or lower-triangular Cholesky factor of <code>a</code>.</p>
<h2 id="raises_36">Raises<a class="headerlink" href="#raises_36" title="Permanent link">&para;</a></h2>
<p>LinAlgError : if decomposition fails.</p>
<h2 id="examples_146">Examples<a class="headerlink" href="#examples_146" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky
a = np.array([[1,-2j],[2j,5]])
L = cholesky(a, lower=True)
L
array([[ 1.+0.j,  0.+0.j],
[ 0.+2.j,  1.+0.j]])
L @ L.T.conj()
array([[ 1.+0.j,  0.-2.j],
[ 0.+2.j,  5.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cholesky decompose a banded Hermitian positive-definite matrix</p>
<p>The matrix a is stored in ab either in lower diagonal or upper
diagonal ordered form::</p>
<p>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>Example of ab (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<h2 id="parameters_159">Parameters<a class="headerlink" href="#parameters_159" title="Permanent link">&para;</a></h2>
<p>ab : (u + 1, M) array_like
Banded matrix
overwrite_ab : bool, optional
Discard data in ab (may enhance performance)
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_159">Returns<a class="headerlink" href="#returns_159" title="Permanent link">&para;</a></h2>
<p>c : (u + 1, M) ndarray
Cholesky factorization of a, in the same banded format as ab</p>
<h2 id="see-also_84">See also<a class="headerlink" href="#see-also_84" title="Permanent link">&para;</a></h2>
<p>cho_solve_banded : Solve a linear set equations, given the Cholesky factorization
of a banded hermitian.</p>
<h2 id="examples_147">Examples<a class="headerlink" href="#examples_147" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import cholesky_banded
from numpy import allclose, zeros, diag
Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])
A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)
A = A + A.conj().T + np.diag(Ab[2, :])
c = cholesky_banded(Ab)
C = np.diag(c[0, 2:], k=2) + np.diag(c[1, 1:], k=1) + np.diag(c[2, :])
np.allclose(C.conj().T @ C - A, np.zeros((5, 5)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">circulant</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a circulant matrix.</p>
<h2 id="parameters_160">Parameters<a class="headerlink" href="#parameters_160" title="Permanent link">&para;</a></h2>
<p>c : (N,) array_like
1-D array, the first column of the matrix.</p>
<h2 id="returns_160">Returns<a class="headerlink" href="#returns_160" title="Permanent link">&para;</a></h2>
<p>A : (N, N) ndarray
A circulant matrix whose first column is <code>c</code>.</p>
<h2 id="see-also_85">See Also<a class="headerlink" href="#see-also_85" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix
hankel : Hankel matrix
solve_circulant : Solve a circulant system.</p>
<h2 id="notes_75">Notes<a class="headerlink" href="#notes_75" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_148">Examples<a class="headerlink" href="#examples_148" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import circulant
circulant([1, 2, 3])
array([[1, 3, 2],
[2, 1, 3],
[3, 2, 1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clarkson_woodruff_transform</span> <span class="o">:</span> <span class="o">?</span><span class="n">seed</span><span class="o">:[`</span><span class="nc">T_numpy_random_mtrand_RandomState_instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">input_matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">sketch_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>'
Applies a Clarkson-Woodruff Transform/sketch to the input matrix.</p>
<p>Given an input_matrix <code>A</code> of size <code>(n, d)</code>, compute a matrix <code>A'</code> of
size (sketch_size, d) so that</p>
<p>.. math:: |Ax| \approx |A'x|</p>
<p>with high probability via the Clarkson-Woodruff Transform, otherwise
known as the CountSketch matrix.</p>
<h2 id="parameters_161">Parameters<a class="headerlink" href="#parameters_161" title="Permanent link">&para;</a></h2>
<p>input_matrix: array_like
Input matrix, of shape <code>(n, d)</code>.
sketch_size: int
Number of rows for the sketch.
seed : None or int or <code>numpy.random.mtrand.RandomState</code> instance, optional
This parameter defines the <code>RandomState</code> object to use for drawing
random variates.
If None (or <code>np.random</code>), the global <code>np.random</code> state is used.
If integer, it is used to seed the local <code>RandomState</code> instance.
Default is None.</p>
<h2 id="returns_161">Returns<a class="headerlink" href="#returns_161" title="Permanent link">&para;</a></h2>
<p>A' : array_like
Sketch of the input matrix <code>A</code>, of size <code>(sketch_size, d)</code>.</p>
<h2 id="notes_76">Notes<a class="headerlink" href="#notes_76" title="Permanent link">&para;</a></h2>
<p>To make the statement</p>
<p>.. math:: |Ax| \approx |A'x|</p>
<p>precise, observe the following result which is adapted from the
proof of Theorem 14 of [2]_ via Markov's Inequality. If we have
a sketch size <code>sketch_size=k</code> which is at least</p>
<p>.. math:: k \geq \frac{2}{\epsilon^2\delta}</p>
<p>Then for any fixed vector <code>x</code>,</p>
<p>.. math:: |Ax| = (1\pm\epsilon)|A'x|</p>
<p>with probability at least one minus delta.</p>
<p>This implementation takes advantage of sparsity: computing
a sketch takes time proportional to <code>A.nnz</code>. Data <code>A</code> which
is in <code>scipy.sparse.csc_matrix</code> format gives the quickest
computation time for sparse input.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
from scipy import sparse
n_rows, n_columns, density, sketch_n_rows = 15000, 100, 0.01, 200
A = sparse.rand(n_rows, n_columns, density=density, format='csc')
B = sparse.rand(n_rows, n_columns, density=density, format='csr')
C = sparse.rand(n_rows, n_columns, density=density, format='coo')
D = np.random.randn(n_rows, n_columns)
SA = linalg.clarkson_woodruff_transform(A, sketch_n_rows) # fastest
SB = linalg.clarkson_woodruff_transform(B, sketch_n_rows) # fast
SC = linalg.clarkson_woodruff_transform(C, sketch_n_rows) # slower
SD = linalg.clarkson_woodruff_transform(D, sketch_n_rows) # slowest</p>
</blockquote>
</blockquote>
</blockquote>
<p>That said, this method does perform well on dense inputs, just slower
on a relative scale.</p>
<h2 id="examples_149">Examples<a class="headerlink" href="#examples_149" title="Permanent link">&para;</a></h2>
<p>Given a big dense matrix <code>A</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
n_rows, n_columns, sketch_n_rows = 15000, 100, 200
A = np.random.randn(n_rows, n_columns)
sketch = linalg.clarkson_woodruff_transform(A, sketch_n_rows)
sketch.shape
(200, 100)
norm_A = np.linalg.norm(A)
norm_sketch = np.linalg.norm(sketch)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now with high probability, the true norm <code>norm_A</code> is close to
the sketched norm <code>norm_sketch</code> in absolute value.</p>
<p>Similarly, applying our sketch preserves the solution to a linear
regression of :math:<code>\min \|Ax - b\|</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
n_rows, n_columns, sketch_n_rows = 15000, 100, 200
A = np.random.randn(n_rows, n_columns)
b = np.random.randn(n_rows)
x = np.linalg.lstsq(A, b, rcond=None)
Ab = np.hstack((A, b.reshape(-1,1)))
SAb = linalg.clarkson_woodruff_transform(Ab, sketch_n_rows)
SA, Sb = SAb[:,:-1], SAb[:,-1]
x_sketched = np.linalg.lstsq(SA, Sb, rcond=None)</p>
</blockquote>
</blockquote>
</blockquote>
<p>As with the matrix norm example, <code>np.linalg.norm(A @ x - b)</code>
is close to <code>np.linalg.norm(A @ x_sketched - b)</code> with high
probability.</p>
<h2 id="references_20">References<a class="headerlink" href="#references_20" title="Permanent link">&para;</a></h2>
<p>.. [1] Kenneth L. Clarkson and David P. Woodruff. Low rank approximation and
regression in input sparsity time. In STOC, 2013.</p>
<p>.. [2] David P. Woodruff. Sketching as a tool for numerical linear algebra.
In Foundations and Trends in Theoretical Computer Science, 2014.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">companion</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a companion matrix.</p>
<p>Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in <code>a</code>.</p>
<h2 id="parameters_162">Parameters<a class="headerlink" href="#parameters_162" title="Permanent link">&para;</a></h2>
<p>a : (N,) array_like
1-D array of polynomial coefficients.  The length of <code>a</code> must be
at least two, and <code>a[0]</code> must not be zero.</p>
<h2 id="returns_162">Returns<a class="headerlink" href="#returns_162" title="Permanent link">&para;</a></h2>
<p>c : (N-1, N-1) ndarray
The first row of <code>c</code> is <code>-a[1:]/a[0]</code>, and the first
sub-diagonal is all ones.  The data-type of the array is the same
as the data-type of <code>1.0*a[0]</code>.</p>
<h2 id="raises_37">Raises<a class="headerlink" href="#raises_37" title="Permanent link">&para;</a></h2>
<p>ValueError
If any of the following are true: a) <code>a.ndim != 1</code>;
b) <code>a.size &lt; 2</code>; c) <code>a[0] == 0</code>.</p>
<h2 id="notes_77">Notes<a class="headerlink" href="#notes_77" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="references_21">References<a class="headerlink" href="#references_21" title="Permanent link">&para;</a></h2>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
Cambridge University Press, 1999, pp. 146-7.</p>
<h2 id="examples_150">Examples<a class="headerlink" href="#examples_150" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import companion
companion([1, -10, 31, -30])
array([[ 10., -31.,  30.],
[  1.,   0.,   0.],
[  0.,   1.,   0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coshm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_163">Parameters<a class="headerlink" href="#parameters_163" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_163">Returns<a class="headerlink" href="#returns_163" title="Permanent link">&para;</a></h2>
<p>coshm : (N, N) ndarray
Hyperbolic matrix cosine of <code>A</code></p>
<h2 id="examples_151">Examples<a class="headerlink" href="#examples_151" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
c = coshm(a)
c
array([[ 11.24592233,  38.76236492],
[ 12.92078831,  50.00828725]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = tanhm(a)
s = sinhm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_164">Parameters<a class="headerlink" href="#parameters_164" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array</p>
<h2 id="returns_164">Returns<a class="headerlink" href="#returns_164" title="Permanent link">&para;</a></h2>
<p>cosm : (N, N) ndarray
Matrix cosine of A</p>
<h2 id="examples_152">Examples<a class="headerlink" href="#examples_152" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">det</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the determinant of a matrix</p>
<p>The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.</p>
<p>The determinant for a 3x3 matrix, for example, is computed as follows::</p>
<p>a    b    c
d    e    f = A
g    h    i</p>
<p>det(A) = a<em>e</em>i + b<em>f</em>g + c<em>d</em>h - c<em>e</em>g - b<em>d</em>i - a<em>f</em>h</p>
<h2 id="parameters_165">Parameters<a class="headerlink" href="#parameters_165" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A square matrix.
overwrite_a : bool, optional
Allow overwriting data in a (may enhance performance).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_165">Returns<a class="headerlink" href="#returns_165" title="Permanent link">&para;</a></h2>
<p>det : float or complex
Determinant of <code>a</code>.</p>
<h2 id="notes_78">Notes<a class="headerlink" href="#notes_78" title="Permanent link">&para;</a></h2>
<p>The determinant is computed via LU factorization, LAPACK routine z/dgetrf.</p>
<h2 id="examples_153">Examples<a class="headerlink" href="#examples_153" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1,2,3], [4,5,6], [7,8,9]])
linalg.det(a)
0.0
a = np.array([[0,2,3], [4,5,6], [7,8,9]])
linalg.det(a)
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dft</span> <span class="o">:</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Discrete Fourier transform matrix.</p>
<p>Create the matrix that computes the discrete Fourier transform of a
sequence [1]_.  The n-th primitive root of unity used to generate the
matrix is exp(-2<em>pi</em>i/n), where i = sqrt(-1).</p>
<h2 id="parameters_166">Parameters<a class="headerlink" href="#parameters_166" title="Permanent link">&para;</a></h2>
<p>n : int
Size the matrix to create.
scale : str, optional
Must be None, 'sqrtn', or 'n'.
If <code>scale</code> is 'sqrtn', the matrix is divided by <code>sqrt(n)</code>.
If <code>scale</code> is 'n', the matrix is divided by <code>n</code>.
If <code>scale</code> is None (the default), the matrix is not normalized, and the
return value is simply the Vandermonde matrix of the roots of unity.</p>
<h2 id="returns_166">Returns<a class="headerlink" href="#returns_166" title="Permanent link">&para;</a></h2>
<p>m : (n, n) ndarray
The DFT matrix.</p>
<h2 id="notes_79">Notes<a class="headerlink" href="#notes_79" title="Permanent link">&para;</a></h2>
<p>When <code>scale</code> is None, multiplying a vector by the matrix returned by
<code>dft</code> is mathematically equivalent to (but much less efficient than)
the calculation performed by <code>scipy.fft.fft</code>.</p>
<p>.. versionadded:: 0.14.0</p>
<h2 id="references_22">References<a class="headerlink" href="#references_22" title="Permanent link">&para;</a></h2>
<p>.. [1] 'DFT matrix', https://en.wikipedia.org/wiki/DFT_matrix</p>
<h2 id="examples_154">Examples<a class="headerlink" href="#examples_154" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import dft
np.set_printoptions(precision=2, suppress=True)  # for compact output
m = dft(5)
m
array([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ],
[ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j],
[ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j],
[ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j],
[ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]])
x = np.array([1, 2, 3, 0, 3])
m @ x  # Compute the DFT of x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify that <code>m @ x</code> is the same as <code>fft(x)</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.fft import fft
fft(x)     # Same result as m @ x
array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagsvd</span> <span class="o">:</span> <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct the sigma matrix in SVD from singular values and size M, N.</p>
<h2 id="parameters_167">Parameters<a class="headerlink" href="#parameters_167" title="Permanent link">&para;</a></h2>
<p>s : (M,) or (N,) array_like
Singular values
M : int
Size of the matrix whose singular values are <code>s</code>.
N : int
Size of the matrix whose singular values are <code>s</code>.</p>
<h2 id="returns_167">Returns<a class="headerlink" href="#returns_167" title="Permanent link">&para;</a></h2>
<p>S : (M, N) ndarray
The S-matrix in the singular value decomposition</p>
<h2 id="see-also_86">See Also<a class="headerlink" href="#see-also_86" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
svdvals : Compute singular values of a matrix.</p>
<h2 id="examples_155">Examples<a class="headerlink" href="#examples_155" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import diagsvd
vals = np.array([1, 2, 3])  # The array representing the computed svd
diagsvd(vals, 3, 4)
array([[1, 0, 0, 0],
[0, 2, 0, 0],
[0, 0, 3, 0]])
diagsvd(vals, 4, 3)
array([[1, 0, 0],
[0, 2, 0],
[0, 0, 3],
[0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]</p>
<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h2 id="parameters_168">Parameters<a class="headerlink" href="#parameters_168" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
Default is None, identity matrix is assumed.
left : bool, optional
Whether to calculate and return left eigenvectors.  Default is False.
right : bool, optional
Whether to calculate and return right eigenvectors.  Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.  Default is False.
overwrite_b : bool, optional
Whether to overwrite <code>b</code>; may improve performance.  Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_168">Returns<a class="headerlink" href="#returns_168" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its
multiplicity. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.
vl : (M, M) double or complex ndarray
The normalized left eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.
vr : (M, M) double or complex ndarray
The normalized right eigenvector corresponding to the eigenvalue
<code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
<h2 id="raises_38">Raises<a class="headerlink" href="#raises_38" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_87">See Also<a class="headerlink" href="#see-also_87" title="Permanent link">&para;</a></h2>
<p>eigvals : eigenvalues of general arrays
eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_156">Examples<a class="headerlink" href="#examples_156" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
<p>a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a) == linalg.eig(a)[0]
array([ True,  True])
linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector
array([[-0.70710678+0.j        , -0.70710678-0.j        ],
[-0.        +0.70710678j, -0.        -0.70710678j]])
linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector
array([[0.70710678+0.j        , 0.70710678-0.j        ],
[0.        -0.70710678j, 0.        +0.70710678j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">max_ev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w and optionally right eigenvectors v of a::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<p>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_169">Parameters<a class="headerlink" href="#parameters_169" title="Permanent link">&para;</a></h2>
<p>a_band : (u+1, M) array_like
The bands of the M by M matrix a.
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
eigvals_only : bool, optional
Compute only the eigenvalues and no eigenvectors.
(Default: calculate also eigenvectors)
overwrite_a_band : bool, optional
Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
max_ev : int, optional
For select=='v', maximum number of eigenvalues expected.
For other values of select, has no meaning.</p>
<p>In doubt, leave this parameter untouched.</p>
<p>check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_169">Returns<a class="headerlink" href="#returns_169" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.
v : (M, M) float or complex ndarray
The normalized eigenvector corresponding to the eigenvalue w[i] is
the column v[:,i].</p>
<h2 id="raises_39">Raises<a class="headerlink" href="#raises_39" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_88">See Also<a class="headerlink" href="#see-also_88" title="Permanent link">&para;</a></h2>
<p>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eig : eigenvalues and right eigenvectors of general arrays.
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_157">Examples<a class="headerlink" href="#examples_157" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eig_banded
A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])
Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])
w, v = eig_banded(Ab, lower=True)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True
w = eig_banded(Ab, lower=True, eigvals_only=True)
w
array([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Request only the eigenvalues between <code>[-3, 4]</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>w, v = eig_banded(Ab, lower=True, select='v', select_range=[-3, 4])
w
array([-2.22987175,  3.95222349])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w and optionally eigenvectors v of matrix <code>a</code>, where
<code>b</code> is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_170">Parameters<a class="headerlink" href="#parameters_170" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
eigvals_only : bool, optional
Whether to calculate only eigenvalues and no eigenvectors.
(Default: both are calculated)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_170">Returns<a class="headerlink" href="#returns_170" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.
v : (M, N) complex ndarray
(if eigvals_only == False)</p>
<p>The normalized selected eigenvector corresponding to the
eigenvalue w[i] is the column v[:,i].</p>
<p>Normalization:</p>
<p>type 1 and 3: v.conj() a      v  = w</p>
<p>type 2: inv(v).conj() a  inv(v) = w</p>
<p>type = 1 or 2: v.conj() b      v  = I</p>
<p>type = 3: v.conj() inv(b) v  = I</p>
<h2 id="raises_40">Raises<a class="headerlink" href="#raises_40" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_89">See Also<a class="headerlink" href="#see-also_89" title="Permanent link">&para;</a></h2>
<p>eigvalsh : eigenvalues of symmetric or Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="notes_80">Notes<a class="headerlink" href="#notes_80" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_158">Examples<a class="headerlink" href="#examples_158" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w, v = eigh(A)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh_tridiagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> and optionally right eigenvectors <code>v</code> of <code>a</code>::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h2 id="parameters_171">Parameters<a class="headerlink" href="#parameters_171" title="Permanent link">&para;</a></h2>
<p>d : ndarray, shape (ndim,)
The diagonal elements of the array.
e : ndarray, shape (ndim-1,)
The off-diagonal elements of the array.
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
tol : float
The absolute tolerance to which each eigenvalue is required
(only used when 'stebz' is the <code>lapack_driver</code>).
An eigenvalue (or cluster) is considered to have converged if it
lies in an interval of this width. If &lt;= 0. (default),
the value <code>eps*|a|</code> is used where eps is the machine precision,
and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.
lapack_driver : str
LAPACK function to use, can be 'auto', 'stemr', 'stebz', 'sterf',
or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
and 'stebz' otherwise. When 'stebz' is used to find the eigenvalues and
<code>eigvals_only=False</code>, then a second LAPACK call (to <code>?STEIN</code>) is
used to find the corresponding eigenvectors. 'sterf' can only be
used when <code>eigvals_only=True</code> and <code>select='a'</code>. 'stev' can only
be used when <code>select='a'</code>.</p>
<h2 id="returns_171">Returns<a class="headerlink" href="#returns_171" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.
v : (M, M) ndarray
The normalized eigenvector corresponding to the eigenvalue <code>w[i]</code> is
the column <code>v[:,i]</code>.</p>
<h2 id="raises_41">Raises<a class="headerlink" href="#raises_41" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_90">See Also<a class="headerlink" href="#see-also_90" title="Permanent link">&para;</a></h2>
<p>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices
eig : eigenvalues and right eigenvectors for non-symmetric arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices</p>
<h2 id="notes_81">Notes<a class="headerlink" href="#notes_81" title="Permanent link">&para;</a></h2>
<p>This function makes use of LAPACK <code>S/DSTEMR</code> routines.</p>
<h2 id="examples_159">Examples<a class="headerlink" href="#examples_159" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh_tridiagonal
d = 3<em>np.ones(4)
e = -1</em>np.ones(3)
w, v = eigh_tridiagonal(d, e)
A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)
np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<p>a   vr[:,i] = w[i]        b   vr[:,i]</p>
<h2 id="parameters_172">Parameters<a class="headerlink" href="#parameters_172" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex or real matrix whose eigenvalues and eigenvectors
will be computed.
b : (M, M) array_like, optional
Right-hand side matrix in a generalized eigenvalue problem.
If omitted, identity matrix is assumed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities
or NaNs.
homogeneous_eigvals : bool, optional
If True, return the eigenvalues in homogeneous coordinates.
In this case <code>w</code> is a (2, M) array so that::</p>
<p>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]</p>
<p>Default is False.</p>
<h2 id="returns_172">Returns<a class="headerlink" href="#returns_172" title="Permanent link">&para;</a></h2>
<p>w : (M,) or (2, M) double or complex ndarray
The eigenvalues, each repeated according to its multiplicity
but not in any specific order. The shape is (M,) unless
<code>homogeneous_eigvals=True</code>.</p>
<h2 id="raises_42">Raises<a class="headerlink" href="#raises_42" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge</p>
<h2 id="see-also_91">See Also<a class="headerlink" href="#see-also_91" title="Permanent link">&para;</a></h2>
<p>eig : eigenvalues and right eigenvectors of general arrays.
eigvalsh : eigenvalues of symmetric or Hermitian arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices</p>
<h2 id="examples_160">Examples<a class="headerlink" href="#examples_160" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0., -1.], [1., 0.]])
linalg.eigvals(a)
array([0.+1.j, 0.-1.j])</p>
<p>b = np.array([[0., 1.], [1., 1.]])
linalg.eigvals(a, b)
array([ 1.+0.j, -1.+0.j])</p>
<p>a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])
linalg.eigvals(a, homogeneous_eigvals=True)
array([[3.+0.j, 8.+0.j, 7.+0.j],
[1.+0.j, 1.+0.j, 1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve real symmetric or complex hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w of a::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<p>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_173">Parameters<a class="headerlink" href="#parameters_173" title="Permanent link">&para;</a></h2>
<p>a_band : (u+1, M) array_like
The bands of the M by M matrix a.
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
overwrite_a_band : bool, optional
Discard data in a_band (may enhance performance)
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_173">Returns<a class="headerlink" href="#returns_173" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.</p>
<h2 id="raises_43">Raises<a class="headerlink" href="#raises_43" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_92">See Also<a class="headerlink" href="#see-also_92" title="Permanent link">&para;</a></h2>
<p>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian
band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices
eigvals : eigenvalues of general arrays
eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eig : eigenvalues and right eigenvectors for non-symmetric arrays</p>
<h2 id="examples_161">Examples<a class="headerlink" href="#examples_161" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvals_banded
A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])
Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])
w = eigvals_banded(Ab, lower=True)
w
array([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh</span> <span class="o">:</span> <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues w of matrix a, where b is positive definite::</p>
<p>a v[:,i] = w[i] b v[:,i]
v[i,:].conj() a v[:,i] = w[i]
v[i,:].conj() b v[:,i] = 1</p>
<h2 id="parameters_174">Parameters<a class="headerlink" href="#parameters_174" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A complex Hermitian or real symmetric matrix whose eigenvalues and
eigenvectors will be computed.
b : (M, M) array_like, optional
A complex Hermitian or real symmetric definite positive matrix in.
If omitted, identity matrix is assumed.
lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
turbo : bool, optional
Use divide and conquer algorithm (faster but expensive in memory,
only for generalized eigenvalue problem and if eigvals=None)
eigvals : tuple (lo, hi), optional
Indexes of the smallest and largest (in ascending order) eigenvalues
and corresponding eigenvectors to be returned: 0 &lt;= lo &lt; hi &lt;= M-1.
If omitted, all eigenvalues and eigenvectors are returned.
type : int, optional
Specifies the problem type to be solved:</p>
<p>type = 1: a   v[:,i] = w[i] b v[:,i]</p>
<p>type = 2: a b v[:,i] = w[i]   v[:,i]</p>
<p>type = 3: b a v[:,i] = w[i]   v[:,i]
overwrite_a : bool, optional
Whether to overwrite data in <code>a</code> (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in <code>b</code> (may improve performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_174">Returns<a class="headerlink" href="#returns_174" title="Permanent link">&para;</a></h2>
<p>w : (N,) float ndarray
The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
repeated according to its multiplicity.</p>
<h2 id="raises_44">Raises<a class="headerlink" href="#raises_44" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge,
an error occurred, or b matrix is not definite positive. Note that
if input matrices are not symmetric or hermitian, no error is reported
but results will be wrong.</p>
<h2 id="see-also_93">See Also<a class="headerlink" href="#see-also_93" title="Permanent link">&para;</a></h2>
<p>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
eigvals : eigenvalues of general arrays
eigvals_banded : eigenvalues for symmetric/Hermitian band matrices
eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
matrices</p>
<h2 id="notes_82">Notes<a class="headerlink" href="#notes_82" title="Permanent link">&para;</a></h2>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<h2 id="examples_162">Examples<a class="headerlink" href="#examples_162" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvalsh
A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])
w = eigvalsh(A)
w
array([-3.74637491, -0.76263923,  6.08502336, 12.42399079])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh_tridiagonal</span> <span class="o">:</span> <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> of <code>a</code>::</p>
<p>a v[:,i] = w[i] v[:,i]
v.H v    = identity</p>
<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h2 id="parameters_175">Parameters<a class="headerlink" href="#parameters_175" title="Permanent link">&para;</a></h2>
<p>d : ndarray, shape (ndim,)
The diagonal elements of the array.
e : ndarray, shape (ndim-1,)
The off-diagonal elements of the array.
select : {'a', 'v', 'i'}, optional
Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================
select_range : (min, max), optional
Range of selected eigenvalues
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
tol : float
The absolute tolerance to which each eigenvalue is required
(only used when <code>lapack_driver='stebz'</code>).
An eigenvalue (or cluster) is considered to have converged if it
lies in an interval of this width. If &lt;= 0. (default),
the value <code>eps*|a|</code> is used where eps is the machine precision,
and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.
lapack_driver : str
LAPACK function to use, can be 'auto', 'stemr', 'stebz',  'sterf',
or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
and 'stebz' otherwise. 'sterf' and 'stev' can only be used when
<code>select='a'</code>.</p>
<h2 id="returns_175">Returns<a class="headerlink" href="#returns_175" title="Permanent link">&para;</a></h2>
<p>w : (M,) ndarray
The eigenvalues, in ascending order, each repeated according to its
multiplicity.</p>
<h2 id="raises_45">Raises<a class="headerlink" href="#raises_45" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue computation does not converge.</p>
<h2 id="see-also_94">See Also<a class="headerlink" href="#see-also_94" title="Permanent link">&para;</a></h2>
<p>eigh_tridiagonal : eigenvalues and right eiegenvectors for
symmetric/Hermitian tridiagonal matrices</p>
<h2 id="examples_163">Examples<a class="headerlink" href="#examples_163" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigvalsh_tridiagonal, eigvalsh
d = 3<em>np.ones(4)
e = -1</em>np.ones(3)
w = eigvalsh_tridiagonal(d, e)
A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)
w2 = eigvalsh(A)  # Verify with other eigenvalue routines
np.allclose(w - w2, np.zeros(4))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h2 id="parameters_176">Parameters<a class="headerlink" href="#parameters_176" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like or sparse matrix
Matrix to be exponentiated.</p>
<h2 id="returns_176">Returns<a class="headerlink" href="#returns_176" title="Permanent link">&para;</a></h2>
<p>expm : (N, N) ndarray
Matrix exponential of <code>A</code>.</p>
<h2 id="references_23">References<a class="headerlink" href="#references_23" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
SIAM Journal on Matrix Analysis and Applications.
31 (3). pp. 970-989. ISSN 1095-7162</p>
<h2 id="examples_164">Examples<a class="headerlink" href="#examples_164" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Matrix version of the formula exp(0) = 1:</p>
<blockquote>
<blockquote>
<blockquote>
<p>expm(np.zeros((2,2)))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_cond</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">float</span>
</code></pre></div>

<p>Relative condition number of the matrix exponential in the Frobenius norm.</p>
<h2 id="parameters_177">Parameters<a class="headerlink" href="#parameters_177" title="Permanent link">&para;</a></h2>
<p>A : 2d array_like
Square input matrix with shape (N, N).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_177">Returns<a class="headerlink" href="#returns_177" title="Permanent link">&para;</a></h2>
<p>kappa : float
The relative condition number of the matrix exponential
in the Frobenius norm</p>
<h2 id="notes_83">Notes<a class="headerlink" href="#notes_83" title="Permanent link">&para;</a></h2>
<p>A faster estimate for the condition number in the 1-norm
has been published but is not yet implemented in scipy.</p>
<p>.. versionadded:: 0.14.0</p>
<h2 id="see-also_95">See also<a class="headerlink" href="#see-also_95" title="Permanent link">&para;</a></h2>
<p>expm : Compute the exponential of a matrix.
expm_frechet : Compute the Frechet derivative of the matrix exponential.</p>
<h2 id="examples_165">Examples<a class="headerlink" href="#examples_165" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm_cond
A = np.array([[-0.3, 0.2, 0.6], [0.6, 0.3, -0.1], [-0.7, 1.2, 0.9]])
k = expm_cond(A)
k
1.7787805864469866</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_frechet</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_expm</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Frechet derivative of the matrix exponential of A in the direction E.</p>
<h2 id="parameters_178">Parameters<a class="headerlink" href="#parameters_178" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix of which to take the matrix exponential.
E : (N, N) array_like
Matrix direction in which to take the Frechet derivative.
method : str, optional
Choice of algorithm.  Should be one of</p>
<ul>
<li><code>SPS</code> (default)</li>
<li><code>blockEnlarge</code></li>
</ul>
<p>compute_expm : bool, optional
Whether to compute also <code>expm_A</code> in addition to <code>expm_frechet_AE</code>.
Default is True.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_178">Returns<a class="headerlink" href="#returns_178" title="Permanent link">&para;</a></h2>
<p>expm_A : ndarray
Matrix exponential of A.
expm_frechet_AE : ndarray
Frechet derivative of the matrix exponential of A in the direction E.</p>
<p>For <code>compute_expm = False</code>, only <code>expm_frechet_AE</code> is returned.</p>
<h2 id="see-also_96">See also<a class="headerlink" href="#see-also_96" title="Permanent link">&para;</a></h2>
<p>expm : Compute the exponential of a matrix.</p>
<h2 id="notes_84">Notes<a class="headerlink" href="#notes_84" title="Permanent link">&para;</a></h2>
<p>This section describes the available implementations that can be selected
by the <code>method</code> parameter. The default method is <em>SPS</em>.</p>
<p>Method <em>blockEnlarge</em> is a naive algorithm.</p>
<p>Method <em>SPS</em> is Scaling-Pade-Squaring [1]_.
It is a sophisticated implementation which should take
only about 3/8 as much time as the naive implementation.
The asymptotics are the same.</p>
<p>.. versionadded:: 0.13.0</p>
<h2 id="references_24">References<a class="headerlink" href="#references_24" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
Computing the Frechet Derivative of the Matrix Exponential,
with an application to Condition Number Estimation.
SIAM Journal On Matrix Analysis and Applications.,
30 (4). pp. 1639-1657. ISSN 1095-7162</p>
<h2 id="examples_166">Examples<a class="headerlink" href="#examples_166" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg
A = np.random.randn(3, 3)
E = np.random.randn(3, 3)
expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
expm_A.shape, expm_frechet_AE.shape
((3, 3), (3, 3))</p>
<p>import scipy.linalg
A = np.random.randn(3, 3)
E = np.random.randn(3, 3)
expm_A, expm_frechet_AE = scipy.linalg.expm_frechet(A, E)
M = np.zeros((6, 6))
M[:3, :3] = A; M[:3, 3:] = E; M[3:, 3:] = A
expm_M = scipy.linalg.expm(M)
np.allclose(expm_A, expm_M[:3, :3])
True
np.allclose(expm_frechet_AE, expm_M[:3, 3:])
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a symmetric Fiedler matrix</p>
<p>Given an sequence of numbers <code>a</code>, Fiedler matrices have the structure
<code>F[i, j] = np.abs(a[i] - a[j])</code>, and hence zero diagonals and nonnegative
entries. A Fiedler matrix has a dominant positive eigenvalue and other
eigenvalues are negative. Although not valid generally, for certain inputs,
the inverse and the determinant can be derived explicitly as given in [1]_.</p>
<h2 id="parameters_179">Parameters<a class="headerlink" href="#parameters_179" title="Permanent link">&para;</a></h2>
<p>a : (n,) array_like
coefficient array</p>
<h2 id="returns_179">Returns<a class="headerlink" href="#returns_179" title="Permanent link">&para;</a></h2>
<p>F : (n, n) ndarray</p>
<h2 id="see-also_97">See Also<a class="headerlink" href="#see-also_97" title="Permanent link">&para;</a></h2>
<p>circulant, toeplitz</p>
<h2 id="notes_85">Notes<a class="headerlink" href="#notes_85" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 1.3.0</p>
<h2 id="references_25">References<a class="headerlink" href="#references_25" title="Permanent link">&para;</a></h2>
<p>.. [1] J. Todd, 'Basic Numerical Mathematics: Vol.2 : Numerical Algebra',
1977, Birkhauser, :doi:<code>10.1007/978-3-0348-7286-7</code></p>
<h2 id="examples_167">Examples<a class="headerlink" href="#examples_167" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import det, inv, fiedler
a = [1, 4, 12, 45, 77]
n = len(a)
A = fiedler(a)
A
array([[ 0,  3, 11, 44, 76],
[ 3,  0,  8, 41, 73],
[11,  8,  0, 33, 65],
[44, 41, 33,  0, 32],
[76, 73, 65, 32,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The explicit formulas for determinant and inverse seem to hold only for
monotonically increasing/decreasing arrays. Note the tridiagonal structure
and the corners.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Ai = inv(A)
Ai[np.abs(Ai) &lt; 1e-12] = 0.  # cleanup the numerical noise for display
Ai
array([[-0.16008772,  0.16666667,  0.        ,  0.        ,  0.00657895],
[ 0.16666667, -0.22916667,  0.0625    ,  0.        ,  0.        ],
[ 0.        ,  0.0625    , -0.07765152,  0.01515152,  0.        ],
[ 0.        ,  0.        ,  0.01515152, -0.03077652,  0.015625  ],
[ 0.00657895,  0.        ,  0.        ,  0.015625  , -0.00904605]])
det(A)
15409151.999999998
(-1)<strong>(n-1) * 2</strong>(n-2) * np.diff(a).prod() * (a[-1] - a[0])
15409152</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler_companion</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a Fiedler companion matrix</p>
<p>Given a polynomial coefficient array <code>a</code>, this function forms a
pentadiagonal matrix with a special structure whose eigenvalues coincides
with the roots of <code>a</code>.</p>
<h2 id="parameters_180">Parameters<a class="headerlink" href="#parameters_180" title="Permanent link">&para;</a></h2>
<p>a : (N,) array_like
1-D array of polynomial coefficients in descending order with a nonzero
leading coefficient. For <code>N &lt; 2</code>, an empty array is returned.</p>
<h2 id="returns_180">Returns<a class="headerlink" href="#returns_180" title="Permanent link">&para;</a></h2>
<p>c : (N-1, N-1) ndarray
Resulting companion matrix</p>
<h2 id="notes_86">Notes<a class="headerlink" href="#notes_86" title="Permanent link">&para;</a></h2>
<p>Similar to <code>companion</code> the leading coefficient should be nonzero. In case
the leading coefficient is not 1., other coefficients are rescaled before
the array generation. To avoid numerical issues, it is best to provide a
monic polynomial.</p>
<p>.. versionadded:: 1.3.0</p>
<h2 id="see-also_98">See Also<a class="headerlink" href="#see-also_98" title="Permanent link">&para;</a></h2>
<p>companion</p>
<h2 id="references_26">References<a class="headerlink" href="#references_26" title="Permanent link">&para;</a></h2>
<p>.. [1] M. Fiedler, ' A note on companion matrices', Linear Algebra and its
Applications, 2003, :doi:<code>10.1016/S0024-3795(03)00548-2</code></p>
<h2 id="examples_168">Examples<a class="headerlink" href="#examples_168" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import fiedler_companion, eigvals
p = np.poly(np.arange(1, 9, 2))  # [1., -16., 86., -176., 105.]
fc = fiedler_companion(p)
fc
array([[  16.,  -86.,    1.,    0.],
[   1.,    0.,    0.,    0.],
[   0.,  176.,    0., -105.],
[   0.,    1.,    0.,    0.]])
eigvals(fc)
array([7.+0.j, 5.+0.j, 3.+0.j, 1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_best_blas_type</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Find best-matching BLAS/LAPACK type.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_181">Parameters<a class="headerlink" href="#parameters_181" title="Permanent link">&para;</a></h2>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.
dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_181">Returns<a class="headerlink" href="#returns_181" title="Permanent link">&para;</a></h2>
<p>prefix : str
BLAS/LAPACK prefix character.
dtype : dtype
Inferred Numpy data type.
prefer_fortran : bool
Whether to prefer Fortran order routines over C order.</p>
<h2 id="examples_169">Examples<a class="headerlink" href="#examples_169" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg.blas as bla
a = np.random.rand(10,15)
b = np.asfortranarray(a)  # Change the memory layout order
bla.find_best_blas_type((a,))
('d', dtype('float64'), False)
bla.find_best_blas_type((a*1j,))
('z', dtype('complex128'), False)
bla.find_best_blas_type((b,))
('d', dtype('float64'), True)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fractional_matrix_power</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the fractional power of a matrix.</p>
<p>Proceeds according to the discussion in section (6) of [1]_.</p>
<h2 id="parameters_182">Parameters<a class="headerlink" href="#parameters_182" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose fractional power to evaluate.
t : float
Fractional power.</p>
<h2 id="returns_182">Returns<a class="headerlink" href="#returns_182" title="Permanent link">&para;</a></h2>
<p>X : (N, N) array_like
The fractional power of the matrix.</p>
<h2 id="references_27">References<a class="headerlink" href="#references_27" title="Permanent link">&para;</a></h2>
<p>.. [1] Nicholas J. Higham and Lijing lin (2011)
'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
SIAM Journal on Matrix Analysis and Applications,
32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h2 id="examples_170">Examples<a class="headerlink" href="#examples_170" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import fractional_matrix_power
a = np.array([[1.0, 3.0], [1.0, 4.0]])
b = fractional_matrix_power(a, 0.5)
b
array([[ 0.75592895,  1.13389342],
[ 0.37796447,  1.88982237]])
np.dot(b, b)      # Verify square root
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">funm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Evaluate a matrix function specified by a callable.</p>
<p>Returns the value of matrix-valued function <code>f</code> at <code>A</code>. The
function <code>f</code> is an extension of the scalar-valued function <code>func</code>
to matrices.</p>
<h2 id="parameters_183">Parameters<a class="headerlink" href="#parameters_183" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix at which to evaluate the function
func : callable
Callable object that evaluates a scalar function f.
Must be vectorized (eg. using vectorize).
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_183">Returns<a class="headerlink" href="#returns_183" title="Permanent link">&para;</a></h2>
<p>funm : (N, N) ndarray
Value of the matrix function specified by func evaluated at <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="examples_171">Examples<a class="headerlink" href="#examples_171" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import funm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
funm(a, lambda x: x*x)
array([[  4.,  15.],
[  5.,  19.]])
a.dot(a)
array([[  4.,  15.],
[  5.,  19.]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_87">Notes<a class="headerlink" href="#notes_87" title="Permanent link">&para;</a></h2>
<p>This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).</p>
<p>If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import eigh
def funm_herm(a, func, check_finite=False):
...     w, v = eigh(a, check_finite=check_finite)
...     ## if you further know that your matrix is positive semidefinite,
...     ## you can optionally guard against precision errors by doing
...     # w = np.maximum(w, 0)
...     w = func(w)
...     return (v * w).dot(v.conj().T)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_28">References<a class="headerlink" href="#references_28" title="Permanent link">&para;</a></h2>
<p>.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h2 id="parameters_184">Parameters<a class="headerlink" href="#parameters_184" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of BLAS functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of BLAS
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_184">Returns<a class="headerlink" href="#returns_184" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_88">Notes<a class="headerlink" href="#notes_88" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h2 id="examples_172">Examples<a class="headerlink" href="#examples_172" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_gemv = LA.get_blas_funcs('gemv', (a,))
x_gemv.typecode
'd'
x_gemv = LA.get_blas_funcs('gemv',(a*1j,))
x_gemv.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span> <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">names</span><span class="o">:[`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h2 id="parameters_185">Parameters<a class="headerlink" href="#parameters_185" title="Permanent link">&para;</a></h2>
<p>names : str or sequence of str
Name(s) of LAPACK functions without type prefix.</p>
<p>arrays : sequence of ndarrays, optional
Arrays can be given to determine optimal prefix of LAPACK
routines. If not given, double-precision routines will be
used, otherwise the most generic type in arrays will be used.</p>
<p>dtype : str or dtype, optional
Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
<h2 id="returns_185">Returns<a class="headerlink" href="#returns_185" title="Permanent link">&para;</a></h2>
<p>funcs : list
List containing the found function(s).</p>
<h2 id="notes_89">Notes<a class="headerlink" href="#notes_89" title="Permanent link">&para;</a></h2>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the numpy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h2 id="examples_173">Examples<a class="headerlink" href="#examples_173" title="Permanent link">&para;</a></h2>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(3,2)
x_lange = LA.get_lapack_funcs('lange', (a,))
x_lange.typecode
'd'
x_lange = LA.get_lapack_funcs('lange',(a*1j,))
x_lange.typecode
'z'</p>
</blockquote>
</blockquote>
</blockquote>
<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>import scipy.linalg as LA
a = np.random.rand(1000,1000)
b = np.random.rand(1000,1)*1j</p>
<h1 id="we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_9">We pick up zsysv and zsysv_lwork due to b array<a class="headerlink" href="#we-pick-up-zsysv-and-zsysv_lwork-due-to-b-array_9" title="Permanent link">&para;</a></h1>
<p>... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b))
opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix
udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hadamard</span> <span class="o">:</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hadamard matrix.</p>
<p>Constructs an n-by-n Hadamard matrix, using Sylvester's
construction.  <code>n</code> must be a power of 2.</p>
<h2 id="parameters_186">Parameters<a class="headerlink" href="#parameters_186" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the matrix.  <code>n</code> must be a power of 2.
dtype : dtype, optional
The data type of the array to be constructed.</p>
<h2 id="returns_186">Returns<a class="headerlink" href="#returns_186" title="Permanent link">&para;</a></h2>
<p>H : (n, n) ndarray
The Hadamard matrix.</p>
<h2 id="notes_90">Notes<a class="headerlink" href="#notes_90" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<h2 id="examples_174">Examples<a class="headerlink" href="#examples_174" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hadamard
hadamard(2, dtype=complex)
array([[ 1.+0.j,  1.+0.j],
[ 1.+0.j, -1.-0.j]])
hadamard(4)
array([[ 1,  1,  1,  1],
[ 1, -1,  1, -1],
[ 1,  1, -1, -1],
[ 1, -1, -1,  1]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hankel matrix.</p>
<p>The Hankel matrix has constant anti-diagonals, with <code>c</code> as its
first column and <code>r</code> as its last row.  If <code>r</code> is not given, then
<code>r = zeros_like(c)</code> is assumed.</p>
<h2 id="parameters_187">Parameters<a class="headerlink" href="#parameters_187" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
Last row of the matrix. If None, <code>r = zeros_like(c)</code> is assumed.
r[0] is ignored; the last row of the returned matrix is
<code>[c[-1], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_187">Returns<a class="headerlink" href="#returns_187" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Hankel matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_99">See Also<a class="headerlink" href="#see-also_99" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix
circulant : circulant matrix</p>
<h2 id="examples_175">Examples<a class="headerlink" href="#examples_175" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hankel
hankel([1, 17, 99])
array([[ 1, 17, 99],
[17, 99,  0],
[99,  0,  0]])
hankel([1,2,3,4], [4,7,7,8,9])
array([[1, 2, 3, 4, 7],
[2, 3, 4, 7, 7],
[3, 4, 7, 7, 8],
[4, 7, 7, 8, 9]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">helmert</span> <span class="o">:</span> <span class="o">?</span><span class="n">full</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Helmert matrix of order <code>n</code>.</p>
<p>This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.</p>
<h2 id="parameters_188">Parameters<a class="headerlink" href="#parameters_188" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the array to create.
full : bool, optional
If True the (n, n) ndarray will be returned.
Otherwise the submatrix that does not include the first
row will be returned.
Default: False.</p>
<h2 id="returns_188">Returns<a class="headerlink" href="#returns_188" title="Permanent link">&para;</a></h2>
<p>M : ndarray
The Helmert matrix.
The shape is (n, n) or (n-1, n) depending on the <code>full</code> argument.</p>
<h2 id="examples_176">Examples<a class="headerlink" href="#examples_176" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import helmert
helmert(5, full=True)
array([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ],
[ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ],
[ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ],
[ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ],
[ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hessenberg</span> <span class="o">:</span> <span class="o">?</span><span class="n">calc_q</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Hessenberg form of a matrix.</p>
<p>The Hessenberg decomposition is::</p>
<p>A = Q H Q^H</p>
<p>where <code>Q</code> is unitary/orthogonal and <code>H</code> has only zero elements below
the first sub-diagonal.</p>
<h2 id="parameters_189">Parameters<a class="headerlink" href="#parameters_189" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to bring into Hessenberg form.
calc_q : bool, optional
Whether to compute the transformation matrix.  Default is False.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_189">Returns<a class="headerlink" href="#returns_189" title="Permanent link">&para;</a></h2>
<p>H : (M, M) ndarray
Hessenberg form of <code>a</code>.
Q : (M, M) ndarray
Unitary/orthogonal similarity transformation matrix <code>A = Q H Q^H</code>.
Only returned if <code>calc_q=True</code>.</p>
<h2 id="examples_177">Examples<a class="headerlink" href="#examples_177" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hessenberg
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
H, Q = hessenberg(A, calc_q=True)
H
array([[  2.        , -11.65843866,   1.42005301,   0.25349066],
[ -9.94987437,  14.53535354,  -5.31022304,   2.43081618],
[  0.        ,  -1.83299243,   0.38969961,  -0.51527034],
[  0.        ,   0.        ,  -3.83189513,   1.07494686]])
np.allclose(Q @ H @ Q.conj().T - A, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Hilbert matrix of order <code>n</code>.</p>
<p>Returns the <code>n</code> by <code>n</code> array with entries <code>h[i,j] = 1 / (i + j + 1)</code>.</p>
<h2 id="parameters_190">Parameters<a class="headerlink" href="#parameters_190" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the array to create.</p>
<h2 id="returns_190">Returns<a class="headerlink" href="#returns_190" title="Permanent link">&para;</a></h2>
<p>h : (n, n) ndarray
The Hilbert matrix.</p>
<h2 id="see-also_100">See Also<a class="headerlink" href="#see-also_100" title="Permanent link">&para;</a></h2>
<p>invhilbert : Compute the inverse of a Hilbert matrix.</p>
<h2 id="notes_91">Notes<a class="headerlink" href="#notes_91" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_178">Examples<a class="headerlink" href="#examples_178" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hilbert
hilbert(3)
array([[ 1.        ,  0.5       ,  0.33333333],
[ 0.5       ,  0.33333333,  0.25      ],
[ 0.33333333,  0.25      ,  0.2       ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h2 id="parameters_191">Parameters<a class="headerlink" href="#parameters_191" title="Permanent link">&para;</a></h2>
<p>a : array_like
Square matrix to be inverted.
overwrite_a : bool, optional
Discard data in <code>a</code> (may improve performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_191">Returns<a class="headerlink" href="#returns_191" title="Permanent link">&para;</a></h2>
<p>ainv : ndarray
Inverse of the matrix <code>a</code>.</p>
<h2 id="raises_46">Raises<a class="headerlink" href="#raises_46" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular.
ValueError
If <code>a</code> is not square, or not 2-dimensional.</p>
<h2 id="examples_179">Examples<a class="headerlink" href="#examples_179" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[1., 2.], [3., 4.]])
linalg.inv(a)
array([[-2. ,  1. ],
[ 1.5, -0.5]])
np.dot(a, linalg.inv(a))
array([[ 1.,  0.],
[ 0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invhilbert</span> <span class="o">:</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the Hilbert matrix of order <code>n</code>.</p>
<p>The entries in the inverse of a Hilbert matrix are integers.  When <code>n</code>
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers.  The <code>exact</code> argument provides two options for
dealing with these large integers.</p>
<h2 id="parameters_192">Parameters<a class="headerlink" href="#parameters_192" title="Permanent link">&para;</a></h2>
<p>n : int
The order of the Hilbert matrix.
exact : bool, optional
If False, the data type of the array that is returned is np.float64,
and the array is an approximation of the inverse.
If True, the array is the exact integer inverse array.  To represent
the exact inverse when n &gt; 14, the returned array is an object array
of long integers.  For n &lt;= 14, the exact inverse is returned as an
array with data type np.int64.</p>
<h2 id="returns_192">Returns<a class="headerlink" href="#returns_192" title="Permanent link">&para;</a></h2>
<p>invh : (n, n) ndarray
The data type of the array is np.float64 if <code>exact</code> is False.
If <code>exact</code> is True, the data type is either np.int64 (for n &lt;= 14)
or object (for n &gt; 14).  In the latter case, the objects in the
array will be long integers.</p>
<h2 id="see-also_101">See Also<a class="headerlink" href="#see-also_101" title="Permanent link">&para;</a></h2>
<p>hilbert : Create a Hilbert matrix.</p>
<h2 id="notes_92">Notes<a class="headerlink" href="#notes_92" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.10.0</p>
<h2 id="examples_180">Examples<a class="headerlink" href="#examples_180" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import invhilbert
invhilbert(4)
array([[   16.,  -120.,   240.,  -140.],
[ -120.,  1200., -2700.,  1680.],
[  240., -2700.,  6480., -4200.],
[ -140.,  1680., -4200.,  2800.]])
invhilbert(4, exact=True)
array([[   16,  -120,   240,  -140],
[ -120,  1200, -2700,  1680],
[  240, -2700,  6480, -4200],
[ -140,  1680, -4200,  2800]], dtype=int64)
invhilbert(16)[7,7]
4.2475099528537506e+19
invhilbert(16, exact=True)[7,7]
42475099528537378560L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invpascal</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the inverse of the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h2 id="parameters_193">Parameters<a class="headerlink" href="#parameters_193" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the matrix to create; that is, the result is an n x n
matrix.
kind : str, optional
Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.
exact : bool, optional
If <code>exact</code> is True, the result is either an array of type
<code>numpy.int64</code> (if <code>n</code> &lt;= 35) or an object array of Python integers.
If <code>exact</code> is False, the coefficients in the matrix are computed using
<code>scipy.special.comb</code> with <code>exact=False</code>.  The result will be a floating
point array, and for large <code>n</code>, the values in the array will not be the
exact coefficients.</p>
<h2 id="returns_193">Returns<a class="headerlink" href="#returns_193" title="Permanent link">&para;</a></h2>
<p>invp : (n, n) ndarray
The inverse of the Pascal matrix.</p>
<h2 id="see-also_102">See Also<a class="headerlink" href="#see-also_102" title="Permanent link">&para;</a></h2>
<p>pascal</p>
<h2 id="notes_93">Notes<a class="headerlink" href="#notes_93" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_29">References<a class="headerlink" href="#references_29" title="Permanent link">&para;</a></h2>
<p>.. [1] 'Pascal matrix', https://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., 'The inverse of a Pascal matrix', Mathematical
Gazette, 59(408), pp. 111-112, 1975.</p>
<h2 id="examples_181">Examples<a class="headerlink" href="#examples_181" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import invpascal, pascal
invp = invpascal(5)
invp
array([[  5, -10,  10,  -5,   1],
[-10,  30, -35,  19,  -4],
[ 10, -35,  46, -27,   6],
[ -5,  19, -27,  17,  -4],
[  1,  -4,   6,  -4,   1]])</p>
<p>p = pascal(5)
p.dot(invp)
array([[ 1.,  0.,  0.,  0.,  0.],
[ 0.,  1.,  0.,  0.,  0.],
[ 0.,  0.,  1.,  0.,  0.],
[ 0.,  0.,  0.,  1.,  0.],
[ 0.,  0.,  0.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An example of the use of <code>kind</code> and <code>exact</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>invpascal(5, kind='lower', exact=False)
array([[ 1., -0.,  0., -0.,  0.],
[-1.,  1., -0.,  0., -0.],
[ 1., -2.,  1., -0.,  0.],
[-1.,  3., -3.,  1., -0.],
[ 1., -4.,  6., -4.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Kronecker product.</p>
<p>The result is the block matrix::</p>
<p>a[0,0]<em>b    a[0,1]</em>b  ... a[0,-1]<em>b
a[1,0]</em>b    a[1,1]<em>b  ... a[1,-1]</em>b
...
a[-1,0]<em>b   a[-1,1]</em>b ... a[-1,-1]*b</p>
<h2 id="parameters_194">Parameters<a class="headerlink" href="#parameters_194" title="Permanent link">&para;</a></h2>
<p>a : (M, N) ndarray
Input array
b : (P, Q) ndarray
Input array</p>
<h2 id="returns_194">Returns<a class="headerlink" href="#returns_194" title="Permanent link">&para;</a></h2>
<p>A : (M<em>P, N</em>Q) ndarray
Kronecker product of <code>a</code> and <code>b</code>.</p>
<h2 id="examples_182">Examples<a class="headerlink" href="#examples_182" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.linalg import kron
kron(array([[1,2],[3,4]]), array([[1,1,1]]))
array([[1, 1, 1, 2, 2, 2],
[3, 3, 3, 4, 4, 4]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ldl</span> <span class="o">:</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Computes the LDLt or Bunch-Kaufman factorization of a symmetric/
hermitian matrix.</p>
<p>This function returns a block diagonal matrix D consisting blocks of size
at most 2x2 and also a possibly permuted unit lower triangular matrix
<code>L</code> such that the factorization <code>A = L D L^H</code> or <code>A = L D L^T</code>
holds. If <code>lower</code> is False then (again possibly permuted) upper
triangular matrices are returned as outer factors.</p>
<p>The permutation array can be used to triangularize the outer factors
simply by a row shuffle, i.e., <code>lu[perm, :]</code> is an upper/lower
triangular matrix. This is also equivalent to multiplication with a
permutation matrix <code>P.dot(lu)</code> where <code>P</code> is a column-permuted
identity matrix <code>I[:, perm]</code>.</p>
<p>Depending on the value of the boolean <code>lower</code>, only upper or lower
triangular part of the input array is referenced. Hence a triangular
matrix on entry would give the same result as if the full matrix is
supplied.</p>
<h2 id="parameters_195">Parameters<a class="headerlink" href="#parameters_195" title="Permanent link">&para;</a></h2>
<p>a : array_like
Square input array
lower : bool, optional
This switches between the lower and upper triangular outer factors of
the factorization. Lower triangular (<code>lower=True</code>) is the default.
hermitian : bool, optional
For complex-valued arrays, this defines whether <code>a = a.conj().T</code> or
<code>a = a.T</code> is assumed. For real-valued arrays, this switch has no
effect.
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance). The default
is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_195">Returns<a class="headerlink" href="#returns_195" title="Permanent link">&para;</a></h2>
<p>lu : ndarray
The (possibly) permuted upper/lower triangular outer factor of the
factorization.
d : ndarray
The block diagonal multiplier of the factorization.
perm : ndarray
The row-permutation index array that brings lu into triangular form.</p>
<h2 id="raises_47">Raises<a class="headerlink" href="#raises_47" title="Permanent link">&para;</a></h2>
<p>ValueError
If input array is not square.
ComplexWarning
If a complex-valued array with nonzero imaginary parts on the
diagonal is given and hermitian is set to True.</p>
<h2 id="examples_183">Examples<a class="headerlink" href="#examples_183" title="Permanent link">&para;</a></h2>
<p>Given an upper triangular array <code>a</code> that represents the full symmetric
array with its entries, obtain <code>l</code>, 'd' and the permutation vector <code>perm</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.linalg import ldl
a = np.array([[2, -1, 3], [0, 2, 0], [0, 0, 1]])
lu, d, perm = ldl(a, lower=0) # Use the upper part
lu
array([[ 0. ,  0. ,  1. ],
[ 0. ,  1. , -0.5],
[ 1. ,  1. ,  1.5]])
d
array([[-5. ,  0. ,  0. ],
[ 0. ,  1.5,  0. ],
[ 0. ,  0. ,  2. ]])
perm
array([2, 1, 0])
lu[perm, :]
array([[ 1. ,  1. ,  1.5],
[ 0. ,  1. , -0.5],
[ 0. ,  0. ,  1. ]])
lu.dot(d).dot(lu.T)
array([[ 2., -1.,  3.],
[-1.,  2.,  0.],
[ 3.,  0.,  1.]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_94">Notes<a class="headerlink" href="#notes_94" title="Permanent link">&para;</a></h2>
<p>This function uses <code>?SYTRF</code> routines for symmetric matrices and
<code>?HETRF</code> routines for Hermitian matrices from LAPACK. See [1]_ for
the algorithm details.</p>
<p>Depending on the <code>lower</code> keyword value, only lower or upper triangular
part of the input array is referenced. Moreover, this keyword also defines
the structure of the outer factors of the factorization.</p>
<p>.. versionadded:: 1.1.0</p>
<h2 id="see-also_103">See also<a class="headerlink" href="#see-also_103" title="Permanent link">&para;</a></h2>
<p>cholesky, lu</p>
<h2 id="references_30">References<a class="headerlink" href="#references_30" title="Permanent link">&para;</a></h2>
<p>.. [1] J.R. Bunch, L. Kaufman, Some stable methods for calculating
inertia and solving symmetric linear systems, Math. Comput. Vol.31,
1977. DOI: 10.2307/2005787</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leslie</span> <span class="o">:</span> <span class="n">f</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Leslie matrix.</p>
<p>Given the length n array of fecundity coefficients <code>f</code> and the length
n-1 array of survival coefficients <code>s</code>, return the associated Leslie
matrix.</p>
<h2 id="parameters_196">Parameters<a class="headerlink" href="#parameters_196" title="Permanent link">&para;</a></h2>
<p>f : (N,) array_like
The 'fecundity' coefficients.
s : (N-1,) array_like
The 'survival' coefficients, has to be 1-D.  The length of <code>s</code>
must be one less than the length of <code>f</code>, and it must be at least 1.</p>
<h2 id="returns_196">Returns<a class="headerlink" href="#returns_196" title="Permanent link">&para;</a></h2>
<p>L : (N, N) ndarray
The array is zero except for the first row,
which is <code>f</code>, and the first sub-diagonal, which is <code>s</code>.
The data-type of the array will be the data-type of <code>f[0]+s[0]</code>.</p>
<h2 id="notes_95">Notes<a class="headerlink" href="#notes_95" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.8.0</p>
<p>The Leslie matrix is used to model discrete-time, age-structured
population growth [1]<em> [2]</em>. In a population with <code>n</code> age classes, two sets
of parameters define a Leslie matrix: the <code>n</code> 'fecundity coefficients',
which give the number of offspring per-capita produced by each age
class, and the <code>n</code> - 1 'survival coefficients', which give the
per-capita survival rate of each age class.</p>
<h2 id="references_31">References<a class="headerlink" href="#references_31" title="Permanent link">&para;</a></h2>
<p>.. [1] P. H. Leslie, On the use of matrices in certain population
mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
(Dec. 1948)</p>
<h2 id="examples_184">Examples<a class="headerlink" href="#examples_184" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import leslie
leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7])
array([[ 0.1,  2. ,  1. ,  0.1],
[ 0.2,  0. ,  0. ,  0. ],
[ 0. ,  0.8,  0. ,  0. ],
[ 0. ,  0. ,  0.7,  0. ]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute matrix logarithm.</p>
<p>The matrix logarithm is the inverse of
expm: expm(logm(<code>A</code>)) == <code>A</code></p>
<h2 id="parameters_197">Parameters<a class="headerlink" href="#parameters_197" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose logarithm to evaluate
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_197">Returns<a class="headerlink" href="#returns_197" title="Permanent link">&para;</a></h2>
<p>logm : (N, N) ndarray
Matrix logarithm of <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="references_32">References<a class="headerlink" href="#references_32" title="Permanent link">&para;</a></h2>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
'Improved Inverse Scaling and Squaring Algorithms
for the Matrix Logarithm.'
SIAM Journal on Scientific Computing, 34 (4). C152-C169.
ISSN 1095-7197</p>
<p>.. [2] Nicholas J. Higham (2008)
'Functions of Matrices: Theory and Computation'
ISBN 978-0-898716-46-7</p>
<p>.. [3] Nicholas J. Higham and Lijing lin (2011)
'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
SIAM Journal on Matrix Analysis and Applications,
32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h2 id="examples_185">Examples<a class="headerlink" href="#examples_185" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import logm, expm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
b = logm(a)
b
array([[-1.02571087,  2.05142174],
[ 0.68380725,  1.02571087]])
expm(b)         # Verify expm(logm(a)) returns a
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lstsq</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Compute least-squares solution to equation Ax = b.</p>
<p>Compute a vector x such that the 2-norm <code>|b - A x|</code> is minimized.</p>
<h2 id="parameters_198">Parameters<a class="headerlink" href="#parameters_198" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Left hand side array
b : (M,) or (M, K) array_like
Right hand side array
cond : float, optional
Cutoff for 'small' singular values; used to determine effective
rank of a. Singular values smaller than
<code>rcond * largest_singular_value</code> are considered zero.
overwrite_a : bool, optional
Discard data in <code>a</code> (may enhance performance). Default is False.
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance). Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : str, optional
Which LAPACK driver is used to solve the least-squares problem.
Options are <code>'gelsd'</code>, <code>'gelsy'</code>, <code>'gelss'</code>. Default
(<code>'gelsd'</code>) is a good choice.  However, <code>'gelsy'</code> can be slightly
faster on many problems.  <code>'gelss'</code> was used historically.  It is
generally slow but uses less memory.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="returns_198">Returns<a class="headerlink" href="#returns_198" title="Permanent link">&para;</a></h2>
<p>x : (N,) or (N, K) ndarray
Least-squares solution.  Return shape matches shape of <code>b</code>.
residues : (K,) ndarray or float
Square of the 2-norm for each column in <code>b - a x</code>, if <code>M &gt; N</code> and
<code>ndim(A) == n</code> (returns a scalar if b is 1-D). Otherwise a
(0,)-shaped array is returned.
rank : int
Effective rank of <code>a</code>.
s : (min(M, N),) ndarray or None
Singular values of <code>a</code>. The condition number of a is
<code>abs(s[0] / s[-1])</code>.</p>
<h2 id="raises_48">Raises<a class="headerlink" href="#raises_48" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If computation does not converge.</p>
<p>ValueError
When parameters are not compatible.</p>
<h2 id="see-also_104">See Also<a class="headerlink" href="#see-also_104" title="Permanent link">&para;</a></h2>
<p>scipy.optimize.nnls : linear least squares with non-negativity constraint</p>
<h2 id="notes_96">Notes<a class="headerlink" href="#notes_96" title="Permanent link">&para;</a></h2>
<p>When <code>'gelsy'</code> is used as a driver, <code>residues</code> is set to a (0,)-shaped
array and <code>s</code> is always <code>None</code>.</p>
<h2 id="examples_186">Examples<a class="headerlink" href="#examples_186" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lstsq
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Suppose we have the following data:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])
y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to fit a quadratic polynomial of the form <code>y = a + b*x**2</code>
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing <code>x**2</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M = x[:, np.newaxis]**[0, 2]
M
array([[  1.  ,   1.  ],
[  1.  ,   6.25],
[  1.  ,  12.25],
[  1.  ,  16.  ],
[  1.  ,  25.  ],
[  1.  ,  49.  ],
[  1.  ,  72.25]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to find the least-squares solution to <code>M.dot(p) = y</code>,
where <code>p</code> is a vector with length 2 that holds the parameters
<code>a</code> and <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>p, res, rnk, s = lstsq(M, y)
p
array([ 0.20925829,  0.12013861])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the data and the fitted curve.</p>
<blockquote>
<blockquote>
<blockquote>
<p>plt.plot(x, y, 'o', label='data')
xx = np.linspace(0, 9, 101)
yy = p[0] + p[1]<em>xx</em>*2
plt.plot(xx, yy, label='least squares fit, <span><span class="MathJax_Preview">y = a + bx^2</span><script type="math/tex">y = a + bx^2</script></span>')
plt.xlabel('x')
plt.ylabel('y')
plt.legend(framealpha=1, shadow=True)
plt.grid(alpha=0.25)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu</span> <span class="o">:</span> <span class="o">?</span><span class="n">permute_l</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_199">Parameters<a class="headerlink" href="#parameters_199" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Array to decompose
permute_l : bool, optional
Perform the multiplication P*L  (Default: do not permute)
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_199">Returns<a class="headerlink" href="#returns_199" title="Permanent link">&para;</a></h2>
<p><strong>(If permute_l == False)</strong></p>
<p>p : (M, M) ndarray
Permutation matrix
l : (M, K) ndarray
Lower triangular or trapezoidal matrix with unit diagonal.
K = min(M, N)
u : (K, N) ndarray
Upper triangular or trapezoidal matrix</p>
<p><strong>(If permute_l == True)</strong></p>
<p>pl : (M, K) ndarray
Permuted L matrix.
K = min(M, N)
u : (K, N) ndarray
Upper triangular or trapezoidal matrix</p>
<h2 id="notes_97">Notes<a class="headerlink" href="#notes_97" title="Permanent link">&para;</a></h2>
<p>This is a LU factorization routine written for SciPy.</p>
<h2 id="examples_187">Examples<a class="headerlink" href="#examples_187" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
p, l, u = lu(A)
np.allclose(A - p @ l @ u, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<p>A = P L U</p>
<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h2 id="parameters_200">Parameters<a class="headerlink" href="#parameters_200" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
overwrite_a : bool, optional
Whether to overwrite data in A (may increase performance)
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_200">Returns<a class="headerlink" href="#returns_200" title="Permanent link">&para;</a></h2>
<p>lu : (N, N) ndarray
Matrix containing U in its upper triangle, and L in its lower triangle.
The unit diagonal elements of L are not stored.
piv : (N,) ndarray
Pivot indices representing the permutation matrix P:
row i of matrix was interchanged with row piv[i].</p>
<h2 id="see-also_105">See also<a class="headerlink" href="#see-also_105" title="Permanent link">&para;</a></h2>
<p>lu_solve : solve an equation system using the LU factorization of a matrix</p>
<h2 id="notes_98">Notes<a class="headerlink" href="#notes_98" title="Permanent link">&para;</a></h2>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h2 id="examples_188">Examples<a class="headerlink" href="#examples_188" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
lu, piv = lu_factor(A)
piv
array([2, 2, 3, 3], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<blockquote>
<blockquote>
<blockquote>
<p>piv_py = [2, 0, 3, 1]
L, U = np.tril(lu, k=-1) + np.eye(4), np.triu(lu)
np.allclose(A[piv_py] - L @ U, np.zeros((4, 4)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h2 id="parameters_201">Parameters<a class="headerlink" href="#parameters_201" title="Permanent link">&para;</a></h2>
<p>(lu, piv)
Factorization of the coefficient matrix a, as given by lu_factor
b : array
Right-hand side
trans : {0, 1, 2}, optional
Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========
overwrite_b : bool, optional
Whether to overwrite data in b (may increase performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_201">Returns<a class="headerlink" href="#returns_201" title="Permanent link">&para;</a></h2>
<p>x : array
Solution to the system</p>
<h2 id="see-also_106">See also<a class="headerlink" href="#see-also_106" title="Permanent link">&para;</a></h2>
<p>lu_factor : LU factorize a matrix</p>
<h2 id="examples_189">Examples<a class="headerlink" href="#examples_189" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import lu_factor, lu_solve
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
b = np.array([1, 1, 1, 1])
lu, piv = lu_factor(A)
x = lu_solve((lu, piv), b)
np.allclose(A @ x - b, np.zeros((4,)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix_balance</span> <span class="o">:</span> <span class="o">?</span><span class="n">permute</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">separate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a diagonal similarity transformation for row/column balancing.</p>
<p>The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.</p>
<p>Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.</p>
<p>The balanced matrix satisfies the following equality</p>
<p>.. math::</p>
<p>B = T^{-1} A T</p>
<p>The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.</p>
<h2 id="parameters_202">Parameters<a class="headerlink" href="#parameters_202" title="Permanent link">&para;</a></h2>
<p>A : (n, n) array_like
Square data matrix for the balancing.
permute : bool, optional
The selector to define whether permutation of A is also performed
prior to scaling.
scale : bool, optional
The selector to turn on and off the scaling. If False, the matrix
will not be scaled.
separate : bool, optional
This switches from returning a full matrix of the transformation
to a tuple of two separate 1D permutation and scaling arrays.
overwrite_a : bool, optional
This is passed to xGEBAL directly. Essentially, overwrites the result
to the data. It might increase the space efficiency. See LAPACK manual
for details. This is False by default.</p>
<h2 id="returns_202">Returns<a class="headerlink" href="#returns_202" title="Permanent link">&para;</a></h2>
<p>B : (n, n) ndarray
Balanced matrix
T : (n, n) ndarray
A possibly permuted diagonal matrix whose nonzero entries are
integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
If <code>separate</code> keyword is set to True then instead of the array
<code>T</code> above, the scaling and the permutation vectors are given
separately as a tuple without allocating the full array <code>T</code>.</p>
<h2 id="notes_99">Notes<a class="headerlink" href="#notes_99" title="Permanent link">&para;</a></h2>
<p>This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.</p>
<p>The algorithm is based on the well-known technique of [1]<em> and has
been modified to account for special cases. See [2]</em> for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.</p>
<p>The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.</p>
<p>.. versionadded:: 0.19.0</p>
<h2 id="examples_190">Examples<a class="headerlink" href="#examples_190" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])</p>
<p>y, permscale = linalg.matrix_balance(x)
np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)
array([ 3.66666667,  0.4995005 ,  0.91312162])</p>
<p>np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)
array([ 1.2       ,  1.27041742,  0.92658316])  # may vary</p>
<p>permscale  # only powers of 2 (0.5 == 2^(-1))
array([[  0.5,   0. ,  0. ],  # may vary
[  0. ,   1. ,  0. ],
[  0. ,   0. ,  1. ]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="references_33">References<a class="headerlink" href="#references_33" title="Permanent link">&para;</a></h2>
<p>.. [1] : B.N. Parlett and C. Reinsch, 'Balancing a Matrix for
Calculation of Eigenvalues and Eigenvectors', Numerische Mathematik,
Vol.13(4), 1969, DOI:10.1007/BF02165404</p>
<p>.. [2] : R. James, J. Langou, B.R. Lowery, 'On matrix balancing and
eigenvector computation', 2014, Available online:
https://arxiv.org/abs/1401.5766</p>
<p>.. [3] :  D.S. Watkins. A case where balancing is harmful.
Electron. Trans. Numer. Anal, Vol.23, 2006.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span> <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h2 id="parameters_203">Parameters<a class="headerlink" href="#parameters_203" title="Permanent link">&para;</a></h2>
<p>a : (M,) or (M, N) array_like
Input array.  If <code>axis</code> is None, <code>a</code> must be 1-D or 2-D.
ord : {non-zero int, inf, -inf, 'fro'}, optional
Order of the norm (see table under <code>Notes</code>). inf means numpy's
<code>inf</code> object
axis : {int, 2-tuple of ints, None}, optional
If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.
keepdims : bool, optional
If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>a</code>.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_203">Returns<a class="headerlink" href="#returns_203" title="Permanent link">&para;</a></h2>
<p>n : float or ndarray
Norm of the matrix or vector(s).</p>
<h2 id="notes_100">Notes<a class="headerlink" href="#notes_100" title="Permanent link">&para;</a></h2>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<p>:math:<code>||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}</code></p>
<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h2 id="references_34">References<a class="headerlink" href="#references_34" title="Permanent link">&para;</a></h2>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h2 id="examples_191">Examples<a class="headerlink" href="#examples_191" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import norm
a = np.arange(9) - 4.0
a
array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])
b = a.reshape((3, 3))
b
array([[-4., -3., -2.],
[-1.,  0.,  1.],
[ 2.,  3.,  4.]])</p>
<p>norm(a)
7.745966692414834
norm(b)
7.745966692414834
norm(b, 'fro')
7.745966692414834
norm(a, np.inf)
4
norm(b, np.inf)
9
norm(a, -np.inf)
0
norm(b, -np.inf)
2</p>
<p>norm(a, 1)
20
norm(b, 1)
7
norm(a, -1)
-4.6566128774142013e-010
norm(b, -1)
6
norm(a, 2)
7.745966692414834
norm(b, 2)
7.3484692283495345</p>
<p>norm(a, -2)
0
norm(b, -2)
1.8570331885190563e-016
norm(a, 3)
5.8480354764257312
norm(a, -3)
0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">null_space</span> <span class="o">:</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the null space of A using SVD</p>
<h2 id="parameters_204">Parameters<a class="headerlink" href="#parameters_204" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
Input array
rcond : float, optional
Relative condition number. Singular values <code>s</code> smaller than
<code>rcond * max(s)</code> are considered zero.
Default: floating point eps * max(M,N).</p>
<h2 id="returns_204">Returns<a class="headerlink" href="#returns_204" title="Permanent link">&para;</a></h2>
<p>Z : (N, K) ndarray
Orthonormal basis for the null space of A.
K = dimension of effective null space, as determined by rcond</p>
<h2 id="see-also_107">See also<a class="headerlink" href="#see-also_107" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
orth : Matrix range</p>
<h2 id="examples_192">Examples<a class="headerlink" href="#examples_192" title="Permanent link">&para;</a></h2>
<p>One-dimensional null space:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import null_space
A = np.array([[1, 1], [1, 1]])
ns = null_space(A)
ns * np.sign(ns[0,0])  # Remove the sign ambiguity of the vector
array([[ 0.70710678],
[-0.70710678]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two-dimensional null space:</p>
<blockquote>
<blockquote>
<blockquote>
<p>B = np.random.rand(3, 5)
Z = null_space(B)
Z.shape
(5, 2)
np.allclose(B.dot(Z), 0)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>The basis vectors are orthonormal (up to rounding error):</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z.T.dot(Z)
array([[  1.00000000e+00,   6.92087741e-17],
[  6.92087741e-17,   1.00000000e+00]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ordqz</span> <span class="o">:</span> <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>QZ decomposition for a pair of matrices with reordering.</p>
<p>.. versionadded:: 0.17.0</p>
<h2 id="parameters_205">Parameters<a class="headerlink" href="#parameters_205" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
2d array to decompose
B : (N, N) array_like
2d array to decompose
sort : {callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
Specifies whether the upper eigenvalues should be sorted. A
callable may be passed that, given an ordered pair <code>(alpha,
beta)</code> representing the eigenvalue <code>x = (alpha/beta)</code>,
returns a boolean denoting whether the eigenvalue should be
sorted to the top-left (True). For the real matrix pairs
<code>beta</code> is real while <code>alpha</code> can be complex, and for
complex matrix pairs both <code>alpha</code> and <code>beta</code> can be
complex. The callable must be able to accept a numpy
array. Alternatively, string parameters may be used:</p>
<ul>
<li>'lhp'   Left-hand plane (x.real &lt; 0.0)</li>
<li>'rhp'   Right-hand plane (x.real &gt; 0.0)</li>
<li>'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0)</li>
<li>'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)</li>
</ul>
<p>With the predefined sorting functions, an infinite eigenvalue
(i.e. <code>alpha != 0</code> and <code>beta = 0</code>) is considered to lie in
neither the left-hand nor the right-hand plane, but it is
considered to lie outside the unit circle. For the eigenvalue
<code>(alpha, beta) = (0, 0)</code> the predefined sorting functions
all return <code>False</code>.
output : str {'real','complex'}, optional
Construct the real or complex QZ decomposition for real matrices.
Default is 'real'.
overwrite_a : bool, optional
If True, the contents of A are overwritten.
overwrite_b : bool, optional
If True, the contents of B are overwritten.
check_finite : bool, optional
If true checks the elements of <code>A</code> and <code>B</code> are finite numbers. If
false does no checking and passes matrix through to
underlying algorithm.</p>
<h2 id="returns_205">Returns<a class="headerlink" href="#returns_205" title="Permanent link">&para;</a></h2>
<p>AA : (N, N) ndarray
Generalized Schur form of A.
BB : (N, N) ndarray
Generalized Schur form of B.
alpha : (N,) ndarray
alpha = alphar + alphai * 1j. See notes.
beta : (N,) ndarray
See notes.
Q : (N, N) ndarray
The left Schur vectors.
Z : (N, N) ndarray
The right Schur vectors.</p>
<h2 id="notes_101">Notes<a class="headerlink" href="#notes_101" title="Permanent link">&para;</a></h2>
<p>On exit, <code>(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N</code>, will be the
generalized eigenvalues.  <code>ALPHAR(j) + ALPHAI(j)*i</code> and
<code>BETA(j),j=1,...,N</code> are the diagonals of the complex Schur form (S,T)
that would result if the 2-by-2 diagonal blocks of the real generalized
Schur form of (A,B) were further reduced to triangular form using complex
unitary transformations. If ALPHAI(j) is zero, then the j-th eigenvalue is
real; if positive, then the <code>j</code>-th and <code>(j+1)</code>-st eigenvalues are a
complex conjugate pair, with <code>ALPHAI(j+1)</code> negative.</p>
<h2 id="see-also_108">See also<a class="headerlink" href="#see-also_108" title="Permanent link">&para;</a></h2>
<p>qz</p>
<h2 id="examples_193">Examples<a class="headerlink" href="#examples_193" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import ordqz
A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])
B = np.array([[0, 6, 0, 0], [5, 0, 2, 1], [5, 2, 6, 6], [4, 7, 7, 7]])
AA, BB, alpha, beta, Q, Z = ordqz(A, B, sort='lhp')</p>
</blockquote>
</blockquote>
</blockquote>
<p>Since we have sorted for left half plane eigenvalues, negatives come first</p>
<blockquote>
<blockquote>
<blockquote>
<p>(alpha/beta).real &lt; 0
array([ True,  True, False, False], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orth</span> <span class="o">:</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the range of A using SVD</p>
<h2 id="parameters_206">Parameters<a class="headerlink" href="#parameters_206" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
Input array
rcond : float, optional
Relative condition number. Singular values <code>s</code> smaller than
<code>rcond * max(s)</code> are considered zero.
Default: floating point eps * max(M,N).</p>
<h2 id="returns_206">Returns<a class="headerlink" href="#returns_206" title="Permanent link">&para;</a></h2>
<p>Q : (M, K) ndarray
Orthonormal basis for the range of A.
K = effective rank of A, as determined by rcond</p>
<h2 id="see-also_109">See also<a class="headerlink" href="#see-also_109" title="Permanent link">&para;</a></h2>
<p>svd : Singular value decomposition of a matrix
null_space : Matrix null space</p>
<h2 id="examples_194">Examples<a class="headerlink" href="#examples_194" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import orth
A = np.array([[2, 0, 0], [0, 5, 0]])  # rank 2 array
orth(A)
array([[0., 1.],
[1., 0.]])
orth(A.T)
array([[0., 1.],
[1., 0.],
[0., 0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orthogonal_procrustes</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute the matrix solution of the orthogonal Procrustes problem.</p>
<p>Given matrices A and B of equal shape, find an orthogonal matrix R
that most closely maps A to B using the algorithm given in [1]_.</p>
<h2 id="parameters_207">Parameters<a class="headerlink" href="#parameters_207" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
Matrix to be mapped.
B : (M, N) array_like
Target matrix.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_207">Returns<a class="headerlink" href="#returns_207" title="Permanent link">&para;</a></h2>
<p>R : (N, N) ndarray
The matrix solution of the orthogonal Procrustes problem.
Minimizes the Frobenius norm of <code>(A @ R) - B</code>, subject to
<code>R.T @ R = I</code>.
scale : float
Sum of the singular values of <code>A.T @ B</code>.</p>
<h2 id="raises_49">Raises<a class="headerlink" href="#raises_49" title="Permanent link">&para;</a></h2>
<p>ValueError
If the input array shapes don't match or if check_finite is True and
the arrays contain Inf or NaN.</p>
<h2 id="notes_102">Notes<a class="headerlink" href="#notes_102" title="Permanent link">&para;</a></h2>
<p>Note that unlike higher level Procrustes analyses of spatial data, this
function only uses orthogonal transformations like rotations and
reflections, and it does not use scaling or translation.</p>
<p>.. versionadded:: 0.15.0</p>
<h2 id="references_35">References<a class="headerlink" href="#references_35" title="Permanent link">&para;</a></h2>
<p>.. [1] Peter H. Schonemann, 'A generalized solution of the orthogonal
Procrustes problem', Psychometrica -- Vol. 31, No. 1, March, 1996.</p>
<h2 id="examples_195">Examples<a class="headerlink" href="#examples_195" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import orthogonal_procrustes
A = np.array([[ 2,  0,  1], [-2,  0,  0]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Flip the order of columns and check for the anti-diagonal mapping</p>
<blockquote>
<blockquote>
<blockquote>
<p>R, sca = orthogonal_procrustes(A, np.fliplr(A))
R
array([[-5.34384992e-17,  0.00000000e+00,  1.00000000e+00],
[ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
[ 1.00000000e+00,  0.00000000e+00, -7.85941422e-17]])
sca
9.0</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pascal</span> <span class="o">:</span> <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h2 id="parameters_208">Parameters<a class="headerlink" href="#parameters_208" title="Permanent link">&para;</a></h2>
<p>n : int
The size of the matrix to create; that is, the result is an n x n
matrix.
kind : str, optional
Must be one of 'symmetric', 'lower', or 'upper'.
Default is 'symmetric'.
exact : bool, optional
If <code>exact</code> is True, the result is either an array of type
numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
If <code>exact</code> is False, the coefficients in the matrix are computed using
<code>scipy.special.comb</code> with <code>exact=False</code>.  The result will be a floating
point array, and the values in the array will not be the exact
coefficients, but this version is much faster than <code>exact=True</code>.</p>
<h2 id="returns_208">Returns<a class="headerlink" href="#returns_208" title="Permanent link">&para;</a></h2>
<p>p : (n, n) ndarray
The Pascal matrix.</p>
<h2 id="see-also_110">See Also<a class="headerlink" href="#see-also_110" title="Permanent link">&para;</a></h2>
<p>invpascal</p>
<h2 id="notes_103">Notes<a class="headerlink" href="#notes_103" title="Permanent link">&para;</a></h2>
<p>See https://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_196">Examples<a class="headerlink" href="#examples_196" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import pascal
pascal(4)
array([[ 1,  1,  1,  1],
[ 1,  2,  3,  4],
[ 1,  3,  6, 10],
[ 1,  4, 10, 20]], dtype=uint64)
pascal(4, kind='lower')
array([[1, 0, 0, 0],
[1, 1, 0, 0],
[1, 2, 1, 0],
[1, 3, 3, 1]], dtype=uint64)
pascal(50)[-1, -1]
25477612258980856902730428600L
from scipy.special import comb
comb(98, 49, exact=True)
25477612258980856902730428600L</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using a least-squares
solver.</p>
<h2 id="parameters_209">Parameters<a class="headerlink" href="#parameters_209" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be pseudo-inverted.
cond, rcond : float, optional
Cutoff factor for 'small' singular values. In <code>lstsq</code>,
singular values less than <code>cond*largest_singular_value</code> will be
considered as zero. If both are omitted, the default value
<code>max(M, N) * eps</code> is passed to <code>lstsq</code> where <code>eps</code> is the
corresponding machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps</code> without the
factor <code>max(M, N)</code>.</p>
<p>return_rank : bool, optional
if True, return the effective rank of the matrix
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_209">Returns<a class="headerlink" href="#returns_209" title="Permanent link">&para;</a></h2>
<p>B : (N, M) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if return_rank == True</p>
<h2 id="raises_50">Raises<a class="headerlink" href="#raises_50" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If computation does not converge.</p>
<h2 id="examples_197">Examples<a class="headerlink" href="#examples_197" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)
B = linalg.pinv(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv2</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.</p>
<h2 id="parameters_210">Parameters<a class="headerlink" href="#parameters_210" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be pseudo-inverted.
cond, rcond : float or None
Cutoff for 'small' singular values; singular values smaller than this
value are considered as zero. If both are omitted, the default value
<code>max(M,N)*largest_singular_value*eps</code> is used where <code>eps</code> is the
machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
<p>return_rank : bool, optional
If True, return the effective rank of the matrix.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_210">Returns<a class="headerlink" href="#returns_210" title="Permanent link">&para;</a></h2>
<p>B : (N, M) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
<h2 id="raises_51">Raises<a class="headerlink" href="#raises_51" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="examples_198">Examples<a class="headerlink" href="#examples_198" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)
B = linalg.pinv2(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinvh</span> <span class="o">:</span> <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</p>
<p>Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.</p>
<h2 id="parameters_211">Parameters<a class="headerlink" href="#parameters_211" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
Cutoff for 'small' singular values; singular values smaller than this
value are considered as zero. If both are omitted, the default
<code>max(M,N)*largest_eigenvalue*eps</code> is used where <code>eps</code> is the
machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
<p>lower : bool, optional
Whether the pertinent array data is taken from the lower or upper
triangle of <code>a</code>. (Default: lower)
return_rank : bool, optional
If True, return the effective rank of the matrix.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_211">Returns<a class="headerlink" href="#returns_211" title="Permanent link">&para;</a></h2>
<p>B : (N, N) ndarray
The pseudo-inverse of matrix <code>a</code>.
rank : int
The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
<h2 id="raises_52">Raises<a class="headerlink" href="#raises_52" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If eigenvalue does not converge</p>
<h2 id="examples_199">Examples<a class="headerlink" href="#examples_199" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import pinvh
a = np.random.randn(9, 6)
a = np.dot(a, a.T)
B = pinvh(a)
np.allclose(a, np.dot(a, np.dot(B, a)))
True
np.allclose(B, np.dot(B, np.dot(a, B)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polar</span> <span class="o">:</span> <span class="o">?</span><span class="n">side</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the polar decomposition.</p>
<p>Returns the factors of the polar decomposition [1]<em> <code>u</code> and <code>p</code> such
that <code>a = up</code> (if <code>side</code> is 'right') or <code>a = pu</code> (if <code>side</code> is
'left'), where <code>p</code> is positive semidefinite.  Depending on the shape
of <code>a</code>, either the rows or columns of <code>u</code> are orthonormal.  When <code>a</code>
is a square array, <code>u</code> is a square unitary array.  When <code>a</code> is not
square, the 'canonical polar decomposition' [2]</em> is computed.</p>
<h2 id="parameters_212">Parameters<a class="headerlink" href="#parameters_212" title="Permanent link">&para;</a></h2>
<p>a : (m, n) array_like
The array to be factored.
side : {'left', 'right'}, optional
Determines whether a right or left polar decomposition is computed.
If <code>side</code> is 'right', then <code>a = up</code>.  If <code>side</code> is 'left',  then
<code>a = pu</code>.  The default is 'right'.</p>
<h2 id="returns_212">Returns<a class="headerlink" href="#returns_212" title="Permanent link">&para;</a></h2>
<p>u : (m, n) ndarray
If <code>a</code> is square, then <code>u</code> is unitary.  If m &gt; n, then the columns
of <code>a</code> are orthonormal, and if m &lt; n, then the rows of <code>u</code> are
orthonormal.
p : ndarray
<code>p</code> is Hermitian positive semidefinite.  If <code>a</code> is nonsingular, <code>p</code>
is positive definite.  The shape of <code>p</code> is (n, n) or (m, m), depending
on whether <code>side</code> is 'right' or 'left', respectively.</p>
<h2 id="references_36">References<a class="headerlink" href="#references_36" title="Permanent link">&para;</a></h2>
<p>.. [1] R. A. Horn and C. R. Johnson, 'Matrix Analysis', Cambridge
University Press, 1985.
.. [2] N. J. Higham, 'Functions of Matrices: Theory and Computation',
SIAM, 2008.</p>
<h2 id="examples_200">Examples<a class="headerlink" href="#examples_200" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import polar
a = np.array([[1, -1], [2, 4]])
u, p = polar(a)
u
array([[ 0.85749293, -0.51449576],
[ 0.51449576,  0.85749293]])
p
array([[ 1.88648444,  1.2004901 ],
[ 1.2004901 ,  3.94446746]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A non-square example, with m &lt; n:</p>
<blockquote>
<blockquote>
<blockquote>
<p>b = np.array([[0.5, 1, 2], [1.5, 3, 4]])
u, p = polar(b)
u
array([[-0.21196618, -0.42393237,  0.88054056],
[ 0.39378971,  0.78757942,  0.4739708 ]])
p
array([[ 0.48470147,  0.96940295,  1.15122648],
[ 0.96940295,  1.9388059 ,  2.30245295],
[ 1.15122648,  2.30245295,  3.65696431]])
u.dot(p)   # Verify the decomposition.
array([[ 0.5,  1. ,  2. ],
[ 1.5,  3. ,  4. ]])
u.dot(u.T)   # The rows of u are orthonormal.
array([[  1.00000000e+00,  -2.07353665e-17],
[ -2.07353665e-17,   1.00000000e+00]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Another non-square example, with m &gt; n:</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = b.T
u, p = polar(c)
u
array([[-0.21196618,  0.39378971],
[-0.42393237,  0.78757942],
[ 0.88054056,  0.4739708 ]])
p
array([[ 1.23116567,  1.93241587],
[ 1.93241587,  4.84930602]])
u.dot(p)   # Verify the decomposition.
array([[ 0.5,  1.5],
[ 1. ,  3. ],
[ 2. ,  4. ]])
u.T.dot(u)  # The columns of u are orthonormal.
array([[  1.00000000e+00,  -1.26363763e-16],
[ -1.26363763e-16,   1.00000000e+00]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_213">Parameters<a class="headerlink" href="#parameters_213" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic', 'raw'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes). The final option 'raw'
(added in SciPy 0.11) makes the function return two matrices
(Q, TAU) in the internal format used by LAPACK.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition. If pivoting, compute the decomposition
<code>A P = Q R</code> as above, but where P is chosen such that the diagonal
of R is non-increasing.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_213">Returns<a class="headerlink" href="#returns_213" title="Permanent link">&para;</a></h2>
<p>Q : float or complex ndarray
Of shape (M, M), or (M, K) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.
R : float or complex ndarray
Of shape (M, N), or (K, N) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
P : int ndarray
Of shape (N,) for <code>pivoting=True</code>. Not returned if
<code>pivoting=False</code>.</p>
<h2 id="raises_53">Raises<a class="headerlink" href="#raises_53" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if decomposition fails</p>
<h2 id="notes_104">Notes<a class="headerlink" href="#notes_104" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_201">Examples<a class="headerlink" href="#examples_201" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(9, 6)</p>
<p>q, r = linalg.qr(a)
np.allclose(a, np.dot(q, r))
True
q.shape, r.shape
((9, 9), (9, 6))</p>
<p>r2 = linalg.qr(a, mode='r')
np.allclose(r, r2)
True</p>
<p>q3, r3 = linalg.qr(a, mode='economic')
q3.shape, r3.shape
((9, 6), (6, 6))</p>
<p>q4, r4, p4 = linalg.qr(a, pivoting=True)
d = np.abs(np.diag(r4))
np.all(d[1:] &lt;= d[:-1])
True
np.allclose(a[:, p4], np.dot(q4, r4))
True
q4.shape, r4.shape, p4.shape
((9, 9), (9, 6), (6,))</p>
<p>q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True)
q5.shape, r5.shape, p5.shape
((9, 6), (6, 6), (6,))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_insert</span> <span class="o">:</span> <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">Row</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Col</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_qru</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>qr_insert(Q, R, u, k, which=u'row', rcond=None, overwrite_qru=False, check_finite=True)</p>
<p>QR update on row or column insertions</p>
<p>If <code>A = Q R</code> is the QR factorization of <code>A</code>, return the QR
factorization of <code>A</code> where rows or columns have been inserted starting
at row or column <code>k</code>.</p>
<h2 id="parameters_214">Parameters<a class="headerlink" href="#parameters_214" title="Permanent link">&para;</a></h2>
<p>Q : (M, M) array_like
Unitary/orthogonal matrix from the QR decomposition of A.
R : (M, N) array_like
Upper triangular matrix from the QR decomposition of A.
u : (N,), (p, N), (M,), or (M, p) array_like
Rows or columns to insert
k : int
Index before which <code>u</code> is to be inserted.
which: {'row', 'col'}, optional
Determines if rows or columns will be inserted, defaults to 'row'
rcond : float
Lower bound on the reciprocal condition number of <code>Q</code> augmented with
<code>u/||u||</code> Only used when updating economic mode (thin, (M,N) (N,N))
decompositions.  If None, machine precision is used.  Defaults to
None.
overwrite_qru : bool, optional
If True, consume Q, R, and u, if possible, while performing the update,
otherwise make copies as necessary. Defaults to False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default is True.</p>
<h2 id="returns_214">Returns<a class="headerlink" href="#returns_214" title="Permanent link">&para;</a></h2>
<p>Q1 : ndarray
Updated unitary/orthogonal factor
R1 : ndarray
Updated upper triangular factor</p>
<h2 id="raises_54">Raises<a class="headerlink" href="#raises_54" title="Permanent link">&para;</a></h2>
<p>LinAlgError :
If updating a (M,N) (N,N) factorization and the reciprocal condition
number of Q augmented with u/||u|| is smaller than rcond.</p>
<h2 id="see-also_111">See Also<a class="headerlink" href="#see-also_111" title="Permanent link">&para;</a></h2>
<p>qr, qr_multiply, qr_delete, qr_update</p>
<h2 id="notes_105">Notes<a class="headerlink" href="#notes_105" title="Permanent link">&para;</a></h2>
<p>This routine does not guarantee that the diagonal entries of <code>R1</code> are
positive.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_37">References<a class="headerlink" href="#references_37" title="Permanent link">&para;</a></h2>
<p>.. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
(Johns Hopkins University Press, 1996).</p>
<p>.. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
Reorthogonalization and stable algorithms for updating the
Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).</p>
<p>.. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
(1990).</p>
<h2 id="examples_202">Examples<a class="headerlink" href="#examples_202" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[  3.,  -2.,  -2.],
...               [  6.,  -7.,   4.],
...               [  7.,   8.,  -6.]])
q, r = linalg.qr(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given this QR decomposition, update q and r when 2 rows are inserted.</p>
<blockquote>
<blockquote>
<blockquote>
<p>u = np.array([[  6.,  -9.,  -3.],
...               [ -3.,  10.,   1.]])
q1, r1 = linalg.qr_insert(q, r, u, 2, 'row')
q1
array([[-0.25445668,  0.02246245,  0.18146236, -0.72798806,  0.60979671],  # may vary (signs)
[-0.50891336,  0.23226178, -0.82836478, -0.02837033, -0.00828114],
[-0.50891336,  0.35715302,  0.38937158,  0.58110733,  0.35235345],
[ 0.25445668, -0.52202743, -0.32165498,  0.36263239,  0.65404509],
[-0.59373225, -0.73856549,  0.16065817, -0.0063658 , -0.27595554]])
r1
array([[-11.78982612,   6.44623587,   3.81685018],  # may vary (signs)
[  0.        , -16.01393278,   3.72202865],
[  0.        ,   0.        ,  -6.13010256],
[  0.        ,   0.        ,   0.        ],
[  0.        ,   0.        ,   0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The update is equivalent, but faster than the following.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a1 = np.insert(a, 2, u, 0)
a1
array([[  3.,  -2.,  -2.],
[  6.,  -7.,   4.],
[  6.,  -9.,  -3.],
[ -3.,  10.,   1.],
[  7.,   8.,  -6.]])
q_direct, r_direct = linalg.qr(a1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check that we have equivalent results:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.dot(q1, r1)
array([[  3.,  -2.,  -2.],
[  6.,  -7.,   4.],
[  6.,  -9.,  -3.],
[ -3.,  10.,   1.],
[  7.,   8.,  -6.]])</p>
<p>np.allclose(np.dot(q1, r1), a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>And the updated Q is still unitary:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.allclose(np.dot(q1.T, q1), np.eye(5))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_multiply</span> <span class="o">:</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">conjugate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_c</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the QR decomposition and multiply Q with a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular. Multiply Q with a vector or a matrix c.</p>
<h2 id="parameters_215">Parameters<a class="headerlink" href="#parameters_215" title="Permanent link">&para;</a></h2>
<p>a : (M, N), array_like
Input array
c : array_like
Input array to be multiplied by <code>q</code>.
mode : {'left', 'right'}, optional
<code>Q @ c</code> is returned if mode is 'left', <code>c @ Q</code> is returned if
mode is 'right'.
The shape of c must be appropriate for the matrix multiplications,
if mode is 'left', <code>min(a.shape) == c.shape[0]</code>,
if mode is 'right', <code>a.shape[0] == c.shape[1]</code>.
pivoting : bool, optional
Whether or not factorization should include pivoting for rank-revealing
qr decomposition, see the documentation of qr.
conjugate : bool, optional
Whether Q should be complex-conjugated. This might be faster
than explicit conjugation.
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
overwrite_c : bool, optional
Whether data in c is overwritten (may improve performance).
If this is used, c must be big enough to keep the result,
i.e. <code>c.shape[0]</code> = <code>a.shape[0]</code> if mode is 'left'.</p>
<h2 id="returns_215">Returns<a class="headerlink" href="#returns_215" title="Permanent link">&para;</a></h2>
<p>CQ : ndarray
The product of <code>Q</code> and <code>c</code>.
R : (K, N), ndarray
R array of the resulting QR factorization where <code>K = min(M, N)</code>.
P : (N,) ndarray
Integer pivot array. Only returned when <code>pivoting=True</code>.</p>
<h2 id="raises_55">Raises<a class="headerlink" href="#raises_55" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Raised if QR decomposition fails.</p>
<h2 id="notes_106">Notes<a class="headerlink" href="#notes_106" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines <code>?GEQRF</code>, <code>?ORMQR</code>,
<code>?UNMQR</code>, and <code>?GEQP3</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_203">Examples<a class="headerlink" href="#examples_203" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import qr_multiply, qr
A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]])
qc, r1, piv1 = qr_multiply(A, 2<em>np.eye(4), pivoting=1)
qc
array([[-1.,  1., -1.],
[-1., -1.,  1.],
[-1., -1., -1.],
[-1.,  1.,  1.]])
r1
array([[-6., -3., -5.            ],
[ 0., -1., -1.11022302e-16],
[ 0.,  0., -1.            ]])
piv1
array([1, 0, 2], dtype=int32)
q2, r2, piv2 = qr(A, mode='economic', pivoting=1)
np.allclose(2</em>q2 - qc, np.zeros((4, 3)))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_update</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_qruv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)</p>
<p>Rank-k QR update</p>
<p>If <code>A = Q R</code> is the QR factorization of <code>A</code>, return the QR
factorization of <code>A + u v**T</code> for real <code>A</code> or <code>A + u v**H</code>
for complex <code>A</code>.</p>
<h2 id="parameters_216">Parameters<a class="headerlink" href="#parameters_216" title="Permanent link">&para;</a></h2>
<p>Q : (M, M) or (M, N) array_like
Unitary/orthogonal matrix from the qr decomposition of A.
R : (M, N) or (N, N) array_like
Upper triangular matrix from the qr decomposition of A.
u : (M,) or (M, k) array_like
Left update vector
v : (N,) or (N, k) array_like
Right update vector
overwrite_qruv : bool, optional
If True, consume Q, R, u, and v, if possible, while performing the
update, otherwise make copies as necessary. Defaults to False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default is True.</p>
<h2 id="returns_216">Returns<a class="headerlink" href="#returns_216" title="Permanent link">&para;</a></h2>
<p>Q1 : ndarray
Updated unitary/orthogonal factor
R1 : ndarray
Updated upper triangular factor</p>
<h2 id="see-also_112">See Also<a class="headerlink" href="#see-also_112" title="Permanent link">&para;</a></h2>
<p>qr, qr_multiply, qr_delete, qr_insert</p>
<h2 id="notes_107">Notes<a class="headerlink" href="#notes_107" title="Permanent link">&para;</a></h2>
<p>This routine does not guarantee that the diagonal entries of <code>R1</code> are
real or positive.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="references_38">References<a class="headerlink" href="#references_38" title="Permanent link">&para;</a></h2>
<p>.. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
(Johns Hopkins University Press, 1996).</p>
<p>.. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
Reorthogonalization and stable algorithms for updating the
Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).</p>
<p>.. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
(1990).</p>
<h2 id="examples_204">Examples<a class="headerlink" href="#examples_204" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[  3.,  -2.,  -2.],
...               [  6.,  -9.,  -3.],
...               [ -3.,  10.,   1.],
...               [  6.,  -7.,   4.],
...               [  7.,   8.,  -6.]])
q, r = linalg.qr(a)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given this q, r decomposition, perform a rank 1 update.</p>
<blockquote>
<blockquote>
<blockquote>
<p>u = np.array([7., -2., 4., 3., 5.])
v = np.array([1., 3., -5.])
q_up, r_up = linalg.qr_update(q, r, u, v, False)
q_up
array([[ 0.54073807,  0.18645997,  0.81707661, -0.02136616,  0.06902409],  # may vary (signs)
[ 0.21629523, -0.63257324,  0.06567893,  0.34125904, -0.65749222],
[ 0.05407381,  0.64757787, -0.12781284, -0.20031219, -0.72198188],
[ 0.48666426, -0.30466718, -0.27487277, -0.77079214,  0.0256951 ],
[ 0.64888568,  0.23001   , -0.4859845 ,  0.49883891,  0.20253783]])
r_up
array([[ 18.49324201,  24.11691794, -44.98940746],  # may vary (signs)
[  0.        ,  31.95894662, -27.40998201],
[  0.        ,   0.        ,  -9.25451794],
[  0.        ,   0.        ,   0.        ],
[  0.        ,   0.        ,   0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The update is equivalent, but faster than the following.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a_up = a + np.outer(u, v)
q_direct, r_direct = linalg.qr(a_up)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check that we have equivalent results:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.allclose(np.dot(q_up, r_up), a_up)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>And the updated Q is still unitary:</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.allclose(np.dot(q_up.T, q_up), np.eye(5))
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Updating economic (reduced, thin) decompositions is also possible:</p>
<blockquote>
<blockquote>
<blockquote>
<p>qe, re = linalg.qr(a, mode='economic')
qe_up, re_up = linalg.qr_update(qe, re, u, v, False)
qe_up
array([[ 0.54073807,  0.18645997,  0.81707661],  # may vary (signs)
[ 0.21629523, -0.63257324,  0.06567893],
[ 0.05407381,  0.64757787, -0.12781284],
[ 0.48666426, -0.30466718, -0.27487277],
[ 0.64888568,  0.23001   , -0.4859845 ]])
re_up
array([[ 18.49324201,  24.11691794, -44.98940746],  # may vary (signs)
[  0.        ,  31.95894662, -27.40998201],
[  0.        ,   0.        ,  -9.25451794]])
np.allclose(np.dot(qe_up, re_up), a_up)
True
np.allclose(np.dot(qe_up.T, qe_up), np.eye(3))
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Similarly to the above, perform a rank 2 update.</p>
<blockquote>
<blockquote>
<blockquote>
<p>u2 = np.array([[ 7., -1,],
...                [-2.,  4.],
...                [ 4.,  2.],
...                [ 3., -6.],
...                [ 5.,  3.]])
v2 = np.array([[ 1., 2.],
...                [ 3., 4.],
...                [-5., 2]])
q_up2, r_up2 = linalg.qr_update(q, r, u2, v2, False)
q_up2
array([[-0.33626508, -0.03477253,  0.61956287, -0.64352987, -0.29618884],  # may vary (signs)
[-0.50439762,  0.58319694, -0.43010077, -0.33395279,  0.33008064],
[-0.21016568, -0.63123106,  0.0582249 , -0.13675572,  0.73163206],
[ 0.12609941,  0.49694436,  0.64590024,  0.31191919,  0.47187344],
[-0.75659643, -0.11517748,  0.10284903,  0.5986227 , -0.21299983]])
r_up2
array([[-23.79075451, -41.1084062 ,  24.71548348],  # may vary (signs)
[  0.        , -33.83931057,  11.02226551],
[  0.        ,   0.        ,  48.91476811],
[  0.        ,   0.        ,   0.        ],
[  0.        ,   0.        ,   0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This update is also a valid qr decomposition of <code>A + U V**T</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>a_up2 = a + np.dot(u2, v2.T)
np.allclose(a_up2, np.dot(q_up2, r_up2))
True
np.allclose(np.dot(q_up2.T, q_up2), np.eye(5))
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qz</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>QZ decomposition for generalized eigenvalues of a pair of matrices.</p>
<p>The QZ, or generalized Schur, decomposition for a pair of N x N
nonsymmetric matrices (A,B) is::</p>
<p>(A,B) = (Q<em>AA</em>Z', Q<em>BB</em>Z')</p>
<p>where AA, BB is in generalized Schur form if BB is upper-triangular
with non-negative diagonal and AA is upper-triangular, or for real QZ
decomposition (<code>output='real'</code>) block upper triangular with 1x1
and 2x2 blocks.  In this case, the 1x1 blocks correspond to real
generalized eigenvalues and 2x2 blocks are 'standardized' by making
the corresponding elements of BB have the form::</p>
<p>[ a 0 ]
[ 0 b ]</p>
<p>and the pair of corresponding 2x2 blocks in AA and BB will have a complex
conjugate pair of generalized eigenvalues.  If (<code>output='complex'</code>) or
A and B are complex matrices, Z' denotes the conjugate-transpose of Z.
Q and Z are unitary matrices.</p>
<h2 id="parameters_217">Parameters<a class="headerlink" href="#parameters_217" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
2d array to decompose
B : (N, N) array_like
2d array to decompose
output : {'real', 'complex'}, optional
Construct the real or complex QZ decomposition for real matrices.
Default is 'real'.
lwork : int, optional
Work array size.  If None or -1, it is automatically computed.
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead.</p>
<p>Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True). For
real matrix pairs, the sort function takes three real arguments
(alphar, alphai, beta). The eigenvalue
<code>x = (alphar + alphai*1j)/beta</code>.  For complex matrix pairs or
output='complex', the sort function takes two complex arguments
(alpha, beta). The eigenvalue <code>x = (alpha/beta)</code>.  Alternatively,
string parameters may be used:</p>
<ul>
<li>'lhp'   Left-hand plane (x.real &lt; 0.0)</li>
<li>'rhp'   Right-hand plane (x.real &gt; 0.0)</li>
<li>'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0)</li>
<li>'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0)</li>
</ul>
<p>Defaults to None (no sorting).
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance)
overwrite_b : bool, optional
Whether to overwrite data in b (may improve performance)
check_finite : bool, optional
If true checks the elements of <code>A</code> and <code>B</code> are finite numbers. If
false does no checking and passes matrix through to
underlying algorithm.</p>
<h2 id="returns_217">Returns<a class="headerlink" href="#returns_217" title="Permanent link">&para;</a></h2>
<p>AA : (N, N) ndarray
Generalized Schur form of A.
BB : (N, N) ndarray
Generalized Schur form of B.
Q : (N, N) ndarray
The left Schur vectors.
Z : (N, N) ndarray
The right Schur vectors.</p>
<h2 id="notes_108">Notes<a class="headerlink" href="#notes_108" title="Permanent link">&para;</a></h2>
<p>Q is transposed versus the equivalent function in Matlab.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_205">Examples<a class="headerlink" href="#examples_205" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
np.random.seed(1234)
A = np.arange(9).reshape((3, 3))
B = np.random.randn(3, 3)</p>
<p>AA, BB, Q, Z = linalg.qz(A, B)
AA
array([[-13.40928183,  -4.62471562,   1.09215523],
[  0.        ,   0.        ,   1.22805978],
[  0.        ,   0.        ,   0.31973817]])
BB
array([[ 0.33362547, -1.37393632,  0.02179805],
[ 0.        ,  1.68144922,  0.74683866],
[ 0.        ,  0.        ,  0.9258294 ]])
Q
array([[ 0.14134727, -0.97562773,  0.16784365],
[ 0.49835904, -0.07636948, -0.86360059],
[ 0.85537081,  0.20571399,  0.47541828]])
Z
array([[-0.24900855, -0.51772687,  0.81850696],
[-0.79813178,  0.58842606,  0.12938478],
[-0.54861681, -0.6210585 , -0.55973739]])</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_113">See also<a class="headerlink" href="#see-also_113" title="Permanent link">&para;</a></h2>
<p>ordqz</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rq</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute RQ decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = R Q</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h2 id="parameters_218">Parameters<a class="headerlink" href="#parameters_218" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to be decomposed
overwrite_a : bool, optional
Whether data in a is overwritten (may improve performance)
lwork : int, optional
Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
is computed.
mode : {'full', 'r', 'economic'}, optional
Determines what information is to be returned: either both Q and R
('full', default), only R ('r') or both Q and R but computed in
economy-size ('economic', see Notes).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_218">Returns<a class="headerlink" href="#returns_218" title="Permanent link">&para;</a></h2>
<p>R : float or complex ndarray
Of shape (M, N) or (M, K) for <code>mode='economic'</code>.  <code>K = min(M, N)</code>.
Q : float or complex ndarray
Of shape (N, N) or (K, N) for <code>mode='economic'</code>.  Not returned
if <code>mode='r'</code>.</p>
<h2 id="raises_56">Raises<a class="headerlink" href="#raises_56" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If decomposition fails.</p>
<h2 id="notes_109">Notes<a class="headerlink" href="#notes_109" title="Permanent link">&para;</a></h2>
<p>This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,
sorgrq, dorgrq, cungrq and zungrq.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (K, N) and (M, K) instead
of (N,N) and (M,N), with <code>K=min(M,N)</code>.</p>
<h2 id="examples_206">Examples<a class="headerlink" href="#examples_206" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.random.randn(6, 9)
r, q = linalg.rq(a)
np.allclose(a, r @ q)
True
r.shape, q.shape
((6, 9), (9, 9))
r2 = linalg.rq(a, mode='r')
np.allclose(r, r2)
True
r3, q3 = linalg.rq(a, mode='economic')
r3.shape, q3.shape
((6, 6), (6, 9))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper triangular
complex-valued Schur form.</p>
<h2 id="parameters_219">Parameters<a class="headerlink" href="#parameters_219" title="Permanent link">&para;</a></h2>
<p>T : (M, M) array_like
Real Schur form of the original array
Z : (M, M) array_like
Schur transformation matrix
check_finite : bool, optional
Whether to check that the input arrays contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_219">Returns<a class="headerlink" href="#returns_219" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Complex Schur form of the original array
Z : (M, M) ndarray
Schur transformation matrix corresponding to the complex form</p>
<h2 id="see-also_114">See Also<a class="headerlink" href="#see-also_114" title="Permanent link">&para;</a></h2>
<p>schur : Schur decomposition of an array</p>
<h2 id="examples_207">Examples<a class="headerlink" href="#examples_207" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, rsf2csf
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])
T2 , Z2 = rsf2csf(T, Z)
T2
array([[2.65896708+0.j, -1.64592781+0.743164187j, -1.21516887+1.00660462j],
[0.+0.j , -0.32948354+8.02254558e-01j, -0.82115218-2.77555756e-17j],
[0.+0.j , 0.+0.j, -0.32948354-0.802254558j]])
Z2
array([[0.72711591+0.j,  0.28220393-0.31385693j,  0.51319638-0.17258824j],
[0.52839428+0.j,  0.24720268+0.41635578j, -0.68079517-0.15118243j],
[0.43829436+0.j, -0.76618703+0.01873251j, -0.03063006+0.46857912j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span> <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<p>A = Z T Z^H</p>
<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular.  In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h2 id="parameters_220">Parameters<a class="headerlink" href="#parameters_220" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Matrix to decompose
output : {'real', 'complex'}, optional
Construct the real or complex Schur decomposition (for real matrices).
lwork : int, optional
Work array size. If None or -1, it is automatically computed.
overwrite_a : bool, optional
Whether to overwrite data in a (may improve performance).
sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional
Specifies whether the upper eigenvalues should be sorted.  A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True).
Alternatively, string parameters may be used::</p>
<p>'lhp'   Left-hand plane (x.real &lt; 0.0)
'rhp'   Right-hand plane (x.real &gt; 0.0)
'iuc'   Inside the unit circle (x<em>x.conjugate() &lt;= 1.0)
'ouc'   Outside the unit circle (x</em>x.conjugate() &gt; 1.0)</p>
<p>Defaults to None (no sorting).
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_220">Returns<a class="headerlink" href="#returns_220" title="Permanent link">&para;</a></h2>
<p>T : (M, M) ndarray
Schur form of A. It is real-valued for the real Schur decomposition.
Z : (M, M) ndarray
An unitary Schur transformation matrix for A.
It is real-valued for the real Schur decomposition.
sdim : int
If and only if sorting was requested, a third return value will
contain the number of eigenvalues satisfying the sort condition.</p>
<h2 id="raises_57">Raises<a class="headerlink" href="#raises_57" title="Permanent link">&para;</a></h2>
<p>LinAlgError
Error raised under three conditions:</p>
<ol>
<li>The algorithm failed due to a failure of the QR algorithm to
compute all eigenvalues</li>
<li>If eigenvalue sorting was requested, the eigenvalues could not be
reordered due to a failure to separate eigenvalues, usually because
of poor conditioning</li>
<li>If eigenvalue sorting was requested, roundoff errors caused the
leading eigenvalues to no longer satisfy the sorting condition</li>
</ol>
<h2 id="see-also_115">See also<a class="headerlink" href="#see-also_115" title="Permanent link">&para;</a></h2>
<p>rsf2csf : Convert real Schur form to complex Schur form</p>
<h2 id="examples_208">Examples<a class="headerlink" href="#examples_208" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import schur, eigvals
A = np.array([[0, 2, 2], [0, 1, 2], [1, 0, 1]])
T, Z = schur(A)
T
array([[ 2.65896708,  1.42440458, -1.92933439],
[ 0.        , -0.32948354, -0.49063704],
[ 0.        ,  1.31178921, -0.32948354]])
Z
array([[0.72711591, -0.60156188, 0.33079564],
[0.52839428, 0.79801892, 0.28976765],
[0.43829436, 0.03590414, -0.89811411]])</p>
<p>T2, Z2 = schur(A, output='complex')
T2
array([[ 2.65896708, -1.22839825+1.32378589j,  0.42590089+1.51937378j],
[ 0.        , -0.32948354+0.80225456j, -0.59877807+0.56192146j],
[ 0.        ,  0.                    , -0.32948354-0.80225456j]])
eigvals(T2)
array([2.65896708, -0.32948354+0.80225456j, -0.32948354-0.80225456j])</p>
</blockquote>
</blockquote>
</blockquote>
<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<blockquote>
<blockquote>
<blockquote>
<p>T3, Z3, sdim = schur(A, output='complex', sort=lambda x: x.imag &gt; 0)
sdim
1</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">signm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix sign function.</p>
<p>Extension of the scalar sign(x) to matrices.</p>
<h2 id="parameters_221">Parameters<a class="headerlink" href="#parameters_221" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix at which to evaluate the sign function
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)</p>
<h2 id="returns_221">Returns<a class="headerlink" href="#returns_221" title="Permanent link">&para;</a></h2>
<p>signm : (N, N) ndarray
Value of the sign function at <code>A</code>
errest : float
(if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
<h2 id="examples_209">Examples<a class="headerlink" href="#examples_209" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import signm, eigvals
a = [[1,2,3], [1,2,1], [1,1,1]]
eigvals(a)
array([ 4.12488542+0.j, -0.76155718+0.j,  0.63667176+0.j])
eigvals(signm(a))
array([-1.+0.j,  1.+0.j,  1.+0.j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinhm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_222">Parameters<a class="headerlink" href="#parameters_222" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_222">Returns<a class="headerlink" href="#returns_222" title="Permanent link">&para;</a></h2>
<p>sinhm : (N, N) ndarray
Hyperbolic matrix sine of <code>A</code></p>
<h2 id="examples_210">Examples<a class="headerlink" href="#examples_210" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
s = sinhm(a)
s
array([[ 10.57300653,  39.28826594],
[ 13.09608865,  49.86127247]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = tanhm(a)
c = coshm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_223">Parameters<a class="headerlink" href="#parameters_223" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_223">Returns<a class="headerlink" href="#returns_223" title="Permanent link">&para;</a></h2>
<p>sinm : (N, N) ndarray
Matrix sine of <code>A</code></p>
<h2 id="examples_211">Examples<a class="headerlink" href="#examples_211" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import expm, sinm, cosm</p>
</blockquote>
</blockquote>
</blockquote>
<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[1.0, 2.0], [-1.0, 3.0]])
expm(1j<em>a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])
cosm(a) + 1j</em>sinm(a)
array([[ 0.42645930+1.89217551j, -2.13721484-0.97811252j],
[ 1.06860742+0.48905626j, -1.71075555+0.91406299j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span> <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
generic matrix       'gen'
symmetric            'sym'
hermitian            'her'
positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h2 id="parameters_224">Parameters<a class="headerlink" href="#parameters_224" title="Permanent link">&para;</a></h2>
<p>a : (N, N) array_like
Square input data
b : (N, NRHS) array_like
Input data for the right hand side.
sym_pos : bool, optional
Assume <code>a</code> is symmetric and positive definite. This key is deprecated
and assume_a = 'pos' keyword is recommended instead. The functionality
is the same. It will be removed in the future.
lower : bool, optional
If True, only the data contained in the lower triangle of <code>a</code>. Default
is to use upper triangle. (ignored for <code>'gen'</code>)
overwrite_a : bool, optional
Allow overwriting data in <code>a</code> (may enhance performance).
Default is False.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance).
Default is False.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
assume_a : str, optional
Valid entries are explained above.
transposed: bool, optional
If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
for complex matrices (only for True).</p>
<h2 id="returns_224">Returns<a class="headerlink" href="#returns_224" title="Permanent link">&para;</a></h2>
<p>x : (N, NRHS) ndarray
The solution array.</p>
<h2 id="raises_58">Raises<a class="headerlink" href="#raises_58" title="Permanent link">&para;</a></h2>
<p>ValueError
If size mismatches detected or input a is not square.
LinAlgError
If the matrix is singular.
LinAlgWarning
If an ill-conditioned input a is detected.
NotImplementedError
If transposed is True and input a is a complex matrix.</p>
<h2 id="examples_212">Examples<a class="headerlink" href="#examples_212" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])
b = np.array([2, 4, -1])
from scipy import linalg
x = linalg.solve(a, b)
x
array([ 2., -2.,  9.])
np.dot(a, x) == b
array([ True,  True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="notes_110">Notes<a class="headerlink" href="#notes_110" title="Permanent link">&para;</a></h2>
<p>If the input b matrix is a 1D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">l_and_u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation a x = b for x, assuming a is banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> using the matrix diagonal ordered form::</p>
<p>ab[u + i - j, j] == a[i,j]</p>
<p>Example of <code>ab</code> (shape of a is (6,6), <code>u</code> =1, <code>l</code> =2)::</p>
<ul>
<li>a01  a12  a23  a34  a45
a00  a11  a22  a33  a44  a55
a10  a21  a32  a43  a54   *
a20  a31  a42  a53   *    *</li>
</ul>
<h2 id="parameters_225">Parameters<a class="headerlink" href="#parameters_225" title="Permanent link">&para;</a></h2>
<p>(l, u) : (integer, integer)
Number of non-zero lower and upper diagonals
ab : (<code>l</code> + <code>u</code> + 1, M) array_like
Banded matrix
b : (M,) or (M, K) array_like
Right-hand side
overwrite_ab : bool, optional
Discard data in <code>ab</code> (may enhance performance)
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_225">Returns<a class="headerlink" href="#returns_225" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system a x = b.  Returned shape depends on the
shape of <code>b</code>.</p>
<h2 id="examples_213">Examples<a class="headerlink" href="#examples_213" title="Permanent link">&para;</a></h2>
<p>Solve the banded system a x = b, where::</p>
<p>[5  2 -1  0  0]       [0]
[1  4  2 -1  0]       [1]
a = [0  1  3  2 -1]   b = [2]
[0  0  1  2  2]       [2]
[0  0  0  1  1]       [3]</p>
<p>There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2).  The diagonal banded form of the matrix is::</p>
<p>[<em>  * -1 -1 -1]
ab = [</em>  2  2  2  2]
[5  4  3  2  1]
[1  1  1  1  *]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_banded
ab = np.array([[0,  0, -1, -1, -1],
...                [0,  2,  2,  2,  2],
...                [5,  4,  3,  2,  1],
...                [1,  1,  1,  1,  0]])
b = np.array([0, 1, 2, 2, 3])
x = solve_banded((1, 2), ab, b)
x
array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_circulant</span> <span class="o">:</span> <span class="o">?</span><span class="n">singular</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">caxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">baxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">outaxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve C x = b for x, where C is a circulant matrix.</p>
<p><code>C</code> is the circulant matrix associated with the vector <code>c</code>.</p>
<p>The system is solved by doing division in Fourier space.  The
calculation is::</p>
<p>x = ifft(fft(b) / fft(c))</p>
<p>where <code>fft</code> and <code>ifft</code> are the fast Fourier transform and its inverse,
respectively.  For a large vector <code>c</code>, this is <em>much</em> faster than
solving the system with the full circulant matrix.</p>
<h2 id="parameters_226">Parameters<a class="headerlink" href="#parameters_226" title="Permanent link">&para;</a></h2>
<p>c : array_like
The coefficients of the circulant matrix.
b : array_like
Right-hand side matrix in <code>a x = b</code>.
singular : str, optional
This argument controls how a near singular circulant matrix is
handled.  If <code>singular</code> is 'raise' and the circulant matrix is
near singular, a <code>LinAlgError</code> is raised.  If <code>singular</code> is
'lstsq', the least squares solution is returned.  Default is 'raise'.
tol : float, optional
If any eigenvalue of the circulant matrix has an absolute value
that is less than or equal to <code>tol</code>, the matrix is considered to be
near singular.  If not given, <code>tol</code> is set to::</p>
<p>tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps</p>
<p>where <code>abs_eigs</code> is the array of absolute values of the eigenvalues
of the circulant matrix.
caxis : int
When <code>c</code> has dimension greater than 1, it is viewed as a collection
of circulant vectors.  In this case, <code>caxis</code> is the axis of <code>c</code> that
holds the vectors of circulant coefficients.
baxis : int
When <code>b</code> has dimension greater than 1, it is viewed as a collection
of vectors.  In this case, <code>baxis</code> is the axis of <code>b</code> that holds the
right-hand side vectors.
outaxis : int
When <code>c</code> or <code>b</code> are multidimensional, the value returned by
<code>solve_circulant</code> is multidimensional.  In this case, <code>outaxis</code> is
the axis of the result that holds the solution vectors.</p>
<h2 id="returns_226">Returns<a class="headerlink" href="#returns_226" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution to the system <code>C x = b</code>.</p>
<h2 id="raises_59">Raises<a class="headerlink" href="#raises_59" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If the circulant matrix associated with <code>c</code> is near singular.</p>
<h2 id="see-also_116">See Also<a class="headerlink" href="#see-also_116" title="Permanent link">&para;</a></h2>
<p>circulant : circulant matrix</p>
<h2 id="notes_111">Notes<a class="headerlink" href="#notes_111" title="Permanent link">&para;</a></h2>
<p>For a one-dimensional vector <code>c</code> with length <code>m</code>, and an array <code>b</code>
with shape <code>(m, ...)</code>,</p>
<p>solve_circulant(c, b)</p>
<p>returns the same result as</p>
<p>solve(circulant(c), b)</p>
<p>where <code>solve</code> and <code>circulant</code> are from <code>scipy.linalg</code>.</p>
<p>.. versionadded:: 0.16.0</p>
<h2 id="examples_214">Examples<a class="headerlink" href="#examples_214" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_circulant, solve, circulant, lstsq</p>
<p>c = np.array([2, 2, 4])
b = np.array([1, 2, 3])
solve_circulant(c, b)
array([ 0.75, -0.25,  0.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare that result to solving the system with <code>scipy.linalg.solve</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve(circulant(c), b)
array([ 0.75, -0.25,  0.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A singular example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([1, 1, 0, 0])
b = np.array([1, 2, 3, 4])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Calling <code>solve_circulant(c, b)</code> will raise a <code>LinAlgError</code>.  For the
least square solution, use the option <code>singular='lstsq'</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve_circulant(c, b, singular='lstsq')
array([ 0.25,  1.25,  2.25,  1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compare to <code>scipy.linalg.lstsq</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x, resid, rnk, s = lstsq(circulant(c), b)
x
array([ 0.25,  1.25,  2.25,  1.25])</p>
</blockquote>
</blockquote>
</blockquote>
<p>A broadcasting example:</p>
<p>Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three <code>b</code> vectors stored in an array with shape
(3, 5).  For example,</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])
b = np.arange(15).reshape(-1, 5)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We want to solve all combinations of circulant matrices and <code>b</code> vectors,
with the result stored in an array with shape (2, 3, 5).  When we
disregard the axes of <code>c</code> and <code>b</code> that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting.  To have a broadcast result with shape
(2, 3), we add a trivial dimension to <code>c</code>: <code>c[:, np.newaxis, :]</code> has
shape (2, 1, 5).  The last dimension holds the coefficients of the
circulant matrices, so when we call <code>solve_circulant</code>, we can use the
default <code>caxis=-1</code>.  The coefficients of the <code>b</code> vectors are in the last
dimension of the array <code>b</code>, so we use <code>baxis=-1</code>.  If we use the
default <code>outaxis</code>, the result will have shape (5, 2, 3), so we'll use
<code>outaxis=-1</code> to put the solution vectors in the last dimension.</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)
x.shape
(2, 3, 5)
np.set_printoptions(precision=3)  # For compact output of numbers.
x
array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],
[ 0.651,  0.989,  2.046,  0.627,  1.072],
[ 1.42 ,  1.758,  2.816,  1.396,  1.841]],
[[ 0.401,  0.304,  0.694, -0.867,  0.377],
[ 0.856,  0.758,  1.149, -0.412,  0.831],
[ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check by solving one pair of <code>c</code> and <code>b</code> vectors (cf. <code>x[1, 1, :]</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>solve_circulant(c[1], b[1, :])
array([ 0.856,  0.758,  1.149, -0.412,  0.831])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_continuous_are</span> <span class="o">:</span> <span class="o">?</span><span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">balanced</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous-time algebraic Riccati equation (CARE).</p>
<p>The CARE is defined as</p>
<p>.. math::</p>
<p>X A + A^H X - X B R^{-1} B^H X + Q = 0</p>
<p>The limitations for a solution to exist are :</p>
<ul>
<li>
<p>All eigenvalues of :math:<code>A</code> on the right half plane, should be
controllable.</p>
</li>
<li>
<p>The associated hamiltonian pencil (See Notes), should have
eigenvalues sufficiently away from the imaginary axis.</p>
</li>
</ul>
<p>Moreover, if <code>e</code> or <code>s</code> is not precisely <code>None</code>, then the
generalized version of CARE</p>
<p>.. math::</p>
<p>E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0</p>
<p>is solved. When omitted, <code>e</code> is assumed to be the identity and <code>s</code>
is assumed to be the zero matrix with sizes compatible with <code>a</code> and
<code>b</code> respectively.</p>
<h2 id="parameters_227">Parameters<a class="headerlink" href="#parameters_227" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Nonsingular square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool, optional
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.</p>
<h2 id="returns_227">Returns<a class="headerlink" href="#returns_227" title="Permanent link">&para;</a></h2>
<p>x : (M, M) ndarray
Solution to the continuous-time algebraic Riccati equation.</p>
<h2 id="raises_60">Raises<a class="headerlink" href="#raises_60" title="Permanent link">&para;</a></h2>
<p>LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.</p>
<h2 id="see-also_117">See Also<a class="headerlink" href="#see-also_117" title="Permanent link">&para;</a></h2>
<p>solve_discrete_are : Solves the discrete-time algebraic Riccati equation</p>
<h2 id="notes_112">Notes<a class="headerlink" href="#notes_112" title="Permanent link">&para;</a></h2>
<p>The equation is solved by forming the extended hamiltonian matrix pencil,
as described in [1]_, :math:<code>H - \lambda J</code> given by the block matrices ::</p>
<p>[ A    0    B ]             [ E   0    0 ]
[-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ]
[ S^H B^H   R ]             [ 0   0    0 ]</p>
<p>and using a QZ decomposition method.</p>
<p>In this algorithm, the fail conditions are linked to the symmetry
of the product :math:<code>U_2 U_1^{-1}</code> and condition number of
:math:<code>U_1</code>. Here, :math:<code>U</code> is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2m rows and partitioned
into two m-row matrices. See [1]<em> and [2]</em> for more details.</p>
<p>In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:<code>H</code> and :math:<code>J</code> entries (after removing the diagonal entries of
the sum) is balanced following the recipe given in [3]_.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_39">References<a class="headerlink" href="#references_39" title="Permanent link">&para;</a></h2>
<p>.. [1]  P. van Dooren , 'A Generalized Eigenvalue Approach For Solving
Riccati Equations.', SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), DOI: 10.1137/0902010</p>
<p>.. [2] A.J. Laub, 'A Schur Method for Solving Algebraic Riccati
Equations.', Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301</p>
<p>.. [3] P. Benner, 'Symplectic Balancing of Hamiltonian Matrices', 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), DOI: 10.1137/S1064827500367993</p>
<h2 id="examples_215">Examples<a class="headerlink" href="#examples_215" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code>, <code>b</code>, <code>q</code>, and <code>r</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[4, 3], [-4.5, -3.5]])
b = np.array([[1], [-1]])
q = np.array([[9, 6], [6, 4.]])
r = 1
x = linalg.solve_continuous_are(a, b, q, r)
x
array([[ 21.72792206,  14.48528137],
[ 14.48528137,   9.65685425]])
np.allclose(a.T.dot(x) + x.dot(a)-x.dot(b).dot(b.T).dot(x), -q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_continuous_lyapunov</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous Lyapunov equation :math:<code>AX + XA^H = Q</code>.</p>
<p>Uses the Bartels-Stewart algorithm to find :math:<code>X</code>.</p>
<h2 id="parameters_228">Parameters<a class="headerlink" href="#parameters_228" title="Permanent link">&para;</a></h2>
<p>a : array_like
A square matrix</p>
<p>q : array_like
Right-hand side square matrix</p>
<h2 id="returns_228">Returns<a class="headerlink" href="#returns_228" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution to the continuous Lyapunov equation</p>
<h2 id="see-also_118">See Also<a class="headerlink" href="#see-also_118" title="Permanent link">&para;</a></h2>
<p>solve_discrete_lyapunov : computes the solution to the discrete-time
Lyapunov equation
solve_sylvester : computes the solution to the Sylvester equation</p>
<h2 id="notes_113">Notes<a class="headerlink" href="#notes_113" title="Permanent link">&para;</a></h2>
<p>The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_216">Examples<a class="headerlink" href="#examples_216" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[-3, -2, 0], [-1, -1, 0], [0, -5, -1]])
b = np.array([2, 4, -1])
q = np.eye(3)
x = linalg.solve_continuous_lyapunov(a, q)
x
array([[ -0.75  ,   0.875 ,  -3.75  ],
[  0.875 ,  -1.375 ,   5.3125],
[ -3.75  ,   5.3125, -27.0625]])
np.allclose(a.dot(x) + x.dot(a.T), q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_discrete_are</span> <span class="o">:</span> <span class="o">?</span><span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">s</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">balanced</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the discrete-time algebraic Riccati equation (DARE).</p>
<p>The DARE is defined as</p>
<p>.. math::</p>
<p>A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0</p>
<p>The limitations for a solution to exist are :</p>
<ul>
<li>
<p>All eigenvalues of :math:<code>A</code> outside the unit disc, should be
controllable.</p>
</li>
<li>
<p>The associated symplectic pencil (See Notes), should have
eigenvalues sufficiently away from the unit circle.</p>
</li>
</ul>
<p>Moreover, if <code>e</code> and <code>s</code> are not both precisely <code>None</code>, then the
generalized version of DARE</p>
<p>.. math::</p>
<p>A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0</p>
<p>is solved. When omitted, <code>e</code> is assumed to be the identity and <code>s</code>
is assumed to be the zero matrix.</p>
<h2 id="parameters_229">Parameters<a class="headerlink" href="#parameters_229" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Square matrix
b : (M, N) array_like
Input
q : (M, M) array_like
Input
r : (N, N) array_like
Square matrix
e : (M, M) array_like, optional
Nonsingular square matrix
s : (M, N) array_like, optional
Input
balanced : bool
The boolean that indicates whether a balancing step is performed
on the data. The default is set to True.</p>
<h2 id="returns_229">Returns<a class="headerlink" href="#returns_229" title="Permanent link">&para;</a></h2>
<p>x : (M, M) ndarray
Solution to the discrete algebraic Riccati equation.</p>
<h2 id="raises_61">Raises<a class="headerlink" href="#raises_61" title="Permanent link">&para;</a></h2>
<p>LinAlgError
For cases where the stable subspace of the pencil could not be
isolated. See Notes section and the references for details.</p>
<h2 id="see-also_119">See Also<a class="headerlink" href="#see-also_119" title="Permanent link">&para;</a></h2>
<p>solve_continuous_are : Solves the continuous algebraic Riccati equation</p>
<h2 id="notes_114">Notes<a class="headerlink" href="#notes_114" title="Permanent link">&para;</a></h2>
<p>The equation is solved by forming the extended symplectic matrix pencil,
as described in [1]_, :math:<code>H - \lambda J</code> given by the block matrices ::</p>
<p>[  A   0   B ]             [ E   0   B ]
[ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ]
[ S^H  0   R ]             [ 0 -B^H  0 ]</p>
<p>and using a QZ decomposition method.</p>
<p>In this algorithm, the fail conditions are linked to the symmetry
of the product :math:<code>U_2 U_1^{-1}</code> and condition number of
:math:<code>U_1</code>. Here, :math:<code>U</code> is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2m rows and partitioned
into two m-row matrices. See [1]<em> and [2]</em> for more details.</p>
<p>In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:<code>H</code> and :math:<code>J</code> rows/cols (after removing the diagonal entries)
is balanced following the recipe given in [3]_. If the data has small
numerical noise, balancing may amplify their effects and some clean up
is required.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_40">References<a class="headerlink" href="#references_40" title="Permanent link">&para;</a></h2>
<p>.. [1]  P. van Dooren , 'A Generalized Eigenvalue Approach For Solving
Riccati Equations.', SIAM Journal on Scientific and Statistical
Computing, Vol.2(2), DOI: 10.1137/0902010</p>
<p>.. [2] A.J. Laub, 'A Schur Method for Solving Algebraic Riccati
Equations.', Massachusetts Institute of Technology. Laboratory for
Information and Decision Systems. LIDS-R ; 859. Available online :
http://hdl.handle.net/1721.1/1301</p>
<p>.. [3] P. Benner, 'Symplectic Balancing of Hamiltonian Matrices', 2001,
SIAM J. Sci. Comput., 2001, Vol.22(5), DOI: 10.1137/S1064827500367993</p>
<h2 id="examples_217">Examples<a class="headerlink" href="#examples_217" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code>, <code>b</code>, <code>q</code>, and <code>r</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg as la
a = np.array([[0, 1], [0, -1]])
b = np.array([[1, 0], [2, 1]])
q = np.array([[-4, -4], [-4, 7]])
r = np.array([[9, 3], [3, 1]])
x = la.solve_discrete_are(a, b, q, r)
x
array([[-4., -4.],
[-4.,  7.]])
R = la.solve(r + b.T.dot(x).dot(b), b.T.dot(x).dot(a))
np.allclose(a.T.dot(x).dot(a) - x - a.T.dot(x).dot(b).dot(R), -q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_discrete_lyapunov</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Bilinear</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Direct</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the discrete Lyapunov equation :math:<code>AXA^H - X + Q = 0</code>.</p>
<h2 id="parameters_230">Parameters<a class="headerlink" href="#parameters_230" title="Permanent link">&para;</a></h2>
<p>a, q : (M, M) array_like
Square matrices corresponding to A and Q in the equation
above respectively. Must have the same shape.</p>
<p>method : {'direct', 'bilinear'}, optional
Type of solver.</p>
<p>If not given, chosen to be <code>direct</code> if <code>M</code> is less than 10 and
<code>bilinear</code> otherwise.</p>
<h2 id="returns_230">Returns<a class="headerlink" href="#returns_230" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution to the discrete Lyapunov equation</p>
<h2 id="see-also_120">See Also<a class="headerlink" href="#see-also_120" title="Permanent link">&para;</a></h2>
<p>solve_continuous_lyapunov : computes the solution to the continuous-time
Lyapunov equation</p>
<h2 id="notes_115">Notes<a class="headerlink" href="#notes_115" title="Permanent link">&para;</a></h2>
<p>This section describes the available solvers that can be selected by the
'method' parameter. The default method is <em>direct</em> if <code>M</code> is less than 10
and <code>bilinear</code> otherwise.</p>
<p>Method <em>direct</em> uses a direct analytical solution to the discrete Lyapunov
equation. The algorithm is given in, for example, [1]_. However it requires
the linear solution of a system with dimension :math:<code>M^2</code> so that
performance degrades rapidly for even moderately sized matrices.</p>
<p>Method <em>bilinear</em> uses a bilinear transformation to convert the discrete
Lyapunov equation to a continuous Lyapunov equation :math:<code>(BX+XB'=-C)</code>
where :math:<code>B=(A-I)(A+I)^{-1}</code> and
:math:<code>C=2(A' + I)^{-1} Q (A + I)^{-1}</code>. The continuous equation can be
efficiently solved since it is a special case of a Sylvester equation.
The transformation algorithm is from Popov (1964) as described in [2]_.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="references_41">References<a class="headerlink" href="#references_41" title="Permanent link">&para;</a></h2>
<p>.. [1] Hamilton, James D. Time Series Analysis, Princeton: Princeton
University Press, 1994.  265.  Print.
http://doc1.lbfl.li/aca/FLMF037168.pdf
.. [2] Gajic, Z., and M.T.J. Qureshi. 2008.
Lyapunov Matrix Equation in System Stability and Control.
Dover Books on Engineering Series. Dover Publications.</p>
<h2 id="examples_218">Examples<a class="headerlink" href="#examples_218" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[0.2, 0.5],[0.7, -0.9]])
q = np.eye(2)
x = linalg.solve_discrete_lyapunov(a, q)
x
array([[ 0.70872893,  1.43518822],
[ 1.43518822, -2.4266315 ]])
np.allclose(a.dot(x).dot(a.T)-x, -q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_lyapunov</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous Lyapunov equation :math:<code>AX + XA^H = Q</code>.</p>
<p>Uses the Bartels-Stewart algorithm to find :math:<code>X</code>.</p>
<h2 id="parameters_231">Parameters<a class="headerlink" href="#parameters_231" title="Permanent link">&para;</a></h2>
<p>a : array_like
A square matrix</p>
<p>q : array_like
Right-hand side square matrix</p>
<h2 id="returns_231">Returns<a class="headerlink" href="#returns_231" title="Permanent link">&para;</a></h2>
<p>x : ndarray
Solution to the continuous Lyapunov equation</p>
<h2 id="see-also_121">See Also<a class="headerlink" href="#see-also_121" title="Permanent link">&para;</a></h2>
<p>solve_discrete_lyapunov : computes the solution to the discrete-time
Lyapunov equation
solve_sylvester : computes the solution to the Sylvester equation</p>
<h2 id="notes_116">Notes<a class="headerlink" href="#notes_116" title="Permanent link">&para;</a></h2>
<p>The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_219">Examples<a class="headerlink" href="#examples_219" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[-3, -2, 0], [-1, -1, 0], [0, -5, -1]])
b = np.array([2, 4, -1])
q = np.eye(3)
x = linalg.solve_continuous_lyapunov(a, q)
x
array([[ -0.75  ,   0.875 ,  -3.75  ],
[  0.875 ,  -1.375 ,   5.3125],
[ -3.75  ,   5.3125, -27.0625]])
np.allclose(a.dot(x) + x.dot(a.T), q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_sylvester</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Computes a solution (X) to the Sylvester equation :math:<code>AX + XB = Q</code>.</p>
<h2 id="parameters_232">Parameters<a class="headerlink" href="#parameters_232" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
Leading matrix of the Sylvester equation
b : (N, N) array_like
Trailing matrix of the Sylvester equation
q : (M, N) array_like
Right-hand side</p>
<h2 id="returns_232">Returns<a class="headerlink" href="#returns_232" title="Permanent link">&para;</a></h2>
<p>x : (M, N) ndarray
The solution to the Sylvester equation.</p>
<h2 id="raises_62">Raises<a class="headerlink" href="#raises_62" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If solution was not found</p>
<h2 id="notes_117">Notes<a class="headerlink" href="#notes_117" title="Permanent link">&para;</a></h2>
<p>Computes a solution to the Sylvester matrix equation via the Bartels-
Stewart algorithm.  The A and B matrices first undergo Schur
decompositions.  The resulting matrices are used to construct an
alternative Sylvester equation (<code>RY + YS^T = F</code>) where the R and S
matrices are in quasi-triangular form (or, when R, S or F are complex,
triangular form).  The simplified equation is then solved using
<code>*TRSYL</code> from LAPACK directly.</p>
<p>.. versionadded:: 0.11.0</p>
<h2 id="examples_220">Examples<a class="headerlink" href="#examples_220" title="Permanent link">&para;</a></h2>
<p>Given <code>a</code>, <code>b</code>, and <code>q</code> solve for <code>x</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
a = np.array([[-3, -2, 0], [-1, -1, 3], [3, -5, -1]])
b = np.array([[1]])
q = np.array([[1],[2],[3]])
x = linalg.solve_sylvester(a, b, q)
x
array([[ 0.0625],
[-0.5625],
[ 0.6875]])
np.allclose(a.dot(x) + x.dot(b), q)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_toeplitz</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">c_or_cr</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_array_like_array_like_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve a Toeplitz system using Levinson Recursion</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h2 id="parameters_233">Parameters<a class="headerlink" href="#parameters_233" title="Permanent link">&para;</a></h2>
<p>c_or_cr : array_like or tuple of (array_like, array_like)
The vector <code>c</code>, or a tuple of arrays (<code>c</code>, <code>r</code>). Whatever the
actual shape of <code>c</code>, it will be converted to a 1-D array. If not
supplied, <code>r = conjugate(c)</code> is assumed; in this case, if c[0] is
real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
of the Toeplitz matrix is <code>[c[0], r[1:]]</code>.  Whatever the actual shape
of <code>r</code>, it will be converted to a 1-D array.
b : (M,) or (M, K) array_like
Right-hand side in <code>T x = b</code>.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(result entirely NaNs) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_233">Returns<a class="headerlink" href="#returns_233" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system <code>T x = b</code>.  Shape of return matches shape
of <code>b</code>.</p>
<h2 id="see-also_122">See Also<a class="headerlink" href="#see-also_122" title="Permanent link">&para;</a></h2>
<p>toeplitz : Toeplitz matrix</p>
<h2 id="notes_118">Notes<a class="headerlink" href="#notes_118" title="Permanent link">&para;</a></h2>
<p>The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.</p>
<h2 id="examples_221">Examples<a class="headerlink" href="#examples_221" title="Permanent link">&para;</a></h2>
<p>Solve the Toeplitz system T x = b, where::</p>
<p>[ 1 -1 -2 -3]       [1]
T = [ 3  1 -1 -2]   b = [2]
[ 6  3  1 -1]       [2]
[10  6  3  1]       [5]</p>
<p>To specify the Toeplitz matrix, only the first column and the first
row are needed.</p>
<blockquote>
<blockquote>
<blockquote>
<p>c = np.array([1, 3, 6, 10])    # First column of T
r = np.array([1, -1, -2, -3])  # First row of T
b = np.array([1, 2, 2, 5])</p>
<p>from scipy.linalg import solve_toeplitz, toeplitz
x = solve_toeplitz((c, r), b)
x
array([ 1.66666667, -1.        , -2.66666667,  2.33333333])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Check the result by creating the full Toeplitz matrix and
multiplying it by <code>x</code>.  We should get <code>b</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>T = toeplitz(c, r)
T.dot(x)
array([ 1.,  2.,  2.,  5.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span> <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h2 id="parameters_234">Parameters<a class="headerlink" href="#parameters_234" title="Permanent link">&para;</a></h2>
<p>a : (M, M) array_like
A triangular matrix
b : (M,) or (M, N) array_like
Right-hand side matrix in <code>a x = b</code>
lower : bool, optional
Use only data contained in the lower triangle of <code>a</code>.
Default is to use upper triangle.
trans : {0, 1, 2, 'N', 'T', 'C'}, optional
Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========
unit_diagonal : bool, optional
If True, diagonal elements of <code>a</code> are assumed to be 1 and
will not be referenced.
overwrite_b : bool, optional
Allow overwriting data in <code>b</code> (may enhance performance)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_234">Returns<a class="headerlink" href="#returns_234" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, N) ndarray
Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</p>
<h2 id="raises_63">Raises<a class="headerlink" href="#raises_63" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If <code>a</code> is singular</p>
<h2 id="notes_119">Notes<a class="headerlink" href="#notes_119" title="Permanent link">&para;</a></h2>
<p>.. versionadded:: 0.9.0</p>
<h2 id="examples_222">Examples<a class="headerlink" href="#examples_222" title="Permanent link">&para;</a></h2>
<p>Solve the lower triangular system a x = b, where::</p>
<p>[3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
[1  0  1  0]       [4]
[1  1  1  1]       [2]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solve_triangular
a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])
b = np.array([4, 2, 4, 2])
x = solve_triangular(a, b, lower=True)
x
array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])
a.dot(x)  # Check the result
array([ 4.,  2.,  4.,  2.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solveh_banded</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve equation a x = b. a is Hermitian positive-definite banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> either in lower diagonal or upper
diagonal ordered form:</p>
<p>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</p>
<p>Example of <code>ab</code> (shape of a is (6, 6), <code>u</code> =2)::</p>
<p>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55</p>
<p>lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *</p>
<p>Cells marked with * are not used.</p>
<h2 id="parameters_235">Parameters<a class="headerlink" href="#parameters_235" title="Permanent link">&para;</a></h2>
<p>ab : (<code>u</code> + 1, M) array_like
Banded matrix
b : (M,) or (M, K) array_like
Right-hand side
overwrite_ab : bool, optional
Discard data in <code>ab</code> (may enhance performance)
overwrite_b : bool, optional
Discard data in <code>b</code> (may enhance performance)
lower : bool, optional
Is the matrix in the lower form. (Default is upper form)
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_235">Returns<a class="headerlink" href="#returns_235" title="Permanent link">&para;</a></h2>
<p>x : (M,) or (M, K) ndarray
The solution to the system a x = b.  Shape of return matches shape
of <code>b</code>.</p>
<h2 id="examples_223">Examples<a class="headerlink" href="#examples_223" title="Permanent link">&para;</a></h2>
<p>Solve the banded system A x = b, where::</p>
<p>[ 4  2 -1  0  0  0]       [1]
[ 2  5  2 -1  0  0]       [2]
A = [-1  2  6  2 -1  0]   b = [2]
[ 0 -1  2  7  2 -1]       [3]
[ 0  0 -1  2  8  2]       [3]
[ 0  0  0 -1  2  9]       [3]</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import solveh_banded</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>ab</code> contains the main diagonal and the nonzero diagonals below the
main diagonal.  That is, we use the lower form:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ab = np.array([[ 4,  5,  6,  7, 8, 9],
...                [ 2,  2,  2,  2, 2, 0],
...                [-1, -1, -1, -1, 0, 0]])
b = np.array([1, 2, 2, 3, 3, 3])
x = solveh_banded(ab, b, lower=True)
x
array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,
0.34733894])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Solve the Hermitian banded system H x = b, where::</p>
<p>[ 8   2-1j   0     0  ]        [ 1  ]
H = [2+1j  5     1j    0  ]    b = [1+1j]
[ 0   -1j    9   -2-1j]        [1-2j]
[ 0    0   -2+1j   6  ]        [ 0  ]</p>
<p>In this example, we put the upper diagonals in the array <code>hb</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hb = np.array([[0, 2-1j, 1j, -2-1j],
...                [8,  5,    9,   6  ]])
b = np.array([1, 1+1j, 1-2j, 0])
x = solveh_banded(hb, b)
x
array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,
0.10077984-0.23035393j, -0.00479904-0.09358128j])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrtm</span> <span class="o">:</span> <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix square root.</p>
<h2 id="parameters_236">Parameters<a class="headerlink" href="#parameters_236" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Matrix whose square root to evaluate
disp : bool, optional
Print warning if error in the result is estimated large
instead of returning estimated error. (Default: True)
blocksize : integer, optional
If the blocksize is not degenerate with respect to the
size of the input array, then use a blocked algorithm. (Default: 64)</p>
<h2 id="returns_236">Returns<a class="headerlink" href="#returns_236" title="Permanent link">&para;</a></h2>
<p>sqrtm : (N, N) ndarray
Value of the sqrt function at <code>A</code></p>
<p>errest : float
(if disp == False)</p>
<p>Frobenius norm of the estimated error, ||err||_F / ||A||_F</p>
<h2 id="references_42">References<a class="headerlink" href="#references_42" title="Permanent link">&para;</a></h2>
<p>.. [1] Edvin Deadman, Nicholas J. Higham, Rui Ralha (2013)
'Blocked Schur Algorithms for Computing the Matrix Square Root,
Lecture Notes in Computer Science, 7782. pp. 171-182.</p>
<h2 id="examples_224">Examples<a class="headerlink" href="#examples_224" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import sqrtm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
r = sqrtm(a)
r
array([[ 0.75592895,  1.13389342],
[ 0.37796447,  1.88982237]])
r.dot(r)
array([[ 1.,  3.],
[ 1.,  4.]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subspace_angles</span> <span class="o">:</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the subspace angles between two matrices.</p>
<h2 id="parameters_237">Parameters<a class="headerlink" href="#parameters_237" title="Permanent link">&para;</a></h2>
<p>A : (M, N) array_like
The first input array.
B : (M, K) array_like
The second input array.</p>
<h2 id="returns_237">Returns<a class="headerlink" href="#returns_237" title="Permanent link">&para;</a></h2>
<p>angles : ndarray, shape (min(N, K),)
The subspace angles between the column spaces of <code>A</code> and <code>B</code> in
descending order.</p>
<h2 id="see-also_123">See Also<a class="headerlink" href="#see-also_123" title="Permanent link">&para;</a></h2>
<p>orth
svd</p>
<h2 id="notes_120">Notes<a class="headerlink" href="#notes_120" title="Permanent link">&para;</a></h2>
<p>This computes the subspace angles according to the formula
provided in [1]_. For equivalence with MATLAB and Octave behavior,
use <code>angles[0]</code>.</p>
<p>.. versionadded:: 1.0</p>
<h2 id="references_43">References<a class="headerlink" href="#references_43" title="Permanent link">&para;</a></h2>
<p>.. [1] Knyazev A, Argentati M (2002) Principal Angles between Subspaces
in an A-Based Scalar Product: Algorithms and Perturbation
Estimates. SIAM J. Sci. Comput. 23:2008-2040.</p>
<h2 id="examples_225">Examples<a class="headerlink" href="#examples_225" title="Permanent link">&para;</a></h2>
<p>A Hadamard matrix, which has orthogonal columns, so we expect that
the suspace angle to be :math:<code>\frac{\pi}{2}</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import hadamard, subspace_angles
H = hadamard(4)
print(H)
[[ 1  1  1  1]
[ 1 -1  1 -1]
[ 1  1 -1 -1]
[ 1 -1 -1  1]]
np.rad2deg(subspace_angles(H[:, :2], H[:, 2:]))
array([ 90.,  90.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>And the subspace angle of a matrix to itself should be zero:</p>
<blockquote>
<blockquote>
<blockquote>
<p>subspace_angles(H[:, :2], H[:, :2]) &lt;= 2 * np.finfo(float).eps
array([ True,  True], dtype=bool)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The angles between non-orthogonal subspaces are in between these extremes:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = np.random.RandomState(0).randn(4, 3)
np.rad2deg(subspace_angles(x[:, :2], x[:, [2]]))
array([ 55.832])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span> <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h2 id="parameters_238">Parameters<a class="headerlink" href="#parameters_238" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
full_matrices : bool, optional
If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
<code>K = min(M, N)</code>.
compute_uv : bool, optional
Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
Default is True.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
lapack_driver : {'gesdd', 'gesvd'}, optional
Whether to use the more efficient divide-and-conquer approach
(<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
<h2 id="returns_238">Returns<a class="headerlink" href="#returns_238" title="Permanent link">&para;</a></h2>
<p>U : ndarray
Unitary matrix having left singular vectors as columns.
Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.
s : ndarray
The singular values, sorted in non-increasing order.
Of shape (K,), with <code>K = min(M, N)</code>.
Vh : ndarray
Unitary matrix having right singular vectors as rows.
Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h2 id="raises_64">Raises<a class="headerlink" href="#raises_64" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="see-also_124">See also<a class="headerlink" href="#see-also_124" title="Permanent link">&para;</a></h2>
<p>svdvals : Compute singular values of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_226">Examples<a class="headerlink" href="#examples_226" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import linalg
m, n = 9, 6
a = np.random.randn(m, n) + 1.j*np.random.randn(m, n)
U, s, Vh = linalg.svd(a)
U.shape,  s.shape, Vh.shape
((9, 9), (6,), (6, 6))</p>
</blockquote>
</blockquote>
</blockquote>
<p>Reconstruct the original matrix from the decomposition:</p>
<blockquote>
<blockquote>
<blockquote>
<p>sigma = np.zeros((m, n))
for i in range(min(m, n)):
...     sigma[i, i] = s[i]
a1 = np.dot(U, np.dot(sigma, Vh))
np.allclose(a, a1)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>U, s, Vh = linalg.svd(a, full_matrices=False)
U.shape, s.shape, Vh.shape
((9, 6), (6,), (6, 6))
S = np.diag(s)
np.allclose(a, np.dot(U, np.dot(S, Vh)))
True</p>
<p>s2 = linalg.svd(a, compute_uv=False)
np.allclose(s, s2)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svdvals</span> <span class="o">:</span> <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute singular values of a matrix.</p>
<h2 id="parameters_239">Parameters<a class="headerlink" href="#parameters_239" title="Permanent link">&para;</a></h2>
<p>a : (M, N) array_like
Matrix to decompose.
overwrite_a : bool, optional
Whether to overwrite <code>a</code>; may improve performance.
Default is False.
check_finite : bool, optional
Whether to check that the input matrix contains only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
<h2 id="returns_239">Returns<a class="headerlink" href="#returns_239" title="Permanent link">&para;</a></h2>
<p>s : (min(M, N),) ndarray
The singular values, sorted in decreasing order.</p>
<h2 id="raises_65">Raises<a class="headerlink" href="#raises_65" title="Permanent link">&para;</a></h2>
<p>LinAlgError
If SVD computation does not converge.</p>
<h2 id="notes_121">Notes<a class="headerlink" href="#notes_121" title="Permanent link">&para;</a></h2>
<p><code>svdvals(a)</code> only differs from <code>svd(a, compute_uv=False)</code> by its
handling of the edge case of empty <code>a</code>, where it returns an
empty sequence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.empty((0, 2))
from scipy.linalg import svdvals
svdvals(a)
array([], dtype=float64)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="see-also_125">See Also<a class="headerlink" href="#see-also_125" title="Permanent link">&para;</a></h2>
<p>svd : Compute the full singular value decomposition of a matrix.
diagsvd : Construct the Sigma matrix, given the vector s.</p>
<h2 id="examples_227">Examples<a class="headerlink" href="#examples_227" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import svdvals
m = np.array([[1.0, 0.0],
...               [2.0, 3.0],
...               [1.0, 1.0],
...               [0.0, 2.0],
...               [1.0, 0.0]])
svdvals(m)
array([ 4.28091555,  1.63516424])</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can verify the maximum singular value of <code>m</code> by computing the maximum
length of <code>m.dot(u)</code> over all the unit vectors <code>u</code> in the (x,y) plane.
We approximate 'all' the unit vectors with a large sample.  Because
of linearity, we only need the unit vectors with angles in [0, pi].</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = np.linspace(0, np.pi, 2000)
u = np.array([np.cos(t), np.sin(t)])
np.linalg.norm(m.dot(u), axis=0).max()
4.2809152422538475</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>p</code> is a projection matrix with rank 1.  With exact arithmetic,
its singular values would be [1, 0, 0, 0].</p>
<blockquote>
<blockquote>
<blockquote>
<p>v = np.array([0.1, 0.3, 0.9, 0.3])
p = np.outer(v, v)
svdvals(p)
array([  1.00000000e+00,   2.02021698e-17,   1.56692500e-17,
8.15115104e-34])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The singular values of an orthogonal matrix are all 1.  Here we
create a random orthogonal matrix by using the <code>rvs()</code> method of
<code>scipy.stats.ortho_group</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.stats import ortho_group
np.random.seed(123)
orth = ortho_group.rvs(4)
svdvals(orth)
array([ 1.,  1.,  1.,  1.])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanhm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_240">Parameters<a class="headerlink" href="#parameters_240" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array</p>
<h2 id="returns_240">Returns<a class="headerlink" href="#returns_240" title="Permanent link">&para;</a></h2>
<p>tanhm : (N, N) ndarray
Hyperbolic matrix tangent of <code>A</code></p>
<h2 id="examples_228">Examples<a class="headerlink" href="#examples_228" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanhm, sinhm, coshm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
t = tanhm(a)
t
array([[ 0.3428582 ,  0.51987926],
[ 0.17329309,  0.86273746]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = sinhm(a)
c = coshm(a)
t - s.dot(np.linalg.inv(c))
array([[  2.72004641e-15,   4.55191440e-15],
[  0.00000000e+00,  -5.55111512e-16]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanm</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h2 id="parameters_241">Parameters<a class="headerlink" href="#parameters_241" title="Permanent link">&para;</a></h2>
<p>A : (N, N) array_like
Input array.</p>
<h2 id="returns_241">Returns<a class="headerlink" href="#returns_241" title="Permanent link">&para;</a></h2>
<p>tanm : (N, N) ndarray
Matrix tangent of <code>A</code></p>
<h2 id="examples_229">Examples<a class="headerlink" href="#examples_229" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tanm, sinm, cosm
a = np.array([[1.0, 3.0], [1.0, 4.0]])
t = tanm(a)
t
array([[ -2.00876993,  -8.41880636],
[ -2.80626879, -10.42757629]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Verify tanm(a) = sinm(a).dot(inv(cosm(a)))</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = sinm(a)
c = cosm(a)
s.dot(np.linalg.inv(c))
array([[ -2.00876993,  -8.41880636],
[ -2.80626879, -10.42757629]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toeplitz</span> <span class="o">:</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Toeplitz matrix.</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row.  If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h2 id="parameters_242">Parameters<a class="headerlink" href="#parameters_242" title="Permanent link">&para;</a></h2>
<p>c : array_like
First column of the matrix.  Whatever the actual shape of <code>c</code>, it
will be converted to a 1-D array.
r : array_like, optional
First row of the matrix. If None, <code>r = conjugate(c)</code> is assumed;
in this case, if c[0] is real, the result is a Hermitian matrix.
r[0] is ignored; the first row of the returned matrix is
<code>[c[0], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
converted to a 1-D array.</p>
<h2 id="returns_242">Returns<a class="headerlink" href="#returns_242" title="Permanent link">&para;</a></h2>
<p>A : (len(c), len(r)) ndarray
The Toeplitz matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</p>
<h2 id="see-also_126">See Also<a class="headerlink" href="#see-also_126" title="Permanent link">&para;</a></h2>
<p>circulant : circulant matrix
hankel : Hankel matrix
solve_toeplitz : Solve a Toeplitz system.</p>
<h2 id="notes_122">Notes<a class="headerlink" href="#notes_122" title="Permanent link">&para;</a></h2>
<p>The behavior when <code>c</code> or <code>r</code> is a scalar, or when <code>c</code> is complex and
<code>r</code> is None, was changed in version 0.8.0.  The behavior in previous
versions was undocumented and is no longer supported.</p>
<h2 id="examples_230">Examples<a class="headerlink" href="#examples_230" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import toeplitz
toeplitz([1,2,3], [1,4,5,6])
array([[1, 4, 5, 6],
[2, 1, 4, 5],
[3, 2, 1, 4]])
toeplitz([1.0, 2+3j, 4-1j])
array([[ 1.+0.j,  2.-3.j,  4.+1.j],
[ 2.+3.j,  1.+0.j,  2.-3.j],
[ 4.-1.j,  2.+3.j,  1.+0.j]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tri</span> <span class="o">:</span> <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct (N, M) matrix filled with ones at and below the k-th diagonal.</p>
<p>The matrix has A[i,j] == 1 for i &lt;= j + k</p>
<h2 id="parameters_243">Parameters<a class="headerlink" href="#parameters_243" title="Permanent link">&para;</a></h2>
<p>N : int
The size of the first dimension of the matrix.
M : int or None, optional
The size of the second dimension of the matrix. If <code>M</code> is None,
<code>M = N</code> is assumed.
k : int, optional
Number of subdiagonal below which matrix is filled with ones.
<code>k</code> = 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and <code>k</code> &gt; 0
superdiagonal.
dtype : dtype, optional
Data type of the matrix.</p>
<h2 id="returns_243">Returns<a class="headerlink" href="#returns_243" title="Permanent link">&para;</a></h2>
<p>tri : (N, M) ndarray
Tri matrix.</p>
<h2 id="examples_231">Examples<a class="headerlink" href="#examples_231" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tri
tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
[1, 1, 1, 1, 0],
[1, 1, 1, 1, 1]])
tri(3, 5, -1, dtype=int)
array([[0, 0, 0, 0, 0],
[1, 0, 0, 0, 0],
[1, 1, 0, 0, 0]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements above the k-th diagonal zeroed.</p>
<h2 id="parameters_244">Parameters<a class="headerlink" href="#parameters_244" title="Permanent link">&para;</a></h2>
<p>m : array_like
Matrix whose elements to return
k : int, optional
Diagonal above which to zero elements.
<code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
<code>k</code> &gt; 0 superdiagonal.</p>
<h2 id="returns_244">Returns<a class="headerlink" href="#returns_244" title="Permanent link">&para;</a></h2>
<p>tril : ndarray
Return is the same shape and type as <code>m</code>.</p>
<h2 id="examples_232">Examples<a class="headerlink" href="#examples_232" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import tril
tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
[ 4,  0,  0],
[ 7,  8,  0],
[10, 11, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span> <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the k-th diagonal zeroed.</p>
<h2 id="parameters_245">Parameters<a class="headerlink" href="#parameters_245" title="Permanent link">&para;</a></h2>
<p>m : array_like
Matrix whose elements to return
k : int, optional
Diagonal below which to zero elements.
<code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
<code>k</code> &gt; 0 superdiagonal.</p>
<h2 id="returns_245">Returns<a class="headerlink" href="#returns_245" title="Permanent link">&para;</a></h2>
<p>triu : ndarray
Return matrix with zeroed elements below the k-th diagonal and has
same shape and type as <code>m</code>.</p>
<h2 id="examples_233">Examples<a class="headerlink" href="#examples_233" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.linalg import triu
triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
[ 4,  5,  6],
[ 0,  8,  9],
[ 0,  0, 12]])</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Io/" title="Io" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Io
              </div>
            </div>
          </a>
        
        
          <a href="../Misc/" title="Misc" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Misc
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>