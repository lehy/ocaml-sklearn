
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.7">
    
    
      
        <title>Linalg - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.19753c6b.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.196e0c26.min.css">
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#linalgerror" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Linalg
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon"></span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cluster/" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Linalg
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      Linalg
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#linalgerror" class="md-nav__link">
    LinAlgError
  </a>
  
    <nav class="md-nav" aria-label="LinAlgError">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#with_traceback" class="md-nav__link">
    with_traceback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linalgwarning" class="md-nav__link">
    LinAlgWarning
  </a>
  
    <nav class="md-nav" aria-label="LinAlgWarning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#with_traceback_1" class="md-nav__link">
    with_traceback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_1" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_1" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_1" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#basic" class="md-nav__link">
    Basic
  </a>
  
    <nav class="md-nav" aria-label="Basic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#atleast_1d" class="md-nav__link">
    atleast_1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atleast_2d" class="md-nav__link">
    atleast_2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#det" class="md-nav__link">
    det
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#levinson" class="md-nav__link">
    levinson
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstsq" class="md-nav__link">
    lstsq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix_balance" class="md-nav__link">
    matrix_balance
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv" class="md-nav__link">
    pinv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv2" class="md-nav__link">
    pinv2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinvh" class="md-nav__link">
    pinvh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_banded" class="md-nav__link">
    solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_circulant" class="md-nav__link">
    solve_circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_toeplitz" class="md-nav__link">
    solve_toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_triangular" class="md-nav__link">
    solve_triangular
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solveh_banded" class="md-nav__link">
    solveh_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#warn" class="md-nav__link">
    warn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#blas" class="md-nav__link">
    Blas
  </a>
  
    <nav class="md-nav" aria-label="Blas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crotg" class="md-nav__link">
    crotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drotg" class="md-nav__link">
    drotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_best_blas_type" class="md-nav__link">
    find_best_blas_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#srotg" class="md-nav__link">
    srotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zrotg" class="md-nav__link">
    zrotg
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cython_blas" class="md-nav__link">
    Cython_blas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cython_lapack" class="md-nav__link">
    Cython_lapack
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp" class="md-nav__link">
    Decomp
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inexact" class="md-nav__link">
    Inexact
  </a>
  
    <nav class="md-nav" aria-label="Inexact">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getitem" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_2" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_2" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_2" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#argsort" class="md-nav__link">
    argsort
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array" class="md-nav__link">
    array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cdf2rdf" class="md-nav__link">
    cdf2rdf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conj" class="md-nav__link">
    conj
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig" class="md-nav__link">
    eig
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_banded" class="md-nav__link">
    eig_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh" class="md-nav__link">
    eigh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_tridiagonal" class="md-nav__link">
    eigh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_banded" class="md-nav__link">
    eigvals_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh" class="md-nav__link">
    eigvalsh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_tridiagonal" class="md-nav__link">
    eigvalsh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#einsum" class="md-nav__link">
    einsum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#empty" class="md-nav__link">
    empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eye" class="md-nav__link">
    eye
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatnonzero" class="md-nav__link">
    flatnonzero
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_1" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hessenberg" class="md-nav__link">
    hessenberg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iscomplex" class="md-nav__link">
    iscomplex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iscomplexobj" class="md-nav__link">
    iscomplexobj
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite" class="md-nav__link">
    isfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nonzero" class="md-nav__link">
    nonzero
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeros" class="md-nav__link">
    zeros
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_cholesky" class="md-nav__link">
    Decomp_cholesky
  </a>
  
    <nav class="md-nav" aria-label="Decomp_cholesky">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#asarray_1" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atleast_2d_1" class="md-nav__link">
    atleast_2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_factor" class="md-nav__link">
    cho_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve" class="md-nav__link">
    cho_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_banded" class="md-nav__link">
    cho_solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky" class="md-nav__link">
    cholesky
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_banded" class="md-nav__link">
    cholesky_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_2" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_lu" class="md-nav__link">
    Decomp_lu
  </a>
  
    <nav class="md-nav" aria-label="Decomp_lu">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#asarray_2" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite_1" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs_1" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_3" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu" class="md-nav__link">
    lu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_factor" class="md-nav__link">
    lu_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_solve" class="md-nav__link">
    lu_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#warn_1" class="md-nav__link">
    warn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_qr" class="md-nav__link">
    Decomp_qr
  </a>
  
    <nav class="md-nav" aria-label="Decomp_qr">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_4" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr" class="md-nav__link">
    qr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_multiply" class="md-nav__link">
    qr_multiply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rq" class="md-nav__link">
    rq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#safecall" class="md-nav__link">
    safecall
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_schur" class="md-nav__link">
    Decomp_schur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single" class="md-nav__link">
    Single
  </a>
  
    <nav class="md-nav" aria-label="Single">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#getitem_1" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#newbyteorder" class="md-nav__link">
    newbyteorder
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_3" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_3" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_3" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_1" class="md-nav__link">
    array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_3" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite_2" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_1" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_5" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_1" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur" class="md-nav__link">
    schur
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_svd" class="md-nav__link">
    Decomp_svd
  </a>
  
    <nav class="md-nav" aria-label="Decomp_svd">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arccos" class="md-nav__link">
    arccos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arcsin" class="md-nav__link">
    arcsin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip" class="md-nav__link">
    clip
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diag" class="md-nav__link">
    diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagsvd" class="md-nav__link">
    diagsvd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot" class="md-nav__link">
    dot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_6" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#null_space" class="md-nav__link">
    null_space
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orth" class="md-nav__link">
    orth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subspace_angles" class="md-nav__link">
    subspace_angles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svdvals" class="md-nav__link">
    svdvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where" class="md-nav__link">
    where
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeros_1" class="md-nav__link">
    zeros
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flinalg" class="md-nav__link">
    Flinalg
  </a>
  
    <nav class="md-nav" aria-label="Flinalg">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs_2" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_column_major_storage" class="md-nav__link">
    has_column_major_storage
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lapack" class="md-nav__link">
    Lapack
  </a>
  
    <nav class="md-nav" aria-label="Lapack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cgegv" class="md-nav__link">
    cgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dgegv" class="md-nav__link">
    dgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_7" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sgegv" class="md-nav__link">
    sgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zgegv" class="md-nav__link">
    zgegv
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matfuncs" class="md-nav__link">
    Matfuncs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single_1" class="md-nav__link">
    Single
  </a>
  
    <nav class="md-nav" aria-label="Single">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#getitem_2" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#newbyteorder_1" class="md-nav__link">
    newbyteorder
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_4" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_4" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_4" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#absolute" class="md-nav__link">
    absolute
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#amax" class="md-nav__link">
    amax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjugate" class="md-nav__link">
    conjugate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coshm" class="md-nav__link">
    coshm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosm" class="md-nav__link">
    cosm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diag_1" class="md-nav__link">
    diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot_1" class="md-nav__link">
    dot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm" class="md-nav__link">
    expm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_cond" class="md-nav__link">
    expm_cond
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_frechet" class="md-nav__link">
    expm_frechet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractional_matrix_power" class="md-nav__link">
    fractional_matrix_power
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funm" class="md-nav__link">
    funm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv_1" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite_1" class="md-nav__link">
    isfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#khatri_rao" class="md-nav__link">
    khatri_rao
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logical_not" class="md-nav__link">
    logical_not
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logm" class="md-nav__link">
    logm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_2" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prod" class="md-nav__link">
    prod
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ravel" class="md-nav__link">
    ravel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf_1" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur_1" class="md-nav__link">
    schur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sign" class="md-nav__link">
    sign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signm" class="md-nav__link">
    signm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinhm" class="md-nav__link">
    sinhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinm" class="md-nav__link">
    sinm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_1" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrtm" class="md-nav__link">
    sqrtm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd_1" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhm" class="md-nav__link">
    tanhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanm" class="md-nav__link">
    tanm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transpose" class="md-nav__link">
    transpose
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu" class="md-nav__link">
    triu
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#misc" class="md-nav__link">
    Misc
  </a>
  
    <nav class="md-nav" aria-label="Misc">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs_1" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_8" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_3" class="md-nav__link">
    norm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#special_matrices" class="md-nav__link">
    Special_matrices
  </a>
  
    <nav class="md-nav" aria-label="Special_matrices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#as_strided" class="md-nav__link">
    as_strided
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_diag" class="md-nav__link">
    block_diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circulant" class="md-nav__link">
    circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#companion" class="md-nav__link">
    companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolution_matrix" class="md-nav__link">
    convolution_matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dft" class="md-nav__link">
    dft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler" class="md-nav__link">
    fiedler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_companion" class="md-nav__link">
    fiedler_companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hadamard" class="md-nav__link">
    hadamard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hankel" class="md-nav__link">
    hankel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#helmert" class="md-nav__link">
    helmert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hilbert" class="md-nav__link">
    hilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invhilbert" class="md-nav__link">
    invhilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invpascal" class="md-nav__link">
    invpascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kron" class="md-nav__link">
    kron
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leslie" class="md-nav__link">
    leslie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pascal" class="md-nav__link">
    pascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toeplitz" class="md-nav__link">
    toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri" class="md-nav__link">
    tri
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tril" class="md-nav__link">
    tril
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu_1" class="md-nav__link">
    triu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_diag_1" class="md-nav__link">
    block_diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cdf2rdf_1" class="md-nav__link">
    cdf2rdf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_factor_1" class="md-nav__link">
    cho_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_1" class="md-nav__link">
    cho_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_banded_1" class="md-nav__link">
    cho_solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_1" class="md-nav__link">
    cholesky
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_banded_1" class="md-nav__link">
    cholesky_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circulant_1" class="md-nav__link">
    circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clarkson_woodruff_transform" class="md-nav__link">
    clarkson_woodruff_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#companion_1" class="md-nav__link">
    companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolution_matrix_1" class="md-nav__link">
    convolution_matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coshm_1" class="md-nav__link">
    coshm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosm_1" class="md-nav__link">
    cosm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cossin" class="md-nav__link">
    cossin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#det_1" class="md-nav__link">
    det
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dft_1" class="md-nav__link">
    dft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagsvd_1" class="md-nav__link">
    diagsvd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_1" class="md-nav__link">
    eig
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_banded_1" class="md-nav__link">
    eig_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_1" class="md-nav__link">
    eigh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_tridiagonal_1" class="md-nav__link">
    eigh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_2" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_banded_1" class="md-nav__link">
    eigvals_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_1" class="md-nav__link">
    eigvalsh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_tridiagonal_1" class="md-nav__link">
    eigvalsh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_1" class="md-nav__link">
    expm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_cond_1" class="md-nav__link">
    expm_cond
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_frechet_1" class="md-nav__link">
    expm_frechet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_1" class="md-nav__link">
    fiedler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_companion_1" class="md-nav__link">
    fiedler_companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_best_blas_type_1" class="md-nav__link">
    find_best_blas_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractional_matrix_power_1" class="md-nav__link">
    fractional_matrix_power
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funm_1" class="md-nav__link">
    funm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs_2" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_9" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hadamard_1" class="md-nav__link">
    hadamard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hankel_1" class="md-nav__link">
    hankel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#helmert_1" class="md-nav__link">
    helmert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hessenberg_1" class="md-nav__link">
    hessenberg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hilbert_1" class="md-nav__link">
    hilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv_2" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invhilbert_1" class="md-nav__link">
    invhilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invpascal_1" class="md-nav__link">
    invpascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#khatri_rao_1" class="md-nav__link">
    khatri_rao
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kron_1" class="md-nav__link">
    kron
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ldl" class="md-nav__link">
    ldl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leslie_1" class="md-nav__link">
    leslie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logm_1" class="md-nav__link">
    logm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstsq_1" class="md-nav__link">
    lstsq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_1" class="md-nav__link">
    lu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_factor_1" class="md-nav__link">
    lu_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_solve_1" class="md-nav__link">
    lu_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix_balance_1" class="md-nav__link">
    matrix_balance
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_4" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#null_space_1" class="md-nav__link">
    null_space
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ordqz" class="md-nav__link">
    ordqz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orth_1" class="md-nav__link">
    orth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orthogonal_procrustes" class="md-nav__link">
    orthogonal_procrustes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pascal_1" class="md-nav__link">
    pascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv_1" class="md-nav__link">
    pinv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv2_1" class="md-nav__link">
    pinv2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinvh_1" class="md-nav__link">
    pinvh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polar" class="md-nav__link">
    polar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_1" class="md-nav__link">
    qr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_insert" class="md-nav__link">
    qr_insert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_multiply_1" class="md-nav__link">
    qr_multiply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_update" class="md-nav__link">
    qr_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qz" class="md-nav__link">
    qz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rq_1" class="md-nav__link">
    rq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf_2" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur_2" class="md-nav__link">
    schur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signm_1" class="md-nav__link">
    signm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinhm_1" class="md-nav__link">
    sinhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinm_1" class="md-nav__link">
    sinm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_2" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_banded_1" class="md-nav__link">
    solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_circulant_1" class="md-nav__link">
    solve_circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_continuous_are" class="md-nav__link">
    solve_continuous_are
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_continuous_lyapunov" class="md-nav__link">
    solve_continuous_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_discrete_are" class="md-nav__link">
    solve_discrete_are
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_discrete_lyapunov" class="md-nav__link">
    solve_discrete_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_lyapunov" class="md-nav__link">
    solve_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_sylvester" class="md-nav__link">
    solve_sylvester
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_toeplitz_1" class="md-nav__link">
    solve_toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_triangular_1" class="md-nav__link">
    solve_triangular
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solveh_banded_1" class="md-nav__link">
    solveh_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrtm_1" class="md-nav__link">
    sqrtm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subspace_angles_1" class="md-nav__link">
    subspace_angles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd_2" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svdvals_1" class="md-nav__link">
    svdvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhm_1" class="md-nav__link">
    tanhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanm_1" class="md-nav__link">
    tanm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toeplitz_1" class="md-nav__link">
    toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri_1" class="md-nav__link">
    tri
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tril_1" class="md-nav__link">
    tril
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu_2" class="md-nav__link">
    triu
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" >
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#linalgerror" class="md-nav__link">
    LinAlgError
  </a>
  
    <nav class="md-nav" aria-label="LinAlgError">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#with_traceback" class="md-nav__link">
    with_traceback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linalgwarning" class="md-nav__link">
    LinAlgWarning
  </a>
  
    <nav class="md-nav" aria-label="LinAlgWarning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#with_traceback_1" class="md-nav__link">
    with_traceback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_1" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_1" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_1" class="md-nav__link">
    pp
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#basic" class="md-nav__link">
    Basic
  </a>
  
    <nav class="md-nav" aria-label="Basic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#atleast_1d" class="md-nav__link">
    atleast_1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atleast_2d" class="md-nav__link">
    atleast_2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#det" class="md-nav__link">
    det
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#levinson" class="md-nav__link">
    levinson
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstsq" class="md-nav__link">
    lstsq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix_balance" class="md-nav__link">
    matrix_balance
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv" class="md-nav__link">
    pinv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv2" class="md-nav__link">
    pinv2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinvh" class="md-nav__link">
    pinvh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_banded" class="md-nav__link">
    solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_circulant" class="md-nav__link">
    solve_circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_toeplitz" class="md-nav__link">
    solve_toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_triangular" class="md-nav__link">
    solve_triangular
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solveh_banded" class="md-nav__link">
    solveh_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#warn" class="md-nav__link">
    warn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#blas" class="md-nav__link">
    Blas
  </a>
  
    <nav class="md-nav" aria-label="Blas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#crotg" class="md-nav__link">
    crotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#drotg" class="md-nav__link">
    drotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_best_blas_type" class="md-nav__link">
    find_best_blas_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#srotg" class="md-nav__link">
    srotg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zrotg" class="md-nav__link">
    zrotg
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cython_blas" class="md-nav__link">
    Cython_blas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cython_lapack" class="md-nav__link">
    Cython_lapack
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp" class="md-nav__link">
    Decomp
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inexact" class="md-nav__link">
    Inexact
  </a>
  
    <nav class="md-nav" aria-label="Inexact">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create" class="md-nav__link">
    create
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getitem" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_2" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_2" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_2" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#argsort" class="md-nav__link">
    argsort
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array" class="md-nav__link">
    array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cdf2rdf" class="md-nav__link">
    cdf2rdf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conj" class="md-nav__link">
    conj
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig" class="md-nav__link">
    eig
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_banded" class="md-nav__link">
    eig_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh" class="md-nav__link">
    eigh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_tridiagonal" class="md-nav__link">
    eigh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_banded" class="md-nav__link">
    eigvals_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh" class="md-nav__link">
    eigvalsh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_tridiagonal" class="md-nav__link">
    eigvalsh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#einsum" class="md-nav__link">
    einsum
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#empty" class="md-nav__link">
    empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eye" class="md-nav__link">
    eye
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flatnonzero" class="md-nav__link">
    flatnonzero
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_1" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hessenberg" class="md-nav__link">
    hessenberg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iscomplex" class="md-nav__link">
    iscomplex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iscomplexobj" class="md-nav__link">
    iscomplexobj
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite" class="md-nav__link">
    isfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nonzero" class="md-nav__link">
    nonzero
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeros" class="md-nav__link">
    zeros
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_cholesky" class="md-nav__link">
    Decomp_cholesky
  </a>
  
    <nav class="md-nav" aria-label="Decomp_cholesky">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#asarray_1" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#atleast_2d_1" class="md-nav__link">
    atleast_2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_factor" class="md-nav__link">
    cho_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve" class="md-nav__link">
    cho_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_banded" class="md-nav__link">
    cho_solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky" class="md-nav__link">
    cholesky
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_banded" class="md-nav__link">
    cholesky_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_2" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_lu" class="md-nav__link">
    Decomp_lu
  </a>
  
    <nav class="md-nav" aria-label="Decomp_lu">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#asarray_2" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite_1" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs_1" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_3" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu" class="md-nav__link">
    lu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_factor" class="md-nav__link">
    lu_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_solve" class="md-nav__link">
    lu_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#warn_1" class="md-nav__link">
    warn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_qr" class="md-nav__link">
    Decomp_qr
  </a>
  
    <nav class="md-nav" aria-label="Decomp_qr">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_4" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr" class="md-nav__link">
    qr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_multiply" class="md-nav__link">
    qr_multiply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rq" class="md-nav__link">
    rq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#safecall" class="md-nav__link">
    safecall
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_schur" class="md-nav__link">
    Decomp_schur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single" class="md-nav__link">
    Single
  </a>
  
    <nav class="md-nav" aria-label="Single">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#getitem_1" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#newbyteorder" class="md-nav__link">
    newbyteorder
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_3" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_3" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_3" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#array_1" class="md-nav__link">
    array
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_3" class="md-nav__link">
    asarray
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asarray_chkfinite_2" class="md-nav__link">
    asarray_chkfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_1" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_5" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_1" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur" class="md-nav__link">
    schur
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decomp_svd" class="md-nav__link">
    Decomp_svd
  </a>
  
    <nav class="md-nav" aria-label="Decomp_svd">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arccos" class="md-nav__link">
    arccos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#arcsin" class="md-nav__link">
    arcsin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip" class="md-nav__link">
    clip
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diag" class="md-nav__link">
    diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagsvd" class="md-nav__link">
    diagsvd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot" class="md-nav__link">
    dot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_6" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#null_space" class="md-nav__link">
    null_space
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orth" class="md-nav__link">
    orth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subspace_angles" class="md-nav__link">
    subspace_angles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svdvals" class="md-nav__link">
    svdvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where" class="md-nav__link">
    where
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeros_1" class="md-nav__link">
    zeros
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flinalg" class="md-nav__link">
    Flinalg
  </a>
  
    <nav class="md-nav" aria-label="Flinalg">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_flinalg_funcs_2" class="md-nav__link">
    get_flinalg_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#has_column_major_storage" class="md-nav__link">
    has_column_major_storage
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lapack" class="md-nav__link">
    Lapack
  </a>
  
    <nav class="md-nav" aria-label="Lapack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cgegv" class="md-nav__link">
    cgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dgegv" class="md-nav__link">
    dgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_7" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sgegv" class="md-nav__link">
    sgegv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zgegv" class="md-nav__link">
    zgegv
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matfuncs" class="md-nav__link">
    Matfuncs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#single_1" class="md-nav__link">
    Single
  </a>
  
    <nav class="md-nav" aria-label="Single">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#getitem_2" class="md-nav__link">
    getitem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#newbyteorder_1" class="md-nav__link">
    newbyteorder
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_string_4" class="md-nav__link">
    to_string
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#show_4" class="md-nav__link">
    show
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pp_4" class="md-nav__link">
    pp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#absolute" class="md-nav__link">
    absolute
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#amax" class="md-nav__link">
    amax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjugate" class="md-nav__link">
    conjugate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coshm" class="md-nav__link">
    coshm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosm" class="md-nav__link">
    cosm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diag_1" class="md-nav__link">
    diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot_1" class="md-nav__link">
    dot
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm" class="md-nav__link">
    expm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_cond" class="md-nav__link">
    expm_cond
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_frechet" class="md-nav__link">
    expm_frechet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractional_matrix_power" class="md-nav__link">
    fractional_matrix_power
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funm" class="md-nav__link">
    funm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv_1" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#isfinite_1" class="md-nav__link">
    isfinite
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#khatri_rao" class="md-nav__link">
    khatri_rao
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logical_not" class="md-nav__link">
    logical_not
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logm" class="md-nav__link">
    logm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_2" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prod" class="md-nav__link">
    prod
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ravel" class="md-nav__link">
    ravel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf_1" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur_1" class="md-nav__link">
    schur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sign" class="md-nav__link">
    sign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signm" class="md-nav__link">
    signm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinhm" class="md-nav__link">
    sinhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinm" class="md-nav__link">
    sinm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_1" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrtm" class="md-nav__link">
    sqrtm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd_1" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhm" class="md-nav__link">
    tanhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanm" class="md-nav__link">
    tanm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transpose" class="md-nav__link">
    transpose
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu" class="md-nav__link">
    triu
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#misc" class="md-nav__link">
    Misc
  </a>
  
    <nav class="md-nav" aria-label="Misc">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs_1" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_8" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_3" class="md-nav__link">
    norm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#special_matrices" class="md-nav__link">
    Special_matrices
  </a>
  
    <nav class="md-nav" aria-label="Special_matrices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#as_strided" class="md-nav__link">
    as_strided
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_diag" class="md-nav__link">
    block_diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circulant" class="md-nav__link">
    circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#companion" class="md-nav__link">
    companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolution_matrix" class="md-nav__link">
    convolution_matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dft" class="md-nav__link">
    dft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler" class="md-nav__link">
    fiedler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_companion" class="md-nav__link">
    fiedler_companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hadamard" class="md-nav__link">
    hadamard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hankel" class="md-nav__link">
    hankel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#helmert" class="md-nav__link">
    helmert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hilbert" class="md-nav__link">
    hilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invhilbert" class="md-nav__link">
    invhilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invpascal" class="md-nav__link">
    invpascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kron" class="md-nav__link">
    kron
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leslie" class="md-nav__link">
    leslie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pascal" class="md-nav__link">
    pascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toeplitz" class="md-nav__link">
    toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri" class="md-nav__link">
    tri
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tril" class="md-nav__link">
    tril
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu_1" class="md-nav__link">
    triu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block_diag_1" class="md-nav__link">
    block_diag
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cdf2rdf_1" class="md-nav__link">
    cdf2rdf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_factor_1" class="md-nav__link">
    cho_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_1" class="md-nav__link">
    cho_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cho_solve_banded_1" class="md-nav__link">
    cho_solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_1" class="md-nav__link">
    cholesky
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cholesky_banded_1" class="md-nav__link">
    cholesky_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#circulant_1" class="md-nav__link">
    circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clarkson_woodruff_transform" class="md-nav__link">
    clarkson_woodruff_transform
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#companion_1" class="md-nav__link">
    companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convolution_matrix_1" class="md-nav__link">
    convolution_matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coshm_1" class="md-nav__link">
    coshm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosm_1" class="md-nav__link">
    cosm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cossin" class="md-nav__link">
    cossin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#det_1" class="md-nav__link">
    det
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dft_1" class="md-nav__link">
    dft
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#diagsvd_1" class="md-nav__link">
    diagsvd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_1" class="md-nav__link">
    eig
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eig_banded_1" class="md-nav__link">
    eig_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_1" class="md-nav__link">
    eigh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigh_tridiagonal_1" class="md-nav__link">
    eigh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_2" class="md-nav__link">
    eigvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvals_banded_1" class="md-nav__link">
    eigvals_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_1" class="md-nav__link">
    eigvalsh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigvalsh_tridiagonal_1" class="md-nav__link">
    eigvalsh_tridiagonal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_1" class="md-nav__link">
    expm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_cond_1" class="md-nav__link">
    expm_cond
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expm_frechet_1" class="md-nav__link">
    expm_frechet
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_1" class="md-nav__link">
    fiedler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fiedler_companion_1" class="md-nav__link">
    fiedler_companion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#find_best_blas_type_1" class="md-nav__link">
    find_best_blas_type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractional_matrix_power_1" class="md-nav__link">
    fractional_matrix_power
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funm_1" class="md-nav__link">
    funm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_blas_funcs_2" class="md-nav__link">
    get_blas_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_lapack_funcs_9" class="md-nav__link">
    get_lapack_funcs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hadamard_1" class="md-nav__link">
    hadamard
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hankel_1" class="md-nav__link">
    hankel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#helmert_1" class="md-nav__link">
    helmert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hessenberg_1" class="md-nav__link">
    hessenberg
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hilbert_1" class="md-nav__link">
    hilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inv_2" class="md-nav__link">
    inv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invhilbert_1" class="md-nav__link">
    invhilbert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#invpascal_1" class="md-nav__link">
    invpascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#khatri_rao_1" class="md-nav__link">
    khatri_rao
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kron_1" class="md-nav__link">
    kron
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ldl" class="md-nav__link">
    ldl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leslie_1" class="md-nav__link">
    leslie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logm_1" class="md-nav__link">
    logm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstsq_1" class="md-nav__link">
    lstsq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_1" class="md-nav__link">
    lu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_factor_1" class="md-nav__link">
    lu_factor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lu_solve_1" class="md-nav__link">
    lu_solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix_balance_1" class="md-nav__link">
    matrix_balance
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#norm_4" class="md-nav__link">
    norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#null_space_1" class="md-nav__link">
    null_space
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ordqz" class="md-nav__link">
    ordqz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orth_1" class="md-nav__link">
    orth
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#orthogonal_procrustes" class="md-nav__link">
    orthogonal_procrustes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pascal_1" class="md-nav__link">
    pascal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv_1" class="md-nav__link">
    pinv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinv2_1" class="md-nav__link">
    pinv2
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pinvh_1" class="md-nav__link">
    pinvh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polar" class="md-nav__link">
    polar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_1" class="md-nav__link">
    qr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_insert" class="md-nav__link">
    qr_insert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_multiply_1" class="md-nav__link">
    qr_multiply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qr_update" class="md-nav__link">
    qr_update
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#qz" class="md-nav__link">
    qz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rq_1" class="md-nav__link">
    rq
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rsf2csf_2" class="md-nav__link">
    rsf2csf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schur_2" class="md-nav__link">
    schur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signm_1" class="md-nav__link">
    signm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinhm_1" class="md-nav__link">
    sinhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sinm_1" class="md-nav__link">
    sinm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_2" class="md-nav__link">
    solve
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_banded_1" class="md-nav__link">
    solve_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_circulant_1" class="md-nav__link">
    solve_circulant
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_continuous_are" class="md-nav__link">
    solve_continuous_are
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_continuous_lyapunov" class="md-nav__link">
    solve_continuous_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_discrete_are" class="md-nav__link">
    solve_discrete_are
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_discrete_lyapunov" class="md-nav__link">
    solve_discrete_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_lyapunov" class="md-nav__link">
    solve_lyapunov
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_sylvester" class="md-nav__link">
    solve_sylvester
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_toeplitz_1" class="md-nav__link">
    solve_toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solve_triangular_1" class="md-nav__link">
    solve_triangular
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solveh_banded_1" class="md-nav__link">
    solveh_banded
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sqrtm_1" class="md-nav__link">
    sqrtm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subspace_angles_1" class="md-nav__link">
    subspace_angles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svd_2" class="md-nav__link">
    svd
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#svdvals_1" class="md-nav__link">
    svdvals
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhm_1" class="md-nav__link">
    tanhm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanm_1" class="md-nav__link">
    tanm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toeplitz_1" class="md-nav__link">
    toeplitz
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri_1" class="md-nav__link">
    tri
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tril_1" class="md-nav__link">
    tril
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triu_2" class="md-nav__link">
    triu
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Linalg.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>Linalg</h1>
                
                <h2 id="linalgerror">LinAlgError<a class="headerlink" href="#linalgerror" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​LinAlgError</code> wraps Python class <code>scipy.linalg.LinAlgError</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="with_traceback">with_traceback<a class="headerlink" href="#with_traceback" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method with_traceback</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span>
  <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
</details>
<h3 id="to_string">to_string<a class="headerlink" href="#to_string" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show">show<a class="headerlink" href="#show" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp">pp<a class="headerlink" href="#pp" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="linalgwarning">LinAlgWarning<a class="headerlink" href="#linalgwarning" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​LinAlgWarning</code> wraps Python class <code>scipy.linalg.LinAlgWarning</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="with_traceback_1">with_traceback<a class="headerlink" href="#with_traceback_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method with_traceback</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span>
  <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
</details>
<h3 id="to_string_1">to_string<a class="headerlink" href="#to_string_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_1">show<a class="headerlink" href="#show_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_1">pp<a class="headerlink" href="#pp_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h2 id="basic">Basic<a class="headerlink" href="#basic" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Basic</code> wraps Python module <code>scipy.linalg.basic</code>.</p>
<h3 id="atleast_1d">atleast_1d<a class="headerlink" href="#atleast_1d" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function atleast_1d</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_1d</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<h4>Parameters</h4>
<p>arys1, arys2, ... : array_like
    One or more input arrays.</p>
<h4>Returns</h4>
<ul>
<li><strong>ret : ndarray</strong>
    An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.
    Copies are made only if necessary.</li>
</ul>
<h4>See Also</h4>
<p>atleast_2d, atleast_3d</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])]</span>
</code></pre></div>

</details>
<h3 id="atleast_2d">atleast_2d<a class="headerlink" href="#atleast_2d" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function atleast_2d</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h4>Parameters</h4>
<p>arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.</p>
<h4>Returns</h4>
<p>res, res2, ... : ndarray
    An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.</p>
<h4>See Also</h4>
<p>atleast_1d, atleast_3d</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])]</span>
</code></pre></div>

</details>
<h3 id="det">det<a class="headerlink" href="#det" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function det</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">det</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the determinant of a matrix</p>
<p>The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.</p>
<p>The determinant for a 3x3 matrix, for example, is computed as follows::</p>
<div class="codehilite"><pre><span></span><code>a    b    c
d    e    f = A
g    h    i

det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A square matrix.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in a (may enhance performance).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>det : float or complex</strong>
    Determinant of <code>a</code>.</li>
</ul>
<h4>Notes</h4>
<p>The determinant is computed via LU factorization, LAPACK routine z/dgetrf.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">0.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">3.0</span>
</code></pre></div>

</details>
<h3 id="get_flinalg_funcs">get_flinalg_funcs<a class="headerlink" href="#get_flinalg_funcs" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_flinalg_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. Arrays are used to determine optimal prefix.</p>
</details>
<h3 id="get_lapack_funcs">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="inv">inv<a class="headerlink" href="#inv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function inv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Square matrix to be inverted.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Discard data in <code>a</code> (may improve performance). Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>ainv : ndarray</strong>
    Inverse of the matrix <code>a</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If <code>a</code> is singular.
ValueError
    If <code>a</code> is not square, or not 2D.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="levinson">levinson<a class="headerlink" href="#levinson" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function levinson</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">levinson</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve a linear Toeplitz system using Levinson recursion.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array, dtype=double or complex128, shape=(2n-1,)</strong>
    The first column of the matrix in reverse order (without the diagonal)
    followed by the first (see below)</p>
</li>
<li>
<p><strong>b : array, dtype=double  or complex128, shape=(n,)</strong>
    The right hand side vector. Both a and b must have the same type
    (double or complex128).</p>
</li>
</ul>
<h4>Notes</h4>
<p>For example, the 5x5 toeplitz matrix below should be represented as
the linear array <code>a</code> on the right ::</p>
<div class="codehilite"><pre><span></span><code>[ a0    a1   a2  a3  a4 ]
[ a-1   a0   a1  a2  a3 ]
[ a-2  a-1   a0  a1  a2 ] -&gt; [a-4  a-3  a-2  a-1  a0  a1  a2  a3  a4]
[ a-3  a-2  a-1  a0  a1 ]
[ a-4  a-3  a-2  a-1 a0 ]
</code></pre></div>


<h4>Returns</h4>
<ul>
<li>
<p><strong>x : arrray, shape=(n,)</strong>
    The solution vector</p>
</li>
<li>
<p><strong>reflection_coeff : array, shape=(n+1,)</strong>
    Toeplitz reflection coefficients. When a is symmetric Toeplitz and
    <code>b</code> is <code>a[n:]</code>, as in the solution of autoregressive systems,
    then <code>reflection_coeff</code> also correspond to the partial
    autocorrelation function.</p>
</li>
</ul>
</details>
<h3 id="lstsq">lstsq<a class="headerlink" href="#lstsq" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lstsq</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lstsq</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Compute least-squares solution to equation Ax = b.</p>
<p>Compute a vector x such that the 2-norm <code>|b - A x|</code> is minimized.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Left-hand side array</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right hand side array</p>
</li>
<li>
<p><strong>cond : float, optional</strong>
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    <code>rcond * largest_singular_value</code> are considered zero.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Discard data in <code>a</code> (may enhance performance). Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance). Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>lapack_driver : str, optional</strong>
    Which LAPACK driver is used to solve the least-squares problem.
    Options are <code>'gelsd'</code>, <code>'gelsy'</code>, <code>'gelss'</code>. Default
    (<code>'gelsd'</code>) is a good choice.  However, <code>'gelsy'</code> can be slightly
    faster on many problems.  <code>'gelss'</code> was used historically.  It is
    generally slow but uses less memory.</p>
<p>.. versionadded:: 0.17.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>x : (N,) or (N, K) ndarray</strong>
    Least-squares solution.  Return shape matches shape of <code>b</code>.</p>
</li>
<li>
<p><strong>residues : (K,) ndarray or float</strong>
    Square of the 2-norm for each column in <code>b - a x</code>, if <code>M &gt; N</code> and
    <code>ndim(A) == n</code> (returns a scalar if b is 1-D). Otherwise a
    (0,)-shaped array is returned.</p>
</li>
<li>
<p><strong>rank : int</strong>
    Effective rank of <code>a</code>.</p>
</li>
<li>
<p><strong>s : (min(M, N),) ndarray or None</strong>
    Singular values of <code>a</code>. The condition number of a is
    <code>abs(s[0] / s[-1])</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If computation does not converge.</p>
<p>ValueError
    When parameters are not compatible.</p>
<h4>See Also</h4>
<ul>
<li><strong>scipy.optimize.nnls : linear least squares with non-negativity constraint</strong></li>
</ul>
<h4>Notes</h4>
<p>When <code>'gelsy'</code> is used as a driver, <code>residues</code> is set to a (0,)-shaped
array and <code>s</code> is always <code>None</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lstsq</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</code></pre></div>

<p>Suppose we have the following data:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">,</span> <span class="mf">8.6</span><span class="p">])</span>
</code></pre></div>

<p>We want to fit a quadratic polynomial of the form <code>y = a + b*x**2</code>
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing <code>x**2</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">**</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.</span>  <span class="p">,</span>   <span class="mf">1.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>   <span class="mf">6.25</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">12.25</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">16.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">25.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">49.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">72.25</span><span class="p">]])</span>
</code></pre></div>

<p>We want to find the least-squares solution to <code>M.dot(p) = y</code>,
where <code>p</code> is a vector with length 2 that holds the parameters
<code>a</code> and <code>b</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rnk</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.20925829</span><span class="p">,</span>  <span class="mf">0.12013861</span><span class="p">])</span>
</code></pre></div>

<p>Plot the data and the fitted curve.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;least squares fit, $y = a + bx^2$&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">framealpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

</details>
<h3 id="matrix_balance">matrix_balance<a class="headerlink" href="#matrix_balance" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function matrix_balance</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix_balance</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">permute</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">separate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a diagonal similarity transformation for row/column balancing.</p>
<p>The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.</p>
<p>Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.</p>
<p>The balanced matrix satisfies the following equality</p>
<div>
<div class="MathJax_Preview">
                    B = T^{-1} A T
</div>
<script type="math/tex; mode=display">
                    B = T^{-1} A T
</script>
</div>
<p>The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (n, n) array_like</strong>
    Square data matrix for the balancing.</p>
</li>
<li>
<p><strong>permute : bool, optional</strong>
    The selector to define whether permutation of A is also performed
    prior to scaling.</p>
</li>
<li>
<p><strong>scale : bool, optional</strong>
    The selector to turn on and off the scaling. If False, the matrix
    will not be scaled.</p>
</li>
<li>
<p><strong>separate : bool, optional</strong>
    This switches from returning a full matrix of the transformation
    to a tuple of two separate 1-D permutation and scaling arrays.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    This is passed to xGEBAL directly. Essentially, overwrites the result
    to the data. It might increase the space efficiency. See LAPACK manual
    for details. This is False by default.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (n, n) ndarray</strong>
    Balanced matrix</p>
</li>
<li>
<p><strong>T : (n, n) ndarray</strong>
    A possibly permuted diagonal matrix whose nonzero entries are
    integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
    If <code>separate</code> keyword is set to True then instead of the array
    <code>T</code> above, the scaling and the permutation vectors are given
    separately as a tuple without allocating the full array <code>T</code>.</p>
</li>
</ul>
<h4>Notes</h4>
<p>This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.</p>
<p>The algorithm is based on the well-known technique of [1]<em> and has
been modified to account for special cases. See [2]</em> for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.</p>
<p>The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.</p>
<p>.. versionadded:: 0.19.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.01</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">permscale</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matrix_balance</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">3.66666667</span><span class="p">,</span>  <span class="mf">0.4995005</span> <span class="p">,</span>  <span class="mf">0.91312162</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.2</span>       <span class="p">,</span>  <span class="mf">1.27041742</span><span class="p">,</span>  <span class="mf">0.92658316</span><span class="p">])</span>  <span class="c1"># may vary</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">permscale</span>  <span class="c1"># only powers of 2 (0.5 == 2^(-1))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">0.5</span><span class="p">,</span>   <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>  <span class="c1"># may vary</span>
       <span class="p">[</span>  <span class="mf">0.</span> <span class="p">,</span>   <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span> <span class="p">,</span>   <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">]])</span>
</code></pre></div>

<h4>References</h4>
<p>.. [1] : B.N. Parlett and C. Reinsch, 'Balancing a Matrix for
   Calculation of Eigenvalues and Eigenvectors', Numerische Mathematik,
   Vol.13(4), 1969, DOI:10.1007/BF02165404</p>
<p>.. [2] : R. James, J. Langou, B.R. Lowery, 'On matrix balancing and
   eigenvector computation', 2014, Available online:</p>
<ul>
<li><strong>https://arxiv.org/abs/1401.5766</strong></li>
</ul>
<p>.. [3] :  D.S. Watkins. A case where balancing is harmful.
   Electron. Trans. Numer. Anal, Vol.23, 2006.</p>
</details>
<h3 id="pinv">pinv<a class="headerlink" href="#pinv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using a least-squares
solver.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be pseudo-inverted.
cond, rcond : float, optional
    Cutoff factor for 'small' singular values. In <code>lstsq</code>,
    singular values less than <code>cond*largest_singular_value</code> will be
    considered as zero. If both are omitted, the default value
    <code>max(M, N) * eps</code> is passed to <code>lstsq</code> where <code>eps</code> is the
    corresponding machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps</code> without the
    factor <code>max(M, N)</code>.</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    if True, return the effective rank of the matrix</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, M) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix. Returned if return_rank == True</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If computation does not converge.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="pinv2">pinv2<a class="headerlink" href="#pinv2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinv2</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv2</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be pseudo-inverted.
cond, rcond : float or None
    Cutoff for 'small' singular values; singular values smaller than this
    value are considered as zero. If both are omitted, the default value
    <code>max(M,N)*largest_singular_value*eps</code> is used where <code>eps</code> is the
    machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
    was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    If True, return the effective rank of the matrix.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, M) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix. Returned if <code>return_rank</code> is True.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinv2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="pinvh">pinvh<a class="headerlink" href="#pinvh" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinvh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinvh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</p>
<p>Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (N, N) array_like</strong>
    Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
    Cutoff for 'small' singular values; singular values smaller than this
    value are considered as zero. If both are omitted, the default
    <code>max(M,N)*largest_eigenvalue*eps</code> is used where <code>eps</code> is the
    machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
    was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code>. (Default: lower)</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    If True, return the effective rank of the matrix.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, N) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue does not converge</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">pinvh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">pinvh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve">solve<a class="headerlink" href="#solve" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (N, N) array_like</strong>
    Square input data</p>
</li>
<li>
<p><strong>b : (N, NRHS) array_like</strong>
    Input data for the right hand side.</p>
</li>
<li>
<p><strong>sym_pos : bool, optional</strong>
    Assume <code>a</code> is symmetric and positive definite. This key is deprecated
    and assume_a = 'pos' keyword is recommended instead. The functionality
    is the same. It will be removed in the future.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    If True, only the data contained in the lower triangle of <code>a</code>. Default
    is to use upper triangle. (ignored for <code>'gen'</code>)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in <code>a</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Allow overwriting data in <code>b</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>assume_a : str, optional</strong>
    Valid entries are explained above.</p>
</li>
<li>
<p><strong>transposed: bool, optional</strong>
    If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
    for complex matrices (only for True).</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (N, NRHS) ndarray</strong>
    The solution array.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.</p>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

<h4>Notes</h4>
<p>If the input b matrix is a 1-D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1-D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
</details>
<h3 id="solve_banded">solve_banded<a class="headerlink" href="#solve_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">l_and_u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation a x = b for x, assuming a is banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> using the matrix diagonal ordered form::</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]
</code></pre></div>


<p>Example of <code>ab</code> (shape of a is (6,6), <code>u</code> =1, <code>l</code> =2)::</p>
<div class="codehilite"><pre><span></span><code>*    a01  a12  a23  a34  a45
a00  a11  a22  a33  a44  a55
a10  a21  a32  a43  a54   *
a20  a31  a42  a53   *    *
</code></pre></div>


<h4>Parameters</h4>
<p>(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals</p>
<ul>
<li>
<p><strong>ab : (<code>l</code> + <code>u</code> + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in <code>ab</code> (may enhance performance)</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system a x = b. Returned shape depends on the
    shape of <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<p>Solve the banded system a x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [5  2 -1  0  0]       [0]
    [1  4  2 -1  0]       [1]
a = [0  1  3  2 -1]   b = [2]
    [0  0  1  2  2]       [2]
    [0  0  0  1  1]       [3]
</code></pre></div>


<p>There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2). The diagonal banded form of the matrix is::</p>
<div class="codehilite"><pre><span></span><code>     [*  * -1 -1 -1]
ab = [*  2  2  2  2]
     [5  4  3  2  1]
     [1  1  1  1  *]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_banded</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.37288136</span><span class="p">,</span>  <span class="mf">3.93220339</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span>        <span class="p">,</span>  <span class="mf">4.3559322</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.3559322</span> <span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_circulant">solve_circulant<a class="headerlink" href="#solve_circulant" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_circulant</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_circulant</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">singular</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">caxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">baxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">outaxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve C x = b for x, where C is a circulant matrix.</p>
<p><code>C</code> is the circulant matrix associated with the vector <code>c</code>.</p>
<p>The system is solved by doing division in Fourier space. The
calculation is::</p>
<div class="codehilite"><pre><span></span><code>x = ifft(fft(b) / fft(c))
</code></pre></div>


<p>where <code>fft</code> and <code>ifft</code> are the fast Fourier transform and its inverse,
respectively. For a large vector <code>c</code>, this is <em>much</em> faster than
solving the system with the full circulant matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    The coefficients of the circulant matrix.</p>
</li>
<li>
<p><strong>b : array_like</strong>
    Right-hand side matrix in <code>a x = b</code>.</p>
</li>
<li>
<p><strong>singular : str, optional</strong>
    This argument controls how a near singular circulant matrix is
    handled.  If <code>singular</code> is 'raise' and the circulant matrix is
    near singular, a <code>LinAlgError</code> is raised. If <code>singular</code> is
    'lstsq', the least squares solution is returned. Default is 'raise'.</p>
</li>
<li>
<p><strong>tol : float, optional</strong>
    If any eigenvalue of the circulant matrix has an absolute value
    that is less than or equal to <code>tol</code>, the matrix is considered to be
    near singular. If not given, <code>tol</code> is set to::</p>
<div class="codehilite"><pre><span></span><code>tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps
</code></pre></div>


<p>where <code>abs_eigs</code> is the array of absolute values of the eigenvalues
of the circulant matrix.</p>
</li>
<li>
<p><strong>caxis : int</strong>
    When <code>c</code> has dimension greater than 1, it is viewed as a collection
    of circulant vectors. In this case, <code>caxis</code> is the axis of <code>c</code> that
    holds the vectors of circulant coefficients.</p>
</li>
<li>
<p><strong>baxis : int</strong>
    When <code>b</code> has dimension greater than 1, it is viewed as a collection
    of vectors. In this case, <code>baxis</code> is the axis of <code>b</code> that holds the
    right-hand side vectors.</p>
</li>
<li>
<p><strong>outaxis : int</strong>
    When <code>c</code> or <code>b</code> are multidimensional, the value returned by
    <code>solve_circulant</code> is multidimensional. In this case, <code>outaxis</code> is
    the axis of the result that holds the solution vectors.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : ndarray</strong>
    Solution to the system <code>C x = b</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If the circulant matrix associated with <code>c</code> is near singular.</p>
<h4>See Also</h4>
<ul>
<li><strong>circulant : circulant matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>For a 1-D vector <code>c</code> with length <code>m</code>, and an array <code>b</code>
with shape <code>(m, ...)</code>,</p>
<div class="codehilite"><pre><span></span><code>solve_circulant(c, b)
</code></pre></div>


<p>returns the same result as</p>
<div class="codehilite"><pre><span></span><code>solve(circulant(c), b)
</code></pre></div>


<p>where <code>solve</code> and <code>circulant</code> are from <code>scipy.linalg</code>.</p>
<p>.. versionadded:: 0.16.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_circulant</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">circulant</span><span class="p">,</span> <span class="n">lstsq</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>  <span class="mf">0.25</span><span class="p">])</span>
</code></pre></div>

<p>Compare that result to solving the system with <code>scipy.linalg.solve</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">circulant</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>  <span class="mf">0.25</span><span class="p">])</span>
</code></pre></div>

<p>A singular example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>

<p>Calling <code>solve_circulant(c, b)</code> will raise a <code>LinAlgError</code>.  For the
least square solution, use the option <code>singular='lstsq'</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">singular</span><span class="o">=</span><span class="s1">&#39;lstsq&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">,</span>  <span class="mf">2.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">])</span>
</code></pre></div>

<p>Compare to <code>scipy.linalg.lstsq</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">rnk</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">circulant</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">,</span>  <span class="mf">2.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">])</span>
</code></pre></div>

<p>A broadcasting example:</p>
<p>Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three <code>b</code> vectors stored in an array with shape
(3, 5).  For example,</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div>

<p>We want to solve all combinations of circulant matrices and <code>b</code> vectors,
with the result stored in an array with shape (2, 3, 5). When we
disregard the axes of <code>c</code> and <code>b</code> that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting. To have a broadcast result with shape
(2, 3), we add a trivial dimension to <code>c</code>: <code>c[:, np.newaxis, :]</code> has
shape (2, 1, 5). The last dimension holds the coefficients of the
circulant matrices, so when we call <code>solve_circulant</code>, we can use the
default <code>caxis=-1</code>. The coefficients of the <code>b</code> vectors are in the last
dimension of the array <code>b</code>, so we use <code>baxis=-1</code>. If we use the
default <code>outaxis</code>, the result will have shape (5, 2, 3), so we'll use
<code>outaxis=-1</code> to put the solution vectors in the last dimension.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">,</span> <span class="n">baxis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># For compact output of numbers.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[[</span><span class="o">-</span><span class="mf">0.118</span><span class="p">,</span>  <span class="mf">0.22</span> <span class="p">,</span>  <span class="mf">1.277</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.142</span><span class="p">,</span>  <span class="mf">0.302</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.651</span><span class="p">,</span>  <span class="mf">0.989</span><span class="p">,</span>  <span class="mf">2.046</span><span class="p">,</span>  <span class="mf">0.627</span><span class="p">,</span>  <span class="mf">1.072</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.42</span> <span class="p">,</span>  <span class="mf">1.758</span><span class="p">,</span>  <span class="mf">2.816</span><span class="p">,</span>  <span class="mf">1.396</span><span class="p">,</span>  <span class="mf">1.841</span><span class="p">]],</span>
       <span class="p">[[</span> <span class="mf">0.401</span><span class="p">,</span>  <span class="mf">0.304</span><span class="p">,</span>  <span class="mf">0.694</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.867</span><span class="p">,</span>  <span class="mf">0.377</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.856</span><span class="p">,</span>  <span class="mf">0.758</span><span class="p">,</span>  <span class="mf">1.149</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.412</span><span class="p">,</span>  <span class="mf">0.831</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.31</span> <span class="p">,</span>  <span class="mf">1.213</span><span class="p">,</span>  <span class="mf">1.603</span><span class="p">,</span>  <span class="mf">0.042</span><span class="p">,</span>  <span class="mf">1.286</span><span class="p">]]])</span>
</code></pre></div>

<p>Check by solving one pair of <code>c</code> and <code>b</code> vectors (cf. <code>x[1, 1, :]</code>):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.856</span><span class="p">,</span>  <span class="mf">0.758</span><span class="p">,</span>  <span class="mf">1.149</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.412</span><span class="p">,</span>  <span class="mf">0.831</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_toeplitz">solve_toeplitz<a class="headerlink" href="#solve_toeplitz" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_toeplitz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_toeplitz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">c_or_cr</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_array_like_array_like_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve a Toeplitz system using Levinson Recursion</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c_or_cr : array_like or tuple of (array_like, array_like)</strong>
    The vector <code>c</code>, or a tuple of arrays (<code>c</code>, <code>r</code>). Whatever the
    actual shape of <code>c</code>, it will be converted to a 1-D array. If not
    supplied, <code>r = conjugate(c)</code> is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is <code>[c[0], r[1:]]</code>. Whatever the actual shape
    of <code>r</code>, it will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side in <code>T x = b</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system <code>T x = b</code>. Shape of return matches shape
    of <code>b</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>toeplitz : Toeplitz matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.</p>
<h4>Examples</h4>
<p>Solve the Toeplitz system T x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 1 -1 -2 -3]       [1]
T = [ 3  1 -1 -2]   b = [2]
    [ 6  3  1 -1]       [2]
    [10  6  3  1]       [5]
</code></pre></div>


<p>To specify the Toeplitz matrix, only the first column and the first
row are needed.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>    <span class="c1"># First column of T</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># First row of T</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_toeplitz</span><span class="p">,</span> <span class="n">toeplitz</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_toeplitz</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">2.66666667</span><span class="p">,</span>  <span class="mf">2.33333333</span><span class="p">])</span>
</code></pre></div>

<p>Check the result by creating the full Toeplitz matrix and
multiplying it by <code>x</code>.  We should get <code>b</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_triangular">solve_triangular<a class="headerlink" href="#solve_triangular" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_triangular</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A triangular matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, N) array_like</strong>
    Right-hand side matrix in <code>a x = b</code></p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Use only data contained in the lower triangle of <code>a</code>.
    Default is to use upper triangle.</p>
</li>
<li>
<p><strong>trans : {0, 1, 2, 'N', 'T', 'C'}, optional</strong>
    Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========</p>
</li>
<li>
<p><strong>unit_diagonal : bool, optional</strong>
    If True, diagonal elements of <code>a</code> are assumed to be 1 and
    will not be referenced.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Allow overwriting data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, N) ndarray</strong>
    Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If <code>a</code> is singular</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.9.0</p>
<h4>Examples</h4>
<p>Solve the lower triangular system a x = b, where::</p>
<div class="codehilite"><pre><span></span><code>     [3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
     [1  0  1  0]       [4]
     [1  1  1  1]       [2]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_triangular</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_triangular</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.33333333</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.66666667</span><span class="p">,</span>  <span class="mf">2.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.33333333</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Check the result</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solveh_banded">solveh_banded<a class="headerlink" href="#solveh_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solveh_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solveh_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve equation a x = b. a is Hermitian positive-definite banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>Example of <code>ab</code> (shape of a is (6, 6), <code>u</code> =2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>ab : (<code>u</code> + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in <code>ab</code> (may enhance performance)</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system a x = b. Shape of return matches shape
    of <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<p>Solve the banded system A x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 4  2 -1  0  0  0]       [1]
    [ 2  5  2 -1  0  0]       [2]
A = [-1  2  6  2 -1  0]   b = [2]
    [ 0 -1  2  7  2 -1]       [3]
    [ 0  0 -1  2  8  2]       [3]
    [ 0  0  0 -1  2  9]       [3]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solveh_banded</span>
</code></pre></div>

<p><code>ab</code> contains the main diagonal and the nonzero diagonals below the
main diagonal. That is, we use the lower form:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solveh_banded</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.03431373</span><span class="p">,</span>  <span class="mf">0.45938375</span><span class="p">,</span>  <span class="mf">0.05602241</span><span class="p">,</span>  <span class="mf">0.47759104</span><span class="p">,</span>  <span class="mf">0.17577031</span><span class="p">,</span>
        <span class="mf">0.34733894</span><span class="p">])</span>
</code></pre></div>

<p>Solve the Hermitian banded system H x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 8   2-1j   0     0  ]        [ 1  ]
H = [2+1j  5     1j    0  ]    b = [1+1j]
    [ 0   -1j    9   -2-1j]        [1-2j]
    [ 0    0   -2+1j   6  ]        [ 0  ]
</code></pre></div>


<p>In this example, we put the upper diagonals in the array <code>hb</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span>  <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solveh_banded</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.07318536</span><span class="o">-</span><span class="mf">0.02939412</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.11877624</span><span class="o">+</span><span class="mf">0.17696461</span><span class="n">j</span><span class="p">,</span>
        <span class="mf">0.10077984</span><span class="o">-</span><span class="mf">0.23035393</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00479904</span><span class="o">-</span><span class="mf">0.09358128</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="warn">warn<a class="headerlink" href="#warn" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function warn</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
</details>
<h2 id="blas">Blas<a class="headerlink" href="#blas" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Blas</code> wraps Python module <code>scipy.linalg.blas</code>.</p>
<h3 id="crotg">crotg<a class="headerlink" href="#crotg" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function crotg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">crotg</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>c,s = crotg(a,b)</p>
<p>Wrapper for <code>crotg</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input complex</strong></p>
</li>
<li>
<p><strong>b : input complex</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : complex</strong></p>
</li>
<li>
<p><strong>s : complex</strong></p>
</li>
</ul>
</details>
<h3 id="drotg">drotg<a class="headerlink" href="#drotg" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function drotg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">drotg</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>c,s = drotg(a,b)</p>
<p>Wrapper for <code>drotg</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input float</strong></p>
</li>
<li>
<p><strong>b : input float</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : float</strong></p>
</li>
<li>
<p><strong>s : float</strong></p>
</li>
</ul>
</details>
<h3 id="find_best_blas_type">find_best_blas_type<a class="headerlink" href="#find_best_blas_type" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function find_best_blas_type</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_best_blas_type</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Find best-matching BLAS/LAPACK type.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>prefix : str</strong>
    BLAS/LAPACK prefix character.</p>
</li>
<li>
<p><strong>dtype : dtype</strong>
    Inferred Numpy data type.</p>
</li>
<li>
<p><strong>prefer_fortran : bool</strong>
    Whether to prefer Fortran order routines over C order.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg.blas</span> <span class="k">as</span> <span class="nn">bla</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Change the memory layout order</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">b</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="get_blas_funcs">get_blas_funcs<a class="headerlink" href="#get_blas_funcs" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_blas_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of BLAS functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

</details>
<h3 id="srotg">srotg<a class="headerlink" href="#srotg" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function srotg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">srotg</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>c,s = srotg(a,b)</p>
<p>Wrapper for <code>srotg</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input float</strong></p>
</li>
<li>
<p><strong>b : input float</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : float</strong></p>
</li>
<li>
<p><strong>s : float</strong></p>
</li>
</ul>
</details>
<h3 id="zrotg">zrotg<a class="headerlink" href="#zrotg" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function zrotg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zrotg</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>c,s = zrotg(a,b)</p>
<p>Wrapper for <code>zrotg</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input complex</strong></p>
</li>
<li>
<p><strong>b : input complex</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : complex</strong></p>
</li>
<li>
<p><strong>s : complex</strong></p>
</li>
</ul>
</details>
<h2 id="cython_blas">Cython_blas<a class="headerlink" href="#cython_blas" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Cython_blas</code> wraps Python module <code>scipy.linalg.cython_blas</code>.</p>
<h2 id="cython_lapack">Cython_lapack<a class="headerlink" href="#cython_lapack" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Cython_lapack</code> wraps Python module <code>scipy.linalg.cython_lapack</code>.</p>
<h2 id="decomp">Decomp<a class="headerlink" href="#decomp" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp</code> wraps Python module <code>scipy.linalg.decomp</code>.</p>
<h2 id="inexact">Inexact<a class="headerlink" href="#inexact" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp.​Inexact</code> wraps Python class <code>scipy.linalg.decomp.inexact</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="create">create<a class="headerlink" href="#create" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>constructor and attributes create</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">create</span> <span class="o">:</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="n">t</span>
</code></pre></div>

<p>Abstract base class of all numeric scalar types with a (potentially)
inexact representation of the values in its range, such as
floating-point numbers.</p>
</details>
<h3 id="getitem"><strong>getitem</strong><a class="headerlink" href="#getitem" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method <strong>getitem</strong></summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span>
  <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
</details>
<h3 id="to_string_2">to_string<a class="headerlink" href="#to_string_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_2">show<a class="headerlink" href="#show_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_2">pp<a class="headerlink" href="#pp_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h3 id="argsort">argsort<a class="headerlink" href="#argsort" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function argsort</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">argsort</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">kind</span><span class="o">:[`</span><span class="nc">Quicksort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Stable</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Mergesort</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Heapsort</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <code>kind</code> keyword. It returns an array of indices of the same shape as
<code>a</code> that index data along the given axis in sorted order.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Array to sort.</p>
</li>
<li>
<p><strong>axis : int or None, optional</strong>
    Axis along which to sort.  The default is -1 (the last axis). If None,
    the flattened array is used.</p>
</li>
<li>
<p><strong>kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional</strong>
    Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
    and 'mergesort' use timsort under the covers and, in general, the
    actual implementation will vary with data type. The 'mergesort' option
    is retained for backwards compatibility.</p>
<p>.. versionchanged:: 1.15.0.
   The 'stable' option was added.</p>
</li>
<li>
<p><strong>order : str or list of str, optional</strong>
    When <code>a</code> is an array with fields defined, this argument specifies
    which fields to compare first, second, etc.  A single field can
    be specified as a string, and not all fields need be specified,
    but unspecified fields will still be used, in the order in which
    they come up in the dtype, to break ties.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>index_array : ndarray, int</strong>
    Array of indices that sort <code>a</code> along the specified <code>axis</code>.
    If <code>a</code> is one-dimensional, <code>a[index_array]</code> yields a sorted <code>a</code>.
    More generally, <code>np.take_along_axis(a, index_array, axis=axis)</code>
    always yields the sorted <code>a</code>, irrespective of dimensionality.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>sort : Describes sorting algorithms used.</strong></p>
</li>
<li>
<p><strong>lexsort : Indirect stable sort with multiple keys.</strong></p>
</li>
<li>
<p><strong>ndarray.sort : Inplace sort.</strong></p>
</li>
<li>
<p><strong>argpartition : Indirect partial sort.</strong></p>
</li>
<li>
<p><strong>take_along_axis : Apply <code>index_array</code> from argsort</strong>
                  to an array as if by calling sort.</p>
</li>
</ul>
<h4>Notes</h4>
<p>See <code>sort</code> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <code>argsort</code> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <code>sort</code>.</p>
<h4>Examples</h4>
<p>One dimensional array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<p>Two-dimensional array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sorts along first axis (down)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># same as np.sort(x, axis=0)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts along last axis (across)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># same as np.sort(x, axis=1)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<p>Indices of the sorted elements of a N-dimensional array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ind</span>
<span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>  <span class="c1"># same as np.sort(x, axis=None)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div>

<p>Sorting with keys:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="array">array<a class="headerlink" href="#array" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function array</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>object : array_like</strong>
    An array, any object exposing the array interface, an object whose
    <strong>array</strong> method returns an array, or any (nested) sequence.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.</p>
</li>
<li>
<p><strong>copy : bool, optional</strong>
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (<code>dtype</code>, <code>order</code>, etc.).</p>
</li>
<li>
<p><strong>order : {'K', 'A', 'C', 'F'}, optional</strong>
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.</p>
</li>
<li>
<p><strong>subok : bool, optional</strong>
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).</p>
</li>
<li>
<p><strong>ndmin : int, optional</strong>
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    An array object satisfying the specified requirements.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>empty_like : Return an empty array with shape and type of input.</strong></p>
</li>
<li>
<p><strong>ones_like : Return an array of ones with shape and type of input.</strong></p>
</li>
<li>
<p><strong>zeros_like : Return an array of zeros with shape and type of input.</strong></p>
</li>
<li>
<p><strong>full_like : Return a new array with shape of input filled with value.</strong></p>
</li>
<li>
<p><strong>empty : Return a new uninitialized array.</strong></p>
</li>
<li>
<p><strong>ones : Return a new array setting values to one.</strong></p>
</li>
<li>
<p><strong>zeros : Return a new array setting values to zero.</strong></p>
</li>
<li>
<p><strong>full : Return a new array of given shape filled with value.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div>

<p>Upcasting:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</code></pre></div>

<p>More than one dimension:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<p>Minimum dimensions 2:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div>

<p>Type provided:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>Data-type consisting of more than one element:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div>

<p>Creating an array from sub-classes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="asarray">asarray<a class="headerlink" href="#asarray" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If <code>a</code> is a
    subclass of ndarray, a base class ndarray is returned.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>asarray_chkfinite : Similar function which checks input for NaNs and Infs.</strong></p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>

<p>Existing arrays are not copied:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
</code></pre></div>

<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cdf2rdf">cdf2rdf<a class="headerlink" href="#cdf2rdf" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cdf2rdf</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cdf2rdf</span> <span class="o">:</span>
  <span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Converts complex eigenvalues <code>w</code> and eigenvectors <code>v</code> to real
eigenvalues in a block diagonal form <code>wr</code> and the associated real
eigenvectors <code>vr</code>, such that::</p>
<div class="codehilite"><pre><span></span><code>vr @ wr = X @ vr
</code></pre></div>


<p>continues to hold, where <code>X</code> is the original array for which <code>w</code> and
<code>v</code> are the eigenvalues and eigenvectors.</p>
<p>.. versionadded:: 1.1.0</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>w : (..., M) array_like</strong>
    Complex or real eigenvalues, an array or stack of arrays</p>
<p>Conjugate pairs must not be interleaved, else the wrong result
will be produced. So <code>[1+1j, 1, 1-1j]</code> will give a correct result,
but <code>[1+1j, 2+1j, 1-1j, 2-1j]</code> will not.</p>
</li>
<li>
<p><strong>v : (..., M, M) array_like</strong>
    Complex or real eigenvectors, a square array or stack of square arrays.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>wr : (..., M, M) ndarray</strong>
    Real diagonal block form of eigenvalues</p>
</li>
<li>
<p><strong>vr : (..., M, M) ndarray</strong>
    Real eigenvectors associated with <code>wr</code></p>
</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig : Eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>rsf2csf : Convert real Schur form to complex Schur form</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p><code>w</code>, <code>v</code> must be the eigenstructure for some <em>real</em> matrix <code>X</code>.
For example, obtained by <code>w, v = scipy.linalg.eig(X)</code> or
<code>w, v = numpy.linalg.eig(X)</code> in which case <code>X</code> can also represent
stacked arrays.</p>
<p>.. versionadded:: 1.1.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">+</span><span class="mf">5.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">-</span><span class="mf">5.</span><span class="n">j</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="o">-</span><span class="mf">0.40016</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="o">+</span><span class="mf">0.40016</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.00000</span><span class="o">-</span><span class="mf">0.64788</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.64788</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">wr</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cdf2rdf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">wr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">0.40016</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="p">,</span>  <span class="mf">0.</span>     <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">vr</span> <span class="o">@</span> <span class="n">wr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">1.69593</span><span class="p">,</span>  <span class="mf">1.9246</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">2.59153</span><span class="p">,</span>  <span class="mf">3.23942</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">3.23942</span><span class="p">,</span>  <span class="mf">2.59153</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">@</span> <span class="n">vr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">1.69593</span><span class="p">,</span>  <span class="mf">1.9246</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">2.59153</span><span class="p">,</span>  <span class="mf">3.23942</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">3.23942</span><span class="p">,</span>  <span class="mf">2.59153</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="conj">conj<a class="headerlink" href="#conj" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function conj</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conj</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input value.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : ndarray</strong>
    The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>Notes</h4>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span>
<span class="kc">True</span>
</code></pre></div>

<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eig">eig<a class="headerlink" href="#eig" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eig</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<div class="codehilite"><pre><span></span><code>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]
</code></pre></div>


<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    Right-hand side matrix in a generalized eigenvalue problem.
    Default is None, identity matrix is assumed.</p>
</li>
<li>
<p><strong>left : bool, optional</strong>
    Whether to calculate and return left eigenvectors.  Default is False.</p>
</li>
<li>
<p><strong>right : bool, optional</strong>
    Whether to calculate and return right eigenvectors.  Default is True.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.  Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite <code>b</code>; may improve performance.  Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>homogeneous_eigvals : bool, optional</strong>
    If True, return the eigenvalues in homogeneous coordinates.
    In this case <code>w</code> is a (2, M) array so that::</p>
<div class="codehilite"><pre><span></span><code>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]
</code></pre></div>


<p>Default is False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) or (2, M) double or complex ndarray</strong>
    The eigenvalues, each repeated according to its
    multiplicity. The shape is (M,) unless
    <code>homogeneous_eigvals=True</code>.</p>
</li>
<li>
<p><strong>vl : (M, M) double or complex ndarray</strong>
    The normalized left eigenvector corresponding to the eigenvalue
    <code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.</p>
</li>
<li>
<p><strong>vr : (M, M) double or complex ndarray</strong>
    The normalized right eigenvector corresponding to the eigenvalue
    <code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.</strong></p>
</li>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">homogeneous_eigvals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">8.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># normalized left eigenvector</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span>        <span class="o">-</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># normalized right eigenvector</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">,</span> <span class="mf">0.70710678</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span>        <span class="o">-</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eig_banded">eig_banded<a class="headerlink" href="#eig_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eig_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_ev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve real symmetric or complex Hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w and optionally right eigenvectors v of a::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a_band : (u+1, M) array_like</strong>
    The bands of the M by M matrix a.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Compute only the eigenvalues and no eigenvectors.
    (Default: calculate also eigenvectors)</p>
</li>
<li>
<p><strong>overwrite_a_band : bool, optional</strong>
    Discard data in a_band (may enhance performance)</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>max_ev : int, optional</strong>
    For select=='v', maximum number of eigenvalues expected.
    For other values of select, has no meaning.</p>
<p>In doubt, leave this parameter untouched.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</p>
</li>
<li>
<p><strong>v : (M, M) float or complex ndarray</strong>
    The normalized eigenvector corresponding to the eigenvalue w[i] is
    the column v[:,i].</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors of general arrays.</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eig_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.26200532</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">,</span> <span class="mf">12.53965359</span><span class="p">])</span>
</code></pre></div>

<p>Request only the eigenvalues between <code>[-3, 4]</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">select_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigh">eigh<a class="headerlink" href="#eigh" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_value</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve a standard or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues array <code>w</code> and optionally eigenvectors array <code>v</code> of
array <code>a</code>, where <code>b</code> is positive definite such that for every
eigenvalue λ (i-th entry of w) and its eigenvector <code>vi</code> (i-th column of
<code>v</code>) satisfies::</p>
<div class="codehilite"><pre><span></span><code>              a @ vi = λ * b @ vi
vi.conj().T @ a @ vi = λ
vi.conj().T @ b @ vi = 1
</code></pre></div>


<p>In the standard problem, <code>b</code> is assumed to be the identity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code> and, if applicable, <code>b</code>. (Default: lower)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)</p>
</li>
<li>
<p><strong>subset_by_index : iterable, optional</strong>
    If provided, this two-element iterable defines the start and the end
    indices of the desired eigenvalues (ascending order and 0-indexed).
    To return only the second smallest to fifth smallest eigenvalues,
    <code>[1, 4]</code> is used. <code>[n-3, n-1]</code> returns the largest three. Only
    available with 'evr', 'evx', and 'gvx' drivers. The entries are
    directly converted to integers via <code>int()</code>.</p>
</li>
<li>
<p><strong>subset_by_value : iterable, optional</strong>
    If provided, this two-element iterable defines the half-open interval
    <code>(a, b]</code> that, if any, only the eigenvalues between these values
    are returned. Only available with 'evr', 'evx', and 'gvx' drivers. Use
    <code>np.inf</code> for the unconstrained ends.</p>
</li>
<li>
<p><strong>driver: str, optional</strong>
    Defines which LAPACK driver should be used. Valid options are 'ev',
    'evd', 'evr', 'evx' for standard problems and 'gv', 'gvd', 'gvx' for
    generalized (where b is not None) problems. See the Notes section.</p>
</li>
<li>
<p><strong>type : int, optional</strong>
    For the generalized problems, this keyword specifies the problem type
    to be solved for <code>w</code> and <code>v</code> (only takes 1, 2, 3 as possible</p>
</li>
<li>
<p><strong>inputs)::</strong></p>
<div class="codehilite"><pre><span></span><code>1 =&gt;     a @ v = w @ b @ v
2 =&gt; a @ b @ v = w @ v
3 =&gt; b @ a @ v = w @ v
</code></pre></div>


<p>This keyword is ignored for standard problems.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in <code>b</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>turbo : bool, optional</strong>
    <em>Deprecated since v1.5.0, use <code>driver=gvd</code> keyword instead</em>.
    Use divide and conquer algorithm (faster but expensive in memory, only
    for generalized eigenvalue problem and if full set of eigenvalues are
    requested.). Has no significant effect if eigenvectors are not
    requested.</p>
</li>
<li>
<p><strong>eigvals : tuple (lo, hi), optional</strong>
    <em>Deprecated since v1.5.0, use <code>subset_by_index</code> keyword instead</em>.
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (N,) ndarray</strong>
    The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.</p>
</li>
<li>
<p><strong>v : (M, N) ndarray</strong>
    (if <code>eigvals_only == False</code>)</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge, an error occurred, or
    b matrix is not definite positive. Note that if input matrices are
    not symmetric or Hermitian, no error will be reported but results will
    be wrong.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvalsh : eigenvalues of symmetric or Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts. Also, note that even though not taken into account,
finiteness check applies to the whole array and unaffected by 'lower'
keyword.</p>
<p>This function uses LAPACK drivers for computations in all possible keyword
combinations, prefixed with <code>sy</code> if arrays are real and <code>he</code> if
complex, e.g., a float array with 'evr' driver is solved via
'syevr', complex arrays with 'gvx' driver problem is solved via 'hegvx'
etc.</p>
<p>As a brief summary, the slowest and the most robust driver is the
classical <code>&lt;sy/he&gt;ev</code> which uses symmetric QR. <code>&lt;sy/he&gt;evr</code> is seen as
the optimal choice for the most general cases. However, there are certain
occassions that <code>&lt;sy/he&gt;evd</code> computes faster at the expense of more
memory usage. <code>&lt;sy/he&gt;evx</code>, while still being faster than <code>&lt;sy/he&gt;ev</code>,
often performs worse than the rest except when very few eigenvalues are
requested for large arrays though there is still no performance guarantee.</p>
<p>For the generalized problem, normalization with respoect to the given
type argument::</p>
<div class="codehilite"><pre><span></span><code>    type 1 and 3 :      v.conj().T @ a @ v = w
    type 2       : inv(v).conj().T @ a @ inv(v) = w

    type 1 or 2  :      v.conj().T @ b @ v  = I
    type 3       : v.conj().T @ inv(b) @ v  = I
</code></pre></div>


<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

<p>Request only the eigenvalues</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>Request eigenvalues that are less than 10.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">34</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="o">-</span><span class="mi">34</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">34</span><span class="p">,</span> <span class="mi">29</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subset_by_value</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="mf">6.69199443e-07</span><span class="p">,</span> <span class="mf">9.11938152e+00</span><span class="p">])</span>
</code></pre></div>

<p>Request the largest second eigenvalue and its eigenvector</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">subset_by_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="mf">9.11938152</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># only a single column is returned</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="eigh_tridiagonal">eigh_tridiagonal<a class="headerlink" href="#eigh_tridiagonal" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigh_tridiagonal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh_tridiagonal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> and optionally right eigenvectors <code>v</code> of <code>a</code>::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>d : ndarray, shape (ndim,)</strong>
    The diagonal elements of the array.</p>
</li>
<li>
<p><strong>e : ndarray, shape (ndim-1,)</strong>
    The off-diagonal elements of the array.</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>tol : float</strong>
    The absolute tolerance to which each eigenvalue is required
    (only used when 'stebz' is the <code>lapack_driver</code>).
    An eigenvalue (or cluster) is considered to have converged if it
    lies in an interval of this width. If &lt;= 0. (default),
    the value <code>eps*|a|</code> is used where eps is the machine precision,
    and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.</p>
</li>
<li>
<p><strong>lapack_driver : str</strong>
    LAPACK function to use, can be 'auto', 'stemr', 'stebz', 'sterf',
    or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
    and 'stebz' otherwise. When 'stebz' is used to find the eigenvalues and
    <code>eigvals_only=False</code>, then a second LAPACK call (to <code>?STEIN</code>) is
    used to find the corresponding eigenvectors. 'sterf' can only be
    used when <code>eigvals_only=True</code> and <code>select='a'</code>. 'stev' can only
    be used when <code>select='a'</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</p>
</li>
<li>
<p><strong>v : (M, M) ndarray</strong>
    The normalized eigenvector corresponding to the eigenvalue <code>w[i]</code> is
    the column <code>v[:,i]</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function makes use of LAPACK <code>S/DSTEMR</code> routines.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh_tridiagonal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh_tridiagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="eigvals">eigvals<a class="headerlink" href="#eigvals" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvals</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<div class="codehilite"><pre><span></span><code>a   vr[:,i] = w[i]        b   vr[:,i]
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    Right-hand side matrix in a generalized eigenvalue problem.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities
    or NaNs.</p>
</li>
<li>
<p><strong>homogeneous_eigvals : bool, optional</strong>
    If True, return the eigenvalues in homogeneous coordinates.
    In this case <code>w</code> is a (2, M) array so that::</p>
<div class="codehilite"><pre><span></span><code>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]
</code></pre></div>


<p>Default is False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) or (2, M) double or complex ndarray</strong>
    The eigenvalues, each repeated according to its multiplicity
    but not in any specific order. The shape is (M,) unless
    <code>homogeneous_eigvals=True</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig : eigenvalues and right eigenvectors of general arrays.</strong></p>
</li>
<li>
<p><strong>eigvalsh : eigenvalues of symmetric or Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">homogeneous_eigvals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">8.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eigvals_banded">eigvals_banded<a class="headerlink" href="#eigvals_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvals_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve real symmetric or complex Hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w of a::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a_band : (u+1, M) array_like</strong>
    The bands of the M by M matrix a.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>overwrite_a_band : bool, optional</strong>
    Discard data in a_band (may enhance performance)</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvals_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvals_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.26200532</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">,</span> <span class="mf">12.53965359</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigvalsh">eigvalsh<a class="headerlink" href="#eigvalsh" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvalsh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_value</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves a standard or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues array <code>w</code> of array <code>a</code>, where <code>b</code> is positive
definite such that for every eigenvalue λ (i-th entry of w) and its
eigenvector vi (i-th column of v) satisfies::</p>
<div class="codehilite"><pre><span></span><code>              a @ vi = λ * b @ vi
vi.conj().T @ a @ vi = λ
vi.conj().T @ b @ vi = 1
</code></pre></div>


<p>In the standard problem, b is assumed to be the identity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex Hermitian or real symmetric matrix whose eigenvalues will
    be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code> and, if applicable, <code>b</code>. (Default: lower)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)</p>
</li>
<li>
<p><strong>subset_by_index : iterable, optional</strong>
    If provided, this two-element iterable defines the start and the end
    indices of the desired eigenvalues (ascending order and 0-indexed).
    To return only the second smallest to fifth smallest eigenvalues,
    <code>[1, 4]</code> is used. <code>[n-3, n-1]</code> returns the largest three. Only
    available with 'evr', 'evx', and 'gvx' drivers. The entries are
    directly converted to integers via <code>int()</code>.</p>
</li>
<li>
<p><strong>subset_by_value : iterable, optional</strong>
    If provided, this two-element iterable defines the half-open interval
    <code>(a, b]</code> that, if any, only the eigenvalues between these values
    are returned. Only available with 'evr', 'evx', and 'gvx' drivers. Use
    <code>np.inf</code> for the unconstrained ends.</p>
</li>
<li>
<p><strong>driver: str, optional</strong>
    Defines which LAPACK driver should be used. Valid options are 'ev',
    'evd', 'evr', 'evx' for standard problems and 'gv', 'gvd', 'gvx' for
    generalized (where b is not None) problems. See the Notes section of
    <code>scipy.linalg.eigh</code>.</p>
</li>
<li>
<p><strong>type : int, optional</strong>
    For the generalized problems, this keyword specifies the problem type
    to be solved for <code>w</code> and <code>v</code> (only takes 1, 2, 3 as possible</p>
</li>
<li>
<p><strong>inputs)::</strong></p>
<div class="codehilite"><pre><span></span><code>1 =&gt;     a @ v = w @ b @ v
2 =&gt; a @ b @ v = w @ v
3 =&gt; b @ a @ v = w @ v
</code></pre></div>


<p>This keyword is ignored for standard problems.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in <code>b</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>turbo : bool, optional</strong>
    <em>Deprecated by <code>driver=gvd</code> option</em>. Has no significant effect for
    eigenvalue computations since no eigenvectors are requested.</p>
<p>..Deprecated in v1.5.0</p>
</li>
<li>
<p><strong>eigvals : tuple (lo, hi), optional</strong>
    <em>Deprecated by <code>subset_by_index</code> keyword</em>. Indexes of the smallest
    and largest (in ascending order) eigenvalues and corresponding
    eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1. If omitted, all
    eigenvalues and eigenvectors are returned.</p>
<p>.. Deprecated in v1.5.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (N,) ndarray</strong>
    The <code>N</code> (<code>1&lt;=N&lt;=M</code>) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge, an error occurred, or
    b matrix is not definite positive. Note that if input matrices are
    not symmetric or Hermitian, no error will be reported but results will
    be wrong.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function does not check the input array for being Hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<p>This function serves as a one-liner shorthand for <code>scipy.linalg.eigh</code> with
the option <code>eigvals_only=True</code> to get the eigenvalues and not the
eigenvectors. Here it is kept as a legacy convenience. It might be
beneficial to use the main function to have full control and to be a bit
more pythonic.</p>
<h4>Examples</h4>
<p>For more examples see <code>scipy.linalg.eigh</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvalsh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvalsh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">3.74637491</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76263923</span><span class="p">,</span>  <span class="mf">6.08502336</span><span class="p">,</span> <span class="mf">12.42399079</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigvalsh_tridiagonal">eigvalsh_tridiagonal<a class="headerlink" href="#eigvalsh_tridiagonal" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvalsh_tridiagonal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh_tridiagonal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> of <code>a</code>::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>d : ndarray, shape (ndim,)</strong>
    The diagonal elements of the array.</p>
</li>
<li>
<p><strong>e : ndarray, shape (ndim-1,)</strong>
    The off-diagonal elements of the array.</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>tol : float</strong>
    The absolute tolerance to which each eigenvalue is required
    (only used when <code>lapack_driver='stebz'</code>).
    An eigenvalue (or cluster) is considered to have converged if it
    lies in an interval of this width. If &lt;= 0. (default),
    the value <code>eps*|a|</code> is used where eps is the machine precision,
    and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.</p>
</li>
<li>
<p><strong>lapack_driver : str</strong>
    LAPACK function to use, can be 'auto', 'stemr', 'stebz',  'sterf',
    or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
    and 'stebz' otherwise. 'sterf' and 'stev' can only be used when
    <code>select='a'</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvalsh_tridiagonal</span><span class="p">,</span> <span class="n">eigvalsh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvalsh_tridiagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">eigvalsh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># Verify with other eigenvalue routines</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">w2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="einsum">einsum<a class="headerlink" href="#einsum" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function einsum</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">einsum</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">optimize</span><span class="o">:[`</span><span class="nc">Optimal</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Greedy</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>einsum(subscripts, *operands, out=None, dtype=None, order='K',
       casting='safe', optimize=False)</p>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In <em>implicit</em> mode <code>einsum</code> computes these values.</p>
<p>In <em>explicit</em> mode, <code>einsum</code> provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.</p>
<p>See the notes and examples for clarification.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>subscripts : str</strong>
    Specifies the subscripts for summation as comma separated list of
    subscript labels. An implicit (classical Einstein summation)
    calculation is performed unless the explicit indicator '-&gt;' is
    included as well as subscript labels of the precise output form.</p>
</li>
<li>
<p><strong>operands : list of array_like</strong>
    These are the arrays for the operation.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    If provided, the calculation is done into this array.</p>
</li>
<li>
<p><strong>dtype : {data-type, None}, optional</strong>
    If provided, forces the calculation to use the data type specified.
    Note that you may have to also give a more liberal <code>casting</code>
    parameter to allow the conversions. Default is None.</p>
</li>
<li>
<p><strong>order : {'C', 'F', 'A', 'K'}, optional</strong>
    Controls the memory layout of the output. 'C' means it should
    be C contiguous. 'F' means it should be Fortran contiguous,
    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
    'K' means it should be as close to the layout as the inputs as
    is possible, including arbitrarily permuted axes.
    Default is 'K'.</p>
</li>
<li>
<p><strong>casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional</strong>
    Controls what kind of data casting may occur.  Setting this to
    'unsafe' is not recommended, as it can adversely affect accumulations.</p>
<ul>
<li>'no' means the data types should not be cast at all.</li>
<li>'equiv' means only byte-order changes are allowed.</li>
<li>'safe' means only casts which can preserve values are allowed.</li>
<li>'same_kind' means only safe casts or casts within a kind,
    like float64 to float32, are allowed.</li>
<li>'unsafe' means any data conversions may be done.</li>
</ul>
<p>Default is 'safe'.</p>
</li>
<li>
<p><strong>optimize : {False, True, 'greedy', 'optimal'}, optional</strong>
    Controls if intermediate optimization should occur. No optimization
    will occur if False and True will default to the 'greedy' algorithm.
    Also accepts an explicit contraction list from the <code>np.einsum_path</code>
    function. See <code>np.einsum_path</code> for more details. Defaults to False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>output : ndarray</strong>
    The calculation based on the Einstein summation convention.</li>
</ul>
<h4>See Also</h4>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</p>
<h4>Notes</h4>
<p>.. versionadded:: 1.6.0</p>
<p>The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. <code>einsum</code>
provides a succinct way of representing these.</p>
<p>A non-exhaustive list of these operations,
which can be computed by <code>einsum</code>, is shown below along with examples:</p>
<ul>
<li>Trace of an array, :py:func:<code>numpy.trace</code>.</li>
<li>Return a diagonal, :py:func:<code>numpy.diag</code>.</li>
<li>Array axis summations, :py:func:<code>numpy.sum</code>.</li>
<li>Transpositions and permutations, :py:func:<code>numpy.transpose</code>.</li>
<li>Matrix multiplication and dot product, :py:func:<code>numpy.matmul</code> :py:func:<code>numpy.dot</code>.</li>
<li>Vector inner and outer products, :py:func:<code>numpy.inner</code> :py:func:<code>numpy.outer</code>.</li>
<li>Broadcasting, element-wise and scalar multiplication, :py:func:<code>numpy.multiply</code>.</li>
<li>Tensor contractions, :py:func:<code>numpy.tensordot</code>.</li>
<li>Chained array operations, in efficient calculation order, :py:func:<code>numpy.einsum_path</code>.</li>
</ul>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so <code>np.einsum('i,i', a, b)</code>
is equivalent to :py:func:<code>np.inner(a,b) &lt;numpy.inner&gt;</code>. If a label
appears only once, it is not summed, so <code>np.einsum('i', a)</code> produces a
view of <code>a</code> with no changes. A further example <code>np.einsum('ij,jk', a, b)</code>
describes traditional matrix multiplication and is equivalent to
:py:func:<code>np.matmul(a,b) &lt;numpy.matmul&gt;</code>. Repeated subscript labels in one
operand take the diagonal. For example, <code>np.einsum('ii', a)</code> is equivalent</p>
<ul>
<li><strong>to :py:func:<code>np.trace(a) &lt;numpy.trace&gt;</code>.</strong></li>
</ul>
<p>In <em>implicit mode</em>, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that <code>np.einsum('ij', a)</code> doesn't affect a 2D array, while
<code>np.einsum('ji', a)</code> takes its transpose. Additionally,
<code>np.einsum('ij,jk', a, b)</code> returns a matrix multiplication, while,
<code>np.einsum('ij,jh', a, b)</code> returns the transpose of the
multiplication since subscript 'h' precedes subscript 'i'.</p>
<p>In <em>explicit mode</em> the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier '-&gt;' as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
<code>np.einsum('i-&gt;', a)</code> is like :py:func:<code>np.sum(a, axis=-1) &lt;numpy.sum&gt;</code>,
and <code>np.einsum('ii-&gt;i', a)</code> is like :py:func:<code>np.diag(a) &lt;numpy.diag&gt;</code>.
The difference is that <code>einsum</code> does not allow broadcasting by default.
Additionally <code>np.einsum('ij,jh-&gt;ih', a, b)</code> directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code>np.einsum('...ii-&gt;...i', a)</code>.
To take the trace along the first and last axes,
you can do <code>np.einsum('i...i', a)</code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
<code>np.einsum('ij...,jk...-&gt;ik...', a, b)</code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code>np.einsum('ii-&gt;i', a)</code>
produces a view (changed in version 1.10.0).</p>
<p><code>einsum</code> also provides an alternative way to provide the subscripts
and operands as <code>einsum(op0, sublist0, op1, sublist1, ..., [sublistout])</code>.
If the output shape is not provided in this format <code>einsum</code> will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding <code>einsum</code> calls with the two
parameter methods.</p>
<p>.. versionadded:: 1.10.0</p>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code>np.einsum('ijk...-&gt;kji...', a)</code> will now
have the same effect as :py:func:<code>np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;</code>
and <code>np.einsum('ii-&gt;i', a)</code> will return a writeable view of the diagonal
of a 2D array.</p>
<p>.. versionadded:: 1.12.0</p>
<p>Added the <code>optimize</code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>Typically a 'greedy' algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases 'optimal'
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.</p>
<ul>
<li><strong>See :py:func:<code>numpy.einsum_path</code> for more details.</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<p>Trace of a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="mi">60</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">60</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">60</span>
</code></pre></div>

<p>Extract the diagonal (requires explicit form):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">])</span>
</code></pre></div>

<p>Sum over an axis (requires explicit form):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">85</span><span class="p">,</span> <span class="mi">110</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">85</span><span class="p">,</span> <span class="mi">110</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">85</span><span class="p">,</span> <span class="mi">110</span><span class="p">])</span>
</code></pre></div>

<p>For higher dimensional arrays summing a single axis can be done with ellipsis:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j-&gt;...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">85</span><span class="p">,</span> <span class="mi">110</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">35</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>  <span class="mi">85</span><span class="p">,</span> <span class="mi">110</span><span class="p">])</span>
</code></pre></div>

<p>Compute a matrix transpose, or reorder any number of axes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij-&gt;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
</code></pre></div>

<p>Vector inner products:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">30</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">30</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="mi">30</span>
</code></pre></div>

<p>Matrix vector multiplication:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">230</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">230</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">230</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">230</span><span class="p">])</span>
</code></pre></div>

<p>Broadcasting and scalar multiplication:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;..., ...&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;,ij&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">]])</span>
</code></pre></div>

<p>Vector outer product:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>

<p>Tensor contraction:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jil-&gt;kl&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">4400.</span><span class="p">,</span> <span class="mf">4730.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4532.</span><span class="p">,</span> <span class="mf">4874.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4664.</span><span class="p">,</span> <span class="mf">5018.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4796.</span><span class="p">,</span> <span class="mf">5162.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4928.</span><span class="p">,</span> <span class="mf">5306.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">4400.</span><span class="p">,</span> <span class="mf">4730.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4532.</span><span class="p">,</span> <span class="mf">4874.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4664.</span><span class="p">,</span> <span class="mf">5018.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4796.</span><span class="p">,</span> <span class="mf">5162.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4928.</span><span class="p">,</span> <span class="mf">5306.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">4400.</span><span class="p">,</span> <span class="mf">4730.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4532.</span><span class="p">,</span> <span class="mf">4874.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4664.</span><span class="p">,</span> <span class="mf">5018.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4796.</span><span class="p">,</span> <span class="mf">5162.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">4928.</span><span class="p">,</span> <span class="mf">5306.</span><span class="p">]])</span>
</code></pre></div>

<p>Writeable returned arrays (since version 1.10.0):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)[:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<p>Example of ellipsis use:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,jk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">94</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,...k-&gt;i...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">94</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;k...,jk&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">64</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">94</span><span class="p">]])</span>
</code></pre></div>

<p>Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a 'greedy' path or pre-computing the
'optimal' path and repeatedly applying it, using an
<code>einsum_path</code> insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div>

<p>Basic <code>einsum</code>: ~1520ms  (benchmarked on 3.1GHz Intel i5.)</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
</code></pre></div>

<p>Sub-optimal <code>einsum</code> (due to repeated path calculation time): ~330ms</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Greedy <code>einsum</code> (faster optimal path approximation): ~160ms</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Optimal <code>einsum</code> (best usage pattern in some use cases): ~110ms</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="empty">empty<a class="headerlink" href="#empty" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function empty</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">empty</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">shape</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_int</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>empty(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, without initializing entries.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>shape : int or tuple of int</strong>
    Shape of the empty array, e.g., <code>(2, 3)</code> or <code>2</code>.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    Desired output data-type for the array, e.g, <code>numpy.int8</code>. Default is
    <code>numpy.float64</code>.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional, default: 'C'</strong>
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array of uninitialized (arbitrary) data of the given shape, dtype, and
    order.  Object arrays will be initialized to None.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>empty_like : Return an empty array with shape and type of input.</strong></p>
</li>
<li>
<p><strong>ones : Return a new array setting values to one.</strong></p>
</li>
<li>
<p><strong>zeros : Return a new array setting values to zero.</strong></p>
</li>
<li>
<p><strong>full : Return a new array of given shape filled with value.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p><code>empty</code>, unlike <code>zeros</code>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">9.74499359e+001</span><span class="p">,</span>   <span class="mf">6.69583040e-309</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">2.13182611e-314</span><span class="p">,</span>   <span class="mf">3.06959433e-309</span><span class="p">]])</span>         <span class="c1">#uninitialized</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1073741821</span><span class="p">,</span> <span class="o">-</span><span class="mi">1067949133</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mi">496041986</span><span class="p">,</span>    <span class="mi">19249760</span><span class="p">]])</span>                     <span class="c1">#uninitialized</span>
</code></pre></div>

</details>
<h3 id="eye">eye<a class="headerlink" href="#eye" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eye</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eye</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>N : int</strong>
  Number of rows in the output.</p>
</li>
<li>
<p><strong>M : int, optional</strong>
  Number of columns in the output. If None, defaults to <code>N</code>.</p>
</li>
<li>
<p><strong>k : int, optional</strong>
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
  Data-type of the returned array.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.</p>
<p>.. versionadded:: 1.14.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>I : ndarray of shape (N,M)</strong>
  An array where all elements are equal to zero, except for the <code>k</code>-th
  diagonal, whose values are equal to one.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>identity : (almost) equivalent function</strong></p>
</li>
<li>
<p><strong>diag : diagonal 2-D array from a 1-D array specified by the user.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="flatnonzero">flatnonzero<a class="headerlink" href="#flatnonzero" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function flatnonzero</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">flatnonzero</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return indices that are non-zero in the flattened version of a.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : array_like</strong>
    Input data.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>res : ndarray</strong>
    Output array, containing the indices of the elements of <code>a.ravel()</code>
    that are non-zero.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>nonzero : Return the indices of the non-zero elements of the input array.</strong></p>
</li>
<li>
<p><strong>ravel : Return a 1-D array containing the elements of the input array.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>

<p>Use the indices of the non-zero elements as an index array to extract
these elements:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_1">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="hessenberg">hessenberg<a class="headerlink" href="#hessenberg" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hessenberg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hessenberg</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">calc_q</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Hessenberg form of a matrix.</p>
<p>The Hessenberg decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = Q H Q^H
</code></pre></div>


<p>where <code>Q</code> is unitary/orthogonal and <code>H</code> has only zero elements below
the first sub-diagonal.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to bring into Hessenberg form.</p>
</li>
<li>
<p><strong>calc_q : bool, optional</strong>
    Whether to compute the transformation matrix.  Default is False.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>H : (M, M) ndarray</strong>
    Hessenberg form of <code>a</code>.</p>
</li>
<li>
<p><strong>Q : (M, M) ndarray</strong>
    Unitary/orthogonal similarity transformation matrix <code>A = Q H Q^H</code>.
    Only returned if <code>calc_q=True</code>.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hessenberg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">hessenberg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">calc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">11.65843866</span><span class="p">,</span>   <span class="mf">1.42005301</span><span class="p">,</span>   <span class="mf">0.25349066</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">9.94987437</span><span class="p">,</span>  <span class="mf">14.53535354</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.31022304</span><span class="p">,</span>   <span class="mf">2.43081618</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">1.83299243</span><span class="p">,</span>   <span class="mf">0.38969961</span><span class="p">,</span>  <span class="o">-</span><span class="mf">0.51527034</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">3.83189513</span><span class="p">,</span>   <span class="mf">1.07494686</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Q</span> <span class="o">@</span> <span class="n">H</span> <span class="o">@</span> <span class="n">Q</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="iscomplex">iscomplex<a class="headerlink" href="#iscomplex" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function iscomplex</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iscomplex</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a bool array, where True if input element is complex.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<h4>Parameters</h4>
<ul>
<li><strong>x : array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray of bools</strong>
    Output array.</li>
</ul>
<h4>See Also</h4>
<p>isreal</p>
<ul>
<li><strong>iscomplexobj : Return True if x is a complex type or an array of complex</strong>
               numbers.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="iscomplexobj">iscomplexobj<a class="headerlink" href="#iscomplexobj" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function iscomplexobj</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">iscomplexobj</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">bool</span>
</code></pre></div>

<p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, <code>iscomplexobj</code> evaluates to True.</p>
<h4>Parameters</h4>
<ul>
<li><strong>x : any</strong>
    The input can be of any type and shape.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>iscomplexobj : bool</strong>
    The return value, True if <code>x</code> is of a complex type or has at least
    one complex element.</li>
</ul>
<h4>See Also</h4>
<p>isrealobj, iscomplex</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="isfinite">isfinite<a class="headerlink" href="#isfinite" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function isfinite</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isfinite</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input values.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : ndarray, bool</strong>
    True where <code>x</code> is not positive infinity, negative infinity,
    or NaN; false otherwise.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>See Also</h4>
<p>isinf, isneginf, isposinf, isnan</p>
<h4>Notes</h4>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <code>x</code> is a scalar input, or if
first and second arguments have different shapes.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="nonzero">nonzero<a class="headerlink" href="#nonzero" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function nonzero</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">nonzero</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <code>a</code>,
containing the indices of the non-zero elements in that
dimension. The values in <code>a</code> are always tested and returned in
row-major, C-style order.</p>
<p>To group the indices by element, rather than dimension, use <code>argwhere</code>,
which returns a row for each non-zero element.</p>
<p>.. note::</p>
<p>When called on a zero-d array or scalar, <code>nonzero(a)</code> is treated
   as <code>nonzero(atleast1d(a))</code>.</p>
<p>.. deprecated:: 1.17.0</p>
<div class="codehilite"><pre><span></span><code>  Use `atleast1d` explicitly if this behavior is deliberate.
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li><strong>a : array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tuple_of_arrays : tuple</strong>
    Indices of elements that are non-zero.</li>
</ul>
<h4>See Also</h4>
<p>flatnonzero :
    Return indices that are non-zero in the flattened version of the input
    array.
ndarray.nonzero :
    Equivalent ndarray method.
count_nonzero :
    Counts the number of non-zero elements in the input array.</p>
<h4>Notes</h4>
<p>While the nonzero values can be obtained with <code>a[nonzero(a)]</code>, it is
recommended to use <code>x[x.astype(bool)]</code> or <code>x[x != 0]</code> instead, which
will correctly handle 0-d arrays.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

<p>A common use for <code>nonzero</code> is to find the indices of an array, where
a condition is True.  Given an array <code>a</code>, the condition <code>a</code> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <code>a</code> where the condition is true.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="n">array</span><span class="p">([[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
       <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
       <span class="p">[</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
</code></pre></div>

<p>Using this result to index <code>a</code> is equivalent to using the mask directly:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)]</span>
<span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># prefer this spelling</span>
<span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
</code></pre></div>

<p><code>nonzero</code> can also be called as a method of the array.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
</code></pre></div>

</details>
<h3 id="norm">norm<a class="headerlink" href="#norm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function norm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fro</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M,) or (M, N) array_like</strong>
    Input array. If <code>axis</code> is None, <code>a</code> must be 1D or 2D.</p>
</li>
<li>
<p><strong>ord : {non-zero int, inf, -inf, 'fro'}, optional</strong>
    Order of the norm (see table under <code>Notes</code>). inf means NumPy's
    <code>inf</code> object</p>
</li>
<li>
<p><strong>axis : {int, 2-tuple of ints, None}, optional</strong>
    If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
    compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
    is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original <code>a</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>n : float or ndarray</strong>
    Norm of the matrix or vector(s).</li>
</ul>
<h4>Notes</h4>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<div class="codehilite"><pre><span></span><code>:math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
</code></pre></div>


<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h4>References</h4>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mf">4.6566128774142013e-010</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.3484692283495345</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">1.8570331885190563e-016</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">5.8480354764257312</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</code></pre></div>

</details>
<h3 id="zeros">zeros<a class="headerlink" href="#zeros" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function zeros</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>shape : int or tuple of ints</strong>
    Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
    <code>numpy.float64</code>.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional, default: 'C'</strong>
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array of zeros with the given shape, dtype, and order.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>zeros_like : Return an array of zeros with shape and type of input.</strong></p>
</li>
<li>
<p><strong>empty : Return a new uninitialized array.</strong></p>
</li>
<li>
<p><strong>ones : Return a new array setting values to one.</strong></p>
</li>
<li>
<p><strong>full : Return a new array of given shape filled with value.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
</code></pre></div>

</details>
<h2 id="decomp_cholesky">Decomp_cholesky<a class="headerlink" href="#decomp_cholesky" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_cholesky</code> wraps Python module <code>scipy.linalg.decomp_cholesky</code>.</p>
<h3 id="asarray_1">asarray<a class="headerlink" href="#asarray_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If <code>a</code> is a
    subclass of ndarray, a base class ndarray is returned.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>asarray_chkfinite : Similar function which checks input for NaNs and Infs.</strong></p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>

<p>Existing arrays are not copied:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
</code></pre></div>

<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="asarray_chkfinite">asarray_chkfinite<a class="headerlink" href="#asarray_chkfinite" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray_chkfinite</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
     Whether to use row-major (C-style) or
     column-major (Fortran-style) memory representation.
     Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
    class ndarray is returned.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asarray : Create and array.</strong></p>
</li>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
</code></pre></div>

<p>Raises ValueError if array_like contains Nans or Infs.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">try</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">...</span> <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="ne">ValueError</span>
</code></pre></div>

</details>
<h3 id="atleast_2d_1">atleast_2d<a class="headerlink" href="#atleast_2d_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function atleast_2d</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">atleast_2d</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>View inputs as arrays with at least two dimensions.</p>
<h4>Parameters</h4>
<p>arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.</p>
<h4>Returns</h4>
<p>res, res2, ... : ndarray
    An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.</p>
<h4>See Also</h4>
<p>atleast_1d, atleast_3d</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="p">[</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])]</span>
</code></pre></div>

</details>
<h3 id="cho_factor">cho_factor<a class="headerlink" href="#cho_factor" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_factor</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_factor</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix, to use in cho_solve</p>
<p>Returns a matrix containing the Cholesky decomposition,
<code>A = L L*</code> or <code>A = U* U</code> of a Hermitian positive-definite matrix <code>a</code>.
The return value can be directly used as the first parameter to cho_solve.</p>
<p>.. warning::
    The returned matrix also contains random data in the entries not
    used by the Cholesky decomposition. If you need to zero these
    entries, use the function <code>cholesky</code> instead.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether to compute the upper or lower triangular Cholesky factorization
    (Default: upper-triangular)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : (M, M) ndarray</strong>
    Matrix whose upper or lower triangle contains the Cholesky factor
    of <code>a</code>. Other parts of the matrix contain random data.</p>
</li>
<li>
<p><strong>lower : bool</strong>
    Flag indicating whether the factor is in the lower or upper triangle</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if decomposition fails.</p>
<h4>See also</h4>
<ul>
<li><strong>cho_solve : Solve a linear set equations using the Cholesky factorization</strong>
            of a matrix.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cho_factor</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">0.33333333</span><span class="p">,</span> <span class="mf">1.66666667</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">2.44948974</span><span class="p">,</span> <span class="mf">1.90515869</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.27216553</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span>        <span class="p">,</span> <span class="mf">5.</span>        <span class="p">,</span> <span class="mf">2.29330749</span><span class="p">,</span> <span class="mf">0.8559528</span> <span class="p">],</span>
       <span class="p">[</span><span class="mf">5.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span> <span class="mf">1.55418563</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span> <span class="n">triu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cho_solve">cho_solve<a class="headerlink" href="#cho_solve" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">c_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p>
<h4>Parameters</h4>
<p>(c, lower) : tuple, (array, bool)
    Cholesky factorization of a, as given by cho_factor</p>
<ul>
<li>
<p><strong>b : array</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in b (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    The solution to the system A x = b</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cho_factor : Cholesky factorization of a matrix</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cho_factor</span><span class="p">,</span> <span class="n">cho_solve</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">low</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cho_solve_banded">cho_solve_banded<a class="headerlink" href="#cho_solve_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_solve_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">cb_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations <code>A x = b</code>, given the Cholesky factorization of
the banded hermitian <code>A</code>.</p>
<h4>Parameters</h4>
<p>(cb, lower) : tuple, (ndarray, bool)
    <code>cb</code> is the Cholesky factorization of A, as given by cholesky_banded.
    <code>lower</code> must be the same value that was given to cholesky_banded.</p>
<ul>
<li>
<p><strong>b : array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    If True, the function will overwrite the values in <code>b</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    The solution to the system A x = b</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cholesky_banded : Cholesky factorization of a banded matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky_banded</span><span class="p">,</span> <span class="n">cho_solve_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cholesky_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cho_solve_banded</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cholesky">cholesky<a class="headerlink" href="#cholesky" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cholesky</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix.</p>
<p>Returns the Cholesky decomposition, :math:<code>A = L L^*</code> or
:math:<code>A = U^* U</code> of a Hermitian positive-definite matrix A.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether to compute the upper- or lower-triangular Cholesky
    factorization.  Default is upper-triangular.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (M, M) ndarray</strong>
    Upper- or lower-triangular Cholesky factor of <code>a</code>.</li>
</ul>
<h4>Raises</h4>
<ul>
<li><strong>LinAlgError : if decomposition fails.</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">],[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">@</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">-</span><span class="mf">2.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">5.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cholesky_banded">cholesky_banded<a class="headerlink" href="#cholesky_banded" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cholesky_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cholesky decompose a banded Hermitian positive-definite matrix</p>
<p>The matrix a is stored in ab either in lower-diagonal or upper-
diagonal ordered form::</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>Example of ab (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>ab : (u + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in ab (may enhance performance)</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (u + 1, M) ndarray</strong>
    Cholesky factorization of a, in the same banded format as ab</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cho_solve_banded : Solve a linear set equations, given the Cholesky factorization</strong>
            of a banded hermitian.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">allclose</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">diag</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cholesky_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_2">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h2 id="decomp_lu">Decomp_lu<a class="headerlink" href="#decomp_lu" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_lu</code> wraps Python module <code>scipy.linalg.decomp_lu</code>.</p>
<h3 id="asarray_2">asarray<a class="headerlink" href="#asarray_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If <code>a</code> is a
    subclass of ndarray, a base class ndarray is returned.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>asarray_chkfinite : Similar function which checks input for NaNs and Infs.</strong></p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>

<p>Existing arrays are not copied:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
</code></pre></div>

<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="asarray_chkfinite_1">asarray_chkfinite<a class="headerlink" href="#asarray_chkfinite_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray_chkfinite</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
     Whether to use row-major (C-style) or
     column-major (Fortran-style) memory representation.
     Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
    class ndarray is returned.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asarray : Create and array.</strong></p>
</li>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
</code></pre></div>

<p>Raises ValueError if array_like contains Nans or Infs.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">try</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">...</span> <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="ne">ValueError</span>
</code></pre></div>

</details>
<h3 id="get_flinalg_funcs_1">get_flinalg_funcs<a class="headerlink" href="#get_flinalg_funcs_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_flinalg_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. Arrays are used to determine optimal prefix.</p>
</details>
<h3 id="get_lapack_funcs_3">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="lu">lu<a class="headerlink" href="#lu" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">permute_l</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = P L U
</code></pre></div>


<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Array to decompose</p>
</li>
<li>
<p><strong>permute_l : bool, optional</strong>
    Perform the multiplication P*L (Default: do not permute)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<p><strong>(If permute_l == False)</strong></p>
<ul>
<li>
<p><strong>p : (M, M) ndarray</strong>
    Permutation matrix</p>
</li>
<li>
<p><strong>l : (M, K) ndarray</strong>
    Lower triangular or trapezoidal matrix with unit diagonal.
    K = min(M, N)</p>
</li>
<li>
<p><strong>u : (K, N) ndarray</strong>
    Upper triangular or trapezoidal matrix</p>
</li>
</ul>
<p><strong>(If permute_l == True)</strong></p>
<ul>
<li>
<p><strong>pl : (M, K) ndarray</strong>
    Permuted L matrix.
    K = min(M, N)</p>
</li>
<li>
<p><strong>u : (K, N) ndarray</strong>
    Upper triangular or trapezoidal matrix</p>
</li>
</ul>
<h4>Notes</h4>
<p>This is a LU factorization routine written for SciPy.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">lu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">p</span> <span class="o">@</span> <span class="n">l</span> <span class="o">@</span> <span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="lu_factor">lu_factor<a class="headerlink" href="#lu_factor" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu_factor</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = P L U
</code></pre></div>


<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to decompose</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in A (may increase performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>lu : (N, N) ndarray</strong>
    Matrix containing U in its upper triangle, and L in its lower triangle.
    The unit diagonal elements of L are not stored.</p>
</li>
<li>
<p><strong>piv : (N,) ndarray</strong>
    Pivot indices representing the permutation matrix P:
    row i of matrix was interchanged with row piv[i].</p>
</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>lu_solve : solve an equation system using the LU factorization of a matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu_factor</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span> <span class="o">=</span> <span class="n">lu_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">piv</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
</code></pre></div>

<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">piv_py</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">lu</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">piv_py</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span> <span class="o">@</span> <span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="lu_solve">lu_solve<a class="headerlink" href="#lu_solve" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu_solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h4>Parameters</h4>
<p>(lu, piv)
    Factorization of the coefficient matrix a, as given by lu_factor</p>
<ul>
<li>
<p><strong>b : array</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>trans : {0, 1, 2}, optional</strong>
    Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in b (may increase performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    Solution to the system</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>lu_factor : LU factorize a matrix</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu_factor</span><span class="p">,</span> <span class="n">lu_solve</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span> <span class="o">=</span> <span class="n">lu_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lu_solve</span><span class="p">((</span><span class="n">lu</span><span class="p">,</span> <span class="n">piv</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="warn_1">warn<a class="headerlink" href="#warn_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function warn</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">warn</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">category</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">stacklevel</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">source</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">message</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Issue a warning, or maybe ignore it or raise an exception.</p>
</details>
<h2 id="decomp_qr">Decomp_qr<a class="headerlink" href="#decomp_qr" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_qr</code> wraps Python module <code>scipy.linalg.decomp_qr</code>.</p>
<h3 id="get_lapack_funcs_4">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="qr">qr<a class="headerlink" href="#qr" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in <code>a</code> is overwritten (may improve performance if
    <code>overwrite_a</code> is set to True by reusing the existing input data
    structure rather than creating a new one.)</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.</p>
</li>
<li>
<p><strong>mode : {'full', 'r', 'economic', 'raw'}, optional</strong>
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes). The final option 'raw'
    (added in SciPy 0.11) makes the function return two matrices
    (Q, TAU) in the internal format used by LAPACK.</p>
</li>
<li>
<p><strong>pivoting : bool, optional</strong>
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition. If pivoting, compute the decomposition
    <code>A P = Q R</code> as above, but where P is chosen such that the diagonal
    of R is non-increasing.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>Q : float or complex ndarray</strong>
    Of shape (M, M), or (M, K) for <code>mode='economic'</code>. Not returned
    if <code>mode='r'</code>.</p>
</li>
<li>
<p><strong>R : float or complex ndarray</strong>
    Of shape (M, N), or (K, N) for <code>mode='economic'</code>. <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>P : int ndarray</strong>
    Of shape (N,) for <code>pivoting=True</code>. Not returned if
    <code>pivoting=False</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if decomposition fails</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q3</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q3</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r3</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q4</span><span class="p">,</span> <span class="n">r4</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">r4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">p4</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q4</span><span class="p">,</span> <span class="n">r4</span><span class="p">))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q4</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r4</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p4</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q5</span><span class="p">,</span> <span class="n">r5</span><span class="p">,</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q5</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r5</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p5</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
</code></pre></div>

</details>
<h3 id="qr_multiply">qr_multiply<a class="headerlink" href="#qr_multiply" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr_multiply</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_multiply</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">conjugate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_c</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the QR decomposition and multiply Q with a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular. Multiply Q with a vector or a matrix c.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N), array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>c : array_like</strong>
    Input array to be multiplied by <code>q</code>.</p>
</li>
<li>
<p><strong>mode : {'left', 'right'}, optional</strong>
    <code>Q @ c</code> is returned if mode is 'left', <code>c @ Q</code> is returned if
    mode is 'right'.
    The shape of c must be appropriate for the matrix multiplications,
    if mode is 'left', <code>min(a.shape) == c.shape[0]</code>,
    if mode is 'right', <code>a.shape[0] == c.shape[1]</code>.</p>
</li>
<li>
<p><strong>pivoting : bool, optional</strong>
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition, see the documentation of qr.</p>
</li>
<li>
<p><strong>conjugate : bool, optional</strong>
    Whether Q should be complex-conjugated. This might be faster
    than explicit conjugation.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in a is overwritten (may improve performance)</p>
</li>
<li>
<p><strong>overwrite_c : bool, optional</strong>
    Whether data in c is overwritten (may improve performance).
    If this is used, c must be big enough to keep the result,
    i.e. <code>c.shape[0]</code> = <code>a.shape[0]</code> if mode is 'left'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>CQ : ndarray</strong>
    The product of <code>Q</code> and <code>c</code>.</p>
</li>
<li>
<p><strong>R : (K, N), ndarray</strong>
    R array of the resulting QR factorization where <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>P : (N,) ndarray</strong>
    Integer pivot array. Only returned when <code>pivoting=True</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if QR decomposition fails.</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines <code>?GEQRF</code>, <code>?ORMQR</code>,
<code>?UNMQR</code>, and <code>?GEQP3</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">qr_multiply</span><span class="p">,</span> <span class="n">qr</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qc</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">piv1</span> <span class="o">=</span> <span class="n">qr_multiply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">pivoting</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qc</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r1</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span>            <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11022302e-16</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span>            <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">piv1</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q2</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">piv2</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q2</span> <span class="o">-</span> <span class="n">qc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="rq">rq<a class="headerlink" href="#rq" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function rq</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rq</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute RQ decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = R Q</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in a is overwritten (may improve performance)</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.</p>
</li>
<li>
<p><strong>mode : {'full', 'r', 'economic'}, optional</strong>
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>R : float or complex ndarray</strong>
    Of shape (M, N) or (M, K) for <code>mode='economic'</code>. <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>Q : float or complex ndarray</strong>
    Of shape (N, N) or (K, N) for <code>mode='economic'</code>. Not returned
    if <code>mode='r'</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If decomposition fails.</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,
sorgrq, dorgrq, cungrq and zungrq.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (K, N) and (M, K) instead
of (N,N) and (M,N), with <code>K=min(M,N)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="o">@</span> <span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r3</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r3</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">q3</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="safecall">safecall<a class="headerlink" href="#safecall" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function safecall</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">safecall</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="n">f</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">name</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Call a LAPACK routine, determining lwork automatically and handling
error return values</p>
</details>
<h2 id="decomp_schur">Decomp_schur<a class="headerlink" href="#decomp_schur" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_schur</code> wraps Python module <code>scipy.linalg.decomp_schur</code>.</p>
<h2 id="single">Single<a class="headerlink" href="#single" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_schur.​Single</code> wraps Python class <code>scipy.linalg.decomp_schur.single</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="getitem_1"><strong>getitem</strong><a class="headerlink" href="#getitem_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method <strong>getitem</strong></summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span>
  <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
</details>
<h3 id="newbyteorder">newbyteorder<a class="headerlink" href="#newbyteorder" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method newbyteorder</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h4>Parameters</h4>
<ul>
<li><strong>new_order : str, optional</strong>
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of <code>new_order</code> for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>new_dtype : dtype</strong>
    New <code>dtype</code> object with the given change to the byte order.</li>
</ul>
</details>
<h3 id="to_string_3">to_string<a class="headerlink" href="#to_string_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_3">show<a class="headerlink" href="#show_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_3">pp<a class="headerlink" href="#pp_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h3 id="array_1">array<a class="headerlink" href="#array_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function array</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="kt">array</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">copy</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">K</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">ndmin</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">object_</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>object : array_like</strong>
    An array, any object exposing the array interface, an object whose
    <strong>array</strong> method returns an array, or any (nested) sequence.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    The desired data-type for the array.  If not given, then the type will
    be determined as the minimum type required to hold the objects in the
    sequence.</p>
</li>
<li>
<p><strong>copy : bool, optional</strong>
    If true (default), then the object is copied.  Otherwise, a copy will
    only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,
    or if a copy is needed to satisfy any of the other requirements
    (<code>dtype</code>, <code>order</code>, etc.).</p>
</li>
<li>
<p><strong>order : {'K', 'A', 'C', 'F'}, optional</strong>
    Specify the memory layout of the array. If object is not an array, the
    newly created array will be in C order (row major) unless 'F' is
    specified, in which case it will be in Fortran order (column major).
    If object is an array the following holds.</p>
<p>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================</p>
<p>When <code>copy=False</code> and a copy is made for other reasons, the result is
the same as if <code>copy=True</code>, with some exceptions for <code>A</code>, see the
Notes section. The default order is 'K'.</p>
</li>
<li>
<p><strong>subok : bool, optional</strong>
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).</p>
</li>
<li>
<p><strong>ndmin : int, optional</strong>
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    An array object satisfying the specified requirements.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>empty_like : Return an empty array with shape and type of input.</strong></p>
</li>
<li>
<p><strong>ones_like : Return an array of ones with shape and type of input.</strong></p>
</li>
<li>
<p><strong>zeros_like : Return an array of zeros with shape and type of input.</strong></p>
</li>
<li>
<p><strong>full_like : Return a new array with shape of input filled with value.</strong></p>
</li>
<li>
<p><strong>empty : Return a new uninitialized array.</strong></p>
</li>
<li>
<p><strong>ones : Return a new array setting values to one.</strong></p>
</li>
<li>
<p><strong>zeros : Return a new array setting values to zero.</strong></p>
</li>
<li>
<p><strong>full : Return a new array of given shape filled with value.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>When order is 'A' and <code>object</code> is an array in neither 'C' nor 'F' order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily 'C' as expected. This is likely a bug.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div>

<p>Upcasting:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</code></pre></div>

<p>More than one dimension:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<p>Minimum dimensions 2:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div>

<p>Type provided:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>Data-type consisting of more than one element:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</code></pre></div>

<p>Creating an array from sub-classes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="asarray_3">asarray<a class="headerlink" href="#asarray_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If <code>a</code> is a
    subclass of ndarray, a base class ndarray is returned.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>asarray_chkfinite : Similar function which checks input for NaNs and Infs.</strong></p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>

<p>Existing arrays are not copied:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
</code></pre></div>

<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="asarray_chkfinite_2">asarray_chkfinite<a class="headerlink" href="#asarray_chkfinite_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function asarray_chkfinite</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">asarray_chkfinite</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert the input to an array, checking for NaNs or Infs.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    By default, the data-type is inferred from the input data.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional</strong>
     Whether to use row-major (C-style) or
     column-major (Fortran-style) memory representation.
     Defaults to 'C'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array interpretation of <code>a</code>.  No copy is performed if the input
    is already an ndarray.  If <code>a</code> is a subclass of ndarray, a base
    class ndarray is returned.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>asarray : Create and array.</strong></p>
</li>
<li>
<p><strong>asanyarray : Similar function which passes through subclasses.</strong></p>
</li>
<li>
<p><strong>ascontiguousarray : Convert input to a contiguous array.</strong></p>
</li>
<li>
<p><strong>asfarray : Convert input to a floating point ndarray.</strong></p>
</li>
<li>
<p><strong>asfortranarray : Convert input to an ndarray with column-major</strong>
                 memory order.</p>
</li>
<li>
<p><strong>fromiter : Create an array from an iterator.</strong></p>
</li>
<li>
<p><strong>fromfunction : Construct an array by executing a function on grid</strong>
               positions.</p>
</li>
</ul>
<h4>Examples</h4>
<p>Convert a list into an array.  If all elements are finite
<code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
</code></pre></div>

<p>Raises ValueError if array_like contains Nans or Infs.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">try</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">...</span> <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="ne">ValueError</span>
</code></pre></div>

</details>
<h3 id="eigvals_1">eigvals<a class="headerlink" href="#eigvals_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvals</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<div class="codehilite"><pre><span></span><code>a   vr[:,i] = w[i]        b   vr[:,i]
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    Right-hand side matrix in a generalized eigenvalue problem.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities
    or NaNs.</p>
</li>
<li>
<p><strong>homogeneous_eigvals : bool, optional</strong>
    If True, return the eigenvalues in homogeneous coordinates.
    In this case <code>w</code> is a (2, M) array so that::</p>
<div class="codehilite"><pre><span></span><code>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]
</code></pre></div>


<p>Default is False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) or (2, M) double or complex ndarray</strong>
    The eigenvalues, each repeated according to its multiplicity
    but not in any specific order. The shape is (M,) unless
    <code>homogeneous_eigvals=True</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig : eigenvalues and right eigenvectors of general arrays.</strong></p>
</li>
<li>
<p><strong>eigvalsh : eigenvalues of symmetric or Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">homogeneous_eigvals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">8.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_5">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="norm_1">norm<a class="headerlink" href="#norm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function norm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">Nuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fro</span> <span class="o">|</span> <span class="o">`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input array.  If <code>axis</code> is None, <code>x</code> must be 1-D or 2-D, unless <code>ord</code>
    is None. If both <code>axis</code> and <code>ord</code> are None, the 2-norm of
    <code>x.ravel</code> will be returned.</p>
</li>
<li>
<p><strong>ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional</strong>
    Order of the norm (see table under <code>Notes</code>). inf means numpy's
    <code>inf</code> object. The default is None.</p>
</li>
<li>
<p><strong>axis : {None, int, 2-tuple of ints}, optional.</strong>
    If <code>axis</code> is an integer, it specifies the axis of <code>x</code> along which to
    compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If <code>axis</code> is None then either a vector norm (when <code>x</code>
    is 1-D) or a matrix norm (when <code>x</code> is 2-D) is returned. The default
    is None.</p>
<p>.. versionadded:: 1.8.0</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original <code>x</code>.</p>
<p>.. versionadded:: 1.10.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>n : float or ndarray</strong>
    Norm of the matrix or vector(s).</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>scipy.linalg.norm : Similar function in SciPy.</strong></li>
</ul>
<h4>Notes</h4>
<p>For values of <code>ord &lt; 1</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
'nuc'  nuclear norm                  --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<div class="codehilite"><pre><span></span><code>:math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
</code></pre></div>


<p>The nuclear norm is the sum of the singular values.</p>
<p>Both the Frobenius and nuclear norm orders are only defined for
matrices and raise a ValueError when <code>x.ndim != 2</code>.</p>
<h4>References</h4>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mf">9.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mf">0.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mf">2.0</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mf">20.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mf">7.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mf">4.6566128774142013e-010</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mf">6.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.3484692283495345</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">0.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">1.8570331885190563e-016</span> <span class="c1"># may vary</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">5.8480354764257312</span> <span class="c1"># may vary</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="mf">0.0</span>
</code></pre></div>

<p>Using the <code>axis</code> argument to compute vector norms:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.41421356</span><span class="p">,</span>  <span class="mf">2.23606798</span><span class="p">,</span>  <span class="mf">5.</span>        <span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">3.74165739</span><span class="p">,</span>  <span class="mf">4.24264069</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">])</span>
</code></pre></div>

<p>Using the <code>axis</code> argument to compute matrix norms:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">3.74165739</span><span class="p">,</span>  <span class="mf">11.22497216</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
<span class="p">(</span><span class="mf">3.7416573867739413</span><span class="p">,</span> <span class="mf">11.224972160321824</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="rsf2csf">rsf2csf<a class="headerlink" href="#rsf2csf" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function rsf2csf</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper-triangular
complex-valued Schur form.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>T : (M, M) array_like</strong>
    Real Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) array_like</strong>
    Schur transformation matrix</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Complex Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    Schur transformation matrix corresponding to the complex form</p>
</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>schur : Schur decomposition of an array</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">rsf2csf</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span> <span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">rsf2csf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">2.65896708</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.64592781</span><span class="o">+</span><span class="mf">0.743164187</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.21516887</span><span class="o">+</span><span class="mf">1.00660462</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">8.02254558e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.82115218</span><span class="o">-</span><span class="mf">2.77555756e-17</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.802254558</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.28220393</span><span class="o">-</span><span class="mf">0.31385693</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.51319638</span><span class="o">-</span><span class="mf">0.17258824</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.24720268</span><span class="o">+</span><span class="mf">0.41635578</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.68079517</span><span class="o">-</span><span class="mf">0.15118243</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76618703</span><span class="o">+</span><span class="mf">0.01873251</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03063006</span><span class="o">+</span><span class="mf">0.46857912</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="schur">schur<a class="headerlink" href="#schur" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function schur</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = Z T Z^H
</code></pre></div>


<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular. In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to decompose</p>
</li>
<li>
<p><strong>output : {'real', 'complex'}, optional</strong>
    Construct the real or complex Schur decomposition (for real matrices).</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size. If None or -1, it is automatically computed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance).</p>
</li>
<li>
<p><strong>sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional</strong>
    Specifies whether the upper eigenvalues should be sorted. A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True).
    Alternatively, string parameters may be used::</p>
<div class="codehilite"><pre><span></span><code>&#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)
&#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)
&#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
&#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)
</code></pre></div>


<p>Defaults to None (no sorting).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Schur form of A. It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    An unitary Schur transformation matrix for A.
    It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>sdim : int</strong>
    If and only if sorting was requested, a third return value will
    contain the number of eigenvalues satisfying the sort condition.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Error raised under three conditions:</p>
<div class="codehilite"><pre><span></span><code>1. The algorithm failed due to a failure of the QR algorithm to
   compute all eigenvalues.
2. If eigenvalue sorting was requested, the eigenvalues could not be
   reordered due to a failure to separate eigenvalues, usually because
   of poor conditioning.
3. If eigenvalue sorting was requested, roundoff errors caused the
   leading eigenvalues to no longer satisfy the sorting condition.
</code></pre></div>


<h4>See also</h4>
<ul>
<li><strong>rsf2csf : Convert real Schur form to complex Schur form</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.22839825</span><span class="o">+</span><span class="mf">1.32378589</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.42590089</span><span class="o">+</span><span class="mf">1.51937378</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.59877807</span><span class="o">+</span><span class="mf">0.56192146</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>                    <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T3</span><span class="p">,</span> <span class="n">Z3</span><span class="p">,</span> <span class="n">sdim</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sdim</span>
<span class="mi">1</span>
</code></pre></div>

</details>
<h2 id="decomp_svd">Decomp_svd<a class="headerlink" href="#decomp_svd" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Decomp_svd</code> wraps Python module <code>scipy.linalg.decomp_svd</code>.</p>
<h3 id="arccos">arccos<a class="headerlink" href="#arccos" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function arccos</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arccos</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of <code>cos</code> so that, if <code>y = cos(x)</code>, then <code>x = arccos(y)</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    <code>x</code>-coordinate on the unit circle.
    For real arguments, the domain is [-1, 1].</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>angle : ndarray</strong>
    The angle of the ray intersecting the unit circle at the given
    <code>x</code>-coordinate in radians [0, pi].
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>See Also</h4>
<p>cos, arctan, arcsin, emath.arccos</p>
<h4>Notes</h4>
<p><code>arccos</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that <code>cos(z) = x</code>. The convention is to return
the angle <code>z</code> whose real part lies in <code>[0, pi]</code>.</p>
<p>For real-valued input data types, <code>arccos</code> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytic function that
has branch cuts <code>[-inf, -1]</code> and <code>[1, inf]</code> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse <code>cos</code> is also known as <code>acos</code> or cos^-1.</p>
<h4>References</h4>
<p>M. Abramowitz and I.A. Stegun, 'Handbook of Mathematical Functions',
10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/</p>
<h4>Examples</h4>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">3.14159265</span><span class="p">])</span>
</code></pre></div>

<p>Plot arccos:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

</details>
<h3 id="arcsin">arcsin<a class="headerlink" href="#arcsin" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function arcsin</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">arcsin</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse sine, element-wise.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    <code>y</code>-coordinate on the unit circle.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>angle : ndarray</strong>
    The inverse sine of each element in <code>x</code>, in radians and in the
    closed interval <code>[-pi/2, pi/2]</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>See Also</h4>
<p>sin, cos, arccos, tan, arctan, arctan2, emath.arcsin</p>
<h4>Notes</h4>
<p><code>arcsin</code> is a multivalued function: for each <code>x</code> there are infinitely
many numbers <code>z</code> such that :math:<code>sin(z) = x</code>.  The convention is to
return the angle <code>z</code> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <em>arcsin</em> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arcsin</code> is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.</p>
<p>The inverse sine is also known as <code>asin</code> or sin^{-1}.</p>
<h4>References</h4>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79ff.</p>
<ul>
<li><strong>http://www.math.sfu.ca/~cbm/aands/</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># pi/2</span>
<span class="mf">1.5707963267948966</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># -pi/2</span>
<span class="o">-</span><span class="mf">1.5707963267948966</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mf">0.0</span>
</code></pre></div>

</details>
<h3 id="clip">clip<a class="headerlink" href="#clip" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function clip</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clip</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a_min</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a_max</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code>[0, 1]</code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<p>Equivalent to but faster than <code>np.minimum(a_max, np.maximum(a, a_min))</code>.</p>
<p>No check is performed to ensure <code>a_min &lt; a_max</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Array containing elements to clip.</p>
</li>
<li>
<p><strong>a_min : scalar or array_like or None</strong>
    Minimum value. If None, clipping is not performed on lower
    interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be
    None.</p>
</li>
<li>
<p><strong>a_max : scalar or array_like or None</strong>
    Maximum value. If None, clipping is not performed on upper
    interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be
    None. If <code>a_min</code> or <code>a_max</code> are array_like, then the three
    arrays will be broadcasted to match their shapes.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    The results will be placed in this array. It may be the input
    array for in-place clipping.  <code>out</code> must be of the right shape
    to hold the output.  Its type is preserved.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<p>.. versionadded:: 1.17.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>clipped_array : ndarray</strong>
    An array with the elements of <code>a</code>, but where values
    &lt; <code>a_min</code> are replaced with <code>a_min</code>, and those &gt; <code>a_max</code>
    with <code>a_max</code>.</li>
</ul>
<h4>See Also</h4>
<p>ufuncs-output-type</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="diag">diag<a class="headerlink" href="#diag" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function diag</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diag</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code>numpy.diagonal</code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>v : array_like</strong>
    If <code>v</code> is a 2-D array, return a copy of its <code>k</code>-th diagonal.
    If <code>v</code> is a 1-D array, return a 2-D array with <code>v</code> on the <code>k</code>-th
    diagonal.</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal in question. The default is 0. Use <code>k&gt;0</code> for diagonals
    above the main diagonal, and <code>k&lt;0</code> for diagonals below the main
    diagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    The extracted diagonal or constructed diagonal array.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>diagonal : Return specified diagonals.</strong></p>
</li>
<li>
<p><strong>diagflat : Create a 2-D array with the flattened input as a diagonal.</strong></p>
</li>
<li>
<p><strong>trace : Sum along diagonals.</strong></p>
</li>
<li>
<p><strong>triu : Upper triangle of an array.</strong></p>
</li>
<li>
<p><strong>tril : Lower triangle of an array.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="diagsvd">diagsvd<a class="headerlink" href="#diagsvd" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function diagsvd</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagsvd</span> <span class="o">:</span>
  <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct the sigma matrix in SVD from singular values and size M, N.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>s : (M,) or (N,) array_like</strong>
    Singular values</p>
</li>
<li>
<p><strong>M : int</strong>
    Size of the matrix whose singular values are <code>s</code>.</p>
</li>
<li>
<p><strong>N : int</strong>
    Size of the matrix whose singular values are <code>s</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>S : (M, N) ndarray</strong>
    The S-matrix in the singular value decomposition</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>svdvals : Compute singular values of a matrix.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">diagsvd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># The array representing the computed svd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">diagsvd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">diagsvd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="dot">dot<a class="headerlink" href="#dot" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dot</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
  (without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
  but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
  and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
  the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
  sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
</li>
</ul>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    First argument.</p>
</li>
<li>
<p><strong>b : array_like</strong>
    Second argument.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>output : ndarray</strong>
    Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If <code>out</code> is given, then it is returned.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If the last dimension of <code>a</code> is not the same size as
    the second-to-last dimension of <code>b</code>.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>vdot : Complex-conjugating dot product.</strong></p>
</li>
<li>
<p><strong>tensordot : Sum products over arbitrary axes.</strong></p>
</li>
<li>
<p><strong>einsum : Einstein summation convention.</strong></p>
</li>
<li>
<p><strong>matmul : '@' operator as method with out parameter.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">12</span>
</code></pre></div>

<p>Neither argument is complex-conjugated:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="p">(</span><span class="o">-</span><span class="mi">13</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>

<p>For 2-D arrays it is the matrix product:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">499128</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="mi">499128</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_6">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_6" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="null_space">null_space<a class="headerlink" href="#null_space" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function null_space</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">null_space</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the null space of A using SVD</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>rcond : float, optional</strong>
    Relative condition number. Singular values <code>s</code> smaller than
    <code>rcond * max(s)</code> are considered zero.</p>
</li>
<li>
<p><strong>Default: floating point eps * max(M,N).</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>Z : (N, K) ndarray</strong>
    Orthonormal basis for the null space of A.
    K = dimension of effective null space, as determined by rcond</li>
</ul>
<h4>See also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>orth : Matrix range</strong></p>
</li>
</ul>
<h4>Examples</h4>
<p>1-D null space:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">null_space</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">null_space</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ns</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Remove the sign ambiguity of the vector</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.70710678</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.70710678</span><span class="p">]])</span>
</code></pre></div>

<p>2-D null space:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">null_space</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>The basis vectors are orthonormal (up to rounding error):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>   <span class="mf">6.92087741e-17</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.92087741e-17</span><span class="p">,</span>   <span class="mf">1.00000000e+00</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="orth">orth<a class="headerlink" href="#orth" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function orth</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orth</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the range of A using SVD</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>rcond : float, optional</strong>
    Relative condition number. Singular values <code>s</code> smaller than
    <code>rcond * max(s)</code> are considered zero.</p>
</li>
<li>
<p><strong>Default: floating point eps * max(M,N).</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>Q : (M, K) ndarray</strong>
    Orthonormal basis for the range of A.
    K = effective rank of A, as determined by rcond</li>
</ul>
<h4>See also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>null_space : Matrix null space</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">orth</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># rank 2 array</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="subspace_angles">subspace_angles<a class="headerlink" href="#subspace_angles" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function subspace_angles</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subspace_angles</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the subspace angles between two matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    The first input array.</p>
</li>
<li>
<p><strong>B : (M, K) array_like</strong>
    The second input array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>angles : ndarray, shape (min(N, K),)</strong>
    The subspace angles between the column spaces of <code>A</code> and <code>B</code> in
    descending order.</li>
</ul>
<h4>See Also</h4>
<p>orth
svd</p>
<h4>Notes</h4>
<p>This computes the subspace angles according to the formula
provided in [1]_. For equivalence with MATLAB and Octave behavior,
use <code>angles[0]</code>.</p>
<p>.. versionadded:: 1.0</p>
<h4>References</h4>
<p>.. [1] Knyazev A, Argentati M (2002) Principal Angles between Subspaces
       in an A-Based Scalar Product: Algorithms and Perturbation
       Estimates. SIAM J. Sci. Comput. 23:2008-2040.</p>
<h4>Examples</h4>
<p>An Hadamard matrix, which has orthogonal columns, so we expect that
the suspace angle to be :math:<code>\frac{\pi}{2}</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hadamard</span><span class="p">,</span> <span class="n">subspace_angles</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span> <span class="o">=</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="p">[[</span> <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span>  <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">subspace_angles</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">H</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]))</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">90.</span><span class="p">,</span>  <span class="mf">90.</span><span class="p">])</span>
</code></pre></div>

<p>And the subspace angle of a matrix to itself should be zero:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">subspace_angles</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

<p>The angles between non-orthogonal subspaces are in between these extremes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">subspace_angles</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">55.832</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="svd">svd<a class="headerlink" href="#svd" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function svd</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to decompose.</p>
</li>
<li>
<p><strong>full_matrices : bool, optional</strong>
    If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
    If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
    <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>compute_uv : bool, optional</strong>
    Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
    Default is True.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>lapack_driver : {'gesdd', 'gesvd'}, optional</strong>
    Whether to use the more efficient divide-and-conquer approach
    (<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
    to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
    Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>U : ndarray</strong>
    Unitary matrix having left singular vectors as columns.
    Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.</p>
</li>
<li>
<p><strong>s : ndarray</strong>
    The singular values, sorted in non-increasing order.
    Of shape (K,), with <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>Vh : ndarray</strong>
    Unitary matrix having right singular vectors as rows.
    Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
</li>
</ul>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>See also</h4>
<ul>
<li>
<p><strong>svdvals : Compute singular values of a matrix.</strong></p>
</li>
<li>
<p><strong>diagsvd : Construct the Sigma matrix, given the vector s.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<p>Reconstruct the original matrix from the decomposition:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
<span class="o">...</span>     <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Vh</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vh</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="svdvals">svdvals<a class="headerlink" href="#svdvals" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function svdvals</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svdvals</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute singular values of a matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to decompose.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>s : (min(M, N),) ndarray</strong>
    The singular values, sorted in decreasing order.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>Notes</h4>
<p><code>svdvals(a)</code> only differs from <code>svd(a, compute_uv=False)</code> by its
handling of the edge case of empty <code>a</code>, where it returns an
empty sequence:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svdvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float64</span><span class="p">)</span>
</code></pre></div>

<h4>See Also</h4>
<ul>
<li>
<p><strong>svd : Compute the full singular value decomposition of a matrix.</strong></p>
</li>
<li>
<p><strong>diagsvd : Construct the Sigma matrix, given the vector s.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svdvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.28091555</span><span class="p">,</span>  <span class="mf">1.63516424</span><span class="p">])</span>
</code></pre></div>

<p>We can verify the maximum singular value of <code>m</code> by computing the maximum
length of <code>m.dot(u)</code> over all the unit vectors <code>u</code> in the (x,y) plane.
We approximate 'all' the unit vectors with a large sample. Because
of linearity, we only need the unit vectors with angles in [0, pi].</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="mf">4.2809152422538475</span>
</code></pre></div>

<p><code>p</code> is a projection matrix with rank 1. With exact arithmetic,
its singular values would be [1, 0, 0, 0].</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>   <span class="mf">2.02021698e-17</span><span class="p">,</span>   <span class="mf">1.56692500e-17</span><span class="p">,</span>
         <span class="mf">8.15115104e-34</span><span class="p">])</span>
</code></pre></div>

<p>The singular values of an orthogonal matrix are all 1. Here, we
create a random orthogonal matrix by using the <code>rvs()</code> method of
<code>scipy.stats.ortho_group</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">ortho_group</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span> <span class="o">=</span> <span class="n">ortho_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">orth</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="where">where<a class="headerlink" href="#where" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function where</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">where</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">x</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">y</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">condition</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>where(condition, [x, y])</p>
<p>Return elements chosen from <code>x</code> or <code>y</code> depending on <code>condition</code>.</p>
<p>.. note::
    When only <code>condition</code> is provided, this function is a shorthand for
    <code>np.asarray(condition).nonzero()</code>. Using <code>nonzero</code> directly should be
    preferred, as it behaves correctly for subclasses. The rest of this
    documentation covers only the case where all three arguments are
    provided.</p>
<h4>Parameters</h4>
<ul>
<li><strong>condition : array_like, bool</strong>
    Where True, yield <code>x</code>, otherwise yield <code>y</code>.
x, y : array_like
    Values from which to choose. <code>x</code>, <code>y</code> and <code>condition</code> need to be
    broadcastable to some shape.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    An array with elements from <code>x</code> where <code>condition</code> is True, and elements
    from <code>y</code> elsewhere.</li>
</ul>
<h4>See Also</h4>
<p>choose</p>
<ul>
<li><strong>nonzero : The function that is called when x and y are omitted</strong></li>
</ul>
<h4>Notes</h4>
<p>If all the arrays are 1-D, <code>where</code> is equivalent to::</p>
<div class="codehilite"><pre><span></span><code>[xv if c else yv
 for c, xv, yv in zip(condition, x, y)]
</code></pre></div>


<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</code></pre></div>

<p>This can be used on multidimensional arrays too:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]],</span>
<span class="o">...</span>          <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="o">...</span>          <span class="p">[[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<p>The shapes of x, y, and the condition are broadcast together:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># both x and 10+y are broadcast</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>  <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># -1 is broadcast</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="zeros_1">zeros<a class="headerlink" href="#zeros_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function zeros</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zeros</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">shape</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>zeros(shape, dtype=float, order='C')</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>shape : int or tuple of ints</strong>
    Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>.</p>
</li>
<li>
<p><strong>dtype : data-type, optional</strong>
    The desired data-type for the array, e.g., <code>numpy.int8</code>.  Default is
    <code>numpy.float64</code>.</p>
</li>
<li>
<p><strong>order : {'C', 'F'}, optional, default: 'C'</strong>
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    Array of zeros with the given shape, dtype, and order.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>zeros_like : Return an array of zeros with shape and type of input.</strong></p>
</li>
<li>
<p><strong>empty : Return a new uninitialized array.</strong></p>
</li>
<li>
<p><strong>ones : Return a new array setting values to one.</strong></p>
</li>
<li>
<p><strong>full : Return a new array of given shape filled with value.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
</code></pre></div>

</details>
<h2 id="flinalg">Flinalg<a class="headerlink" href="#flinalg" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Flinalg</code> wraps Python module <code>scipy.linalg.flinalg</code>.</p>
<h3 id="get_flinalg_funcs_2">get_flinalg_funcs<a class="headerlink" href="#get_flinalg_funcs_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_flinalg_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_flinalg_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return optimal available _flinalg function objects with
names. Arrays are used to determine optimal prefix.</p>
</details>
<h3 id="has_column_major_storage">has_column_major_storage<a class="headerlink" href="#has_column_major_storage" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function has_column_major_storage</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">has_column_major_storage</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

</details>
<h2 id="lapack">Lapack<a class="headerlink" href="#lapack" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Lapack</code> wraps Python module <code>scipy.linalg.lapack</code>.</p>
<h3 id="cgegv">cgegv<a class="headerlink" href="#cgegv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cgegv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cgegv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>cgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alpha,beta,vl,vr,info = cgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>cgegv</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input rank-2 array('F') with bounds (n,n)</strong></p>
</li>
<li>
<p><strong>b : input rank-2 array('F') with bounds (n,n)</strong></p>
</li>
</ul>
<h4>Other Parameters</h4>
<ul>
<li>
<p><strong>compute_vl : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>compute_vr : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>overwrite_a : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>overwrite_b : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>lwork : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: max(2*n,1)</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>alpha : rank-1 array('F') with bounds (n)</strong></p>
</li>
<li>
<p><strong>beta : rank-1 array('F') with bounds (n)</strong></p>
</li>
<li>
<p><strong>vl : rank-2 array('F') with bounds (ldvl,n)</strong></p>
</li>
<li>
<p><strong>vr : rank-2 array('F') with bounds (ldvr,n)</strong></p>
</li>
<li>
<p><strong>info : int</strong></p>
</li>
</ul>
</details>
<h3 id="dgegv">dgegv<a class="headerlink" href="#dgegv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dgegv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dgegv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>dgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alphar,alphai,beta,vl,vr,info = dgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>dgegv</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input rank-2 array('d') with bounds (n,n)</strong></p>
</li>
<li>
<p><strong>b : input rank-2 array('d') with bounds (n,n)</strong></p>
</li>
</ul>
<h4>Other Parameters</h4>
<ul>
<li>
<p><strong>compute_vl : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>compute_vr : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>overwrite_a : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>overwrite_b : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>lwork : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: max(8*n,1)</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>alphar : rank-1 array('d') with bounds (n)</strong></p>
</li>
<li>
<p><strong>alphai : rank-1 array('d') with bounds (n)</strong></p>
</li>
<li>
<p><strong>beta : rank-1 array('d') with bounds (n)</strong></p>
</li>
<li>
<p><strong>vl : rank-2 array('d') with bounds (ldvl,n)</strong></p>
</li>
<li>
<p><strong>vr : rank-2 array('d') with bounds (ldvr,n)</strong></p>
</li>
<li>
<p><strong>info : int</strong></p>
</li>
</ul>
</details>
<h3 id="get_lapack_funcs_7">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="sgegv">sgegv<a class="headerlink" href="#sgegv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sgegv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sgegv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>sgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alphar,alphai,beta,vl,vr,info = sgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>sgegv</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input rank-2 array('f') with bounds (n,n)</strong></p>
</li>
<li>
<p><strong>b : input rank-2 array('f') with bounds (n,n)</strong></p>
</li>
</ul>
<h4>Other Parameters</h4>
<ul>
<li>
<p><strong>compute_vl : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>compute_vr : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>overwrite_a : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>overwrite_b : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>lwork : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: max(8*n,1)</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>alphar : rank-1 array('f') with bounds (n)</strong></p>
</li>
<li>
<p><strong>alphai : rank-1 array('f') with bounds (n)</strong></p>
</li>
<li>
<p><strong>beta : rank-1 array('f') with bounds (n)</strong></p>
</li>
<li>
<p><strong>vl : rank-2 array('f') with bounds (ldvl,n)</strong></p>
</li>
<li>
<p><strong>vr : rank-2 array('f') with bounds (ldvr,n)</strong></p>
</li>
<li>
<p><strong>info : int</strong></p>
</li>
</ul>
</details>
<h3 id="zgegv">zgegv<a class="headerlink" href="#zgegv" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function zgegv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">zgegv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p><code>zgegv</code> is deprecated!
The <code>*gegv</code> family of routines has been deprecated in
LAPACK 3.6.0 in favor of the <code>*ggev</code> family of routines.
The corresponding wrappers will be removed from SciPy in
a future release.</p>
<p>alpha,beta,vl,vr,info = zgegv(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])</p>
<p>Wrapper for <code>zgegv</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : input rank-2 array('D') with bounds (n,n)</strong></p>
</li>
<li>
<p><strong>b : input rank-2 array('D') with bounds (n,n)</strong></p>
</li>
</ul>
<h4>Other Parameters</h4>
<ul>
<li>
<p><strong>compute_vl : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>compute_vr : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 1</strong></p>
</li>
<li>
<p><strong>overwrite_a : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>overwrite_b : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: 0</strong></p>
</li>
<li>
<p><strong>lwork : input int, optional</strong></p>
</li>
<li>
<p><strong>Default: max(2*n,1)</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>alpha : rank-1 array('D') with bounds (n)</strong></p>
</li>
<li>
<p><strong>beta : rank-1 array('D') with bounds (n)</strong></p>
</li>
<li>
<p><strong>vl : rank-2 array('D') with bounds (ldvl,n)</strong></p>
</li>
<li>
<p><strong>vr : rank-2 array('D') with bounds (ldvr,n)</strong></p>
</li>
<li>
<p><strong>info : int</strong></p>
</li>
</ul>
</details>
<h2 id="matfuncs">Matfuncs<a class="headerlink" href="#matfuncs" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Matfuncs</code> wraps Python module <code>scipy.linalg.matfuncs</code>.</p>
<h2 id="single_1">Single<a class="headerlink" href="#single_1" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Matfuncs.​Single</code> wraps Python class <code>scipy.linalg.matfuncs.single</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span> <span class="n">t</span>
</code></pre></div>

<h3 id="getitem_2"><strong>getitem</strong><a class="headerlink" href="#getitem_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method <strong>getitem</strong></summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span>
  <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
</details>
<h3 id="newbyteorder_1">newbyteorder<a class="headerlink" href="#newbyteorder_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method newbyteorder</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">newbyteorder</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">new_order</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>newbyteorder(new_order='S')</p>
<p>Return a new <code>dtype</code> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <code>new_order</code> code can be any from the following:</p>
<ul>
<li>'S' - swap dtype from current to opposite endian</li>
<li>{'&lt;', 'L'} - little endian</li>
<li>{'&gt;', 'B'} - big endian</li>
<li>{'=', 'N'} - native order</li>
<li>{'|', 'I'} - ignore (no change to byte order)</li>
</ul>
<h4>Parameters</h4>
<ul>
<li><strong>new_order : str, optional</strong>
    Byte order to force; a value from the byte order specifications
    above.  The default value ('S') results in swapping the current
    byte order. The code does a case-insensitive check on the first
    letter of <code>new_order</code> for the alternatives above.  For example,
    any of 'B' or 'b' or 'biggish' are valid to specify big-endian.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>new_dtype : dtype</strong>
    New <code>dtype</code> object with the given change to the byte order.</li>
</ul>
</details>
<h3 id="to_string_4">to_string<a class="headerlink" href="#to_string_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method to_string</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="show_4">show<a class="headerlink" href="#show_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method show</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
</details>
<h3 id="pp_4">pp<a class="headerlink" href="#pp_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>method pp</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span><span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
</details>
<h3 id="absolute">absolute<a class="headerlink" href="#absolute" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function absolute</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">absolute</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input array.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>absolute : ndarray</strong>
    An ndarray containing the absolute value of
    each element in <code>x</code>.  For complex input, <code>a + ib</code>, the
    absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="mf">1.5620499351813308</span>
</code></pre></div>

<p>Plot the function over <code>[-10, 10]</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p>Plot the function over the complex plane:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

</details>
<h3 id="amax">amax<a class="headerlink" href="#amax" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function amax</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">amax</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum of an array or maximum along an axis.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data.</p>
</li>
<li>
<p><strong>axis : None or int or tuple of ints, optional</strong>
    Axis or axes along which to operate.  By default, flattened input is
    used.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    Alternative output array in which to place the result.  Must
    be of the same shape and buffer length as the expected output.
    See <code>ufuncs-output-type</code> for more details.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>amax</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.</p>
</li>
<li>
<p><strong>initial : scalar, optional</strong>
    The minimum value of an output element. Must be present to allow
    computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
</li>
<li>
<p><strong>where : array_like of bool, optional</strong>
    Elements to compare for the maximum. See <code>~numpy.ufunc.reduce</code>
    for details.</p>
<p>.. versionadded:: 1.17.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>amax : ndarray or scalar</strong>
    Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.
    If <code>axis</code> is given, the result is an array of dimension
    <code>a.ndim - 1</code>.</li>
</ul>
<h4>See Also</h4>
<p>amin :
    The minimum value of an array along a given axis, propagating any NaNs.
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
argmax :
    Return the indices of the maximum values.</p>
<p>nanmin, minimum, fmin</p>
<h4>Notes</h4>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don't use <code>amax</code> for element-wise comparison of 2 arrays; when
<code>a.shape[0]</code> is 2, <code>maximum(a[0], a[1])</code> is faster than
<code>amax(a, axis=0)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">nan</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">initial</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">4.0</span>
</code></pre></div>

<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
</code></pre></div>

<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python's max
function, which is only used for empty iterables.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="mi">5</span>
</code></pre></div>

</details>
<h3 id="conjugate">conjugate<a class="headerlink" href="#conjugate" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function conjugate</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">conjugate</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input value.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : ndarray</strong>
    The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>Notes</h4>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span>
<span class="kc">True</span>
</code></pre></div>

<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="coshm">coshm<a class="headerlink" href="#coshm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function coshm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coshm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>coshm : (N, N) ndarray</strong>
    Hyperbolic matrix cosine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">11.24592233</span><span class="p">,</span>  <span class="mf">38.76236492</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">12.92078831</span><span class="p">,</span>  <span class="mf">50.00828725</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cosm">cosm<a class="headerlink" href="#cosm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cosm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>cosm : (N, N) ndarray</strong>
    Matrix cosine of A</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="diag_1">diag<a class="headerlink" href="#diag_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function diag</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diag</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">v</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code>numpy.diagonal</code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>v : array_like</strong>
    If <code>v</code> is a 2-D array, return a copy of its <code>k</code>-th diagonal.
    If <code>v</code> is a 1-D array, return a 2-D array with <code>v</code> on the <code>k</code>-th
    diagonal.</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal in question. The default is 0. Use <code>k&gt;0</code> for diagonals
    above the main diagonal, and <code>k&lt;0</code> for diagonals below the main
    diagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>out : ndarray</strong>
    The extracted diagonal or constructed diagonal array.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>diagonal : Return specified diagonals.</strong></p>
</li>
<li>
<p><strong>diagflat : Create a 2-D array with the flattened input as a diagonal.</strong></p>
</li>
<li>
<p><strong>trace : Sum along diagonals.</strong></p>
</li>
<li>
<p><strong>triu : Upper triangle of an array.</strong></p>
</li>
<li>
<p><strong>tril : Lower triangle of an array.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="dot_1">dot<a class="headerlink" href="#dot_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dot</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dot</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
<li>
<p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors
  (without complex conjugation).</p>
</li>
<li>
<p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,
  but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p>
</li>
<li>
<p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>
  and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over
  the last axis of <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a
  sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
<p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
</li>
</ul>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    First argument.</p>
</li>
<li>
<p><strong>b : array_like</strong>
    Second argument.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>output : ndarray</strong>
    Returns the dot product of <code>a</code> and <code>b</code>.  If <code>a</code> and <code>b</code> are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.
    If <code>out</code> is given, then it is returned.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If the last dimension of <code>a</code> is not the same size as
    the second-to-last dimension of <code>b</code>.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>vdot : Complex-conjugating dot product.</strong></p>
</li>
<li>
<p><strong>tensordot : Sum products over arbitrary axes.</strong></p>
</li>
<li>
<p><strong>einsum : Einstein summation convention.</strong></p>
</li>
<li>
<p><strong>matmul : '@' operator as method with out parameter.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">12</span>
</code></pre></div>

<p>Neither argument is complex-conjugated:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="p">(</span><span class="o">-</span><span class="mi">13</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>

<p>For 2-D arrays it is the matrix product:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">499128</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="mi">499128</span>
</code></pre></div>

</details>
<h3 id="expm">expm<a class="headerlink" href="#expm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like or sparse matrix</strong>
    Matrix to be exponentiated.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>expm : (N, N) ndarray</strong>
    Matrix exponential of <code>A</code>.</li>
</ul>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
       SIAM Journal on Matrix Analysis and Applications.
       31 (3). pp. 970-989. ISSN 1095-7162</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Matrix version of the formula exp(0) = 1:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="expm_cond">expm_cond<a class="headerlink" href="#expm_cond" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm_cond</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_cond</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>Relative condition number of the matrix exponential in the Frobenius norm.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : 2-D array_like</strong>
    Square input matrix with shape (N, N).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>kappa : float</strong>
    The relative condition number of the matrix exponential
    in the Frobenius norm</li>
</ul>
<h4>Notes</h4>
<p>A faster estimate for the condition number in the 1-norm
has been published but is not yet implemented in SciPy.</p>
<p>.. versionadded:: 0.14.0</p>
<h4>See also</h4>
<ul>
<li>
<p><strong>expm : Compute the exponential of a matrix.</strong></p>
</li>
<li>
<p><strong>expm_frechet : Compute the Frechet derivative of the matrix exponential.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm_cond</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">expm_cond</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span>
<span class="mf">1.7787805864469866</span>
</code></pre></div>

</details>
<h3 id="expm_frechet">expm_frechet<a class="headerlink" href="#expm_frechet" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm_frechet</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_frechet</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_expm</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Frechet derivative of the matrix exponential of A in the direction E.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix of which to take the matrix exponential.</p>
</li>
<li>
<p><strong>E : (N, N) array_like</strong>
    Matrix direction in which to take the Frechet derivative.</p>
</li>
<li>
<p><strong>method : str, optional</strong>
    Choice of algorithm. Should be one of</p>
<ul>
<li><code>SPS</code> (default)</li>
<li><code>blockEnlarge</code></li>
</ul>
</li>
<li>
<p><strong>compute_expm : bool, optional</strong>
    Whether to compute also <code>expm_A</code> in addition to <code>expm_frechet_AE</code>.
    Default is True.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>expm_A : ndarray</strong>
    Matrix exponential of A.</p>
</li>
<li>
<p><strong>expm_frechet_AE : ndarray</strong>
    Frechet derivative of the matrix exponential of A in the direction E.</p>
</li>
</ul>
<p>For <code>compute_expm = False</code>, only <code>expm_frechet_AE</code> is returned.</p>
<h4>See also</h4>
<ul>
<li><strong>expm : Compute the exponential of a matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>This section describes the available implementations that can be selected
by the <code>method</code> parameter. The default method is <em>SPS</em>.</p>
<p>Method <em>blockEnlarge</em> is a naive algorithm.</p>
<p>Method <em>SPS</em> is Scaling-Pade-Squaring [1]_.
It is a sophisticated implementation which should take
only about 3/8 as much time as the naive implementation.
The asymptotics are the same.</p>
<p>.. versionadded:: 0.13.0</p>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       Computing the Frechet Derivative of the Matrix Exponential,
       with an application to Condition Number Estimation.
       SIAM Journal On Matrix Analysis and Applications.,
       30 (4). pp. 1639-1657. ISSN 1095-7162</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_frechet_AE</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_frechet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">expm_frechet_AE</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_frechet_AE</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_frechet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expm_frechet_AE</span><span class="p">,</span> <span class="n">expm_M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:])</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="fractional_matrix_power">fractional_matrix_power<a class="headerlink" href="#fractional_matrix_power" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fractional_matrix_power</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fractional_matrix_power</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the fractional power of a matrix.</p>
<p>Proceeds according to the discussion in section (6) of [1]_.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose fractional power to evaluate.</p>
</li>
<li>
<p><strong>t : float</strong>
    Fractional power.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X : (N, N) array_like</strong>
    The fractional power of the matrix.</li>
</ul>
<h4>References</h4>
<p>.. [1] Nicholas J. Higham and Lijing lin (2011)
       'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">fractional_matrix_power</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fractional_matrix_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.75592895</span><span class="p">,</span>  <span class="mf">1.13389342</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.37796447</span><span class="p">,</span>  <span class="mf">1.88982237</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>      <span class="c1"># Verify square root</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="funm">funm<a class="headerlink" href="#funm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function funm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">funm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Evaluate a matrix function specified by a callable.</p>
<p>Returns the value of matrix-valued function <code>f</code> at <code>A</code>. The
function <code>f</code> is an extension of the scalar-valued function <code>func</code>
to matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix at which to evaluate the function</p>
</li>
<li>
<p><strong>func : callable</strong>
    Callable object that evaluates a scalar function f.
    Must be vectorized (eg. using vectorize).</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>funm : (N, N) ndarray</strong>
    Value of the matrix function specified by func evaluated at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">funm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">funm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]])</span>
</code></pre></div>

<h4>Notes</h4>
<p>This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).</p>
<p>If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">funm_herm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
<span class="o">...</span>     <span class="c1">## if you further know that your matrix is positive semidefinite,</span>
<span class="o">...</span>     <span class="c1">## you can optionally guard against precision errors by doing</span>
<span class="o">...</span>     <span class="c1"># w = np.maximum(w, 0)</span>
<span class="o">...</span>     <span class="n">w</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</code></pre></div>

<h4>References</h4>
<p>.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</p>
</details>
<h3 id="inv_1">inv<a class="headerlink" href="#inv_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function inv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Square matrix to be inverted.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Discard data in <code>a</code> (may improve performance). Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>ainv : ndarray</strong>
    Inverse of the matrix <code>a</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If <code>a</code> is singular.
ValueError
    If <code>a</code> is not square, or not 2D.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="isfinite_1">isfinite<a class="headerlink" href="#isfinite_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function isfinite</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">isfinite</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input values.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : ndarray, bool</strong>
    True where <code>x</code> is not positive infinity, negative infinity,
    or NaN; false otherwise.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>See Also</h4>
<p>isinf, isneginf, isposinf, isnan</p>
<h4>Notes</h4>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <code>x</code> is a scalar input, or if
first and second arguments have different shapes.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="khatri_rao">khatri_rao<a class="headerlink" href="#khatri_rao" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function khatri_rao</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">khatri_rao</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Khatri-rao product</p>
<p>A column-wise Kronecker product of two matrices</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a:  (n, k) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>b:  (m, k) array_like</strong>
    Input array</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c:  (n*m, k) ndarray</strong>
    Khatri-rao product of <code>a</code> and <code>b</code>.</li>
</ul>
<h4>Notes</h4>
<p>The mathematical definition of the Khatri-Rao product is:</p>
<div>
<div class="MathJax_Preview">
    (A_{ij}  \bigotimes B_{ij})_{ij}
</div>
<script type="math/tex; mode=display">
    (A_{ij}  \bigotimes B_{ij})_{ij}
</script>
</div>
<p>which is the Kronecker product of every column of A and B, e.g.::</p>
<div class="codehilite"><pre><span></span><code>c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T
</code></pre></div>


<h4>See Also</h4>
<ul>
<li><strong>kron : Kronecker product</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">khatri_rao</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">24</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">48</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">54</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="logical_not">logical_not<a class="headerlink" href="#logical_not" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function logical_not</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logical_not</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of NOT x element-wise.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Logical NOT is applied to the elements of <code>x</code>.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : bool or ndarray of bool</strong>
    Boolean result with the same shape as <code>x</code> of the NOT operation
    on elements of <code>x</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>See Also</h4>
<p>logical_and, logical_or, logical_xor</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="logm">logm<a class="headerlink" href="#logm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function logm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute matrix logarithm.</p>
<p>The matrix logarithm is the inverse of</p>
<ul>
<li><strong>expm: expm(logm(<code>A</code>)) == <code>A</code></strong></li>
</ul>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose logarithm to evaluate</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>logm : (N, N) ndarray</strong>
    Matrix logarithm of <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       'Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm.'
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197</p>
<p>.. [2] Nicholas J. Higham (2008)
       'Functions of Matrices: Theory and Computation'
       ISBN 978-0-898716-46-7</p>
<p>.. [3] Nicholas J. Higham and Lijing lin (2011)
       'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">logm</span><span class="p">,</span> <span class="n">expm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">logm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.02571087</span><span class="p">,</span>  <span class="mf">2.05142174</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.68380725</span><span class="p">,</span>  <span class="mf">1.02571087</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>         <span class="c1"># Verify expm(logm(a)) returns a</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="norm_2">norm<a class="headerlink" href="#norm_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function norm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fro</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M,) or (M, N) array_like</strong>
    Input array. If <code>axis</code> is None, <code>a</code> must be 1D or 2D.</p>
</li>
<li>
<p><strong>ord : {non-zero int, inf, -inf, 'fro'}, optional</strong>
    Order of the norm (see table under <code>Notes</code>). inf means NumPy's
    <code>inf</code> object</p>
</li>
<li>
<p><strong>axis : {int, 2-tuple of ints, None}, optional</strong>
    If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
    compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
    is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original <code>a</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>n : float or ndarray</strong>
    Norm of the matrix or vector(s).</li>
</ul>
<h4>Notes</h4>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<div class="codehilite"><pre><span></span><code>:math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
</code></pre></div>


<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h4>References</h4>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mf">4.6566128774142013e-010</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.3484692283495345</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">1.8570331885190563e-016</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">5.8480354764257312</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</code></pre></div>

</details>
<h3 id="prod">prod<a class="headerlink" href="#prod" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function prod</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">prod</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">initial</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the product of array elements over a given axis.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input data.</p>
</li>
<li>
<p><strong>axis : None or int or tuple of ints, optional</strong>
    Axis or axes along which a product is performed.  The default,
    axis=None, will calculate the product of all the elements in the
    input array. If axis is negative it counts from the last to the
    first axis.</p>
<p>.. versionadded:: 1.7.0</p>
<p>If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.</p>
</li>
<li>
<p><strong>dtype : dtype, optional</strong>
    The type of the returned array, as well as of the accumulator in
    which the elements are multiplied.  The dtype of <code>a</code> is used by
    default unless <code>a</code> has an integer dtype of less precision than the
    default platform integer.  In that case, if <code>a</code> is signed then the
    platform integer is used while if <code>a</code> is unsigned then an unsigned
    integer of the same precision as the platform integer is used.</p>
</li>
<li>
<p><strong>out : ndarray, optional</strong>
    Alternative output array in which to place the result. It must have
    the same shape as the expected output, but the type of the output
    values will be cast if necessary.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are reduced are left in the
    result as dimensions with size one. With this option, the result
    will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <code>keepdims</code> will not be
passed through to the <code>prod</code> method of sub-classes of
<code>ndarray</code>, however any non-default value will be.  If the
sub-class' method does not implement <code>keepdims</code> any
exceptions will be raised.</p>
</li>
<li>
<p><strong>initial : scalar, optional</strong>
    The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.15.0</p>
</li>
<li>
<p><strong>where : array_like of bool, optional</strong>
    Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<p>.. versionadded:: 1.17.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>product_along_axis : ndarray, see <code>dtype</code> parameter above.</strong>
    An array shaped as <code>a</code> but with the specified axis removed.
    Returns a reference to <code>out</code> if specified.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>ndarray.prod : equivalent method</strong>
ufuncs-output-type</li>
</ul>
<h4>Notes</h4>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="mi">16</span> <span class="c1"># may vary</span>
</code></pre></div>

<p>The product of an empty array is the neutral element 1:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="mf">1.0</span>
</code></pre></div>

<h4>Examples</h4>
<p>By default, calculate the product of all elements:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="mf">2.0</span>
</code></pre></div>

<p>Even when the input array is two-dimensional:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="mf">24.0</span>
</code></pre></div>

<p>But we can also specify the axis over which to multiply:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">])</span>
</code></pre></div>

<p>Or select specific elements to include:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="mf">3.0</span>
</code></pre></div>

<p>If the type of <code>x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="kc">True</span>
</code></pre></div>

<p>If <code>x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="kc">True</span>
</code></pre></div>

<p>You can also start the product with a value other than one:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">10</span>
</code></pre></div>

</details>
<h3 id="ravel">ravel<a class="headerlink" href="#ravel" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function ravel</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ravel</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">order</span><span class="o">:[`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">F</span> <span class="o">|</span> <span class="o">`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">K</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input array.  The elements in <code>a</code> are read in the order specified by
    <code>order</code>, and packed as a 1-D array.</p>
</li>
<li>
<p><strong>order : {'C','F', 'A', 'K'}, optional</strong></p>
<p>The elements of <code>a</code> are read using this index order. 'C' means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  'F' means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  'A' means to read the elements in
Fortran-like index order if <code>a</code> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  'K' means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, 'C'
index order is used.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : array_like</strong>
    y is an array of the same subtype as <code>a</code>, with shape <code>(a.size,)</code>.
    Note that matrices are special cased for backward compatibility, if <code>a</code>
    is a matrix, then y is a 1-D ndarray.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>ndarray.flat : 1-D iterator over an array.</strong></p>
</li>
<li>
<p><strong>ndarray.flatten : 1-D array copy of the elements of an array</strong>
                  in row-major order.</p>
</li>
<li>
<p><strong>ndarray.reshape : Change the shape of an array without changing its data.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code>arr.reshape(-1)</code>
may be preferable.</p>
<h4>Examples</h4>
<p>It is equivalent to <code>reshape(-1, order=order)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<p>When <code>order</code> is 'A', it will preserve the array's 'C' or 'F' ordering:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<p>When <code>order</code> is 'K', it will preserve orderings that are neither 'C'
nor 'F', but won't reverse axes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([[[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">]],</span>
       <span class="p">[[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">7</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="rsf2csf_1">rsf2csf<a class="headerlink" href="#rsf2csf_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function rsf2csf</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper-triangular
complex-valued Schur form.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>T : (M, M) array_like</strong>
    Real Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) array_like</strong>
    Schur transformation matrix</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Complex Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    Schur transformation matrix corresponding to the complex form</p>
</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>schur : Schur decomposition of an array</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">rsf2csf</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span> <span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">rsf2csf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">2.65896708</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.64592781</span><span class="o">+</span><span class="mf">0.743164187</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.21516887</span><span class="o">+</span><span class="mf">1.00660462</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">8.02254558e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.82115218</span><span class="o">-</span><span class="mf">2.77555756e-17</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.802254558</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.28220393</span><span class="o">-</span><span class="mf">0.31385693</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.51319638</span><span class="o">-</span><span class="mf">0.17258824</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.24720268</span><span class="o">+</span><span class="mf">0.41635578</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.68079517</span><span class="o">-</span><span class="mf">0.15118243</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76618703</span><span class="o">+</span><span class="mf">0.01873251</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03063006</span><span class="o">+</span><span class="mf">0.46857912</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="schur_1">schur<a class="headerlink" href="#schur_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function schur</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = Z T Z^H
</code></pre></div>


<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular. In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to decompose</p>
</li>
<li>
<p><strong>output : {'real', 'complex'}, optional</strong>
    Construct the real or complex Schur decomposition (for real matrices).</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size. If None or -1, it is automatically computed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance).</p>
</li>
<li>
<p><strong>sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional</strong>
    Specifies whether the upper eigenvalues should be sorted. A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True).
    Alternatively, string parameters may be used::</p>
<div class="codehilite"><pre><span></span><code>&#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)
&#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)
&#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
&#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)
</code></pre></div>


<p>Defaults to None (no sorting).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Schur form of A. It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    An unitary Schur transformation matrix for A.
    It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>sdim : int</strong>
    If and only if sorting was requested, a third return value will
    contain the number of eigenvalues satisfying the sort condition.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Error raised under three conditions:</p>
<div class="codehilite"><pre><span></span><code>1. The algorithm failed due to a failure of the QR algorithm to
   compute all eigenvalues.
2. If eigenvalue sorting was requested, the eigenvalues could not be
   reordered due to a failure to separate eigenvalues, usually because
   of poor conditioning.
3. If eigenvalue sorting was requested, roundoff errors caused the
   leading eigenvalues to no longer satisfy the sorting condition.
</code></pre></div>


<h4>See also</h4>
<ul>
<li><strong>rsf2csf : Convert real Schur form to complex Schur form</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.22839825</span><span class="o">+</span><span class="mf">1.32378589</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.42590089</span><span class="o">+</span><span class="mf">1.51937378</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.59877807</span><span class="o">+</span><span class="mf">0.56192146</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>                    <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T3</span><span class="p">,</span> <span class="n">Z3</span><span class="p">,</span> <span class="n">sdim</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sdim</span>
<span class="mi">1</span>
</code></pre></div>

</details>
<h3 id="sign">sign<a class="headerlink" href="#sign" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sign</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sign</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">out</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_ndarray_and_None</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">where</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])</p>
<p>Returns an element-wise indication of the sign of a number.</p>
<p>The <code>sign</code> function returns <code>-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0</code>.  nan
is returned for nan inputs.</p>
<p>For complex inputs, the <code>sign</code> function returns
<code>sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j</code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : array_like</strong>
    Input values.</p>
</li>
<li>
<p><strong>out : ndarray, None, or tuple of ndarray and None, optional</strong>
    A location into which the result is stored. If provided, it must have
    a shape that the inputs broadcast to. If not provided or None,
    a freshly-allocated array is returned. A tuple (possible only as a
    keyword argument) must have length equal to the number of outputs.</p>
</li>
<li>
<p><strong>where : array_like, optional</strong>
    This condition is broadcast over the input. At locations where the
    condition is True, the <code>out</code> array will be set to the ufunc result.
    Elsewhere, the <code>out</code> array will retain its original value.
    Note that if an uninitialized <code>out</code> array is created via the default
    <code>out=None</code>, locations within it where the condition is False will
    remain uninitialized.
**kwargs
    For other keyword-only arguments, see the
    :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>y : ndarray</strong>
    The sign of <code>x</code>.
    This is a scalar if <code>x</code> is a scalar.</li>
</ul>
<h4>Notes</h4>
<p>There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to :math:<code>x/\sqrt{x*x}</code>
which is different from a common alternative, :math:<code>x/|x|</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">([</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="signm">signm<a class="headerlink" href="#signm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function signm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">signm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix sign function.</p>
<p>Extension of the scalar sign(x) to matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix at which to evaluate the sign function</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>signm : (N, N) ndarray</strong>
    Value of the sign function at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">signm</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.12488542</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76155718</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.63667176</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">signm</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="sinhm">sinhm<a class="headerlink" href="#sinhm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sinhm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinhm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>sinhm : (N, N) ndarray</strong>
    Hyperbolic matrix sine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">10.57300653</span><span class="p">,</span>  <span class="mf">39.28826594</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">13.09608865</span><span class="p">,</span>  <span class="mf">49.86127247</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="sinm">sinm<a class="headerlink" href="#sinm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sinm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>sinm : (N, N) ndarray</strong>
    Matrix sine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="solve_1">solve<a class="headerlink" href="#solve_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (N, N) array_like</strong>
    Square input data</p>
</li>
<li>
<p><strong>b : (N, NRHS) array_like</strong>
    Input data for the right hand side.</p>
</li>
<li>
<p><strong>sym_pos : bool, optional</strong>
    Assume <code>a</code> is symmetric and positive definite. This key is deprecated
    and assume_a = 'pos' keyword is recommended instead. The functionality
    is the same. It will be removed in the future.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    If True, only the data contained in the lower triangle of <code>a</code>. Default
    is to use upper triangle. (ignored for <code>'gen'</code>)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in <code>a</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Allow overwriting data in <code>b</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>assume_a : str, optional</strong>
    Valid entries are explained above.</p>
</li>
<li>
<p><strong>transposed: bool, optional</strong>
    If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
    for complex matrices (only for True).</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (N, NRHS) ndarray</strong>
    The solution array.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.</p>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

<h4>Notes</h4>
<p>If the input b matrix is a 1-D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1-D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
</details>
<h3 id="sqrtm">sqrtm<a class="headerlink" href="#sqrtm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sqrtm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrtm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix square root.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose square root to evaluate</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
<li>
<p><strong>blocksize : integer, optional</strong>
    If the blocksize is not degenerate with respect to the
    size of the input array, then use a blocked algorithm. (Default: 64)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>sqrtm : (N, N) ndarray</strong>
    Value of the sqrt function at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>Frobenius norm of the estimated error, ||err||_F / ||A||_F</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] Edvin Deadman, Nicholas J. Higham, Rui Ralha (2013)
       'Blocked Schur Algorithms for Computing the Matrix Square Root,
       Lecture Notes in Computer Science, 7782. pp. 171-182.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.75592895</span><span class="p">,</span>  <span class="mf">1.13389342</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.37796447</span><span class="p">,</span>  <span class="mf">1.88982237</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="svd_1">svd<a class="headerlink" href="#svd_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function svd</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to decompose.</p>
</li>
<li>
<p><strong>full_matrices : bool, optional</strong>
    If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
    If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
    <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>compute_uv : bool, optional</strong>
    Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
    Default is True.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>lapack_driver : {'gesdd', 'gesvd'}, optional</strong>
    Whether to use the more efficient divide-and-conquer approach
    (<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
    to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
    Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>U : ndarray</strong>
    Unitary matrix having left singular vectors as columns.
    Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.</p>
</li>
<li>
<p><strong>s : ndarray</strong>
    The singular values, sorted in non-increasing order.
    Of shape (K,), with <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>Vh : ndarray</strong>
    Unitary matrix having right singular vectors as rows.
    Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
</li>
</ul>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>See also</h4>
<ul>
<li>
<p><strong>svdvals : Compute singular values of a matrix.</strong></p>
</li>
<li>
<p><strong>diagsvd : Construct the Sigma matrix, given the vector s.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<p>Reconstruct the original matrix from the decomposition:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
<span class="o">...</span>     <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Vh</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vh</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="tanhm">tanhm<a class="headerlink" href="#tanhm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tanhm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanhm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tanhm : (N, N) ndarray</strong>
    Hyperbolic matrix tangent of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.3428582</span> <span class="p">,</span>  <span class="mf">0.51987926</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.17329309</span><span class="p">,</span>  <span class="mf">0.86273746</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tanm">tanm<a class="headerlink" href="#tanm" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tanm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tanm : (N, N) ndarray</strong>
    Matrix tangent of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">2.00876993</span><span class="p">,</span>  <span class="o">-</span><span class="mf">8.41880636</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">2.80626879</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.42757629</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanm(a) = sinm(a).dot(inv(cosm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">2.00876993</span><span class="p">,</span>  <span class="o">-</span><span class="mf">8.41880636</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">2.80626879</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.42757629</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="transpose">transpose<a class="headerlink" href="#transpose" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function transpose</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">transpose</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">axes</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Reverse or permute the axes of an array; returns the modified array.</p>
<p>For an array a with two axes, transpose(a) gives the matrix transpose.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Input array.</p>
</li>
<li>
<p><strong>axes : tuple or list of ints, optional</strong>
    If specified, it must be a tuple or list which contains a permutation of
    [0,1,..,N-1] where N is the number of axes of a.  The i'th axis of the
    returned array will correspond to the axis numbered <code>axes[i]</code> of the
    input.  If not specified, defaults to <code>range(a.ndim)[::-1]</code>, which
    reverses the order of the axes.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>p : ndarray</strong>
    <code>a</code> with its axes permuted.  A view is returned whenever
    possible.</li>
</ul>
<h4>See Also</h4>
<p>moveaxis
argsort</p>
<h4>Notes</h4>
<p>Use <code>transpose(a, argsort(axes))</code> to invert the transposition of tensors
when using the <code>axes</code> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="triu">triu<a class="headerlink" href="#triu" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function triu</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the kth diagonal zeroed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>m : array_like</strong>
    Matrix whose elements to return</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal below which to zero elements.
    <code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
    <code>k</code> &gt; 0 superdiagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>triu : ndarray</strong>
    Return matrix with zeroed elements below the kth diagonal and has
    same shape and type as <code>m</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">triu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">triu</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</code></pre></div>

</details>
<h2 id="misc">Misc<a class="headerlink" href="#misc" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Misc</code> wraps Python module <code>scipy.linalg.misc</code>.</p>
<h3 id="get_blas_funcs_1">get_blas_funcs<a class="headerlink" href="#get_blas_funcs_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_blas_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of BLAS functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_8">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_8" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="norm_3">norm<a class="headerlink" href="#norm_3" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function norm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fro</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M,) or (M, N) array_like</strong>
    Input array. If <code>axis</code> is None, <code>a</code> must be 1D or 2D.</p>
</li>
<li>
<p><strong>ord : {non-zero int, inf, -inf, 'fro'}, optional</strong>
    Order of the norm (see table under <code>Notes</code>). inf means NumPy's
    <code>inf</code> object</p>
</li>
<li>
<p><strong>axis : {int, 2-tuple of ints, None}, optional</strong>
    If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
    compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
    is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original <code>a</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>n : float or ndarray</strong>
    Norm of the matrix or vector(s).</li>
</ul>
<h4>Notes</h4>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<div class="codehilite"><pre><span></span><code>:math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
</code></pre></div>


<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h4>References</h4>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mf">4.6566128774142013e-010</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.3484692283495345</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">1.8570331885190563e-016</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">5.8480354764257312</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</code></pre></div>

</details>
<h2 id="special_matrices">Special_matrices<a class="headerlink" href="#special_matrices" title="Permanent link">&para;</a></h2>
<p>Module <code>Scipy.​Linalg.​Special_matrices</code> wraps Python module <code>scipy.linalg.special_matrices</code>.</p>
<h3 id="as_strided">as_strided<a class="headerlink" href="#as_strided" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function as_strided</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">as_strided</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">shape</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">strides</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subok</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">writeable</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a view into the array with the given shape and strides.</p>
<p>.. warning:: This function has to be used with extreme care, see notes.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>x : ndarray</strong>
    Array to create a new.</p>
</li>
<li>
<p><strong>shape : sequence of int, optional</strong>
    The shape of the new array. Defaults to <code>x.shape</code>.</p>
</li>
<li>
<p><strong>strides : sequence of int, optional</strong>
    The strides of the new array. Defaults to <code>x.strides</code>.</p>
</li>
<li>
<p><strong>subok : bool, optional</strong>
    .. versionadded:: 1.10</p>
<p>If True, subclasses are preserved.</p>
</li>
<li>
<p><strong>writeable : bool, optional</strong>
    .. versionadded:: 1.12</p>
<p>If set to False, the returned array will always be readonly.
Otherwise it will be writable if the original array was. It
is advisable to set this to False if possible (see Notes).</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>view : ndarray</strong></li>
</ul>
<h4>See also</h4>
<ul>
<li>
<p><strong>broadcast_to: broadcast an array to a given shape.</strong></p>
</li>
<li>
<p><strong>reshape : reshape an array.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p><code>as_strided</code> creates a view into the array given the exact strides
and shape. This means it manipulates the internal data structure of
ndarray and, if done incorrectly, the array elements can point to
invalid memory and can corrupt results or crash your program.
It is advisable to always use the original <code>x.strides</code> when
calculating new strides to avoid reliance on a contiguous memory
layout.</p>
<p>Furthermore, arrays created with this function often contain self
overlapping memory, so that two elements are identical.
Vectorized write operations on such arrays will typically be
unpredictable. They may even give different results for small, large,
or transposed arrays.
Since writing to these arrays has to be tested and done with great
care, you may want to use <code>writeable=False</code> to avoid accidental write
operations.</p>
<p>For these reasons it is advisable to avoid <code>as_strided</code> when
possible.</p>
</details>
<h3 id="block_diag">block_diag<a class="headerlink" href="#block_diag" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function block_diag</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a block diagonal matrix from provided arrays.</p>
<p>Given the inputs <code>A</code>, <code>B</code> and <code>C</code>, the output will have these
arrays arranged on the diagonal::</p>
<div class="codehilite"><pre><span></span><code>[[A, 0, 0],
 [0, B, 0],
 [0, 0, C]]
</code></pre></div>


<h4>Parameters</h4>
<p>A, B, C, ... : array_like, up to 2-D
    Input arrays.  A 1-D array or array_like sequence of length <code>n</code> is
    treated as a 2-D array with shape <code>(1,n)</code>.</p>
<h4>Returns</h4>
<ul>
<li><strong>D : ndarray</strong>
    Array with <code>A</code>, <code>B</code>, <code>C</code>, ... on the diagonal. <code>D</code> has the
    same dtype as <code>A</code>.</li>
</ul>
<h4>Notes</h4>
<p>If all the input arrays are square, the output is known as a
block diagonal matrix.</p>
<p>Empty sequences (i.e., array-likes of zero size) will not be ignored.
Noteworthy, both [] and [[]] are treated as matrices with shape <code>(1,0)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="o">...</span>      <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="circulant">circulant<a class="headerlink" href="#circulant" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function circulant</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">circulant</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a circulant matrix.</p>
<h4>Parameters</h4>
<ul>
<li><strong>c : (N,) array_like</strong>
    1-D array, the first column of the matrix.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (N, N) ndarray</strong>
    A circulant matrix whose first column is <code>c</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>toeplitz : Toeplitz matrix</strong></p>
</li>
<li>
<p><strong>hankel : Hankel matrix</strong></p>
</li>
<li>
<p><strong>solve_circulant : Solve a circulant system.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">circulant</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">circulant</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="companion">companion<a class="headerlink" href="#companion" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function companion</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">companion</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a companion matrix.</p>
<p>Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in <code>a</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (N,) array_like</strong>
    1-D array of polynomial coefficients. The length of <code>a</code> must be
    at least two, and <code>a[0]</code> must not be zero.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (N-1, N-1) ndarray</strong>
    The first row of <code>c</code> is <code>-a[1:]/a[0]</code>, and the first
    sub-diagonal is all ones.  The data-type of the array is the same
    as the data-type of <code>1.0*a[0]</code>.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If any of the following are true: a) <code>a.ndim != 1</code>;
    b) <code>a.size &lt; 2</code>; c) <code>a[0] == 0</code>.</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>References</h4>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">companion</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">companion</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">31.</span><span class="p">,</span>  <span class="mf">30.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="convolution_matrix">convolution_matrix<a class="headerlink" href="#convolution_matrix" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function convolution_matrix</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolution_matrix</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a convolution matrix.</p>
<p>Constructs the Toeplitz matrix representing one-dimensional
convolution [1]_.  See the notes below for details.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (m,) array_like</strong>
    The 1-D array to convolve.</p>
</li>
<li>
<p><strong>n : int</strong>
    The number of columns in the resulting matrix.  It gives the length
    of the input to be convolved with <code>a</code>.  This is analogous to the
    length of <code>v</code> in <code>numpy.convolve(a, v)</code>.</p>
</li>
<li>
<p><strong>mode : str</strong>
    This is analogous to <code>mode</code> in <code>numpy.convolve(v, a, mode)</code>.
    It must be one of ('full', 'valid', 'same').
    See below for how <code>mode</code> determines the shape of the result.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (k, n) ndarray</strong>
    The convolution matrix whose row count <code>k</code> depends on <code>mode</code>::<div class="codehilite"><pre><span></span><code>=======  =========================
 mode    k
=======  =========================
&#39;full&#39;   m + n -1
&#39;same&#39;   max(m, n)
&#39;valid&#39;  max(m, n) - min(m, n) + 1
=======  =========================
</code></pre></div>


</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>toeplitz : Toeplitz matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>The code::</p>
<div class="codehilite"><pre><span></span><code>A = convolution_matrix(a, n, mode)
</code></pre></div>


<p>creates a Toeplitz matrix <code>A</code> such that <code>A @ v</code> is equivalent to
using <code>convolve(a, v, mode)</code>.  The returned array always has <code>n</code>
columns.  The number of rows depends on the specified <code>mode</code>, as
explained above.</p>
<p>In the default 'full' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>A[i, j] == (a[i-j] if (0 &lt;= (i-j) &lt; m) else 0)
</code></pre></div>


<p>where <code>m = len(a)</code>.  Suppose, for example, the input array is
<code>[x, y, z]</code>.  The convolution matrix has the form::</p>
<div class="codehilite"><pre><span></span><code>[x, 0, 0, ..., 0, 0]
[y, x, 0, ..., 0, 0]
[z, y, x, ..., 0, 0]
...
[0, 0, 0, ..., x, 0]
[0, 0, 0, ..., y, x]
[0, 0, 0, ..., z, y]
[0, 0, 0, ..., 0, z]
</code></pre></div>


<p>In 'valid' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>A[i, j] == (a[i-j+m-1] if (0 &lt;= (i-j+m-1) &lt; m) else 0)
</code></pre></div>


<p>This corresponds to a matrix whose rows are the subset of those from
the 'full' case where all the coefficients in <code>a</code> are contained in the
row.  For input <code>[x, y, z]</code>, this array looks like::</p>
<div class="codehilite"><pre><span></span><code>[z, y, x, 0, 0, ..., 0, 0, 0]
[0, z, y, x, 0, ..., 0, 0, 0]
[0, 0, z, y, x, ..., 0, 0, 0]
...
[0, 0, 0, 0, 0, ..., x, 0, 0]
[0, 0, 0, 0, 0, ..., y, x, 0]
[0, 0, 0, 0, 0, ..., z, y, x]
</code></pre></div>


<p>In the 'same' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>d = (m - 1) // 2
A[i, j] == (a[i-j+d] if (0 &lt;= (i-j+d) &lt; m) else 0)
</code></pre></div>


<p>The typical application of the 'same' mode is when one has a signal of
length <code>n</code> (with <code>n</code> greater than <code>len(a)</code>), and the desired output
is a filtered signal that is still of length <code>n</code>.</p>
<p>For input <code>[x, y, z]</code>, this array looks like::</p>
<div class="codehilite"><pre><span></span><code>[y, x, 0, 0, ..., 0, 0, 0]
[z, y, x, 0, ..., 0, 0, 0]
[0, z, y, x, ..., 0, 0, 0]
[0, 0, z, y, ..., 0, 0, 0]
...
[0, 0, 0, 0, ..., y, x, 0]
[0, 0, 0, 0, ..., z, y, x]
[0, 0, 0, 0, ..., 0, z, y]
</code></pre></div>


<p>.. versionadded:: 1.5.0</p>
<h4>References</h4>
<p>.. [1] 'Convolution', https://en.wikipedia.org/wiki/Convolution</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">convolution_matrix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<p>Compare multiplication by <code>A</code> with the use of <code>numpy.convolve</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">2.</span> <span class="p">,</span>   <span class="mf">6.</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">12.5</span><span class="p">,</span>   <span class="mf">8.</span> <span class="p">])</span>
</code></pre></div>

<p>Verify that <code>A @ x</code> produced the same result as applying the
convolution function.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">2.</span> <span class="p">,</span>   <span class="mf">6.</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">12.5</span><span class="p">,</span>   <span class="mf">8.</span> <span class="p">])</span>
</code></pre></div>

<p>For comparison to the case <code>mode='same'</code> shown above, here are the
matrices produced by <code>mode='full'</code> and <code>mode='valid'</code> for the
same coefficients and size.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="dft">dft<a class="headerlink" href="#dft" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dft</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dft</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Discrete Fourier transform matrix.</p>
<p>Create the matrix that computes the discrete Fourier transform of a
sequence [1]_. The nth primitive root of unity used to generate the
matrix is exp(-2<em>pi</em>i/n), where i = sqrt(-1).</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    Size the matrix to create.</p>
</li>
<li>
<p><strong>scale : str, optional</strong>
    Must be None, 'sqrtn', or 'n'.
    If <code>scale</code> is 'sqrtn', the matrix is divided by <code>sqrt(n)</code>.
    If <code>scale</code> is 'n', the matrix is divided by <code>n</code>.
    If <code>scale</code> is None (the default), the matrix is not normalized, and the
    return value is simply the Vandermonde matrix of the roots of unity.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>m : (n, n) ndarray</strong>
    The DFT matrix.</li>
</ul>
<h4>Notes</h4>
<p>When <code>scale</code> is None, multiplying a vector by the matrix returned by
<code>dft</code> is mathematically equivalent to (but much less efficient than)
the calculation performed by <code>scipy.fft.fft</code>.</p>
<p>.. versionadded:: 0.14.0</p>
<h4>References</h4>
<p>.. [1] 'DFT matrix', https://en.wikipedia.org/wiki/DFT_matrix</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">dft</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># for compact output</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">dft</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">@</span> <span class="n">x</span>  <span class="c1"># Compute the DFT of x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">9.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.12</span><span class="o">-</span><span class="mf">0.81</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">+</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">-</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12</span><span class="o">+</span><span class="mf">0.81</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>Verify that <code>m @ x</code> is the same as <code>fft(x)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">fft</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c1"># Same result as m @ x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">9.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.12</span><span class="o">-</span><span class="mf">0.81</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">+</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">-</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12</span><span class="o">+</span><span class="mf">0.81</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="fiedler">fiedler<a class="headerlink" href="#fiedler" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fiedler</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a symmetric Fiedler matrix</p>
<p>Given an sequence of numbers <code>a</code>, Fiedler matrices have the structure
<code>F[i, j] = np.abs(a[i] - a[j])</code>, and hence zero diagonals and nonnegative
entries. A Fiedler matrix has a dominant positive eigenvalue and other
eigenvalues are negative. Although not valid generally, for certain inputs,
the inverse and the determinant can be derived explicitly as given in [1]_.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (n,) array_like</strong>
    coefficient array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>F : (n, n) ndarray</strong></li>
</ul>
<h4>See Also</h4>
<p>circulant, toeplitz</p>
<h4>Notes</h4>
<p>.. versionadded:: 1.3.0</p>
<h4>References</h4>
<p>.. [1] J. Todd, 'Basic Numerical Mathematics: Vol.2 : Numerical Algebra',
    1977, Birkhauser, :doi:<code>10.1007/978-3-0348-7286-7</code></p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">det</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">fiedler</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">77</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">fiedler</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">76</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">73</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">65</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">76</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

<p>The explicit formulas for determinant and inverse seem to hold only for
monotonically increasing/decreasing arrays. Note the tridiagonal structure
and the corners.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># cleanup the numerical noise for display</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.16008772</span><span class="p">,</span>  <span class="mf">0.16666667</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.00657895</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.16666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.22916667</span><span class="p">,</span>  <span class="mf">0.0625</span>    <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.0625</span>    <span class="p">,</span> <span class="o">-</span><span class="mf">0.07765152</span><span class="p">,</span>  <span class="mf">0.01515152</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.01515152</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03077652</span><span class="p">,</span>  <span class="mf">0.015625</span>  <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00657895</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.015625</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.00904605</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mf">15409151.999999998</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">15409152</span>
</code></pre></div>

</details>
<h3 id="fiedler_companion">fiedler_companion<a class="headerlink" href="#fiedler_companion" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fiedler_companion</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler_companion</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a Fiedler companion matrix</p>
<p>Given a polynomial coefficient array <code>a</code>, this function forms a
pentadiagonal matrix with a special structure whose eigenvalues coincides
with the roots of <code>a</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (N,) array_like</strong>
    1-D array of polynomial coefficients in descending order with a nonzero
    leading coefficient. For <code>N &lt; 2</code>, an empty array is returned.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (N-1, N-1) ndarray</strong>
    Resulting companion matrix</li>
</ul>
<h4>Notes</h4>
<p>Similar to <code>companion</code> the leading coefficient should be nonzero. In the case
the leading coefficient is not 1, other coefficients are rescaled before
the array generation. To avoid numerical issues, it is best to provide a
monic polynomial.</p>
<p>.. versionadded:: 1.3.0</p>
<h4>See Also</h4>
<p>companion</p>
<h4>References</h4>
<p>.. [1] M. Fiedler, ' A note on companion matrices', Linear Algebra and its
    Applications, 2003, :doi:<code>10.1016/S0024-3795(03)00548-2</code></p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">fiedler_companion</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># [1., -16., 86., -176., 105.]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">fiedler_companion</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fc</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">16.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">86.</span><span class="p">,</span>    <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">0.</span><span class="p">,</span>  <span class="mf">176.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">105.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">0.</span><span class="p">,</span>    <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">5.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="hadamard">hadamard<a class="headerlink" href="#hadamard" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hadamard</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hadamard</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an Hadamard matrix.</p>
<p>Constructs an n-by-n Hadamard matrix, using Sylvester's
construction. <code>n</code> must be a power of 2.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The order of the matrix. <code>n</code> must be a power of 2.</p>
</li>
<li>
<p><strong>dtype : dtype, optional</strong>
    The data type of the array to be constructed.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>H : (n, n) ndarray</strong>
    The Hadamard matrix.</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hadamard</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="hankel">hankel<a class="headerlink" href="#hankel" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hankel</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hankel matrix.</p>
<p>The Hankel matrix has constant anti-diagonals, with <code>c</code> as its
first column and <code>r</code> as its last row. If <code>r</code> is not given, then
<code>r = zeros_like(c)</code> is assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    First column of the matrix. Whatever the actual shape of <code>c</code>, it
    will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>r : array_like, optional</strong>
    Last row of the matrix. If None, <code>r = zeros_like(c)</code> is assumed.
    r[0] is ignored; the last row of the returned matrix is
    <code>[c[-1], r[1:]]</code>. Whatever the actual shape of <code>r</code>, it will be
    converted to a 1-D array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (len(c), len(r)) ndarray</strong>
    The Hankel matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>toeplitz : Toeplitz matrix</strong></p>
</li>
<li>
<p><strong>circulant : circulant matrix</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hankel</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hankel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">99</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hankel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="helmert">helmert<a class="headerlink" href="#helmert" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function helmert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">helmert</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">full</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create an Helmert matrix of order <code>n</code>.</p>
<p>This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the array to create.</p>
</li>
<li>
<p><strong>full : bool, optional</strong>
    If True the (n, n) ndarray will be returned.
    Otherwise the submatrix that does not include the first
    row will be returned.</p>
</li>
<li>
<p><strong>Default: False.</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>M : ndarray</strong>
    The Helmert matrix.
    The shape is (n, n) or (n-1, n) depending on the <code>full</code> argument.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">helmert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">helmert</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.40824829</span><span class="p">,</span>  <span class="mf">0.40824829</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81649658</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.28867513</span><span class="p">,</span>  <span class="mf">0.28867513</span><span class="p">,</span>  <span class="mf">0.28867513</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8660254</span> <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.89442719</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="hilbert">hilbert<a class="headerlink" href="#hilbert" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hilbert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span>
  <span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Hilbert matrix of order <code>n</code>.</p>
<p>Returns the <code>n</code> by <code>n</code> array with entries <code>h[i,j] = 1 / (i + j + 1)</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>n : int</strong>
    The size of the array to create.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>h : (n, n) ndarray</strong>
    The Hilbert matrix.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>invhilbert : Compute the inverse of a Hilbert matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.10.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hilbert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>        <span class="p">,</span>  <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">,</span>  <span class="mf">0.25</span>      <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.33333333</span><span class="p">,</span>  <span class="mf">0.25</span>      <span class="p">,</span>  <span class="mf">0.2</span>       <span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="invhilbert">invhilbert<a class="headerlink" href="#invhilbert" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function invhilbert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invhilbert</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the Hilbert matrix of order <code>n</code>.</p>
<p>The entries in the inverse of a Hilbert matrix are integers. When <code>n</code>
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers. The <code>exact</code> argument provides two options for
dealing with these large integers.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The order of the Hilbert matrix.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If False, the data type of the array that is returned is np.float64,
    and the array is an approximation of the inverse.
    If True, the array is the exact integer inverse array. To represent
    the exact inverse when n &gt; 14, the returned array is an object array
    of long integers. For n &lt;= 14, the exact inverse is returned as an
    array with data type np.int64.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>invh : (n, n) ndarray</strong>
    The data type of the array is np.float64 if <code>exact</code> is False.
    If <code>exact</code> is True, the data type is either np.int64 (for n &lt;= 14)
    or object (for n &gt; 14). In the latter case, the objects in the
    array will be long integers.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>hilbert : Create a Hilbert matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.10.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">invhilbert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>   <span class="mf">16.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">120.</span><span class="p">,</span>   <span class="mf">240.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">140.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">120.</span><span class="p">,</span>  <span class="mf">1200.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2700.</span><span class="p">,</span>  <span class="mf">1680.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">240.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2700.</span><span class="p">,</span>  <span class="mf">6480.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4200.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">140.</span><span class="p">,</span>  <span class="mf">1680.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4200.</span><span class="p">,</span>  <span class="mf">2800.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>   <span class="mi">16</span><span class="p">,</span>  <span class="o">-</span><span class="mi">120</span><span class="p">,</span>   <span class="mi">240</span><span class="p">,</span>  <span class="o">-</span><span class="mi">140</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span>  <span class="mi">1200</span><span class="p">,</span> <span class="o">-</span><span class="mi">2700</span><span class="p">,</span>  <span class="mi">1680</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mi">240</span><span class="p">,</span> <span class="o">-</span><span class="mi">2700</span><span class="p">,</span>  <span class="mi">6480</span><span class="p">,</span> <span class="o">-</span><span class="mi">4200</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">140</span><span class="p">,</span>  <span class="mi">1680</span><span class="p">,</span> <span class="o">-</span><span class="mi">4200</span><span class="p">,</span>  <span class="mi">2800</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">16</span><span class="p">)[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mf">4.2475099528537506e+19</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">42475099528537378560</span>
</code></pre></div>

</details>
<h3 id="invpascal">invpascal<a class="headerlink" href="#invpascal" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function invpascal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invpascal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the inverse of the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the matrix to create; that is, the result is an n x n
    matrix.</p>
</li>
<li>
<p><strong>kind : str, optional</strong>
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If <code>exact</code> is True, the result is either an array of type
    <code>numpy.int64</code> (if <code>n</code> &lt;= 35) or an object array of Python integers.
    If <code>exact</code> is False, the coefficients in the matrix are computed using
    <code>scipy.special.comb</code> with <code>exact=False</code>. The result will be a floating
    point array, and for large <code>n</code>, the values in the array will not be the
    exact coefficients.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>invp : (n, n) ndarray</strong>
    The inverse of the Pascal matrix.</li>
</ul>
<h4>See Also</h4>
<p>pascal</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.16.0</p>
<h4>References</h4>
<p>.. [1] 'Pascal matrix', https://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., 'The inverse of a Pascal matrix', Mathematical
       Gazette, 59(408), pp. 111-112, 1975.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">invpascal</span><span class="p">,</span> <span class="n">pascal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invp</span> <span class="o">=</span> <span class="n">invpascal</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invp</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>  <span class="o">-</span><span class="mi">5</span><span class="p">,</span>   <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>  <span class="mi">19</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>  <span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span>   <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span>  <span class="mi">17</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">,</span>   <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invp</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<p>An example of the use of <code>kind</code> and <code>exact</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">invpascal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="kron">kron<a class="headerlink" href="#kron" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function kron</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Kronecker product.</p>
<p>The result is the block matrix::</p>
<div class="codehilite"><pre><span></span><code>a[0,0]*b    a[0,1]*b  ... a[0,-1]*b
a[1,0]*b    a[1,1]*b  ... a[1,-1]*b
...
a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) ndarray</strong>
    Input array</p>
</li>
<li>
<p><strong>b : (P, Q) ndarray</strong>
    Input array</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (M<em>P, N</em>Q) ndarray</strong>
    Kronecker product of <code>a</code> and <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">kron</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kron</span><span class="p">(</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="leslie">leslie<a class="headerlink" href="#leslie" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function leslie</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leslie</span> <span class="o">:</span>
  <span class="n">f</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Leslie matrix.</p>
<p>Given the length n array of fecundity coefficients <code>f</code> and the length
n-1 array of survival coefficients <code>s</code>, return the associated Leslie
matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>f : (N,) array_like</strong>
    The 'fecundity' coefficients.</p>
</li>
<li>
<p><strong>s : (N-1,) array_like</strong>
    The 'survival' coefficients, has to be 1-D.  The length of <code>s</code>
    must be one less than the length of <code>f</code>, and it must be at least 1.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>L : (N, N) ndarray</strong>
    The array is zero except for the first row,
    which is <code>f</code>, and the first sub-diagonal, which is <code>s</code>.
    The data-type of the array will be the data-type of <code>f[0]+s[0]</code>.</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<p>The Leslie matrix is used to model discrete-time, age-structured
population growth [1]<em> [2]</em>. In a population with <code>n</code> age classes, two sets
of parameters define a Leslie matrix: the <code>n</code> 'fecundity coefficients',
which give the number of offspring per-capita produced by each age
class, and the <code>n</code> - 1 'survival coefficients', which give the
per-capita survival rate of each age class.</p>
<h4>References</h4>
<p>.. [1] P. H. Leslie, On the use of matrices in certain population
       mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
       population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
       (Dec. 1948)</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">leslie</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">leslie</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">0.1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.8</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.7</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="pascal">pascal<a class="headerlink" href="#pascal" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pascal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pascal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the matrix to create; that is, the result is an n x n
    matrix.</p>
</li>
<li>
<p><strong>kind : str, optional</strong>
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If <code>exact</code> is True, the result is either an array of type
    numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
    If <code>exact</code> is False, the coefficients in the matrix are computed using
    <code>scipy.special.comb</code> with <code>exact=False</code>. The result will be a floating
    point array, and the values in the array will not be the exact
    coefficients, but this version is much faster than <code>exact=True</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>p : (n, n) ndarray</strong>
    The Pascal matrix.</li>
</ul>
<h4>See Also</h4>
<p>invpascal</p>
<h4>Notes</h4>
<p>See https://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">pascal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">50</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">25477612258980856902730428600</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">comb</span><span class="p">(</span><span class="mi">98</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="mi">25477612258980856902730428600</span>
</code></pre></div>

</details>
<h3 id="toeplitz">toeplitz<a class="headerlink" href="#toeplitz" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function toeplitz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toeplitz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Toeplitz matrix.</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    First column of the matrix.  Whatever the actual shape of <code>c</code>, it
    will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>r : array_like, optional</strong>
    First row of the matrix. If None, <code>r = conjugate(c)</code> is assumed;
    in this case, if c[0] is real, the result is a Hermitian matrix.
    r[0] is ignored; the first row of the returned matrix is
    <code>[c[0], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
    converted to a 1-D array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (len(c), len(r)) ndarray</strong>
    The Toeplitz matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>circulant : circulant matrix</strong></p>
</li>
<li>
<p><strong>hankel : Hankel matrix</strong></p>
</li>
<li>
<p><strong>solve_toeplitz : Solve a Toeplitz system.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>The behavior when <code>c</code> or <code>r</code> is a scalar, or when <code>c</code> is complex and
<code>r</code> is None, was changed in version 0.8.0. The behavior in previous
versions was undocumented and is no longer supported.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">toeplitz</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">toeplitz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">toeplitz</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">4.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tri">tri<a class="headerlink" href="#tri" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tri</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tri</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct (N, M) matrix filled with ones at and below the kth diagonal.</p>
<p>The matrix has A[i,j] == 1 for i &lt;= j + k</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>N : int</strong>
    The size of the first dimension of the matrix.</p>
</li>
<li>
<p><strong>M : int or None, optional</strong>
    The size of the second dimension of the matrix. If <code>M</code> is None,
    <code>M = N</code> is assumed.</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Number of subdiagonal below which matrix is filled with ones.
    <code>k</code> = 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and <code>k</code> &gt; 0
    superdiagonal.</p>
</li>
<li>
<p><strong>dtype : dtype, optional</strong>
    Data type of the matrix.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tri : (N, M) ndarray</strong>
    Tri matrix.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tri</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tril">tril<a class="headerlink" href="#tril" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tril</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements above the kth diagonal zeroed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>m : array_like</strong>
    Matrix whose elements to return</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal above which to zero elements.
    <code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
    <code>k</code> &gt; 0 superdiagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tril : ndarray</strong>
    Return is the same shape and type as <code>m</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tril</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tril</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="triu_1">triu<a class="headerlink" href="#triu_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function triu</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the kth diagonal zeroed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>m : array_like</strong>
    Matrix whose elements to return</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal below which to zero elements.
    <code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
    <code>k</code> &gt; 0 superdiagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>triu : ndarray</strong>
    Return matrix with zeroed elements below the kth diagonal and has
    same shape and type as <code>m</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">triu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">triu</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="block_diag_1">block_diag<a class="headerlink" href="#block_diag_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function block_diag</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">block_diag</span> <span class="o">:</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a block diagonal matrix from provided arrays.</p>
<p>Given the inputs <code>A</code>, <code>B</code> and <code>C</code>, the output will have these
arrays arranged on the diagonal::</p>
<div class="codehilite"><pre><span></span><code>[[A, 0, 0],
 [0, B, 0],
 [0, 0, C]]
</code></pre></div>


<h4>Parameters</h4>
<p>A, B, C, ... : array_like, up to 2-D
    Input arrays.  A 1-D array or array_like sequence of length <code>n</code> is
    treated as a 2-D array with shape <code>(1,n)</code>.</p>
<h4>Returns</h4>
<ul>
<li><strong>D : ndarray</strong>
    Array with <code>A</code>, <code>B</code>, <code>C</code>, ... on the diagonal. <code>D</code> has the
    same dtype as <code>A</code>.</li>
</ul>
<h4>Notes</h4>
<p>If all the input arrays are square, the output is known as a
block diagonal matrix.</p>
<p>Empty sequences (i.e., array-likes of zero size) will not be ignored.
Noteworthy, both [] and [[]] are treated as matrices with shape <code>(1,0)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="o">...</span>      <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">block_diag</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cdf2rdf_1">cdf2rdf<a class="headerlink" href="#cdf2rdf_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cdf2rdf</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cdf2rdf</span> <span class="o">:</span>
  <span class="n">w</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Converts complex eigenvalues <code>w</code> and eigenvectors <code>v</code> to real
eigenvalues in a block diagonal form <code>wr</code> and the associated real
eigenvectors <code>vr</code>, such that::</p>
<div class="codehilite"><pre><span></span><code>vr @ wr = X @ vr
</code></pre></div>


<p>continues to hold, where <code>X</code> is the original array for which <code>w</code> and
<code>v</code> are the eigenvalues and eigenvectors.</p>
<p>.. versionadded:: 1.1.0</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>w : (..., M) array_like</strong>
    Complex or real eigenvalues, an array or stack of arrays</p>
<p>Conjugate pairs must not be interleaved, else the wrong result
will be produced. So <code>[1+1j, 1, 1-1j]</code> will give a correct result,
but <code>[1+1j, 2+1j, 1-1j, 2-1j]</code> will not.</p>
</li>
<li>
<p><strong>v : (..., M, M) array_like</strong>
    Complex or real eigenvectors, a square array or stack of square arrays.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>wr : (..., M, M) ndarray</strong>
    Real diagonal block form of eigenvalues</p>
</li>
<li>
<p><strong>vr : (..., M, M) ndarray</strong>
    Real eigenvectors associated with <code>wr</code></p>
</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig : Eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>rsf2csf : Convert real Schur form to complex Schur form</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p><code>w</code>, <code>v</code> must be the eigenstructure for some <em>real</em> matrix <code>X</code>.
For example, obtained by <code>w, v = scipy.linalg.eig(X)</code> or
<code>w, v = numpy.linalg.eig(X)</code> in which case <code>X</code> can also represent
stacked arrays.</p>
<p>.. versionadded:: 1.1.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">+</span><span class="mf">5.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">-</span><span class="mf">5.</span><span class="n">j</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="o">-</span><span class="mf">0.40016</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="o">+</span><span class="mf">0.40016</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.00000</span><span class="o">-</span><span class="mf">0.64788</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.64788</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00000</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>     <span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">wr</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cdf2rdf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">wr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">0.40016</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01906</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="p">,</span>  <span class="mf">0.</span>     <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">0.64788</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">vr</span> <span class="o">@</span> <span class="n">wr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">1.69593</span><span class="p">,</span>  <span class="mf">1.9246</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">2.59153</span><span class="p">,</span>  <span class="mf">3.23942</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">3.23942</span><span class="p">,</span>  <span class="mf">2.59153</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span> <span class="o">@</span> <span class="n">vr</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>     <span class="p">,</span>  <span class="mf">1.69593</span><span class="p">,</span>  <span class="mf">1.9246</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span>  <span class="mf">2.59153</span><span class="p">,</span>  <span class="mf">3.23942</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>     <span class="p">,</span> <span class="o">-</span><span class="mf">3.23942</span><span class="p">,</span>  <span class="mf">2.59153</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cho_factor_1">cho_factor<a class="headerlink" href="#cho_factor_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_factor</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_factor</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix, to use in cho_solve</p>
<p>Returns a matrix containing the Cholesky decomposition,
<code>A = L L*</code> or <code>A = U* U</code> of a Hermitian positive-definite matrix <code>a</code>.
The return value can be directly used as the first parameter to cho_solve.</p>
<p>.. warning::
    The returned matrix also contains random data in the entries not
    used by the Cholesky decomposition. If you need to zero these
    entries, use the function <code>cholesky</code> instead.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether to compute the upper or lower triangular Cholesky factorization
    (Default: upper-triangular)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>c : (M, M) ndarray</strong>
    Matrix whose upper or lower triangle contains the Cholesky factor
    of <code>a</code>. Other parts of the matrix contain random data.</p>
</li>
<li>
<p><strong>lower : bool</strong>
    Flag indicating whether the factor is in the lower or upper triangle</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if decomposition fails.</p>
<h4>See also</h4>
<ul>
<li><strong>cho_solve : Solve a linear set equations using the Cholesky factorization</strong>
            of a matrix.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cho_factor</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">0.33333333</span><span class="p">,</span> <span class="mf">1.66666667</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">3.</span>        <span class="p">,</span> <span class="mf">2.44948974</span><span class="p">,</span> <span class="mf">1.90515869</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.27216553</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span>        <span class="p">,</span> <span class="mf">5.</span>        <span class="p">,</span> <span class="mf">2.29330749</span><span class="p">,</span> <span class="mf">0.8559528</span> <span class="p">],</span>
       <span class="p">[</span><span class="mf">5.</span>        <span class="p">,</span> <span class="mf">1.</span>        <span class="p">,</span> <span class="mf">2.</span>        <span class="p">,</span> <span class="mf">1.55418563</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span> <span class="n">triu</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cho_solve_1">cho_solve<a class="headerlink" href="#cho_solve_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">c_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations A x = b, given the Cholesky factorization of A.</p>
<h4>Parameters</h4>
<p>(c, lower) : tuple, (array, bool)
    Cholesky factorization of a, as given by cho_factor</p>
<ul>
<li>
<p><strong>b : array</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in b (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    The solution to the system A x = b</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cho_factor : Cholesky factorization of a matrix</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cho_factor</span><span class="p">,</span> <span class="n">cho_solve</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">low</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cho_solve_banded_1">cho_solve_banded<a class="headerlink" href="#cho_solve_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cho_solve_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cho_solve_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">cb_and_lower</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the linear equations <code>A x = b</code>, given the Cholesky factorization of
the banded hermitian <code>A</code>.</p>
<h4>Parameters</h4>
<p>(cb, lower) : tuple, (ndarray, bool)
    <code>cb</code> is the Cholesky factorization of A, as given by cholesky_banded.
    <code>lower</code> must be the same value that was given to cholesky_banded.</p>
<ul>
<li>
<p><strong>b : array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    If True, the function will overwrite the values in <code>b</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    The solution to the system A x = b</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cholesky_banded : Cholesky factorization of a banded matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky_banded</span><span class="p">,</span> <span class="n">cho_solve_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cholesky_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cho_solve_banded</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="cholesky_1">cholesky<a class="headerlink" href="#cholesky_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cholesky</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the Cholesky decomposition of a matrix.</p>
<p>Returns the Cholesky decomposition, :math:<code>A = L L^*</code> or
:math:<code>A = U^* U</code> of a Hermitian positive-definite matrix A.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether to compute the upper- or lower-triangular Cholesky
    factorization.  Default is upper-triangular.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (M, M) ndarray</strong>
    Upper- or lower-triangular Cholesky factor of <code>a</code>.</li>
</ul>
<h4>Raises</h4>
<ul>
<li><strong>LinAlgError : if decomposition fails.</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">],[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">@</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.</span><span class="o">-</span><span class="mf">2.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">5.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cholesky_banded_1">cholesky_banded<a class="headerlink" href="#cholesky_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cholesky_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cholesky_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cholesky decompose a banded Hermitian positive-definite matrix</p>
<p>The matrix a is stored in ab either in lower-diagonal or upper-
diagonal ordered form::</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>Example of ab (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>ab : (u + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in ab (may enhance performance)</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (u + 1, M) ndarray</strong>
    Cholesky factorization of a, in the same banded format as ab</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>cho_solve_banded : Solve a linear set equations, given the Cholesky factorization</strong>
            of a banded hermitian.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cholesky_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">allclose</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">diag</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Ab</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cholesky_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="circulant_1">circulant<a class="headerlink" href="#circulant_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function circulant</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">circulant</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a circulant matrix.</p>
<h4>Parameters</h4>
<ul>
<li><strong>c : (N,) array_like</strong>
    1-D array, the first column of the matrix.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (N, N) ndarray</strong>
    A circulant matrix whose first column is <code>c</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>toeplitz : Toeplitz matrix</strong></p>
</li>
<li>
<p><strong>hankel : Hankel matrix</strong></p>
</li>
<li>
<p><strong>solve_circulant : Solve a circulant system.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">circulant</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">circulant</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="clarkson_woodruff_transform">clarkson_woodruff_transform<a class="headerlink" href="#clarkson_woodruff_transform" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function clarkson_woodruff_transform</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">clarkson_woodruff_transform</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">seed</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T_numpy_random_RandomState_instance</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">input_matrix</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">sketch_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>'
Applies a Clarkson-Woodruff Transform/sketch to the input matrix.</p>
<p>Given an input_matrix <code>A</code> of size <code>(n, d)</code>, compute a matrix <code>A'</code> of
size (sketch_size, d) so that</p>
<p>.. math:: |Ax| \approx |A'x|</p>
<p>with high probability via the Clarkson-Woodruff Transform, otherwise
known as the CountSketch matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>input_matrix: array_like</strong>
    Input matrix, of shape <code>(n, d)</code>.</p>
</li>
<li>
<p><strong>sketch_size: int</strong>
    Number of rows for the sketch.</p>
</li>
<li>
<p><strong>seed : None or int or <code>numpy.random.RandomState</code> instance, optional</strong>
    This parameter defines the <code>RandomState</code> object to use for drawing
    random variates.
    If None (or <code>np.random</code>), the global <code>np.random</code> state is used.
    If integer, it is used to seed the local <code>RandomState</code> instance.
    Default is None.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A' : array_like</strong>
    Sketch of the input matrix <code>A</code>, of size <code>(sketch_size, d)</code>.</li>
</ul>
<h4>Notes</h4>
<p>To make the statement</p>
<p>.. math:: |Ax| \approx |A'x|</p>
<p>precise, observe the following result which is adapted from the
proof of Theorem 14 of [2]_ via Markov's Inequality. If we have
a sketch size <code>sketch_size=k</code> which is at least</p>
<p>.. math:: k \geq \frac{2}{\epsilon^2\delta}</p>
<p>Then for any fixed vector <code>x</code>,</p>
<p>.. math:: |Ax| = (1\pm\epsilon)|A'x|</p>
<p>with probability at least one minus delta.</p>
<p>This implementation takes advantage of sparsity: computing
a sketch takes time proportional to <code>A.nnz</code>. Data <code>A</code> which
is in <code>scipy.sparse.csc_matrix</code> format gives the quickest
computation time for sparse input.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">sketch_n_rows</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">200</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;coo&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SA</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span> <span class="c1"># fastest</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SB</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span> <span class="c1"># fast</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SC</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span> <span class="c1"># slower</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SD</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span> <span class="c1"># slowest</span>
</code></pre></div>

<p>That said, this method does perform well on dense inputs, just slower
on a relative scale.</p>
<h4>Examples</h4>
<p>Given a big dense matrix <code>A</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">sketch_n_rows</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sketch</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sketch</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm_sketch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sketch</span><span class="p">)</span>
</code></pre></div>

<p>Now with high probability, the true norm <code>norm_A</code> is close to
the sketched norm <code>norm_sketch</code> in absolute value.</p>
<p>Similarly, applying our sketch preserves the solution to a linear
regression of :math:<code>\min \|Ax - b\|</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">,</span> <span class="n">sketch_n_rows</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_columns</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_rows</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SAb</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">clarkson_woodruff_transform</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">sketch_n_rows</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">SA</span><span class="p">,</span> <span class="n">Sb</span> <span class="o">=</span> <span class="n">SAb</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">SAb</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_sketched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">SA</span><span class="p">,</span> <span class="n">Sb</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

<p>As with the matrix norm example, <code>np.linalg.norm(A @ x - b)</code>
is close to <code>np.linalg.norm(A @ x_sketched - b)</code> with high
probability.</p>
<h4>References</h4>
<p>.. [1] Kenneth L. Clarkson and David P. Woodruff. Low rank approximation and
       regression in input sparsity time. In STOC, 2013.</p>
<p>.. [2] David P. Woodruff. Sketching as a tool for numerical linear algebra.
       In Foundations and Trends in Theoretical Computer Science, 2014.</p>
</details>
<h3 id="companion_1">companion<a class="headerlink" href="#companion_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function companion</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">companion</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a companion matrix.</p>
<p>Create the companion matrix [1]_ associated with the polynomial whose
coefficients are given in <code>a</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (N,) array_like</strong>
    1-D array of polynomial coefficients. The length of <code>a</code> must be
    at least two, and <code>a[0]</code> must not be zero.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (N-1, N-1) ndarray</strong>
    The first row of <code>c</code> is <code>-a[1:]/a[0]</code>, and the first
    sub-diagonal is all ones.  The data-type of the array is the same
    as the data-type of <code>1.0*a[0]</code>.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If any of the following are true: a) <code>a.ndim != 1</code>;
    b) <code>a.size &lt; 2</code>; c) <code>a[0] == 0</code>.</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>References</h4>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
    Cambridge University Press, 1999, pp. 146-7.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">companion</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">companion</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">31.</span><span class="p">,</span>  <span class="mf">30.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="convolution_matrix_1">convolution_matrix<a class="headerlink" href="#convolution_matrix_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function convolution_matrix</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">convolution_matrix</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a convolution matrix.</p>
<p>Constructs the Toeplitz matrix representing one-dimensional
convolution [1]_.  See the notes below for details.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (m,) array_like</strong>
    The 1-D array to convolve.</p>
</li>
<li>
<p><strong>n : int</strong>
    The number of columns in the resulting matrix.  It gives the length
    of the input to be convolved with <code>a</code>.  This is analogous to the
    length of <code>v</code> in <code>numpy.convolve(a, v)</code>.</p>
</li>
<li>
<p><strong>mode : str</strong>
    This is analogous to <code>mode</code> in <code>numpy.convolve(v, a, mode)</code>.
    It must be one of ('full', 'valid', 'same').
    See below for how <code>mode</code> determines the shape of the result.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (k, n) ndarray</strong>
    The convolution matrix whose row count <code>k</code> depends on <code>mode</code>::<div class="codehilite"><pre><span></span><code>=======  =========================
 mode    k
=======  =========================
&#39;full&#39;   m + n -1
&#39;same&#39;   max(m, n)
&#39;valid&#39;  max(m, n) - min(m, n) + 1
=======  =========================
</code></pre></div>


</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>toeplitz : Toeplitz matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>The code::</p>
<div class="codehilite"><pre><span></span><code>A = convolution_matrix(a, n, mode)
</code></pre></div>


<p>creates a Toeplitz matrix <code>A</code> such that <code>A @ v</code> is equivalent to
using <code>convolve(a, v, mode)</code>.  The returned array always has <code>n</code>
columns.  The number of rows depends on the specified <code>mode</code>, as
explained above.</p>
<p>In the default 'full' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>A[i, j] == (a[i-j] if (0 &lt;= (i-j) &lt; m) else 0)
</code></pre></div>


<p>where <code>m = len(a)</code>.  Suppose, for example, the input array is
<code>[x, y, z]</code>.  The convolution matrix has the form::</p>
<div class="codehilite"><pre><span></span><code>[x, 0, 0, ..., 0, 0]
[y, x, 0, ..., 0, 0]
[z, y, x, ..., 0, 0]
...
[0, 0, 0, ..., x, 0]
[0, 0, 0, ..., y, x]
[0, 0, 0, ..., z, y]
[0, 0, 0, ..., 0, z]
</code></pre></div>


<p>In 'valid' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>A[i, j] == (a[i-j+m-1] if (0 &lt;= (i-j+m-1) &lt; m) else 0)
</code></pre></div>


<p>This corresponds to a matrix whose rows are the subset of those from
the 'full' case where all the coefficients in <code>a</code> are contained in the
row.  For input <code>[x, y, z]</code>, this array looks like::</p>
<div class="codehilite"><pre><span></span><code>[z, y, x, 0, 0, ..., 0, 0, 0]
[0, z, y, x, 0, ..., 0, 0, 0]
[0, 0, z, y, x, ..., 0, 0, 0]
...
[0, 0, 0, 0, 0, ..., x, 0, 0]
[0, 0, 0, 0, 0, ..., y, x, 0]
[0, 0, 0, 0, 0, ..., z, y, x]
</code></pre></div>


<p>In the 'same' mode, the entries of <code>A</code> are given by::</p>
<div class="codehilite"><pre><span></span><code>d = (m - 1) // 2
A[i, j] == (a[i-j+d] if (0 &lt;= (i-j+d) &lt; m) else 0)
</code></pre></div>


<p>The typical application of the 'same' mode is when one has a signal of
length <code>n</code> (with <code>n</code> greater than <code>len(a)</code>), and the desired output
is a filtered signal that is still of length <code>n</code>.</p>
<p>For input <code>[x, y, z]</code>, this array looks like::</p>
<div class="codehilite"><pre><span></span><code>[y, x, 0, 0, ..., 0, 0, 0]
[z, y, x, 0, ..., 0, 0, 0]
[0, z, y, x, ..., 0, 0, 0]
[0, 0, z, y, ..., 0, 0, 0]
...
[0, 0, 0, 0, ..., y, x, 0]
[0, 0, 0, 0, ..., z, y, x]
[0, 0, 0, 0, ..., 0, z, y]
</code></pre></div>


<p>.. versionadded:: 1.5.0</p>
<h4>References</h4>
<p>.. [1] 'Convolution', https://en.wikipedia.org/wiki/Convolution</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">convolution_matrix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<p>Compare multiplication by <code>A</code> with the use of <code>numpy.convolve</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">2.</span> <span class="p">,</span>   <span class="mf">6.</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">12.5</span><span class="p">,</span>   <span class="mf">8.</span> <span class="p">])</span>
</code></pre></div>

<p>Verify that <code>A @ x</code> produced the same result as applying the
convolution function.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">2.</span> <span class="p">,</span>   <span class="mf">6.</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">12.5</span><span class="p">,</span>   <span class="mf">8.</span> <span class="p">])</span>
</code></pre></div>

<p>For comparison to the case <code>mode='same'</code> shown above, here are the
matrices produced by <code>mode='full'</code> and <code>mode='valid'</code> for the
same coefficients and size.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">convolution_matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="coshm_1">coshm<a class="headerlink" href="#coshm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function coshm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">coshm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>coshm : (N, N) ndarray</strong>
    Hyperbolic matrix cosine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">11.24592233</span><span class="p">,</span>  <span class="mf">38.76236492</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">12.92078831</span><span class="p">,</span>  <span class="mf">50.00828725</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cosm_1">cosm<a class="headerlink" href="#cosm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cosm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cosm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix cosine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>cosm : (N, N) ndarray</strong>
    Matrix cosine of A</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="cossin">cossin<a class="headerlink" href="#cossin" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function cossin</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cossin</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">q</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">separate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">swap_sign</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_u</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_vh</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.</p>
<p>X is an <code>(m, m)</code> orthogonal/unitary matrix, partitioned as the following
where upper left block has the shape of <code>(p, q)</code>::</p>
<div class="codehilite"><pre><span></span><code>                           ┌                   ┐
                           │ I  0  0 │ 0  0  0 │
┌           ┐   ┌         ┐│ 0  C  0 │ 0 -S  0 │┌         ┐*
│ X11 │ X12 │   │ U1 │    ││ 0  0  0 │ 0  0 -I ││ V1 │    │
│ ────┼──── │ = │────┼────││─────────┼─────────││────┼────│
│ X21 │ X22 │   │    │ U2 ││ 0  0  0 │ I  0  0 ││    │ V2 │
└           ┘   └         ┘│ 0  S  0 │ 0  C  0 │└         ┘
                           │ 0  0  I │ 0  0  0 │
                           └                   ┘
</code></pre></div>


<p><code>U1</code>, <code>U2</code>, <code>V1</code>, <code>V2</code> are square orthogonal/unitary matrices of
dimensions <code>(p,p)</code>, <code>(m-p,m-p)</code>, <code>(q,q)</code>, and <code>(m-q,m-q)</code>
respectively, and <code>C</code> and <code>S</code> are <code>(r, r)</code> nonnegative diagonal
matrices satisfying <code>C^2 + S^2 = I</code> where <code>r = min(p, m-p, q, m-q)</code>.</p>
<p>Moreover, the rank of the identity matrices are <code>min(p, q) - r</code>,
<code>min(p, m - q) - r</code>, <code>min(m - p, q) - r</code>, and <code>min(m - p, m - q) - r</code>
respectively.</p>
<p>X can be supplied either by itself and block specifications p, q or its
subblocks in an iterable from which the shapes would be derived. See the
examples below.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>X : array_like, iterable</strong>
    complex unitary or real orthogonal matrix to be decomposed, or iterable
    of subblocks <code>X11</code>, <code>X12</code>, <code>X21</code>, <code>X22</code>, when <code>p</code>, <code>q</code> are
    omitted.</p>
</li>
<li>
<p><strong>p : int, optional</strong>
    Number of rows of the upper left block <code>X11</code>, used only when X is
    given as an array.</p>
</li>
<li>
<p><strong>q : int, optional</strong>
    Number of columns of the upper left block <code>X11</code>, used only when X is
    given as an array.</p>
</li>
<li>
<p><strong>separate : bool, optional</strong>
    if <code>True</code>, the low level components are returned instead of the
    matrix factors, i.e. <code>(u1,u2)</code>, <code>theta</code>, <code>(v1h,v2h)</code> instead of
    <code>u</code>, <code>cs</code>, <code>vh</code>.</p>
</li>
<li>
<p><strong>swap_sign : bool, optional</strong>
    if <code>True</code>, the <code>-S</code>, <code>-I</code> block will be the bottom left,
    otherwise (by default) they will be in the upper right block.</p>
</li>
<li>
<p><strong>compute_u : bool, optional</strong>
    if <code>False</code>, <code>u</code> won't be computed and an empty array is returned.</p>
</li>
<li>
<p><strong>compute_vh : bool, optional</strong>
    if <code>False</code>, <code>vh</code> won't be computed and an empty array is returned.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>u : ndarray</strong>
    When <code>compute_u=True</code>, contains the block diagonal orthogonal/unitary
    matrix consisting of the blocks <code>U1</code> (<code>p</code> x <code>p</code>) and <code>U2</code>
    (<code>m-p</code> x <code>m-p</code>) orthogonal/unitary matrices. If <code>separate=True</code>,
    this contains the tuple of <code>(U1, U2)</code>.</p>
</li>
<li>
<p><strong>cs : ndarray</strong>
    The cosine-sine factor with the structure described above.
     If <code>separate=True</code>, this contains the <code>theta</code> array containing the
     angles in radians.</p>
</li>
<li>
<p><strong>vh : ndarray</strong>
    When <code>compute_vh=True`, contains the block diagonal orthogonal/unitary
    matrix consisting of the blocks</code>V1H<code>(</code>q<code>x</code>q<code>) and</code>V2H<code>(</code>m-q<code>x</code>m-q<code>) orthogonal/unitary matrices. If</code>separate=True<code>,
    this contains the tuple of</code>(V1H, V2H)``.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cossin</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">unitary_group</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">vdh</span> <span class="o">=</span> <span class="n">cossin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span> <span class="o">@</span> <span class="n">cs</span> <span class="o">@</span> <span class="n">vdh</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>Same can be entered via subblocks without the need of <code>p</code> and <code>q</code>. Also
let's skip the computation of <code>u</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ue</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">vdh</span> <span class="o">=</span> <span class="n">cossin</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">2</span><span class="p">:]),</span>
<span class="o">...</span>                      <span class="n">compute_u</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">ue</span><span class="p">)</span>
<span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span> <span class="o">@</span> <span class="n">cs</span> <span class="o">@</span> <span class="n">vdh</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<h4>References</h4>
<p>.. [1] : Brian D. Sutton. Computing the complete CS decomposition. Numer.
       Algorithms, 50(1):33-65, 2009.</p>
</details>
<h3 id="det_1">det<a class="headerlink" href="#det_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function det</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">det</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the determinant of a matrix</p>
<p>The determinant of a square matrix is a value derived arithmetically
from the coefficients of the matrix.</p>
<p>The determinant for a 3x3 matrix, for example, is computed as follows::</p>
<div class="codehilite"><pre><span></span><code>a    b    c
d    e    f = A
g    h    i

det(A) = a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A square matrix.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in a (may enhance performance).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>det : float or complex</strong>
    Determinant of <code>a</code>.</li>
</ul>
<h4>Notes</h4>
<p>The determinant is computed via LU factorization, LAPACK routine z/dgetrf.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">0.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">3.0</span>
</code></pre></div>

</details>
<h3 id="dft_1">dft<a class="headerlink" href="#dft_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function dft</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dft</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Discrete Fourier transform matrix.</p>
<p>Create the matrix that computes the discrete Fourier transform of a
sequence [1]_. The nth primitive root of unity used to generate the
matrix is exp(-2<em>pi</em>i/n), where i = sqrt(-1).</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    Size the matrix to create.</p>
</li>
<li>
<p><strong>scale : str, optional</strong>
    Must be None, 'sqrtn', or 'n'.
    If <code>scale</code> is 'sqrtn', the matrix is divided by <code>sqrt(n)</code>.
    If <code>scale</code> is 'n', the matrix is divided by <code>n</code>.
    If <code>scale</code> is None (the default), the matrix is not normalized, and the
    return value is simply the Vandermonde matrix of the roots of unity.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>m : (n, n) ndarray</strong>
    The DFT matrix.</li>
</ul>
<h4>Notes</h4>
<p>When <code>scale</code> is None, multiplying a vector by the matrix returned by
<code>dft</code> is mathematically equivalent to (but much less efficient than)
the calculation performed by <code>scipy.fft.fft</code>.</p>
<p>.. versionadded:: 0.14.0</p>
<h4>References</h4>
<p>.. [1] 'DFT matrix', https://en.wikipedia.org/wiki/DFT_matrix</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">dft</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># for compact output</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">dft</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.31</span><span class="o">+</span><span class="mf">0.95</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">+</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81</span><span class="o">-</span><span class="mf">0.59</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.31</span><span class="o">-</span><span class="mf">0.95</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">@</span> <span class="n">x</span>  <span class="c1"># Compute the DFT of x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">9.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.12</span><span class="o">-</span><span class="mf">0.81</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">+</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">-</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12</span><span class="o">+</span><span class="mf">0.81</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>Verify that <code>m @ x</code> is the same as <code>fft(x)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">fft</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c1"># Same result as m @ x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">9.</span>  <span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="p">,</span>  <span class="mf">0.12</span><span class="o">-</span><span class="mf">0.81</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">+</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.12</span><span class="o">-</span><span class="mf">3.44</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12</span><span class="o">+</span><span class="mf">0.81</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="diagsvd_1">diagsvd<a class="headerlink" href="#diagsvd_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function diagsvd</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">diagsvd</span> <span class="o">:</span>
  <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct the sigma matrix in SVD from singular values and size M, N.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>s : (M,) or (N,) array_like</strong>
    Singular values</p>
</li>
<li>
<p><strong>M : int</strong>
    Size of the matrix whose singular values are <code>s</code>.</p>
</li>
<li>
<p><strong>N : int</strong>
    Size of the matrix whose singular values are <code>s</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>S : (M, N) ndarray</strong>
    The S-matrix in the singular value decomposition</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>svdvals : Compute singular values of a matrix.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">diagsvd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># The array representing the computed svd</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">diagsvd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">diagsvd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eig_1">eig<a class="headerlink" href="#eig_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eig</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix::</p>
<div class="codehilite"><pre><span></span><code>a   vr[:,i] = w[i]        b   vr[:,i]
a.H vl[:,i] = w[i].conj() b.H vl[:,i]
</code></pre></div>


<p>where <code>.H</code> is the Hermitian conjugation.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    Right-hand side matrix in a generalized eigenvalue problem.
    Default is None, identity matrix is assumed.</p>
</li>
<li>
<p><strong>left : bool, optional</strong>
    Whether to calculate and return left eigenvectors.  Default is False.</p>
</li>
<li>
<p><strong>right : bool, optional</strong>
    Whether to calculate and return right eigenvectors.  Default is True.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.  Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite <code>b</code>; may improve performance.  Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>homogeneous_eigvals : bool, optional</strong>
    If True, return the eigenvalues in homogeneous coordinates.
    In this case <code>w</code> is a (2, M) array so that::</p>
<div class="codehilite"><pre><span></span><code>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]
</code></pre></div>


<p>Default is False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) or (2, M) double or complex ndarray</strong>
    The eigenvalues, each repeated according to its
    multiplicity. The shape is (M,) unless
    <code>homogeneous_eigvals=True</code>.</p>
</li>
<li>
<p><strong>vl : (M, M) double or complex ndarray</strong>
    The normalized left eigenvector corresponding to the eigenvalue
    <code>w[i]</code> is the column vl[:,i]. Only returned if <code>left=True</code>.</p>
</li>
<li>
<p><strong>vr : (M, M) double or complex ndarray</strong>
    The normalized right eigenvector corresponding to the eigenvalue
    <code>w[i]</code> is the column <code>vr[:,i]</code>.  Only returned if <code>right=True</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays.</strong></p>
</li>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">homogeneous_eigvals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">8.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># normalized left eigenvector</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span>        <span class="o">-</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># normalized right eigenvector</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.70710678</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">,</span> <span class="mf">0.70710678</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span>        <span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span>        <span class="o">-</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span>        <span class="o">+</span><span class="mf">0.70710678</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eig_banded_1">eig_banded<a class="headerlink" href="#eig_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eig_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eig_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">max_ev</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve real symmetric or complex Hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w and optionally right eigenvectors v of a::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a_band : (u+1, M) array_like</strong>
    The bands of the M by M matrix a.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Compute only the eigenvalues and no eigenvectors.
    (Default: calculate also eigenvectors)</p>
</li>
<li>
<p><strong>overwrite_a_band : bool, optional</strong>
    Discard data in a_band (may enhance performance)</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>max_ev : int, optional</strong>
    For select=='v', maximum number of eigenvalues expected.
    For other values of select, has no meaning.</p>
<p>In doubt, leave this parameter untouched.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</p>
</li>
<li>
<p><strong>v : (M, M) float or complex ndarray</strong>
    The normalized eigenvector corresponding to the eigenvalue w[i] is
    the column v[:,i].</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors of general arrays.</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eig_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.26200532</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">,</span> <span class="mf">12.53965359</span><span class="p">])</span>
</code></pre></div>

<p>Request only the eigenvalues between <code>[-3, 4]</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eig_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">select_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigh_1">eigh<a class="headerlink" href="#eigh_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_value</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve a standard or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues array <code>w</code> and optionally eigenvectors array <code>v</code> of
array <code>a</code>, where <code>b</code> is positive definite such that for every
eigenvalue λ (i-th entry of w) and its eigenvector <code>vi</code> (i-th column of
<code>v</code>) satisfies::</p>
<div class="codehilite"><pre><span></span><code>              a @ vi = λ * b @ vi
vi.conj().T @ a @ vi = λ
vi.conj().T @ b @ vi = 1
</code></pre></div>


<p>In the standard problem, <code>b</code> is assumed to be the identity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex Hermitian or real symmetric matrix whose eigenvalues and
    eigenvectors will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code> and, if applicable, <code>b</code>. (Default: lower)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)</p>
</li>
<li>
<p><strong>subset_by_index : iterable, optional</strong>
    If provided, this two-element iterable defines the start and the end
    indices of the desired eigenvalues (ascending order and 0-indexed).
    To return only the second smallest to fifth smallest eigenvalues,
    <code>[1, 4]</code> is used. <code>[n-3, n-1]</code> returns the largest three. Only
    available with 'evr', 'evx', and 'gvx' drivers. The entries are
    directly converted to integers via <code>int()</code>.</p>
</li>
<li>
<p><strong>subset_by_value : iterable, optional</strong>
    If provided, this two-element iterable defines the half-open interval
    <code>(a, b]</code> that, if any, only the eigenvalues between these values
    are returned. Only available with 'evr', 'evx', and 'gvx' drivers. Use
    <code>np.inf</code> for the unconstrained ends.</p>
</li>
<li>
<p><strong>driver: str, optional</strong>
    Defines which LAPACK driver should be used. Valid options are 'ev',
    'evd', 'evr', 'evx' for standard problems and 'gv', 'gvd', 'gvx' for
    generalized (where b is not None) problems. See the Notes section.</p>
</li>
<li>
<p><strong>type : int, optional</strong>
    For the generalized problems, this keyword specifies the problem type
    to be solved for <code>w</code> and <code>v</code> (only takes 1, 2, 3 as possible</p>
</li>
<li>
<p><strong>inputs)::</strong></p>
<div class="codehilite"><pre><span></span><code>1 =&gt;     a @ v = w @ b @ v
2 =&gt; a @ b @ v = w @ v
3 =&gt; b @ a @ v = w @ v
</code></pre></div>


<p>This keyword is ignored for standard problems.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in <code>b</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>turbo : bool, optional</strong>
    <em>Deprecated since v1.5.0, use <code>driver=gvd</code> keyword instead</em>.
    Use divide and conquer algorithm (faster but expensive in memory, only
    for generalized eigenvalue problem and if full set of eigenvalues are
    requested.). Has no significant effect if eigenvectors are not
    requested.</p>
</li>
<li>
<p><strong>eigvals : tuple (lo, hi), optional</strong>
    <em>Deprecated since v1.5.0, use <code>subset_by_index</code> keyword instead</em>.
    Indexes of the smallest and largest (in ascending order) eigenvalues
    and corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.
    If omitted, all eigenvalues and eigenvectors are returned.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (N,) ndarray</strong>
    The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.</p>
</li>
<li>
<p><strong>v : (M, N) ndarray</strong>
    (if <code>eigvals_only == False</code>)</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge, an error occurred, or
    b matrix is not definite positive. Note that if input matrices are
    not symmetric or Hermitian, no error will be reported but results will
    be wrong.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvalsh : eigenvalues of symmetric or Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function does not check the input array for being hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts. Also, note that even though not taken into account,
finiteness check applies to the whole array and unaffected by 'lower'
keyword.</p>
<p>This function uses LAPACK drivers for computations in all possible keyword
combinations, prefixed with <code>sy</code> if arrays are real and <code>he</code> if
complex, e.g., a float array with 'evr' driver is solved via
'syevr', complex arrays with 'gvx' driver problem is solved via 'hegvx'
etc.</p>
<p>As a brief summary, the slowest and the most robust driver is the
classical <code>&lt;sy/he&gt;ev</code> which uses symmetric QR. <code>&lt;sy/he&gt;evr</code> is seen as
the optimal choice for the most general cases. However, there are certain
occassions that <code>&lt;sy/he&gt;evd</code> computes faster at the expense of more
memory usage. <code>&lt;sy/he&gt;evx</code>, while still being faster than <code>&lt;sy/he&gt;ev</code>,
often performs worse than the rest except when very few eigenvalues are
requested for large arrays though there is still no performance guarantee.</p>
<p>For the generalized problem, normalization with respoect to the given
type argument::</p>
<div class="codehilite"><pre><span></span><code>    type 1 and 3 :      v.conj().T @ a @ v = w
    type 2       : inv(v).conj().T @ a @ inv(v) = w

    type 1 or 2  :      v.conj().T @ b @ v  = I
    type 3       : v.conj().T @ inv(b) @ v  = I
</code></pre></div>


<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

<p>Request only the eigenvalues</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>Request eigenvalues that are less than 10.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">34</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="o">-</span><span class="mi">34</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">34</span><span class="p">,</span> <span class="mi">29</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subset_by_value</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="n">array</span><span class="p">([</span><span class="mf">6.69199443e-07</span><span class="p">,</span> <span class="mf">9.11938152e+00</span><span class="p">])</span>
</code></pre></div>

<p>Request the largest second eigenvalue and its eigenvector</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">subset_by_index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="mf">9.11938152</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># only a single column is returned</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="eigh_tridiagonal_1">eigh_tridiagonal<a class="headerlink" href="#eigh_tridiagonal_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigh_tridiagonal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigh_tridiagonal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">eigvals_only</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> and optionally right eigenvectors <code>v</code> of <code>a</code>::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>d : ndarray, shape (ndim,)</strong>
    The diagonal elements of the array.</p>
</li>
<li>
<p><strong>e : ndarray, shape (ndim-1,)</strong>
    The off-diagonal elements of the array.</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>tol : float</strong>
    The absolute tolerance to which each eigenvalue is required
    (only used when 'stebz' is the <code>lapack_driver</code>).
    An eigenvalue (or cluster) is considered to have converged if it
    lies in an interval of this width. If &lt;= 0. (default),
    the value <code>eps*|a|</code> is used where eps is the machine precision,
    and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.</p>
</li>
<li>
<p><strong>lapack_driver : str</strong>
    LAPACK function to use, can be 'auto', 'stemr', 'stebz', 'sterf',
    or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
    and 'stebz' otherwise. When 'stebz' is used to find the eigenvalues and
    <code>eigvals_only=False</code>, then a second LAPACK call (to <code>?STEIN</code>) is
    used to find the corresponding eigenvectors. 'sterf' can only be
    used when <code>eigvals_only=True</code> and <code>select='a'</code>. 'stev' can only
    be used when <code>select='a'</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</p>
</li>
<li>
<p><strong>v : (M, M) ndarray</strong>
    The normalized eigenvector corresponding to the eigenvalue <code>w[i]</code> is
    the column <code>v[:,i]</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function makes use of LAPACK <code>S/DSTEMR</code> routines.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh_tridiagonal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh_tridiagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="eigvals_2">eigvals<a class="headerlink" href="#eigvals_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvals</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">homogeneous_eigvals</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute eigenvalues from an ordinary or generalized eigenvalue problem.</p>
<p>Find eigenvalues of a general matrix::</p>
<div class="codehilite"><pre><span></span><code>a   vr[:,i] = w[i]        b   vr[:,i]
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex or real matrix whose eigenvalues and eigenvectors
    will be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    Right-hand side matrix in a generalized eigenvalue problem.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities
    or NaNs.</p>
</li>
<li>
<p><strong>homogeneous_eigvals : bool, optional</strong>
    If True, return the eigenvalues in homogeneous coordinates.
    In this case <code>w</code> is a (2, M) array so that::</p>
<div class="codehilite"><pre><span></span><code>w[1,i] a vr[:,i] = w[0,i] b vr[:,i]
</code></pre></div>


<p>Default is False.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) or (2, M) double or complex ndarray</strong>
    The eigenvalues, each repeated according to its multiplicity
    but not in any specific order. The shape is (M,) unless
    <code>homogeneous_eigvals=True</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig : eigenvalues and right eigenvectors of general arrays.</strong></p>
</li>
<li>
<p><strong>eigvalsh : eigenvalues of symmetric or Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">homogeneous_eigvals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">8.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="eigvals_banded_1">eigvals_banded<a class="headerlink" href="#eigvals_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvals_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvals_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a_band</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a_band</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve real symmetric or complex Hermitian band matrix eigenvalue problem.</p>
<p>Find eigenvalues w of a::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>The matrix a is stored in a_band either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>where u is the number of bands above the diagonal.</p>
<p>Example of a_band (shape of a is (6,6), u=2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a_band : (u+1, M) array_like</strong>
    The bands of the M by M matrix a.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>overwrite_a_band : bool, optional</strong>
    Discard data in a_band (may enhance performance)</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian</strong>
    band matrices</p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eig : eigenvalues and right eigenvectors for non-symmetric arrays</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvals_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvals_banded</span><span class="p">(</span><span class="n">Ab</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.26200532</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.22987175</span><span class="p">,</span>  <span class="mf">3.95222349</span><span class="p">,</span> <span class="mf">12.53965359</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigvalsh_1">eigvalsh<a class="headerlink" href="#eigvalsh_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvalsh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">turbo</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">eigvals</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">type_</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_index</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">subset_by_value</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves a standard or generalized eigenvalue problem for a complex
Hermitian or real symmetric matrix.</p>
<p>Find eigenvalues array <code>w</code> of array <code>a</code>, where <code>b</code> is positive
definite such that for every eigenvalue λ (i-th entry of w) and its
eigenvector vi (i-th column of v) satisfies::</p>
<div class="codehilite"><pre><span></span><code>              a @ vi = λ * b @ vi
vi.conj().T @ a @ vi = λ
vi.conj().T @ b @ vi = 1
</code></pre></div>


<p>In the standard problem, b is assumed to be the identity matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A complex Hermitian or real symmetric matrix whose eigenvalues will
    be computed.</p>
</li>
<li>
<p><strong>b : (M, M) array_like, optional</strong>
    A complex Hermitian or real symmetric definite positive matrix in.
    If omitted, identity matrix is assumed.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code> and, if applicable, <code>b</code>. (Default: lower)</p>
</li>
<li>
<p><strong>eigvals_only : bool, optional</strong>
    Whether to calculate only eigenvalues and no eigenvectors.
    (Default: both are calculated)</p>
</li>
<li>
<p><strong>subset_by_index : iterable, optional</strong>
    If provided, this two-element iterable defines the start and the end
    indices of the desired eigenvalues (ascending order and 0-indexed).
    To return only the second smallest to fifth smallest eigenvalues,
    <code>[1, 4]</code> is used. <code>[n-3, n-1]</code> returns the largest three. Only
    available with 'evr', 'evx', and 'gvx' drivers. The entries are
    directly converted to integers via <code>int()</code>.</p>
</li>
<li>
<p><strong>subset_by_value : iterable, optional</strong>
    If provided, this two-element iterable defines the half-open interval
    <code>(a, b]</code> that, if any, only the eigenvalues between these values
    are returned. Only available with 'evr', 'evx', and 'gvx' drivers. Use
    <code>np.inf</code> for the unconstrained ends.</p>
</li>
<li>
<p><strong>driver: str, optional</strong>
    Defines which LAPACK driver should be used. Valid options are 'ev',
    'evd', 'evr', 'evx' for standard problems and 'gv', 'gvd', 'gvx' for
    generalized (where b is not None) problems. See the Notes section of
    <code>scipy.linalg.eigh</code>.</p>
</li>
<li>
<p><strong>type : int, optional</strong>
    For the generalized problems, this keyword specifies the problem type
    to be solved for <code>w</code> and <code>v</code> (only takes 1, 2, 3 as possible</p>
</li>
<li>
<p><strong>inputs)::</strong></p>
<div class="codehilite"><pre><span></span><code>1 =&gt;     a @ v = w @ b @ v
2 =&gt; a @ b @ v = w @ v
3 =&gt; b @ a @ v = w @ v
</code></pre></div>


<p>This keyword is ignored for standard problems.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in <code>a</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in <code>b</code> (may improve performance). Default
    is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>turbo : bool, optional</strong>
    <em>Deprecated by <code>driver=gvd</code> option</em>. Has no significant effect for
    eigenvalue computations since no eigenvectors are requested.</p>
<p>..Deprecated in v1.5.0</p>
</li>
<li>
<p><strong>eigvals : tuple (lo, hi), optional</strong>
    <em>Deprecated by <code>subset_by_index</code> keyword</em>. Indexes of the smallest
    and largest (in ascending order) eigenvalues and corresponding
    eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1. If omitted, all
    eigenvalues and eigenvectors are returned.</p>
<p>.. Deprecated in v1.5.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (N,) ndarray</strong>
    The <code>N</code> (<code>1&lt;=N&lt;=M</code>) selected eigenvalues, in ascending order, each
    repeated according to its multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge, an error occurred, or
    b matrix is not definite positive. Note that if input matrices are
    not symmetric or Hermitian, no error will be reported but results will
    be wrong.</p>
<h4>See Also</h4>
<ul>
<li>
<p><strong>eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</strong></p>
</li>
<li>
<p><strong>eigvals : eigenvalues of general arrays</strong></p>
</li>
<li>
<p><strong>eigvals_banded : eigenvalues for symmetric/Hermitian band matrices</strong></p>
</li>
<li>
<p><strong>eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal</strong>
    matrices</p>
</li>
</ul>
<h4>Notes</h4>
<p>This function does not check the input array for being Hermitian/symmetric
in order to allow for representing arrays with only their upper/lower
triangular parts.</p>
<p>This function serves as a one-liner shorthand for <code>scipy.linalg.eigh</code> with
the option <code>eigvals_only=True</code> to get the eigenvalues and not the
eigenvectors. Here it is kept as a legacy convenience. It might be
beneficial to use the main function to have full control and to be a bit
more pythonic.</p>
<h4>Examples</h4>
<p>For more examples see <code>scipy.linalg.eigh</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvalsh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvalsh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">3.74637491</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76263923</span><span class="p">,</span>  <span class="mf">6.08502336</span><span class="p">,</span> <span class="mf">12.42399079</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="eigvalsh_tridiagonal_1">eigvalsh_tridiagonal<a class="headerlink" href="#eigvalsh_tridiagonal_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function eigvalsh_tridiagonal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">eigvalsh_tridiagonal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">select</span><span class="o">:[`</span><span class="nc">A</span> <span class="o">|</span> <span class="o">`</span><span class="nc">V</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">select_range</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">d</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve eigenvalue problem for a real symmetric tridiagonal matrix.</p>
<p>Find eigenvalues <code>w</code> of <code>a</code>::</p>
<div class="codehilite"><pre><span></span><code>a v[:,i] = w[i] v[:,i]
v.H v    = identity
</code></pre></div>


<p>For a real symmetric matrix <code>a</code> with diagonal elements <code>d</code> and
off-diagonal elements <code>e</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>d : ndarray, shape (ndim,)</strong>
    The diagonal elements of the array.</p>
</li>
<li>
<p><strong>e : ndarray, shape (ndim-1,)</strong>
    The off-diagonal elements of the array.</p>
</li>
<li>
<p><strong>select : {'a', 'v', 'i'}, optional</strong>
    Which eigenvalues to calculate</p>
<p>======  ========================================
select  calculated
======  ========================================
'a'     All eigenvalues
'v'     Eigenvalues in the interval (min, max]
'i'     Eigenvalues with indices min &lt;= i &lt;= max
======  ========================================</p>
</li>
<li>
<p><strong>select_range : (min, max), optional</strong>
    Range of selected eigenvalues</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>tol : float</strong>
    The absolute tolerance to which each eigenvalue is required
    (only used when <code>lapack_driver='stebz'</code>).
    An eigenvalue (or cluster) is considered to have converged if it
    lies in an interval of this width. If &lt;= 0. (default),
    the value <code>eps*|a|</code> is used where eps is the machine precision,
    and <code>|a|</code> is the 1-norm of the matrix <code>a</code>.</p>
</li>
<li>
<p><strong>lapack_driver : str</strong>
    LAPACK function to use, can be 'auto', 'stemr', 'stebz',  'sterf',
    or 'stev'. When 'auto' (default), it will use 'stemr' if <code>select='a'</code>
    and 'stebz' otherwise. 'sterf' and 'stev' can only be used when
    <code>select='a'</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>w : (M,) ndarray</strong>
    The eigenvalues, in ascending order, each repeated according to its
    multiplicity.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue computation does not converge.</p>
<h4>See Also</h4>
<ul>
<li><strong>eigh_tridiagonal : eigenvalues and right eiegenvectors for</strong>
    symmetric/Hermitian tridiagonal matrices</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvalsh_tridiagonal</span><span class="p">,</span> <span class="n">eigvalsh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">eigvalsh_tridiagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">eigvalsh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># Verify with other eigenvalue routines</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">w2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="expm_1">expm<a class="headerlink" href="#expm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">ArrayLike</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix exponential using Pade approximation.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like or sparse matrix</strong>
    Matrix to be exponentiated.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>expm : (N, N) ndarray</strong>
    Matrix exponential of <code>A</code>.</li>
</ul>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       'A New Scaling and Squaring Algorithm for the Matrix Exponential.'
       SIAM Journal on Matrix Analysis and Applications.
       31 (3). pp. 970-989. ISSN 1095-7162</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Matrix version of the formula exp(0) = 1:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="expm_cond_1">expm_cond<a class="headerlink" href="#expm_cond_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm_cond</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_cond</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="kt">float</span>
</code></pre></div>

<p>Relative condition number of the matrix exponential in the Frobenius norm.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : 2-D array_like</strong>
    Square input matrix with shape (N, N).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>kappa : float</strong>
    The relative condition number of the matrix exponential
    in the Frobenius norm</li>
</ul>
<h4>Notes</h4>
<p>A faster estimate for the condition number in the 1-norm
has been published but is not yet implemented in SciPy.</p>
<p>.. versionadded:: 0.14.0</p>
<h4>See also</h4>
<ul>
<li>
<p><strong>expm : Compute the exponential of a matrix.</strong></p>
</li>
<li>
<p><strong>expm_frechet : Compute the Frechet derivative of the matrix exponential.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm_cond</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">expm_cond</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">k</span>
<span class="mf">1.7787805864469866</span>
</code></pre></div>

</details>
<h3 id="expm_frechet_1">expm_frechet<a class="headerlink" href="#expm_frechet_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function expm_frechet</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">expm_frechet</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_expm</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Frechet derivative of the matrix exponential of A in the direction E.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix of which to take the matrix exponential.</p>
</li>
<li>
<p><strong>E : (N, N) array_like</strong>
    Matrix direction in which to take the Frechet derivative.</p>
</li>
<li>
<p><strong>method : str, optional</strong>
    Choice of algorithm. Should be one of</p>
<ul>
<li><code>SPS</code> (default)</li>
<li><code>blockEnlarge</code></li>
</ul>
</li>
<li>
<p><strong>compute_expm : bool, optional</strong>
    Whether to compute also <code>expm_A</code> in addition to <code>expm_frechet_AE</code>.
    Default is True.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>expm_A : ndarray</strong>
    Matrix exponential of A.</p>
</li>
<li>
<p><strong>expm_frechet_AE : ndarray</strong>
    Frechet derivative of the matrix exponential of A in the direction E.</p>
</li>
</ul>
<p>For <code>compute_expm = False</code>, only <code>expm_frechet_AE</code> is returned.</p>
<h4>See also</h4>
<ul>
<li><strong>expm : Compute the exponential of a matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>This section describes the available implementations that can be selected
by the <code>method</code> parameter. The default method is <em>SPS</em>.</p>
<p>Method <em>blockEnlarge</em> is a naive algorithm.</p>
<p>Method <em>SPS</em> is Scaling-Pade-Squaring [1]_.
It is a sophisticated implementation which should take
only about 3/8 as much time as the naive implementation.
The asymptotics are the same.</p>
<p>.. versionadded:: 0.13.0</p>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
       Computing the Frechet Derivative of the Matrix Exponential,
       with an application to Condition Number Estimation.
       SIAM Journal On Matrix Analysis and Applications.,
       30 (4). pp. 1639-1657. ISSN 1095-7162</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_frechet_AE</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_frechet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">expm_frechet_AE</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_frechet_AE</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm_frechet</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm_M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expm_A</span><span class="p">,</span> <span class="n">expm_M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expm_frechet_AE</span><span class="p">,</span> <span class="n">expm_M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:])</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="fiedler_1">fiedler<a class="headerlink" href="#fiedler_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fiedler</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a symmetric Fiedler matrix</p>
<p>Given an sequence of numbers <code>a</code>, Fiedler matrices have the structure
<code>F[i, j] = np.abs(a[i] - a[j])</code>, and hence zero diagonals and nonnegative
entries. A Fiedler matrix has a dominant positive eigenvalue and other
eigenvalues are negative. Although not valid generally, for certain inputs,
the inverse and the determinant can be derived explicitly as given in [1]_.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (n,) array_like</strong>
    coefficient array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>F : (n, n) ndarray</strong></li>
</ul>
<h4>See Also</h4>
<p>circulant, toeplitz</p>
<h4>Notes</h4>
<p>.. versionadded:: 1.3.0</p>
<h4>References</h4>
<p>.. [1] J. Todd, 'Basic Numerical Mathematics: Vol.2 : Numerical Algebra',
    1977, Birkhauser, :doi:<code>10.1007/978-3-0348-7286-7</code></p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">det</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">fiedler</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">77</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">fiedler</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">76</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">73</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">11</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">65</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">76</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

<p>The explicit formulas for determinant and inverse seem to hold only for
monotonically increasing/decreasing arrays. Note the tridiagonal structure
and the corners.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># cleanup the numerical noise for display</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Ai</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.16008772</span><span class="p">,</span>  <span class="mf">0.16666667</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.00657895</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.16666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.22916667</span><span class="p">,</span>  <span class="mf">0.0625</span>    <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.0625</span>    <span class="p">,</span> <span class="o">-</span><span class="mf">0.07765152</span><span class="p">,</span>  <span class="mf">0.01515152</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.01515152</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03077652</span><span class="p">,</span>  <span class="mf">0.015625</span>  <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00657895</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.015625</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.00904605</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="mf">15409151.999999998</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="mi">15409152</span>
</code></pre></div>

</details>
<h3 id="fiedler_companion_1">fiedler_companion<a class="headerlink" href="#fiedler_companion_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fiedler_companion</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fiedler_companion</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns a Fiedler companion matrix</p>
<p>Given a polynomial coefficient array <code>a</code>, this function forms a
pentadiagonal matrix with a special structure whose eigenvalues coincides
with the roots of <code>a</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>a : (N,) array_like</strong>
    1-D array of polynomial coefficients in descending order with a nonzero
    leading coefficient. For <code>N &lt; 2</code>, an empty array is returned.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c : (N-1, N-1) ndarray</strong>
    Resulting companion matrix</li>
</ul>
<h4>Notes</h4>
<p>Similar to <code>companion</code> the leading coefficient should be nonzero. In the case
the leading coefficient is not 1, other coefficients are rescaled before
the array generation. To avoid numerical issues, it is best to provide a
monic polynomial.</p>
<p>.. versionadded:: 1.3.0</p>
<h4>See Also</h4>
<p>companion</p>
<h4>References</h4>
<p>.. [1] M. Fiedler, ' A note on companion matrices', Linear Algebra and its
    Applications, 2003, :doi:<code>10.1016/S0024-3795(03)00548-2</code></p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">fiedler_companion</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># [1., -16., 86., -176., 105.]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">fiedler_companion</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fc</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">16.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">86.</span><span class="p">,</span>    <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">0.</span><span class="p">,</span>  <span class="mf">176.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">105.</span><span class="p">],</span>
       <span class="p">[</span>   <span class="mf">0.</span><span class="p">,</span>    <span class="mf">1.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">7.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">5.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">3.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="find_best_blas_type_1">find_best_blas_type<a class="headerlink" href="#find_best_blas_type_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function find_best_blas_type</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">find_best_blas_type</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">bool</span><span class="o">)</span>
</code></pre></div>

<p>Find best-matching BLAS/LAPACK type.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>prefix : str</strong>
    BLAS/LAPACK prefix character.</p>
</li>
<li>
<p><strong>dtype : dtype</strong>
    Inferred Numpy data type.</p>
</li>
<li>
<p><strong>prefer_fortran : bool</strong>
    Whether to prefer Fortran order routines over C order.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg.blas</span> <span class="k">as</span> <span class="nn">bla</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Change the memory layout order</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bla</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">b</span><span class="p">,))</span>
<span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="fractional_matrix_power_1">fractional_matrix_power<a class="headerlink" href="#fractional_matrix_power_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function fractional_matrix_power</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fractional_matrix_power</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">t</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the fractional power of a matrix.</p>
<p>Proceeds according to the discussion in section (6) of [1]_.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose fractional power to evaluate.</p>
</li>
<li>
<p><strong>t : float</strong>
    Fractional power.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>X : (N, N) array_like</strong>
    The fractional power of the matrix.</li>
</ul>
<h4>References</h4>
<p>.. [1] Nicholas J. Higham and Lijing lin (2011)
       'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">fractional_matrix_power</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fractional_matrix_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.75592895</span><span class="p">,</span>  <span class="mf">1.13389342</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.37796447</span><span class="p">,</span>  <span class="mf">1.88982237</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>      <span class="c1"># Verify square root</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="funm_1">funm<a class="headerlink" href="#funm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function funm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">funm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Evaluate a matrix function specified by a callable.</p>
<p>Returns the value of matrix-valued function <code>f</code> at <code>A</code>. The
function <code>f</code> is an extension of the scalar-valued function <code>func</code>
to matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix at which to evaluate the function</p>
</li>
<li>
<p><strong>func : callable</strong>
    Callable object that evaluates a scalar function f.
    Must be vectorized (eg. using vectorize).</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>funm : (N, N) ndarray</strong>
    Value of the matrix function specified by func evaluated at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">funm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">funm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]])</span>
</code></pre></div>

<h4>Notes</h4>
<p>This function implements the general algorithm based on Schur decomposition
(Algorithm 9.1.1. in [1]_).</p>
<p>If the input matrix is known to be diagonalizable, then relying on the
eigendecomposition is likely to be faster. For example, if your matrix is
Hermitian, you can do</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">funm_herm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
<span class="o">...</span>     <span class="c1">## if you further know that your matrix is positive semidefinite,</span>
<span class="o">...</span>     <span class="c1">## you can optionally guard against precision errors by doing</span>
<span class="o">...</span>     <span class="c1"># w = np.maximum(w, 0)</span>
<span class="o">...</span>     <span class="n">w</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</code></pre></div>

<h4>References</h4>
<p>.. [1] Gene H. Golub, Charles F. van Loan, Matrix Computations 4th ed.</p>
</details>
<h3 id="get_blas_funcs_2">get_blas_funcs<a class="headerlink" href="#get_blas_funcs_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_blas_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_blas_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available BLAS function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of BLAS routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of BLAS functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of BLAS
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In BLAS, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively.
The code and the dtype are stored in attributes <code>typecode</code> and <code>dtype</code>
of the returned functions.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;gemv&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_gemv</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

</details>
<h3 id="get_lapack_funcs_9">get_lapack_funcs<a class="headerlink" href="#get_lapack_funcs_9" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function get_lapack_funcs</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_lapack_funcs</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">arrays</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Dtype</span> <span class="k">of</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">names</span><span class="o">:[`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Sequence_of_str</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return available LAPACK function objects from names.</p>
<p>Arrays are used to determine the optimal prefix of LAPACK routines.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>names : str or sequence of str</strong>
    Name(s) of LAPACK functions without type prefix.</p>
</li>
<li>
<p><strong>arrays : sequence of ndarrays, optional</strong>
    Arrays can be given to determine optimal prefix of LAPACK
    routines. If not given, double-precision routines will be
    used, otherwise the most generic type in arrays will be used.</p>
</li>
<li>
<p><strong>dtype : str or dtype, optional</strong>
    Data-type specifier. Not used if <code>arrays</code> is non-empty.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>funcs : list</strong>
    List containing the found function(s).</li>
</ul>
<h4>Notes</h4>
<p>This routine automatically chooses between Fortran/C
interfaces. Fortran code is used whenever possible for arrays with
column major order. In all other cases, C code is preferred.</p>
<p>In LAPACK, the naming convention is that all functions start with a
type prefix, which depends on the type of the principal
matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy
types {float32, float64, complex64, complex128} respectively, and
are stored in attribute <code>typecode</code> of the returned functions.</p>
<h4>Examples</h4>
<p>Suppose we would like to use '?lange' routine which computes the selected
norm of an array. We pass our array in order to get the correct 'lange'
flavor.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;d&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_lange</span><span class="o">.</span><span class="n">typecode</span>
<span class="s1">&#39;z&#39;</span>
</code></pre></div>

<p>Several LAPACK routines work best when its internal WORK array has
the optimal size (big enough for fast computation and small enough to
avoid waste of memory). This size is determined also by a dedicated query
to the function which is often wrapped as a standalone function and
commonly denoted as <code>###_lwork</code>. Below is an example for <code>?sysv</code></p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">LA</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># We pick up zsysv and zsysv_lwork due to b array</span>
<span class="o">...</span> <span class="n">xsysv</span><span class="p">,</span> <span class="n">xlwork</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sysv&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">opt_lwork</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xlwork</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># returns a complex for &#39;z&#39; prefix</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">udut</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">xsysv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opt_lwork</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="hadamard_1">hadamard<a class="headerlink" href="#hadamard_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hadamard</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hadamard</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an Hadamard matrix.</p>
<p>Constructs an n-by-n Hadamard matrix, using Sylvester's
construction. <code>n</code> must be a power of 2.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The order of the matrix. <code>n</code> must be a power of 2.</p>
</li>
<li>
<p><strong>dtype : dtype, optional</strong>
    The data type of the array to be constructed.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>H : (n, n) ndarray</strong>
    The Hadamard matrix.</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hadamard</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="o">-</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="hankel_1">hankel<a class="headerlink" href="#hankel_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hankel</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hankel</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Hankel matrix.</p>
<p>The Hankel matrix has constant anti-diagonals, with <code>c</code> as its
first column and <code>r</code> as its last row. If <code>r</code> is not given, then
<code>r = zeros_like(c)</code> is assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    First column of the matrix. Whatever the actual shape of <code>c</code>, it
    will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>r : array_like, optional</strong>
    Last row of the matrix. If None, <code>r = zeros_like(c)</code> is assumed.
    r[0] is ignored; the last row of the returned matrix is
    <code>[c[-1], r[1:]]</code>. Whatever the actual shape of <code>r</code>, it will be
    converted to a 1-D array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (len(c), len(r)) ndarray</strong>
    The Hankel matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>toeplitz : Toeplitz matrix</strong></p>
</li>
<li>
<p><strong>circulant : circulant matrix</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hankel</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hankel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">99</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hankel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="helmert_1">helmert<a class="headerlink" href="#helmert_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function helmert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">helmert</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">full</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create an Helmert matrix of order <code>n</code>.</p>
<p>This has applications in statistics, compositional or simplicial analysis,
and in Aitchison geometry.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the array to create.</p>
</li>
<li>
<p><strong>full : bool, optional</strong>
    If True the (n, n) ndarray will be returned.
    Otherwise the submatrix that does not include the first
    row will be returned.</p>
</li>
<li>
<p><strong>Default: False.</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>M : ndarray</strong>
    The Helmert matrix.
    The shape is (n, n) or (n-1, n) depending on the <code>full</code> argument.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">helmert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">helmert</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">,</span>  <span class="mf">0.4472136</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.70710678</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.70710678</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.40824829</span><span class="p">,</span>  <span class="mf">0.40824829</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81649658</span><span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.28867513</span><span class="p">,</span>  <span class="mf">0.28867513</span><span class="p">,</span>  <span class="mf">0.28867513</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8660254</span> <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span>  <span class="mf">0.2236068</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.89442719</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="hessenberg_1">hessenberg<a class="headerlink" href="#hessenberg_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hessenberg</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hessenberg</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">calc_q</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute Hessenberg form of a matrix.</p>
<p>The Hessenberg decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = Q H Q^H
</code></pre></div>


<p>where <code>Q</code> is unitary/orthogonal and <code>H</code> has only zero elements below
the first sub-diagonal.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to bring into Hessenberg form.</p>
</li>
<li>
<p><strong>calc_q : bool, optional</strong>
    Whether to compute the transformation matrix.  Default is False.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>H : (M, M) ndarray</strong>
    Hessenberg form of <code>a</code>.</p>
</li>
<li>
<p><strong>Q : (M, M) ndarray</strong>
    Unitary/orthogonal similarity transformation matrix <code>A = Q H Q^H</code>.
    Only returned if <code>calc_q=True</code>.</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hessenberg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">hessenberg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">calc_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">11.65843866</span><span class="p">,</span>   <span class="mf">1.42005301</span><span class="p">,</span>   <span class="mf">0.25349066</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">9.94987437</span><span class="p">,</span>  <span class="mf">14.53535354</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.31022304</span><span class="p">,</span>   <span class="mf">2.43081618</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">1.83299243</span><span class="p">,</span>   <span class="mf">0.38969961</span><span class="p">,</span>  <span class="o">-</span><span class="mf">0.51527034</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">3.83189513</span><span class="p">,</span>   <span class="mf">1.07494686</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Q</span> <span class="o">@</span> <span class="n">H</span> <span class="o">@</span> <span class="n">Q</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="hilbert_1">hilbert<a class="headerlink" href="#hilbert_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function hilbert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">hilbert</span> <span class="o">:</span>
  <span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Hilbert matrix of order <code>n</code>.</p>
<p>Returns the <code>n</code> by <code>n</code> array with entries <code>h[i,j] = 1 / (i + j + 1)</code>.</p>
<h4>Parameters</h4>
<ul>
<li><strong>n : int</strong>
    The size of the array to create.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>h : (n, n) ndarray</strong>
    The Hilbert matrix.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>invhilbert : Compute the inverse of a Hilbert matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.10.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hilbert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span>        <span class="p">,</span>  <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">,</span>  <span class="mf">0.25</span>      <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.33333333</span><span class="p">,</span>  <span class="mf">0.25</span>      <span class="p">,</span>  <span class="mf">0.2</span>       <span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="inv_2">inv<a class="headerlink" href="#inv_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function inv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of a matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Square matrix to be inverted.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Discard data in <code>a</code> (may improve performance). Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>ainv : ndarray</strong>
    Inverse of the matrix <code>a</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If <code>a</code> is singular.
ValueError
    If <code>a</code> is not square, or not 2D.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="invhilbert_1">invhilbert<a class="headerlink" href="#invhilbert_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function invhilbert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invhilbert</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the inverse of the Hilbert matrix of order <code>n</code>.</p>
<p>The entries in the inverse of a Hilbert matrix are integers. When <code>n</code>
is greater than 14, some entries in the inverse exceed the upper limit
of 64 bit integers. The <code>exact</code> argument provides two options for
dealing with these large integers.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The order of the Hilbert matrix.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If False, the data type of the array that is returned is np.float64,
    and the array is an approximation of the inverse.
    If True, the array is the exact integer inverse array. To represent
    the exact inverse when n &gt; 14, the returned array is an object array
    of long integers. For n &lt;= 14, the exact inverse is returned as an
    array with data type np.int64.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>invh : (n, n) ndarray</strong>
    The data type of the array is np.float64 if <code>exact</code> is False.
    If <code>exact</code> is True, the data type is either np.int64 (for n &lt;= 14)
    or object (for n &gt; 14). In the latter case, the objects in the
    array will be long integers.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>hilbert : Create a Hilbert matrix.</strong></li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.10.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">invhilbert</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>   <span class="mf">16.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">120.</span><span class="p">,</span>   <span class="mf">240.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">140.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">120.</span><span class="p">,</span>  <span class="mf">1200.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2700.</span><span class="p">,</span>  <span class="mf">1680.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">240.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2700.</span><span class="p">,</span>  <span class="mf">6480.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4200.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">140.</span><span class="p">,</span>  <span class="mf">1680.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4200.</span><span class="p">,</span>  <span class="mf">2800.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>   <span class="mi">16</span><span class="p">,</span>  <span class="o">-</span><span class="mi">120</span><span class="p">,</span>   <span class="mi">240</span><span class="p">,</span>  <span class="o">-</span><span class="mi">140</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span>  <span class="mi">1200</span><span class="p">,</span> <span class="o">-</span><span class="mi">2700</span><span class="p">,</span>  <span class="mi">1680</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mi">240</span><span class="p">,</span> <span class="o">-</span><span class="mi">2700</span><span class="p">,</span>  <span class="mi">6480</span><span class="p">,</span> <span class="o">-</span><span class="mi">4200</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">140</span><span class="p">,</span>  <span class="mi">1680</span><span class="p">,</span> <span class="o">-</span><span class="mi">4200</span><span class="p">,</span>  <span class="mi">2800</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">16</span><span class="p">)[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mf">4.2475099528537506e+19</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invhilbert</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">42475099528537378560</span>
</code></pre></div>

</details>
<h3 id="invpascal_1">invpascal<a class="headerlink" href="#invpascal_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function invpascal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">invpascal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the inverse of the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the matrix to create; that is, the result is an n x n
    matrix.</p>
</li>
<li>
<p><strong>kind : str, optional</strong>
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If <code>exact</code> is True, the result is either an array of type
    <code>numpy.int64</code> (if <code>n</code> &lt;= 35) or an object array of Python integers.
    If <code>exact</code> is False, the coefficients in the matrix are computed using
    <code>scipy.special.comb</code> with <code>exact=False</code>. The result will be a floating
    point array, and for large <code>n</code>, the values in the array will not be the
    exact coefficients.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>invp : (n, n) ndarray</strong>
    The inverse of the Pascal matrix.</li>
</ul>
<h4>See Also</h4>
<p>pascal</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.16.0</p>
<h4>References</h4>
<p>.. [1] 'Pascal matrix', https://en.wikipedia.org/wiki/Pascal_matrix
.. [2] Cohen, A. M., 'The inverse of a Pascal matrix', Mathematical
       Gazette, 59(408), pp. 111-112, 1975.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">invpascal</span><span class="p">,</span> <span class="n">pascal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invp</span> <span class="o">=</span> <span class="n">invpascal</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">invp</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>  <span class="o">-</span><span class="mi">5</span><span class="p">,</span>   <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span>  <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>  <span class="mi">19</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span>  <span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span>   <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span>  <span class="mi">17</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>  <span class="o">-</span><span class="mi">4</span><span class="p">,</span>   <span class="mi">1</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invp</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<p>An example of the use of <code>kind</code> and <code>exact</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">invpascal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="khatri_rao_1">khatri_rao<a class="headerlink" href="#khatri_rao_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function khatri_rao</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">khatri_rao</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Khatri-rao product</p>
<p>A column-wise Kronecker product of two matrices</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a:  (n, k) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>b:  (m, k) array_like</strong>
    Input array</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>c:  (n*m, k) ndarray</strong>
    Khatri-rao product of <code>a</code> and <code>b</code>.</li>
</ul>
<h4>Notes</h4>
<p>The mathematical definition of the Khatri-Rao product is:</p>
<div>
<div class="MathJax_Preview">
    (A_{ij}  \bigotimes B_{ij})_{ij}
</div>
<script type="math/tex; mode=display">
    (A_{ij}  \bigotimes B_{ij})_{ij}
</script>
</div>
<p>which is the Kronecker product of every column of A and B, e.g.::</p>
<div class="codehilite"><pre><span></span><code>c = np.vstack([np.kron(a[:, k], b[:, k]) for k in range(b.shape[1])]).T
</code></pre></div>


<h4>See Also</h4>
<ul>
<li><strong>kron : Kronecker product</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">linalg</span><span class="o">.</span><span class="n">khatri_rao</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">24</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">27</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">48</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">54</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="kron_1">kron<a class="headerlink" href="#kron_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function kron</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kron</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Kronecker product.</p>
<p>The result is the block matrix::</p>
<div class="codehilite"><pre><span></span><code>a[0,0]*b    a[0,1]*b  ... a[0,-1]*b
a[1,0]*b    a[1,1]*b  ... a[1,-1]*b
...
a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b
</code></pre></div>


<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) ndarray</strong>
    Input array</p>
</li>
<li>
<p><strong>b : (P, Q) ndarray</strong>
    Input array</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (M<em>P, N</em>Q) ndarray</strong>
    Kronecker product of <code>a</code> and <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">kron</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kron</span><span class="p">(</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="ldl">ldl<a class="headerlink" href="#ldl" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function ldl</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ldl</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">hermitian</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Computes the LDLt or Bunch-Kaufman factorization of a symmetric/
hermitian matrix.</p>
<p>This function returns a block diagonal matrix D consisting blocks of size
at most 2x2 and also a possibly permuted unit lower triangular matrix
<code>L</code> such that the factorization <code>A = L D L^H</code> or <code>A = L D L^T</code>
holds. If <code>lower</code> is False then (again possibly permuted) upper
triangular matrices are returned as outer factors.</p>
<p>The permutation array can be used to triangularize the outer factors
simply by a row shuffle, i.e., <code>lu[perm, :]</code> is an upper/lower
triangular matrix. This is also equivalent to multiplication with a
permutation matrix <code>P.dot(lu)</code>, where <code>P</code> is a column-permuted
identity matrix <code>I[:, perm]</code>.</p>
<p>Depending on the value of the boolean <code>lower</code>, only upper or lower
triangular part of the input array is referenced. Hence, a triangular
matrix on entry would give the same result as if the full matrix is
supplied.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    Square input array</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    This switches between the lower and upper triangular outer factors of
    the factorization. Lower triangular (<code>lower=True</code>) is the default.</p>
</li>
<li>
<p><strong>hermitian : bool, optional</strong>
    For complex-valued arrays, this defines whether <code>a = a.conj().T</code> or
    <code>a = a.T</code> is assumed. For real-valued arrays, this switch has no
    effect.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in <code>a</code> (may enhance performance). The default
    is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>lu : ndarray</strong>
    The (possibly) permuted upper/lower triangular outer factor of the
    factorization.</p>
</li>
<li>
<p><strong>d : ndarray</strong>
    The block diagonal multiplier of the factorization.</p>
</li>
<li>
<p><strong>perm : ndarray</strong>
    The row-permutation index array that brings lu into triangular form.</p>
</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If input array is not square.
ComplexWarning
    If a complex-valued array with nonzero imaginary parts on the
    diagonal is given and hermitian is set to True.</p>
<h4>Examples</h4>
<p>Given an upper triangular array <code>a</code> that represents the full symmetric
array with its entries, obtain <code>l</code>, 'd' and the permutation vector <code>perm</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">ldl</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">ldl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Use the upper part</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">5.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">2.</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">perm</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">[</span><span class="n">perm</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
</code></pre></div>

<h4>Notes</h4>
<p>This function uses <code>?SYTRF</code> routines for symmetric matrices and
<code>?HETRF</code> routines for Hermitian matrices from LAPACK. See [1]_ for
the algorithm details.</p>
<p>Depending on the <code>lower</code> keyword value, only lower or upper triangular
part of the input array is referenced. Moreover, this keyword also defines
the structure of the outer factors of the factorization.</p>
<p>.. versionadded:: 1.1.0</p>
<h4>See also</h4>
<p>cholesky, lu</p>
<h4>References</h4>
<p>.. [1] J.R. Bunch, L. Kaufman, Some stable methods for calculating
   inertia and solving symmetric linear systems, Math. Comput. Vol.31,
   1977. DOI: 10.2307/2005787</p>
</details>
<h3 id="leslie_1">leslie<a class="headerlink" href="#leslie_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function leslie</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leslie</span> <span class="o">:</span>
  <span class="n">f</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">s</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Create a Leslie matrix.</p>
<p>Given the length n array of fecundity coefficients <code>f</code> and the length
n-1 array of survival coefficients <code>s</code>, return the associated Leslie
matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>f : (N,) array_like</strong>
    The 'fecundity' coefficients.</p>
</li>
<li>
<p><strong>s : (N-1,) array_like</strong>
    The 'survival' coefficients, has to be 1-D.  The length of <code>s</code>
    must be one less than the length of <code>f</code>, and it must be at least 1.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>L : (N, N) ndarray</strong>
    The array is zero except for the first row,
    which is <code>f</code>, and the first sub-diagonal, which is <code>s</code>.
    The data-type of the array will be the data-type of <code>f[0]+s[0]</code>.</li>
</ul>
<h4>Notes</h4>
<p>.. versionadded:: 0.8.0</p>
<p>The Leslie matrix is used to model discrete-time, age-structured
population growth [1]<em> [2]</em>. In a population with <code>n</code> age classes, two sets
of parameters define a Leslie matrix: the <code>n</code> 'fecundity coefficients',
which give the number of offspring per-capita produced by each age
class, and the <code>n</code> - 1 'survival coefficients', which give the
per-capita survival rate of each age class.</p>
<h4>References</h4>
<p>.. [1] P. H. Leslie, On the use of matrices in certain population
       mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945)
.. [2] P. H. Leslie, Some further notes on the use of matrices in
       population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245
       (Dec. 1948)</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">leslie</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">leslie</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">2.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">0.1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.8</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.7</span><span class="p">,</span>  <span class="mf">0.</span> <span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="logm_1">logm<a class="headerlink" href="#logm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function logm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">logm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute matrix logarithm.</p>
<p>The matrix logarithm is the inverse of</p>
<ul>
<li><strong>expm: expm(logm(<code>A</code>)) == <code>A</code></strong></li>
</ul>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose logarithm to evaluate</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>logm : (N, N) ndarray</strong>
    Matrix logarithm of <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] Awad H. Al-Mohy and Nicholas J. Higham (2012)
       'Improved Inverse Scaling and Squaring Algorithms
       for the Matrix Logarithm.'
       SIAM Journal on Scientific Computing, 34 (4). C152-C169.
       ISSN 1095-7197</p>
<p>.. [2] Nicholas J. Higham (2008)
       'Functions of Matrices: Theory and Computation'
       ISBN 978-0-898716-46-7</p>
<p>.. [3] Nicholas J. Higham and Lijing lin (2011)
       'A Schur-Pade Algorithm for Fractional Powers of a Matrix.'
       SIAM Journal on Matrix Analysis and Applications,
       32 (3). pp. 1056-1078. ISSN 0895-4798</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">logm</span><span class="p">,</span> <span class="n">expm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">logm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.02571087</span><span class="p">,</span>  <span class="mf">2.05142174</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.68380725</span><span class="p">,</span>  <span class="mf">1.02571087</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>         <span class="c1"># Verify expm(logm(a)) returns a</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="lstsq_1">lstsq<a class="headerlink" href="#lstsq_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lstsq</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lstsq</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="n">option</span><span class="o">)</span>
</code></pre></div>

<p>Compute least-squares solution to equation Ax = b.</p>
<p>Compute a vector x such that the 2-norm <code>|b - A x|</code> is minimized.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Left-hand side array</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right hand side array</p>
</li>
<li>
<p><strong>cond : float, optional</strong>
    Cutoff for 'small' singular values; used to determine effective
    rank of a. Singular values smaller than
    <code>rcond * largest_singular_value</code> are considered zero.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Discard data in <code>a</code> (may enhance performance). Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance). Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>lapack_driver : str, optional</strong>
    Which LAPACK driver is used to solve the least-squares problem.
    Options are <code>'gelsd'</code>, <code>'gelsy'</code>, <code>'gelss'</code>. Default
    (<code>'gelsd'</code>) is a good choice.  However, <code>'gelsy'</code> can be slightly
    faster on many problems.  <code>'gelss'</code> was used historically.  It is
    generally slow but uses less memory.</p>
<p>.. versionadded:: 0.17.0</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>x : (N,) or (N, K) ndarray</strong>
    Least-squares solution.  Return shape matches shape of <code>b</code>.</p>
</li>
<li>
<p><strong>residues : (K,) ndarray or float</strong>
    Square of the 2-norm for each column in <code>b - a x</code>, if <code>M &gt; N</code> and
    <code>ndim(A) == n</code> (returns a scalar if b is 1-D). Otherwise a
    (0,)-shaped array is returned.</p>
</li>
<li>
<p><strong>rank : int</strong>
    Effective rank of <code>a</code>.</p>
</li>
<li>
<p><strong>s : (min(M, N),) ndarray or None</strong>
    Singular values of <code>a</code>. The condition number of a is
    <code>abs(s[0] / s[-1])</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If computation does not converge.</p>
<p>ValueError
    When parameters are not compatible.</p>
<h4>See Also</h4>
<ul>
<li><strong>scipy.optimize.nnls : linear least squares with non-negativity constraint</strong></li>
</ul>
<h4>Notes</h4>
<p>When <code>'gelsy'</code> is used as a driver, <code>residues</code> is set to a (0,)-shaped
array and <code>s</code> is always <code>None</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lstsq</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</code></pre></div>

<p>Suppose we have the following data:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">,</span> <span class="mf">8.6</span><span class="p">])</span>
</code></pre></div>

<p>We want to fit a quadratic polynomial of the form <code>y = a + b*x**2</code>
to this data.  We first form the 'design matrix' M, with a constant
column of 1s and a column containing <code>x**2</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">**</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">M</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.</span>  <span class="p">,</span>   <span class="mf">1.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>   <span class="mf">6.25</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">12.25</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">16.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">25.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">49.</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">1.</span>  <span class="p">,</span>  <span class="mf">72.25</span><span class="p">]])</span>
</code></pre></div>

<p>We want to find the least-squares solution to <code>M.dot(p) = y</code>,
where <code>p</code> is a vector with length 2 that holds the parameters
<code>a</code> and <code>b</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rnk</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.20925829</span><span class="p">,</span>  <span class="mf">0.12013861</span><span class="p">])</span>
</code></pre></div>

<p>Plot the data and the fitted curve.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;least squares fit, $y = a + bx^2$&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">framealpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

</details>
<h3 id="lu_1">lu<a class="headerlink" href="#lu_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">permute_l</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = P L U
</code></pre></div>


<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Array to decompose</p>
</li>
<li>
<p><strong>permute_l : bool, optional</strong>
    Perform the multiplication P*L (Default: do not permute)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<p><strong>(If permute_l == False)</strong></p>
<ul>
<li>
<p><strong>p : (M, M) ndarray</strong>
    Permutation matrix</p>
</li>
<li>
<p><strong>l : (M, K) ndarray</strong>
    Lower triangular or trapezoidal matrix with unit diagonal.
    K = min(M, N)</p>
</li>
<li>
<p><strong>u : (K, N) ndarray</strong>
    Upper triangular or trapezoidal matrix</p>
</li>
</ul>
<p><strong>(If permute_l == True)</strong></p>
<ul>
<li>
<p><strong>pl : (M, K) ndarray</strong>
    Permuted L matrix.
    K = min(M, N)</p>
</li>
<li>
<p><strong>u : (K, N) ndarray</strong>
    Upper triangular or trapezoidal matrix</p>
</li>
</ul>
<h4>Notes</h4>
<p>This is a LU factorization routine written for SciPy.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">lu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">p</span> <span class="o">@</span> <span class="n">l</span> <span class="o">@</span> <span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="lu_factor_1">lu_factor<a class="headerlink" href="#lu_factor_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu_factor</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_factor</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute pivoted LU decomposition of a matrix.</p>
<p>The decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = P L U
</code></pre></div>


<p>where P is a permutation matrix, L lower triangular with unit
diagonal elements, and U upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to decompose</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in A (may increase performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>lu : (N, N) ndarray</strong>
    Matrix containing U in its upper triangle, and L in its lower triangle.
    The unit diagonal elements of L are not stored.</p>
</li>
<li>
<p><strong>piv : (N,) ndarray</strong>
    Pivot indices representing the permutation matrix P:
    row i of matrix was interchanged with row piv[i].</p>
</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>lu_solve : solve an equation system using the LU factorization of a matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>This is a wrapper to the <code>*GETRF</code> routines from LAPACK.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu_factor</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span> <span class="o">=</span> <span class="n">lu_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">piv</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
</code></pre></div>

<p>Convert LAPACK's <code>piv</code> array to NumPy index and test the permutation</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">piv_py</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">lu</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">piv_py</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span> <span class="o">@</span> <span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="lu_solve_1">lu_solve<a class="headerlink" href="#lu_solve_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function lu_solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">lu_solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">lu_and_piv</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve an equation system, a x = b, given the LU factorization of a</p>
<h4>Parameters</h4>
<p>(lu, piv)
    Factorization of the coefficient matrix a, as given by lu_factor</p>
<ul>
<li>
<p><strong>b : array</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>trans : {0, 1, 2}, optional</strong>
    Type of system to solve:</p>
<p>=====  =========
trans  system
=====  =========
0      a x   = b
1      a^T x = b
2      a^H x = b
=====  =========</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in b (may increase performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : array</strong>
    Solution to the system</li>
</ul>
<h4>See also</h4>
<ul>
<li><strong>lu_factor : LU factorize a matrix</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu_factor</span><span class="p">,</span> <span class="n">lu_solve</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span> <span class="o">=</span> <span class="n">lu_factor</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lu_solve</span><span class="p">((</span><span class="n">lu</span><span class="p">,</span> <span class="n">piv</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="matrix_balance_1">matrix_balance<a class="headerlink" href="#matrix_balance_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function matrix_balance</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">matrix_balance</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">permute</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">scale</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">separate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute a diagonal similarity transformation for row/column balancing.</p>
<p>The balancing tries to equalize the row and column 1-norms by applying
a similarity transformation such that the magnitude variation of the
matrix entries is reflected to the scaling matrices.</p>
<p>Moreover, if enabled, the matrix is first permuted to isolate the upper
triangular parts of the matrix and, again if scaling is also enabled,
only the remaining subblocks are subjected to scaling.</p>
<p>The balanced matrix satisfies the following equality</p>
<div>
<div class="MathJax_Preview">
                    B = T^{-1} A T
</div>
<script type="math/tex; mode=display">
                    B = T^{-1} A T
</script>
</div>
<p>The scaling coefficients are approximated to the nearest power of 2
to avoid round-off errors.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (n, n) array_like</strong>
    Square data matrix for the balancing.</p>
</li>
<li>
<p><strong>permute : bool, optional</strong>
    The selector to define whether permutation of A is also performed
    prior to scaling.</p>
</li>
<li>
<p><strong>scale : bool, optional</strong>
    The selector to turn on and off the scaling. If False, the matrix
    will not be scaled.</p>
</li>
<li>
<p><strong>separate : bool, optional</strong>
    This switches from returning a full matrix of the transformation
    to a tuple of two separate 1-D permutation and scaling arrays.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    This is passed to xGEBAL directly. Essentially, overwrites the result
    to the data. It might increase the space efficiency. See LAPACK manual
    for details. This is False by default.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (n, n) ndarray</strong>
    Balanced matrix</p>
</li>
<li>
<p><strong>T : (n, n) ndarray</strong>
    A possibly permuted diagonal matrix whose nonzero entries are
    integer powers of 2 to avoid numerical truncation errors.
scale, perm : (n,) ndarray
    If <code>separate</code> keyword is set to True then instead of the array
    <code>T</code> above, the scaling and the permutation vectors are given
    separately as a tuple without allocating the full array <code>T</code>.</p>
</li>
</ul>
<h4>Notes</h4>
<p>This algorithm is particularly useful for eigenvalue and matrix
decompositions and in many cases it is already called by various
LAPACK routines.</p>
<p>The algorithm is based on the well-known technique of [1]<em> and has
been modified to account for special cases. See [2]</em> for details
which have been implemented since LAPACK v3.5.0. Before this version
there are corner cases where balancing can actually worsen the
conditioning. See [3]_ for such examples.</p>
<p>The code is a wrapper around LAPACK's xGEBAL routine family for matrix
balancing.</p>
<p>.. versionadded:: 0.19.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.01</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">permscale</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matrix_balance</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">3.66666667</span><span class="p">,</span>  <span class="mf">0.4995005</span> <span class="p">,</span>  <span class="mf">0.91312162</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.2</span>       <span class="p">,</span>  <span class="mf">1.27041742</span><span class="p">,</span>  <span class="mf">0.92658316</span><span class="p">])</span>  <span class="c1"># may vary</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">permscale</span>  <span class="c1"># only powers of 2 (0.5 == 2^(-1))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">0.5</span><span class="p">,</span>   <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>  <span class="c1"># may vary</span>
       <span class="p">[</span>  <span class="mf">0.</span> <span class="p">,</span>   <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">0.</span> <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span> <span class="p">,</span>   <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">1.</span> <span class="p">]])</span>
</code></pre></div>

<h4>References</h4>
<p>.. [1] : B.N. Parlett and C. Reinsch, 'Balancing a Matrix for
   Calculation of Eigenvalues and Eigenvectors', Numerische Mathematik,
   Vol.13(4), 1969, DOI:10.1007/BF02165404</p>
<p>.. [2] : R. James, J. Langou, B.R. Lowery, 'On matrix balancing and
   eigenvector computation', 2014, Available online:</p>
<ul>
<li><strong>https://arxiv.org/abs/1401.5766</strong></li>
</ul>
<p>.. [3] :  D.S. Watkins. A case where balancing is harmful.
   Electron. Trans. Numer. Anal, Vol.23, 2006.</p>
</details>
<h3 id="norm_4">norm<a class="headerlink" href="#norm_4" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function norm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">norm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">ord</span><span class="o">:[`</span><span class="nc">PyObject</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Fro</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">axis</span><span class="o">:[`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T2_tuple_of_ints</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">keepdims</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Matrix or vector norm.</p>
<p>This function is able to return one of seven different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <code>ord</code> parameter.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M,) or (M, N) array_like</strong>
    Input array. If <code>axis</code> is None, <code>a</code> must be 1D or 2D.</p>
</li>
<li>
<p><strong>ord : {non-zero int, inf, -inf, 'fro'}, optional</strong>
    Order of the norm (see table under <code>Notes</code>). inf means NumPy's
    <code>inf</code> object</p>
</li>
<li>
<p><strong>axis : {int, 2-tuple of ints, None}, optional</strong>
    If <code>axis</code> is an integer, it specifies the axis of <code>a</code> along which to
    compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
    axes that hold 2-D matrices, and the matrix norms of these matrices
    are computed.  If <code>axis</code> is None then either a vector norm (when <code>a</code>
    is 1-D) or a matrix norm (when <code>a</code> is 2-D) is returned.</p>
</li>
<li>
<p><strong>keepdims : bool, optional</strong>
    If this is set to True, the axes which are normed over are left in the
    result as dimensions with size one.  With this option the result will
    broadcast correctly against the original <code>a</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>n : float or ndarray</strong>
    Norm of the matrix or vector(s).</li>
</ul>
<h4>Notes</h4>
<p>For values of <code>ord &lt;= 0</code>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<p>=====  ============================  ==========================
ord    norm for matrices             norm for vectors
=====  ============================  ==========================
None   Frobenius norm                2-norm
'fro'  Frobenius norm                --
inf    max(sum(abs(x), axis=1))      max(abs(x))
-inf   min(sum(abs(x), axis=1))      min(abs(x))
0      --                            sum(x != 0)
1      max(sum(abs(x), axis=0))      as below
-1     min(sum(abs(x), axis=0))      as below
2      2-norm (largest sing. value)  as below
-2     smallest singular value       as below
other  --                            sum(abs(x)<strong>ord)</strong>(1./ord)
=====  ============================  ==========================</p>
<p>The Frobenius norm is given by [1]_:</p>
<div class="codehilite"><pre><span></span><code>:math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
</code></pre></div>


<p>The <code>axis</code> and <code>keepdims</code> arguments are passed directly to
<code>numpy.linalg.norm</code> and are only usable if they are supported
by the version of numpy in use.</p>
<h4>References</h4>
<p>.. [1] G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
       Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span> <span class="mf">4.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mf">4.6566128774142013e-010</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.745966692414834</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.3484692283495345</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="mf">1.8570331885190563e-016</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">5.8480354764257312</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">0</span>
</code></pre></div>

</details>
<h3 id="null_space_1">null_space<a class="headerlink" href="#null_space_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function null_space</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">null_space</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the null space of A using SVD</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>rcond : float, optional</strong>
    Relative condition number. Singular values <code>s</code> smaller than
    <code>rcond * max(s)</code> are considered zero.</p>
</li>
<li>
<p><strong>Default: floating point eps * max(M,N).</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>Z : (N, K) ndarray</strong>
    Orthonormal basis for the null space of A.
    K = dimension of effective null space, as determined by rcond</li>
</ul>
<h4>See also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>orth : Matrix range</strong></p>
</li>
</ul>
<h4>Examples</h4>
<p>1-D null space:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">null_space</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">null_space</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ns</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Remove the sign ambiguity of the vector</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.70710678</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.70710678</span><span class="p">]])</span>
</code></pre></div>

<p>2-D null space:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">null_space</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>The basis vectors are orthonormal (up to rounding error):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>   <span class="mf">6.92087741e-17</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.92087741e-17</span><span class="p">,</span>   <span class="mf">1.00000000e+00</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="ordqz">ordqz<a class="headerlink" href="#ordqz" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function ordqz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ordqz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>QZ decomposition for a pair of matrices with reordering.</p>
<p>.. versionadded:: 0.17.0</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    2-D array to decompose</p>
</li>
<li>
<p><strong>B : (N, N) array_like</strong>
    2-D array to decompose</p>
</li>
<li>
<p><strong>sort : {callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional</strong>
    Specifies whether the upper eigenvalues should be sorted. A
    callable may be passed that, given an ordered pair <code>(alpha,
    beta)</code> representing the eigenvalue <code>x = (alpha/beta)</code>,
    returns a boolean denoting whether the eigenvalue should be
    sorted to the top-left (True). For the real matrix pairs
    <code>beta</code> is real while <code>alpha</code> can be complex, and for
    complex matrix pairs both <code>alpha</code> and <code>beta</code> can be
    complex. The callable must be able to accept a NumPy
    array. Alternatively, string parameters may be used:</p>
<div class="codehilite"><pre><span></span><code>- &#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)
- &#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)
- &#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt; 1.0)
- &#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)
</code></pre></div>


<p>With the predefined sorting functions, an infinite eigenvalue
(i.e., <code>alpha != 0</code> and <code>beta = 0</code>) is considered to lie in
neither the left-hand nor the right-hand plane, but it is
considered to lie outside the unit circle. For the eigenvalue
<code>(alpha, beta) = (0, 0)</code>, the predefined sorting functions
all return <code>False</code>.</p>
</li>
<li>
<p><strong>output : str {'real','complex'}, optional</strong>
    Construct the real or complex QZ decomposition for real matrices.
    Default is 'real'.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    If True, the contents of A are overwritten.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    If True, the contents of B are overwritten.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    If true checks the elements of <code>A</code> and <code>B</code> are finite numbers. If
    false does no checking and passes matrix through to
    underlying algorithm.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>AA : (N, N) ndarray</strong>
    Generalized Schur form of A.</p>
</li>
<li>
<p><strong>BB : (N, N) ndarray</strong>
    Generalized Schur form of B.</p>
</li>
<li>
<p><strong>alpha : (N,) ndarray</strong>
    alpha = alphar + alphai * 1j. See notes.</p>
</li>
<li>
<p><strong>beta : (N,) ndarray</strong>
    See notes.</p>
</li>
<li>
<p><strong>Q : (N, N) ndarray</strong>
    The left Schur vectors.</p>
</li>
<li>
<p><strong>Z : (N, N) ndarray</strong>
    The right Schur vectors.</p>
</li>
</ul>
<h4>Notes</h4>
<p>On exit, <code>(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N</code>, will be the
generalized eigenvalues.  <code>ALPHAR(j) + ALPHAI(j)*i</code> and
<code>BETA(j),j=1,...,N</code> are the diagonals of the complex Schur form (S,T)
that would result if the 2-by-2 diagonal blocks of the real generalized
Schur form of (A,B) were further reduced to triangular form using complex
unitary transformations. If ALPHAI(j) is zero, then the jth eigenvalue is
real; if positive, then the <code>j</code>th and <code>(j+1)</code>st eigenvalues are a
complex conjugate pair, with <code>ALPHAI(j+1)</code> negative.</p>
<h4>See also</h4>
<p>qz</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">ordqz</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">AA</span><span class="p">,</span> <span class="n">BB</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">ordqz</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s1">&#39;lhp&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Since we have sorted for left half plane eigenvalues, negatives come first</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mi">0</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

</details>
<h3 id="orth_1">orth<a class="headerlink" href="#orth_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function orth</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orth</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct an orthonormal basis for the range of A using SVD</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>rcond : float, optional</strong>
    Relative condition number. Singular values <code>s</code> smaller than
    <code>rcond * max(s)</code> are considered zero.</p>
</li>
<li>
<p><strong>Default: floating point eps * max(M,N).</strong></p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>Q : (M, K) ndarray</strong>
    Orthonormal basis for the range of A.
    K = effective rank of A, as determined by rcond</li>
</ul>
<h4>See also</h4>
<ul>
<li>
<p><strong>svd : Singular value decomposition of a matrix</strong></p>
</li>
<li>
<p><strong>null_space : Matrix null space</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">orth</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># rank 2 array</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="orthogonal_procrustes">orthogonal_procrustes<a class="headerlink" href="#orthogonal_procrustes" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function orthogonal_procrustes</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">orthogonal_procrustes</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Compute the matrix solution of the orthogonal Procrustes problem.</p>
<p>Given matrices A and B of equal shape, find an orthogonal matrix R
that most closely maps A to B using the algorithm given in [1]_.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    Matrix to be mapped.</p>
</li>
<li>
<p><strong>B : (M, N) array_like</strong>
    Target matrix.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>R : (N, N) ndarray</strong>
    The matrix solution of the orthogonal Procrustes problem.
    Minimizes the Frobenius norm of <code>(A @ R) - B</code>, subject to
    <code>R.T @ R = I</code>.</p>
</li>
<li>
<p><strong>scale : float</strong>
    Sum of the singular values of <code>A.T @ B</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If the input array shapes don't match or if check_finite is True and
    the arrays contain Inf or NaN.</p>
<h4>Notes</h4>
<p>Note that unlike higher level Procrustes analyses of spatial data, this
function only uses orthogonal transformations like rotations and
reflections, and it does not use scaling or translation.</p>
<p>.. versionadded:: 0.15.0</p>
<h4>References</h4>
<p>.. [1] Peter H. Schonemann, 'A generalized solution of the orthogonal
       Procrustes problem', Psychometrica -- Vol. 31, No. 1, March, 1996.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">orthogonal_procrustes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

<p>Flip the order of columns and check for the anti-diagonal mapping</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">R</span><span class="p">,</span> <span class="n">sca</span> <span class="o">=</span> <span class="n">orthogonal_procrustes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">R</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">5.34384992e-17</span><span class="p">,</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="mf">1.00000000e+00</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>  <span class="mf">0.00000000e+00</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.00000000e+00</span><span class="p">,</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.85941422e-17</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sca</span>
<span class="mf">9.0</span>
</code></pre></div>

</details>
<h3 id="pascal_1">pascal<a class="headerlink" href="#pascal_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pascal</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pascal</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">kind</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">exact</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Returns the n x n Pascal matrix.</p>
<p>The Pascal matrix is a matrix containing the binomial coefficients as
its elements.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>n : int</strong>
    The size of the matrix to create; that is, the result is an n x n
    matrix.</p>
</li>
<li>
<p><strong>kind : str, optional</strong>
    Must be one of 'symmetric', 'lower', or 'upper'.
    Default is 'symmetric'.</p>
</li>
<li>
<p><strong>exact : bool, optional</strong>
    If <code>exact</code> is True, the result is either an array of type
    numpy.uint64 (if n &lt; 35) or an object array of Python long integers.
    If <code>exact</code> is False, the coefficients in the matrix are computed using
    <code>scipy.special.comb</code> with <code>exact=False</code>. The result will be a floating
    point array, and the values in the array will not be the exact
    coefficients, but this version is much faster than <code>exact=True</code>.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>p : (n, n) ndarray</strong>
    The Pascal matrix.</li>
</ul>
<h4>See Also</h4>
<p>invpascal</p>
<h4>Notes</h4>
<p>See https://en.wikipedia.org/wiki/Pascal_matrix for more information
about Pascal matrices.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">pascal</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint64</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pascal</span><span class="p">(</span><span class="mi">50</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">25477612258980856902730428600</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">comb</span><span class="p">(</span><span class="mi">98</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="mi">25477612258980856902730428600</span>
</code></pre></div>

</details>
<h3 id="pinv_1">pinv<a class="headerlink" href="#pinv_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinv</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using a least-squares
solver.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be pseudo-inverted.
cond, rcond : float, optional
    Cutoff factor for 'small' singular values. In <code>lstsq</code>,
    singular values less than <code>cond*largest_singular_value</code> will be
    considered as zero. If both are omitted, the default value
    <code>max(M, N) * eps</code> is passed to <code>lstsq</code> where <code>eps</code> is the
    corresponding machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps</code> without the
    factor <code>max(M, N)</code>.</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    if True, return the effective rank of the matrix</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, M) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix. Returned if return_rank == True</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If computation does not converge.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="pinv2_1">pinv2<a class="headerlink" href="#pinv2_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinv2</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinv2</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate a generalized inverse of a matrix using its
singular-value decomposition and including all 'large' singular
values.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be pseudo-inverted.
cond, rcond : float or None
    Cutoff for 'small' singular values; singular values smaller than this
    value are considered as zero. If both are omitted, the default value
    <code>max(M,N)*largest_singular_value*eps</code> is used where <code>eps</code> is the
    machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
    was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    If True, return the effective rank of the matrix.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, M) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix. Returned if <code>return_rank</code> is True.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinv2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="pinvh_1">pinvh<a class="headerlink" href="#pinvh_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function pinvh</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pinvh</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">cond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">return_rank</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</p>
<p>Calculate a generalized inverse of a Hermitian or real symmetric matrix
using its eigenvalue decomposition and including all eigenvalues with
'large' absolute value.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (N, N) array_like</strong>
    Real symmetric or complex hermetian matrix to be pseudo-inverted
cond, rcond : float or None
    Cutoff for 'small' singular values; singular values smaller than this
    value are considered as zero. If both are omitted, the default
    <code>max(M,N)*largest_eigenvalue*eps</code> is used where <code>eps</code> is the
    machine precision value of the datatype of <code>a</code>.</p>
<p>.. versionchanged:: 1.3.0
    Previously the default cutoff value was just <code>eps*f</code> where <code>f</code>
    was <code>1e3</code> for single precision and <code>1e6</code> for double precision.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Whether the pertinent array data is taken from the lower or upper
    triangle of <code>a</code>. (Default: lower)</p>
</li>
<li>
<p><strong>return_rank : bool, optional</strong>
    If True, return the effective rank of the matrix.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>B : (N, N) ndarray</strong>
    The pseudo-inverse of matrix <code>a</code>.</p>
</li>
<li>
<p><strong>rank : int</strong>
    The effective rank of the matrix.  Returned if <code>return_rank</code> is True.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If eigenvalue does not converge</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">pinvh</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">pinvh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">)))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="polar">polar<a class="headerlink" href="#polar" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function polar</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">polar</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">side</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute the polar decomposition.</p>
<p>Returns the factors of the polar decomposition [1]<em> <code>u</code> and <code>p</code> such
that <code>a = up</code> (if <code>side</code> is 'right') or <code>a = pu</code> (if <code>side</code> is
'left'), where <code>p</code> is positive semidefinite. Depending on the shape
of <code>a</code>, either the rows or columns of <code>u</code> are orthonormal. When <code>a</code>
is a square array, <code>u</code> is a square unitary array. When <code>a</code> is not
square, the 'canonical polar decomposition' [2]</em> is computed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (m, n) array_like</strong>
    The array to be factored.</p>
</li>
<li>
<p><strong>side : {'left', 'right'}, optional</strong>
    Determines whether a right or left polar decomposition is computed.
    If <code>side</code> is 'right', then <code>a = up</code>.  If <code>side</code> is 'left',  then
    <code>a = pu</code>.  The default is 'right'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>u : (m, n) ndarray</strong>
    If <code>a</code> is square, then <code>u</code> is unitary. If m &gt; n, then the columns
    of <code>a</code> are orthonormal, and if m &lt; n, then the rows of <code>u</code> are
    orthonormal.</p>
</li>
<li>
<p><strong>p : ndarray</strong>
    <code>p</code> is Hermitian positive semidefinite. If <code>a</code> is nonsingular, <code>p</code>
    is positive definite. The shape of <code>p</code> is (n, n) or (m, m), depending
    on whether <code>side</code> is 'right' or 'left', respectively.</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] R. A. Horn and C. R. Johnson, 'Matrix Analysis', Cambridge
       University Press, 1985.
.. [2] N. J. Higham, 'Functions of Matrices: Theory and Computation',
       SIAM, 2008.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">polar</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.85749293</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.51449576</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.51449576</span><span class="p">,</span>  <span class="mf">0.85749293</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.88648444</span><span class="p">,</span>  <span class="mf">1.2004901</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.2004901</span> <span class="p">,</span>  <span class="mf">3.94446746</span><span class="p">]])</span>
</code></pre></div>

<p>A non-square example, with m &lt; n:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.21196618</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.42393237</span><span class="p">,</span>  <span class="mf">0.88054056</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.39378971</span><span class="p">,</span>  <span class="mf">0.78757942</span><span class="p">,</span>  <span class="mf">0.4739708</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.48470147</span><span class="p">,</span>  <span class="mf">0.96940295</span><span class="p">,</span>  <span class="mf">1.15122648</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.96940295</span><span class="p">,</span>  <span class="mf">1.9388059</span> <span class="p">,</span>  <span class="mf">2.30245295</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.15122648</span><span class="p">,</span>  <span class="mf">2.30245295</span><span class="p">,</span>  <span class="mf">3.65696431</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># Verify the decomposition.</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">2.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">3.</span> <span class="p">,</span>  <span class="mf">4.</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>   <span class="c1"># The rows of u are orthonormal.</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.07353665e-17</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">2.07353665e-17</span><span class="p">,</span>   <span class="mf">1.00000000e+00</span><span class="p">]])</span>
</code></pre></div>

<p>Another non-square example, with m &gt; n:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.21196618</span><span class="p">,</span>  <span class="mf">0.39378971</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.42393237</span><span class="p">,</span>  <span class="mf">0.78757942</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.88054056</span><span class="p">,</span>  <span class="mf">0.4739708</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.23116567</span><span class="p">,</span>  <span class="mf">1.93241587</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.93241587</span><span class="p">,</span>  <span class="mf">4.84930602</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>   <span class="c1"># Verify the decomposition.</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">1.5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">3.</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span> <span class="p">,</span>  <span class="mf">4.</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c1"># The columns of u are orthonormal.</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">1.26363763e-16</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">1.26363763e-16</span><span class="p">,</span>   <span class="mf">1.00000000e+00</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="qr_1">qr<a class="headerlink" href="#qr_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Raw</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute QR decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in <code>a</code> is overwritten (may improve performance if
    <code>overwrite_a</code> is set to True by reusing the existing input data
    structure rather than creating a new one.)</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.</p>
</li>
<li>
<p><strong>mode : {'full', 'r', 'economic', 'raw'}, optional</strong>
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes). The final option 'raw'
    (added in SciPy 0.11) makes the function return two matrices
    (Q, TAU) in the internal format used by LAPACK.</p>
</li>
<li>
<p><strong>pivoting : bool, optional</strong>
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition. If pivoting, compute the decomposition
    <code>A P = Q R</code> as above, but where P is chosen such that the diagonal
    of R is non-increasing.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>Q : float or complex ndarray</strong>
    Of shape (M, M), or (M, K) for <code>mode='economic'</code>. Not returned
    if <code>mode='r'</code>.</p>
</li>
<li>
<p><strong>R : float or complex ndarray</strong>
    Of shape (M, N), or (K, N) for <code>mode='economic'</code>. <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>P : int ndarray</strong>
    Of shape (N,) for <code>pivoting=True</code>. Not returned if
    <code>pivoting=False</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if decomposition fails</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines dgeqrf, zgeqrf,
dorgqr, zungqr, dgeqp3, and zgeqp3.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (M, K) and (K, N) instead
of (M,M) and (M,N), with <code>K=min(M,N)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q3</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q3</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r3</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q4</span><span class="p">,</span> <span class="n">r4</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">r4</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">p4</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q4</span><span class="p">,</span> <span class="n">r4</span><span class="p">))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q4</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r4</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p4</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">q5</span><span class="p">,</span> <span class="n">r5</span><span class="p">,</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q5</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">r5</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">p5</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
</code></pre></div>

</details>
<h3 id="qr_insert">qr_insert<a class="headerlink" href="#qr_insert" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr_insert</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_insert</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">which</span><span class="o">:[`</span><span class="nc">Row</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Col</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">rcond</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_qru</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>qr_insert(Q, R, u, k, which=u'row', rcond=None, overwrite_qru=False, check_finite=True)</p>
<p>QR update on row or column insertions</p>
<p>If <code>A = Q R</code> is the QR factorization of <code>A</code>, return the QR
factorization of <code>A</code> where rows or columns have been inserted starting
at row or column <code>k</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>Q : (M, M) array_like</strong>
    Unitary/orthogonal matrix from the QR decomposition of A.</p>
</li>
<li>
<p><strong>R : (M, N) array_like</strong>
    Upper triangular matrix from the QR decomposition of A.</p>
</li>
<li>
<p><strong>u : (N,), (p, N), (M,), or (M, p) array_like</strong>
    Rows or columns to insert</p>
</li>
<li>
<p><strong>k : int</strong>
    Index before which <code>u</code> is to be inserted.</p>
</li>
<li>
<p><strong>which: {'row', 'col'}, optional</strong>
    Determines if rows or columns will be inserted, defaults to 'row'</p>
</li>
<li>
<p><strong>rcond : float</strong>
    Lower bound on the reciprocal condition number of <code>Q</code> augmented with
    <code>u/||u||</code> Only used when updating economic mode (thin, (M,N) (N,N))
    decompositions.  If None, machine precision is used.  Defaults to
    None.</p>
</li>
<li>
<p><strong>overwrite_qru : bool, optional</strong>
    If True, consume Q, R, and u, if possible, while performing the update,
    otherwise make copies as necessary. Defaults to False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>Q1 : ndarray</strong>
    Updated unitary/orthogonal factor</p>
</li>
<li>
<p><strong>R1 : ndarray</strong>
    Updated upper triangular factor</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError :
    If updating a (M,N) (N,N) factorization and the reciprocal condition
    number of Q augmented with u/||u|| is smaller than rcond.</p>
<h4>See Also</h4>
<p>qr, qr_multiply, qr_delete, qr_update</p>
<h4>Notes</h4>
<p>This routine does not guarantee that the diagonal entries of <code>R1</code> are
positive.</p>
<p>.. versionadded:: 0.16.0</p>
<h4>References</h4>
<p>.. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
       (Johns Hopkins University Press, 1996).</p>
<p>.. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
       Reorthogonalization and stable algorithms for updating the
       Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).</p>
<p>.. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
       Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
       (1990).</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">7.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">6.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div>

<p>Given this QR decomposition, update q and r when 2 rows are inserted.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">9.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q1</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr_insert</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;row&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q1</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.25445668</span><span class="p">,</span>  <span class="mf">0.02246245</span><span class="p">,</span>  <span class="mf">0.18146236</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.72798806</span><span class="p">,</span>  <span class="mf">0.60979671</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.50891336</span><span class="p">,</span>  <span class="mf">0.23226178</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.82836478</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02837033</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00828114</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.50891336</span><span class="p">,</span>  <span class="mf">0.35715302</span><span class="p">,</span>  <span class="mf">0.38937158</span><span class="p">,</span>  <span class="mf">0.58110733</span><span class="p">,</span>  <span class="mf">0.35235345</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.25445668</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.52202743</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32165498</span><span class="p">,</span>  <span class="mf">0.36263239</span><span class="p">,</span>  <span class="mf">0.65404509</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.59373225</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.73856549</span><span class="p">,</span>  <span class="mf">0.16065817</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0063658</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.27595554</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r1</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">11.78982612</span><span class="p">,</span>   <span class="mf">6.44623587</span><span class="p">,</span>   <span class="mf">3.81685018</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">16.01393278</span><span class="p">,</span>   <span class="mf">3.72202865</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">6.13010256</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">]])</span>
</code></pre></div>

<p>The update is equivalent, but faster than the following.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">7.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">9.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">6.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_direct</span><span class="p">,</span> <span class="n">r_direct</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
</code></pre></div>

<p>Check that we have equivalent results:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">7.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">9.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">6.</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="n">a1</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>And the updated Q is still unitary:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="qr_multiply_1">qr_multiply<a class="headerlink" href="#qr_multiply_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr_multiply</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_multiply</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Left</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Right</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">pivoting</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">conjugate</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_c</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the QR decomposition and multiply Q with a matrix.</p>
<p>Calculate the decomposition <code>A = Q R</code> where Q is unitary/orthogonal
and R upper triangular. Multiply Q with a vector or a matrix c.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N), array_like</strong>
    Input array</p>
</li>
<li>
<p><strong>c : array_like</strong>
    Input array to be multiplied by <code>q</code>.</p>
</li>
<li>
<p><strong>mode : {'left', 'right'}, optional</strong>
    <code>Q @ c</code> is returned if mode is 'left', <code>c @ Q</code> is returned if
    mode is 'right'.
    The shape of c must be appropriate for the matrix multiplications,
    if mode is 'left', <code>min(a.shape) == c.shape[0]</code>,
    if mode is 'right', <code>a.shape[0] == c.shape[1]</code>.</p>
</li>
<li>
<p><strong>pivoting : bool, optional</strong>
    Whether or not factorization should include pivoting for rank-revealing
    qr decomposition, see the documentation of qr.</p>
</li>
<li>
<p><strong>conjugate : bool, optional</strong>
    Whether Q should be complex-conjugated. This might be faster
    than explicit conjugation.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in a is overwritten (may improve performance)</p>
</li>
<li>
<p><strong>overwrite_c : bool, optional</strong>
    Whether data in c is overwritten (may improve performance).
    If this is used, c must be big enough to keep the result,
    i.e. <code>c.shape[0]</code> = <code>a.shape[0]</code> if mode is 'left'.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>CQ : ndarray</strong>
    The product of <code>Q</code> and <code>c</code>.</p>
</li>
<li>
<p><strong>R : (K, N), ndarray</strong>
    R array of the resulting QR factorization where <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>P : (N,) ndarray</strong>
    Integer pivot array. Only returned when <code>pivoting=True</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Raised if QR decomposition fails.</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines <code>?GEQRF</code>, <code>?ORMQR</code>,
<code>?UNMQR</code>, and <code>?GEQP3</code>.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">qr_multiply</span><span class="p">,</span> <span class="n">qr</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qc</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">piv1</span> <span class="o">=</span> <span class="n">qr_multiply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">pivoting</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qc</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r1</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span>            <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.11022302e-16</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span>            <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">piv1</span>
<span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q2</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">piv2</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q2</span> <span class="o">-</span> <span class="n">qc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="qr_update">qr_update<a class="headerlink" href="#qr_update" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qr_update</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qr_update</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_qruv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">r</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">v</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)</p>
<p>Rank-k QR update</p>
<p>If <code>A = Q R</code> is the QR factorization of <code>A</code>, return the QR
factorization of <code>A + u v**T</code> for real <code>A</code> or <code>A + u v**H</code>
for complex <code>A</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>Q : (M, M) or (M, N) array_like</strong>
    Unitary/orthogonal matrix from the qr decomposition of A.</p>
</li>
<li>
<p><strong>R : (M, N) or (N, N) array_like</strong>
    Upper triangular matrix from the qr decomposition of A.</p>
</li>
<li>
<p><strong>u : (M,) or (M, k) array_like</strong>
    Left update vector</p>
</li>
<li>
<p><strong>v : (N,) or (N, k) array_like</strong>
    Right update vector</p>
</li>
<li>
<p><strong>overwrite_qruv : bool, optional</strong>
    If True, consume Q, R, u, and v, if possible, while performing the
    update, otherwise make copies as necessary. Defaults to False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.
    Default is True.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>Q1 : ndarray</strong>
    Updated unitary/orthogonal factor</p>
</li>
<li>
<p><strong>R1 : ndarray</strong>
    Updated upper triangular factor</p>
</li>
</ul>
<h4>See Also</h4>
<p>qr, qr_multiply, qr_delete, qr_insert</p>
<h4>Notes</h4>
<p>This routine does not guarantee that the diagonal entries of <code>R1</code> are
real or positive.</p>
<p>.. versionadded:: 0.16.0</p>
<h4>References</h4>
<p>.. [1] Golub, G. H. &amp; Van Loan, C. F. Matrix Computations, 3rd Ed.
       (Johns Hopkins University Press, 1996).</p>
<p>.. [2] Daniel, J. W., Gragg, W. B., Kaufman, L. &amp; Stewart, G. W.
       Reorthogonalization and stable algorithms for updating the
       Gram-Schmidt QR factorization. Math. Comput. 30, 772-795 (1976).</p>
<p>.. [3] Reichel, L. &amp; Gragg, W. B. Algorithm 686: FORTRAN Subroutines for
       Updating the QR Decomposition. ACM Trans. Math. Softw. 16, 369-377
       (1990).</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">2.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">9.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">7.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>  <span class="o">-</span><span class="mf">6.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div>

<p>Given this q, r decomposition, perform a rank 1 update.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">7.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_up</span><span class="p">,</span> <span class="n">r_up</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr_update</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_up</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.54073807</span><span class="p">,</span>  <span class="mf">0.18645997</span><span class="p">,</span>  <span class="mf">0.81707661</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02136616</span><span class="p">,</span>  <span class="mf">0.06902409</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span> <span class="mf">0.21629523</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.63257324</span><span class="p">,</span>  <span class="mf">0.06567893</span><span class="p">,</span>  <span class="mf">0.34125904</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.65749222</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.05407381</span><span class="p">,</span>  <span class="mf">0.64757787</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.12781284</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.20031219</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.72198188</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.48666426</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.30466718</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.27487277</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.77079214</span><span class="p">,</span>  <span class="mf">0.0256951</span> <span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.64888568</span><span class="p">,</span>  <span class="mf">0.23001</span>   <span class="p">,</span> <span class="o">-</span><span class="mf">0.4859845</span> <span class="p">,</span>  <span class="mf">0.49883891</span><span class="p">,</span>  <span class="mf">0.20253783</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r_up</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">18.49324201</span><span class="p">,</span>  <span class="mf">24.11691794</span><span class="p">,</span> <span class="o">-</span><span class="mf">44.98940746</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">31.95894662</span><span class="p">,</span> <span class="o">-</span><span class="mf">27.40998201</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">9.25451794</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">]])</span>
</code></pre></div>

<p>The update is equivalent, but faster than the following.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a_up</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_direct</span><span class="p">,</span> <span class="n">r_direct</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a_up</span><span class="p">)</span>
</code></pre></div>

<p>Check that we have equivalent results:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_up</span><span class="p">,</span> <span class="n">r_up</span><span class="p">),</span> <span class="n">a_up</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>And the updated Q is still unitary:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_up</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q_up</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

<p>Updating economic (reduced, thin) decompositions is also possible:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">qe</span><span class="p">,</span> <span class="n">re</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qe_up</span><span class="p">,</span> <span class="n">re_up</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr_update</span><span class="p">(</span><span class="n">qe</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">qe_up</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.54073807</span><span class="p">,</span>  <span class="mf">0.18645997</span><span class="p">,</span>  <span class="mf">0.81707661</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span> <span class="mf">0.21629523</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.63257324</span><span class="p">,</span>  <span class="mf">0.06567893</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.05407381</span><span class="p">,</span>  <span class="mf">0.64757787</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.12781284</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.48666426</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.30466718</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.27487277</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.64888568</span><span class="p">,</span>  <span class="mf">0.23001</span>   <span class="p">,</span> <span class="o">-</span><span class="mf">0.4859845</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">re_up</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">18.49324201</span><span class="p">,</span>  <span class="mf">24.11691794</span><span class="p">,</span> <span class="o">-</span><span class="mf">44.98940746</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">31.95894662</span><span class="p">,</span> <span class="o">-</span><span class="mf">27.40998201</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="o">-</span><span class="mf">9.25451794</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">qe_up</span><span class="p">,</span> <span class="n">re_up</span><span class="p">),</span> <span class="n">a_up</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">qe_up</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">qe_up</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

<p>Similarly to the above, perform a rank 2 update.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">7.</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,],</span>
<span class="o">...</span>                <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_up2</span><span class="p">,</span> <span class="n">r_up2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr_update</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q_up2</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.33626508</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03477253</span><span class="p">,</span>  <span class="mf">0.61956287</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.64352987</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.29618884</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.50439762</span><span class="p">,</span>  <span class="mf">0.58319694</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.43010077</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.33395279</span><span class="p">,</span>  <span class="mf">0.33008064</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.21016568</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.63123106</span><span class="p">,</span>  <span class="mf">0.0582249</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.13675572</span><span class="p">,</span>  <span class="mf">0.73163206</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.12609941</span><span class="p">,</span>  <span class="mf">0.49694436</span><span class="p">,</span>  <span class="mf">0.64590024</span><span class="p">,</span>  <span class="mf">0.31191919</span><span class="p">,</span>  <span class="mf">0.47187344</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.75659643</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.11517748</span><span class="p">,</span>  <span class="mf">0.10284903</span><span class="p">,</span>  <span class="mf">0.5986227</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.21299983</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r_up2</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">23.79075451</span><span class="p">,</span> <span class="o">-</span><span class="mf">41.1084062</span> <span class="p">,</span>  <span class="mf">24.71548348</span><span class="p">],</span>  <span class="c1"># may vary (signs)</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">33.83931057</span><span class="p">,</span>  <span class="mf">11.02226551</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">48.91476811</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">]])</span>
</code></pre></div>

<p>This update is also a valid qr decomposition of <code>A + U V**T</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a_up2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="n">v2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a_up2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_up2</span><span class="p">,</span> <span class="n">r_up2</span><span class="p">))</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_up2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q_up2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="qz">qz<a class="headerlink" href="#qz" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function qz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">qz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>QZ decomposition for generalized eigenvalues of a pair of matrices.</p>
<p>The QZ, or generalized Schur, decomposition for a pair of N x N
nonsymmetric matrices (A,B) is::</p>
<div class="codehilite"><pre><span></span><code>(A,B) = (Q*AA*Z&#39;, Q*BB*Z&#39;)
</code></pre></div>


<p>where AA, BB is in generalized Schur form if BB is upper-triangular
with non-negative diagonal and AA is upper-triangular, or for real QZ
decomposition (<code>output='real'</code>) block upper triangular with 1x1
and 2x2 blocks. In this case, the 1x1 blocks correspond to real
generalized eigenvalues and 2x2 blocks are 'standardized' by making
the corresponding elements of BB have the form::</p>
<div class="codehilite"><pre><span></span><code>[ a 0 ]
[ 0 b ]
</code></pre></div>


<p>and the pair of corresponding 2x2 blocks in AA and BB will have a complex
conjugate pair of generalized eigenvalues. If (<code>output='complex'</code>) or
A and B are complex matrices, Z' denotes the conjugate-transpose of Z.
Q and Z are unitary matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    2-D array to decompose</p>
</li>
<li>
<p><strong>B : (N, N) array_like</strong>
    2-D array to decompose</p>
</li>
<li>
<p><strong>output : {'real', 'complex'}, optional</strong>
    Construct the real or complex QZ decomposition for real matrices.
    Default is 'real'.</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size. If None or -1, it is automatically computed.</p>
</li>
<li>
<p><strong>sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional</strong></p>
</li>
<li>
<p><strong>NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead.</strong></p>
<p>Specifies whether the upper eigenvalues should be sorted. A callable
may be passed that, given a eigenvalue, returns a boolean denoting
whether the eigenvalue should be sorted to the top-left (True). For
real matrix pairs, the sort function takes three real arguments
(alphar, alphai, beta). The eigenvalue
<code>x = (alphar + alphai*1j)/beta</code>. For complex matrix pairs or
output='complex', the sort function takes two complex arguments
(alpha, beta). The eigenvalue <code>x = (alpha/beta)</code>.  Alternatively,
string parameters may be used:</p>
<div class="codehilite"><pre><span></span><code>- &#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)
- &#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)
- &#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt; 1.0)
- &#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)
</code></pre></div>


<p>Defaults to None (no sorting).</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance)</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Whether to overwrite data in b (may improve performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    If true checks the elements of <code>A</code> and <code>B</code> are finite numbers. If
    false does no checking and passes matrix through to
    underlying algorithm.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>AA : (N, N) ndarray</strong>
    Generalized Schur form of A.</p>
</li>
<li>
<p><strong>BB : (N, N) ndarray</strong>
    Generalized Schur form of B.</p>
</li>
<li>
<p><strong>Q : (N, N) ndarray</strong>
    The left Schur vectors.</p>
</li>
<li>
<p><strong>Z : (N, N) ndarray</strong>
    The right Schur vectors.</p>
</li>
</ul>
<h4>Notes</h4>
<p>Q is transposed versus the equivalent function in Matlab.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">AA</span><span class="p">,</span> <span class="n">BB</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qz</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">AA</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">13.40928183</span><span class="p">,</span>  <span class="o">-</span><span class="mf">4.62471562</span><span class="p">,</span>   <span class="mf">1.09215523</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">1.22805978</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.</span>        <span class="p">,</span>   <span class="mf">0.31973817</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">BB</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.33362547</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.37393632</span><span class="p">,</span>  <span class="mf">0.02179805</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.68144922</span><span class="p">,</span>  <span class="mf">0.74683866</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.9258294</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Q</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.14134727</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.97562773</span><span class="p">,</span>  <span class="mf">0.16784365</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.49835904</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.07636948</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.86360059</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.85537081</span><span class="p">,</span>  <span class="mf">0.20571399</span><span class="p">,</span>  <span class="mf">0.47541828</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.24900855</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.51772687</span><span class="p">,</span>  <span class="mf">0.81850696</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.79813178</span><span class="p">,</span>  <span class="mf">0.58842606</span><span class="p">,</span>  <span class="mf">0.12938478</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.54861681</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6210585</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.55973739</span><span class="p">]])</span>
</code></pre></div>

<h4>See also</h4>
<p>ordqz</p>
</details>
<h3 id="rq_1">rq<a class="headerlink" href="#rq_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function rq</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rq</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">mode</span><span class="o">:[`</span><span class="nc">Full</span> <span class="o">|</span> <span class="o">`</span><span class="nc">R</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Economic</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">(</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Compute RQ decomposition of a matrix.</p>
<p>Calculate the decomposition <code>A = R Q</code> where Q is unitary/orthogonal
and R upper triangular.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to be decomposed</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether data in a is overwritten (may improve performance)</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size
    is computed.</p>
</li>
<li>
<p><strong>mode : {'full', 'r', 'economic'}, optional</strong>
    Determines what information is to be returned: either both Q and R
    ('full', default), only R ('r') or both Q and R but computed in
    economy-size ('economic', see Notes).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>R : float or complex ndarray</strong>
    Of shape (M, N) or (M, K) for <code>mode='economic'</code>. <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>Q : float or complex ndarray</strong>
    Of shape (N, N) or (K, N) for <code>mode='economic'</code>. Not returned
    if <code>mode='r'</code>.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If decomposition fails.</p>
<h4>Notes</h4>
<p>This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf,
sorgrq, dorgrq, cungrq and zungrq.</p>
<p>If <code>mode=economic</code>, the shapes of Q and R are (K, N) and (M, K) instead
of (N,N) and (M,N), with <code>K=min(M,N)</code>.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="o">@</span> <span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r3</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r3</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">q3</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
</code></pre></div>

</details>
<h3 id="rsf2csf_2">rsf2csf<a class="headerlink" href="#rsf2csf_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function rsf2csf</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">rsf2csf</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Convert real Schur form to complex Schur form.</p>
<p>Convert a quasi-diagonal real-valued Schur form to the upper-triangular
complex-valued Schur form.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>T : (M, M) array_like</strong>
    Real Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) array_like</strong>
    Schur transformation matrix</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input arrays contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Complex Schur form of the original array</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    Schur transformation matrix corresponding to the complex form</p>
</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>schur : Schur decomposition of an array</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">rsf2csf</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span> <span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">rsf2csf</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">2.65896708</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.64592781</span><span class="o">+</span><span class="mf">0.743164187</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.21516887</span><span class="o">+</span><span class="mf">1.00660462</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">8.02254558e-01</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.82115218</span><span class="o">-</span><span class="mf">2.77555756e-17</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="p">,</span> <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.802254558</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z2</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.28220393</span><span class="o">-</span><span class="mf">0.31385693</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.51319638</span><span class="o">-</span><span class="mf">0.17258824</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.24720268</span><span class="o">+</span><span class="mf">0.41635578</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.68079517</span><span class="o">-</span><span class="mf">0.15118243</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76618703</span><span class="o">+</span><span class="mf">0.01873251</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03063006</span><span class="o">+</span><span class="mf">0.46857912</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="schur_2">schur<a class="headerlink" href="#schur_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function schur</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">schur</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">output</span><span class="o">:[`</span><span class="nc">Real</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Complex</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lwork</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">sort</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Lhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Iuc</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Rhp</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Ouc</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span>
</code></pre></div>

<p>Compute Schur decomposition of a matrix.</p>
<p>The Schur decomposition is::</p>
<div class="codehilite"><pre><span></span><code>A = Z T Z^H
</code></pre></div>


<p>where Z is unitary and T is either upper-triangular, or for real
Schur decomposition (output='real'), quasi-upper triangular. In
the quasi-triangular form, 2x2 blocks describing complex-valued
eigenvalue pairs may extrude from the diagonal.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Matrix to decompose</p>
</li>
<li>
<p><strong>output : {'real', 'complex'}, optional</strong>
    Construct the real or complex Schur decomposition (for real matrices).</p>
</li>
<li>
<p><strong>lwork : int, optional</strong>
    Work array size. If None or -1, it is automatically computed.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite data in a (may improve performance).</p>
</li>
<li>
<p><strong>sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional</strong>
    Specifies whether the upper eigenvalues should be sorted. A callable
    may be passed that, given a eigenvalue, returns a boolean denoting
    whether the eigenvalue should be sorted to the top-left (True).
    Alternatively, string parameters may be used::</p>
<div class="codehilite"><pre><span></span><code>&#39;lhp&#39;   Left-hand plane (x.real &lt; 0.0)
&#39;rhp&#39;   Right-hand plane (x.real &gt; 0.0)
&#39;iuc&#39;   Inside the unit circle (x*x.conjugate() &lt;= 1.0)
&#39;ouc&#39;   Outside the unit circle (x*x.conjugate() &gt; 1.0)
</code></pre></div>


<p>Defaults to None (no sorting).</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>T : (M, M) ndarray</strong>
    Schur form of A. It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>Z : (M, M) ndarray</strong>
    An unitary Schur transformation matrix for A.
    It is real-valued for the real Schur decomposition.</p>
</li>
<li>
<p><strong>sdim : int</strong>
    If and only if sorting was requested, a third return value will
    contain the number of eigenvalues satisfying the sort condition.</p>
</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    Error raised under three conditions:</p>
<div class="codehilite"><pre><span></span><code>1. The algorithm failed due to a failure of the QR algorithm to
   compute all eigenvalues.
2. If eigenvalue sorting was requested, the eigenvalues could not be
   reordered due to a failure to separate eigenvalues, usually because
   of poor conditioning.
3. If eigenvalue sorting was requested, roundoff errors caused the
   leading eigenvalues to no longer satisfy the sorting condition.
</code></pre></div>


<h4>See also</h4>
<ul>
<li><strong>rsf2csf : Convert real Schur form to complex Schur form</strong></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">schur</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span>  <span class="mf">1.42440458</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.92933439</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.49063704</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">1.31178921</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Z</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.72711591</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.60156188</span><span class="p">,</span> <span class="mf">0.33079564</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.52839428</span><span class="p">,</span> <span class="mf">0.79801892</span><span class="p">,</span> <span class="mf">0.28976765</span><span class="p">],</span>
       <span class="p">[</span><span class="mf">0.43829436</span><span class="p">,</span> <span class="mf">0.03590414</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.89811411</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">Z2</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T2</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.22839825</span><span class="o">+</span><span class="mf">1.32378589</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.42590089</span><span class="o">+</span><span class="mf">1.51937378</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.59877807</span><span class="o">+</span><span class="mf">0.56192146</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>                    <span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">2.65896708</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">+</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.32948354</span><span class="o">-</span><span class="mf">0.80225456</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

<p>An arbitrary custom eig-sorting condition, having positive imaginary part,
which is satisfied by only one eigenvalue</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T3</span><span class="p">,</span> <span class="n">Z3</span><span class="p">,</span> <span class="n">sdim</span> <span class="o">=</span> <span class="n">schur</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sdim</span>
<span class="mi">1</span>
</code></pre></div>

</details>
<h3 id="signm_1">signm<a class="headerlink" href="#signm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function signm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">signm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix sign function.</p>
<p>Extension of the scalar sign(x) to matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix at which to evaluate the sign function</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>signm : (N, N) ndarray</strong>
    Value of the sign function at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>1-norm of the estimated error, ||err||_1 / ||A||_1</p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">signm</span><span class="p">,</span> <span class="n">eigvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.12488542</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.76155718</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.63667176</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">signm</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="sinhm_1">sinhm<a class="headerlink" href="#sinhm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sinhm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinhm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>sinhm : (N, N) ndarray</strong>
    Hyperbolic matrix sine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">10.57300653</span><span class="p">,</span>  <span class="mf">39.28826594</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">13.09608865</span><span class="p">,</span>  <span class="mf">49.86127247</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="sinm_1">sinm<a class="headerlink" href="#sinm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sinm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sinm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix sine.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>sinm : (N, N) ndarray</strong>
    Matrix sine of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
</code></pre></div>

<p>Euler's identity (exp(i<em>theta) = cos(theta) + i</em>sin(theta))
applied to a matrix:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expm</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.42645930</span><span class="o">+</span><span class="mf">1.89217551</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.13721484</span><span class="o">-</span><span class="mf">0.97811252</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.06860742</span><span class="o">+</span><span class="mf">0.48905626</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.71075555</span><span class="o">+</span><span class="mf">0.91406299</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="solve_2">solve<a class="headerlink" href="#solve_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">sym_pos</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">assume_a</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">transposed</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the linear equation set <code>a * x = b</code> for the unknown <code>x</code>
for square <code>a</code> matrix.</p>
<p>If the data matrix is known to be a particular type then supplying the
corresponding string to <code>assume_a</code> key chooses the dedicated solver.
The available options are</p>
<p>===================  ========
 generic matrix       'gen'
 symmetric            'sym'
 hermitian            'her'
 positive definite    'pos'
===================  ========</p>
<p>If omitted, <code>'gen'</code> is the default structure.</p>
<p>The datatype of the arrays define which solver is called regardless
of the values. In other words, even when the complex array entries have
precisely zero imaginary parts, the complex solver will be called based
on the data type of the array.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (N, N) array_like</strong>
    Square input data</p>
</li>
<li>
<p><strong>b : (N, NRHS) array_like</strong>
    Input data for the right hand side.</p>
</li>
<li>
<p><strong>sym_pos : bool, optional</strong>
    Assume <code>a</code> is symmetric and positive definite. This key is deprecated
    and assume_a = 'pos' keyword is recommended instead. The functionality
    is the same. It will be removed in the future.</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    If True, only the data contained in the lower triangle of <code>a</code>. Default
    is to use upper triangle. (ignored for <code>'gen'</code>)</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Allow overwriting data in <code>a</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Allow overwriting data in <code>b</code> (may enhance performance).
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>assume_a : str, optional</strong>
    Valid entries are explained above.</p>
</li>
<li>
<p><strong>transposed: bool, optional</strong>
    If True, <code>a^T x = b</code> for real matrices, raises <code>NotImplementedError</code>
    for complex matrices (only for True).</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (N, NRHS) ndarray</strong>
    The solution array.</li>
</ul>
<h4>Raises</h4>
<p>ValueError
    If size mismatches detected or input a is not square.
LinAlgError
    If the matrix is singular.
LinAlgWarning
    If an ill-conditioned input a is detected.
NotImplementedError
    If transposed is True and input a is a complex matrix.</p>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>b</code>, solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

<h4>Notes</h4>
<p>If the input b matrix is a 1-D array with N elements, when supplied
together with an NxN input a, it is assumed as a valid column vector
despite the apparent size mismatch. This is compatible with the
numpy.dot() behavior and the returned result is still 1-D array.</p>
<p>The generic, symmetric, hermitian and positive definite solutions are
obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of
LAPACK respectively.</p>
</details>
<h3 id="solve_banded_1">solve_banded<a class="headerlink" href="#solve_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">l_and_u</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation a x = b for x, assuming a is banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> using the matrix diagonal ordered form::</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]
</code></pre></div>


<p>Example of <code>ab</code> (shape of a is (6,6), <code>u</code> =1, <code>l</code> =2)::</p>
<div class="codehilite"><pre><span></span><code>*    a01  a12  a23  a34  a45
a00  a11  a22  a33  a44  a55
a10  a21  a32  a43  a54   *
a20  a31  a42  a53   *    *
</code></pre></div>


<h4>Parameters</h4>
<p>(l, u) : (integer, integer)
    Number of non-zero lower and upper diagonals</p>
<ul>
<li>
<p><strong>ab : (<code>l</code> + <code>u</code> + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in <code>ab</code> (may enhance performance)</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system a x = b. Returned shape depends on the
    shape of <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<p>Solve the banded system a x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [5  2 -1  0  0]       [0]
    [1  4  2 -1  0]       [1]
a = [0  1  3  2 -1]   b = [2]
    [0  0  1  2  2]       [2]
    [0  0  0  1  1]       [3]
</code></pre></div>


<p>There is one nonzero diagonal below the main diagonal (l = 1), and
two above (u = 2). The diagonal banded form of the matrix is::</p>
<div class="codehilite"><pre><span></span><code>     [*  * -1 -1 -1]
ab = [*  2  2  2  2]
     [5  4  3  2  1]
     [1  1  1  1  *]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_banded</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_banded</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.37288136</span><span class="p">,</span>  <span class="mf">3.93220339</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span>        <span class="p">,</span>  <span class="mf">4.3559322</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.3559322</span> <span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_circulant_1">solve_circulant<a class="headerlink" href="#solve_circulant_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_circulant</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_circulant</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">singular</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">tol</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">caxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">baxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">outaxis</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve C x = b for x, where C is a circulant matrix.</p>
<p><code>C</code> is the circulant matrix associated with the vector <code>c</code>.</p>
<p>The system is solved by doing division in Fourier space. The
calculation is::</p>
<div class="codehilite"><pre><span></span><code>x = ifft(fft(b) / fft(c))
</code></pre></div>


<p>where <code>fft</code> and <code>ifft</code> are the fast Fourier transform and its inverse,
respectively. For a large vector <code>c</code>, this is <em>much</em> faster than
solving the system with the full circulant matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    The coefficients of the circulant matrix.</p>
</li>
<li>
<p><strong>b : array_like</strong>
    Right-hand side matrix in <code>a x = b</code>.</p>
</li>
<li>
<p><strong>singular : str, optional</strong>
    This argument controls how a near singular circulant matrix is
    handled.  If <code>singular</code> is 'raise' and the circulant matrix is
    near singular, a <code>LinAlgError</code> is raised. If <code>singular</code> is
    'lstsq', the least squares solution is returned. Default is 'raise'.</p>
</li>
<li>
<p><strong>tol : float, optional</strong>
    If any eigenvalue of the circulant matrix has an absolute value
    that is less than or equal to <code>tol</code>, the matrix is considered to be
    near singular. If not given, <code>tol</code> is set to::</p>
<div class="codehilite"><pre><span></span><code>tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps
</code></pre></div>


<p>where <code>abs_eigs</code> is the array of absolute values of the eigenvalues
of the circulant matrix.</p>
</li>
<li>
<p><strong>caxis : int</strong>
    When <code>c</code> has dimension greater than 1, it is viewed as a collection
    of circulant vectors. In this case, <code>caxis</code> is the axis of <code>c</code> that
    holds the vectors of circulant coefficients.</p>
</li>
<li>
<p><strong>baxis : int</strong>
    When <code>b</code> has dimension greater than 1, it is viewed as a collection
    of vectors. In this case, <code>baxis</code> is the axis of <code>b</code> that holds the
    right-hand side vectors.</p>
</li>
<li>
<p><strong>outaxis : int</strong>
    When <code>c</code> or <code>b</code> are multidimensional, the value returned by
    <code>solve_circulant</code> is multidimensional. In this case, <code>outaxis</code> is
    the axis of the result that holds the solution vectors.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : ndarray</strong>
    Solution to the system <code>C x = b</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If the circulant matrix associated with <code>c</code> is near singular.</p>
<h4>See Also</h4>
<ul>
<li><strong>circulant : circulant matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>For a 1-D vector <code>c</code> with length <code>m</code>, and an array <code>b</code>
with shape <code>(m, ...)</code>,</p>
<div class="codehilite"><pre><span></span><code>solve_circulant(c, b)
</code></pre></div>


<p>returns the same result as</p>
<div class="codehilite"><pre><span></span><code>solve(circulant(c), b)
</code></pre></div>


<p>where <code>solve</code> and <code>circulant</code> are from <code>scipy.linalg</code>.</p>
<p>.. versionadded:: 0.16.0</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_circulant</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">circulant</span><span class="p">,</span> <span class="n">lstsq</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>  <span class="mf">0.25</span><span class="p">])</span>
</code></pre></div>

<p>Compare that result to solving the system with <code>scipy.linalg.solve</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">circulant</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span>  <span class="mf">0.25</span><span class="p">])</span>
</code></pre></div>

<p>A singular example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>

<p>Calling <code>solve_circulant(c, b)</code> will raise a <code>LinAlgError</code>.  For the
least square solution, use the option <code>singular='lstsq'</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">singular</span><span class="o">=</span><span class="s1">&#39;lstsq&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">,</span>  <span class="mf">2.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">])</span>
</code></pre></div>

<p>Compare to <code>scipy.linalg.lstsq</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">rnk</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">circulant</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">,</span>  <span class="mf">2.25</span><span class="p">,</span>  <span class="mf">1.25</span><span class="p">])</span>
</code></pre></div>

<p>A broadcasting example:</p>
<p>Suppose we have the vectors of two circulant matrices stored in an array
with shape (2, 5), and three <code>b</code> vectors stored in an array with shape
(3, 5).  For example,</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div>

<p>We want to solve all combinations of circulant matrices and <code>b</code> vectors,
with the result stored in an array with shape (2, 3, 5). When we
disregard the axes of <code>c</code> and <code>b</code> that hold the vectors of coefficients,
the shapes of the collections are (2,) and (3,), respectively, which are
not compatible for broadcasting. To have a broadcast result with shape
(2, 3), we add a trivial dimension to <code>c</code>: <code>c[:, np.newaxis, :]</code> has
shape (2, 1, 5). The last dimension holds the coefficients of the
circulant matrices, so when we call <code>solve_circulant</code>, we can use the
default <code>caxis=-1</code>. The coefficients of the <code>b</code> vectors are in the last
dimension of the array <code>b</code>, so we use <code>baxis=-1</code>. If we use the
default <code>outaxis</code>, the result will have shape (5, 2, 3), so we'll use
<code>outaxis=-1</code> to put the solution vectors in the last dimension.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">,</span> <span class="n">baxis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># For compact output of numbers.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[[</span><span class="o">-</span><span class="mf">0.118</span><span class="p">,</span>  <span class="mf">0.22</span> <span class="p">,</span>  <span class="mf">1.277</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.142</span><span class="p">,</span>  <span class="mf">0.302</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.651</span><span class="p">,</span>  <span class="mf">0.989</span><span class="p">,</span>  <span class="mf">2.046</span><span class="p">,</span>  <span class="mf">0.627</span><span class="p">,</span>  <span class="mf">1.072</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.42</span> <span class="p">,</span>  <span class="mf">1.758</span><span class="p">,</span>  <span class="mf">2.816</span><span class="p">,</span>  <span class="mf">1.396</span><span class="p">,</span>  <span class="mf">1.841</span><span class="p">]],</span>
       <span class="p">[[</span> <span class="mf">0.401</span><span class="p">,</span>  <span class="mf">0.304</span><span class="p">,</span>  <span class="mf">0.694</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.867</span><span class="p">,</span>  <span class="mf">0.377</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.856</span><span class="p">,</span>  <span class="mf">0.758</span><span class="p">,</span>  <span class="mf">1.149</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.412</span><span class="p">,</span>  <span class="mf">0.831</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">1.31</span> <span class="p">,</span>  <span class="mf">1.213</span><span class="p">,</span>  <span class="mf">1.603</span><span class="p">,</span>  <span class="mf">0.042</span><span class="p">,</span>  <span class="mf">1.286</span><span class="p">]]])</span>
</code></pre></div>

<p>Check by solving one pair of <code>c</code> and <code>b</code> vectors (cf. <code>x[1, 1, :]</code>):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.856</span><span class="p">,</span>  <span class="mf">0.758</span><span class="p">,</span>  <span class="mf">1.149</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.412</span><span class="p">,</span>  <span class="mf">0.831</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_continuous_are">solve_continuous_are<a class="headerlink" href="#solve_continuous_are" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_continuous_are</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_continuous_are</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">s</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">balanced</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous-time algebraic Riccati equation (CARE).</p>
<p>The CARE is defined as</p>
<div>
<div class="MathJax_Preview">
      X A + A^H X - X B R^{-1} B^H X + Q = 0
</div>
<script type="math/tex; mode=display">
      X A + A^H X - X B R^{-1} B^H X + Q = 0
</script>
</div>
<p>The limitations for a solution to exist are :</p>
<div class="codehilite"><pre><span></span><code>* All eigenvalues of :math:`A` on the right half plane, should be
  controllable.

* The associated hamiltonian pencil (See Notes), should have
  eigenvalues sufficiently away from the imaginary axis.
</code></pre></div>


<p>Moreover, if <code>e</code> or <code>s</code> is not precisely <code>None</code>, then the
generalized version of CARE</p>
<div>
<div class="MathJax_Preview">
      E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0
</div>
<script type="math/tex; mode=display">
      E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0
</script>
</div>
<p>is solved. When omitted, <code>e</code> is assumed to be the identity and <code>s</code>
is assumed to be the zero matrix with sizes compatible with <code>a</code> and
<code>b</code>, respectively.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Square matrix</p>
</li>
<li>
<p><strong>b : (M, N) array_like</strong>
    Input</p>
</li>
<li>
<p><strong>q : (M, M) array_like</strong>
    Input</p>
</li>
<li>
<p><strong>r : (N, N) array_like</strong>
    Nonsingular square matrix</p>
</li>
<li>
<p><strong>e : (M, M) array_like, optional</strong>
    Nonsingular square matrix</p>
</li>
<li>
<p><strong>s : (M, N) array_like, optional</strong>
    Input</p>
</li>
<li>
<p><strong>balanced : bool, optional</strong>
    The boolean that indicates whether a balancing step is performed
    on the data. The default is set to True.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M, M) ndarray</strong>
    Solution to the continuous-time algebraic Riccati equation.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    For cases where the stable subspace of the pencil could not be
    isolated. See Notes section and the references for details.</p>
<h4>See Also</h4>
<ul>
<li><strong>solve_discrete_are : Solves the discrete-time algebraic Riccati equation</strong></li>
</ul>
<h4>Notes</h4>
<p>The equation is solved by forming the extended hamiltonian matrix pencil,
as described in [1]_, :math:<code>H - \lambda J</code> given by the block matrices ::</p>
<div class="codehilite"><pre><span></span><code>[ A    0    B ]             [ E   0    0 ]
[-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ]
[ S^H B^H   R ]             [ 0   0    0 ]
</code></pre></div>


<p>and using a QZ decomposition method.</p>
<p>In this algorithm, the fail conditions are linked to the symmetry
of the product :math:<code>U_2 U_1^{-1}</code> and condition number of
:math:<code>U_1</code>. Here, :math:<code>U</code> is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]<em> and [2]</em> for more details.</p>
<p>In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:<code>H</code> and :math:<code>J</code> entries (after removing the diagonal entries of
the sum) is balanced following the recipe given in [3]_.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>References</h4>
<p>.. [1]  P. van Dooren , 'A Generalized Eigenvalue Approach For Solving
   Riccati Equations.', SIAM Journal on Scientific and Statistical
   Computing, Vol.2(2), DOI: 10.1137/0902010</p>
<p>.. [2] A.J. Laub, 'A Schur Method for Solving Algebraic Riccati
   Equations.', Massachusetts Institute of Technology. Laboratory for
   Information and Decision Systems. LIDS-R ; 859. Available online :</p>
<ul>
<li><strong>http://hdl.handle.net/1721.1/1301</strong></li>
</ul>
<p>.. [3] P. Benner, 'Symplectic Balancing of Hamiltonian Matrices', 2001,
   SIAM J. Sci. Comput., 2001, Vol.22(5), DOI: 10.1137/S1064827500367993</p>
<h4>Examples</h4>
<p>Given <code>a</code>, <code>b</code>, <code>q</code>, and <code>r</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_continuous_are</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">21.72792206</span><span class="p">,</span>  <span class="mf">14.48528137</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">14.48528137</span><span class="p">,</span>   <span class="mf">9.65685425</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_continuous_lyapunov">solve_continuous_lyapunov<a class="headerlink" href="#solve_continuous_lyapunov" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_continuous_lyapunov</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_continuous_lyapunov</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous Lyapunov equation :math:<code>AX + XA^H = Q</code>.</p>
<p>Uses the Bartels-Stewart algorithm to find :math:<code>X</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    A square matrix</p>
</li>
<li>
<p><strong>q : array_like</strong>
    Right-hand side square matrix</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : ndarray</strong>
    Solution to the continuous Lyapunov equation</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>solve_discrete_lyapunov : computes the solution to the discrete-time</strong>
    Lyapunov equation</p>
</li>
<li>
<p><strong>solve_sylvester : computes the solution to the Sylvester equation</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_continuous_lyapunov</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">0.75</span>  <span class="p">,</span>   <span class="mf">0.875</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">3.75</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.875</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.375</span> <span class="p">,</span>   <span class="mf">5.3125</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">3.75</span>  <span class="p">,</span>   <span class="mf">5.3125</span><span class="p">,</span> <span class="o">-</span><span class="mf">27.0625</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_discrete_are">solve_discrete_are<a class="headerlink" href="#solve_discrete_are" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_discrete_are</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_discrete_are</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">e</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">s</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">balanced</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the discrete-time algebraic Riccati equation (DARE).</p>
<p>The DARE is defined as</p>
<div>
<div class="MathJax_Preview">
      A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0
</div>
<script type="math/tex; mode=display">
      A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0
</script>
</div>
<p>The limitations for a solution to exist are :</p>
<div class="codehilite"><pre><span></span><code>* All eigenvalues of :math:`A` outside the unit disc, should be
  controllable.

* The associated symplectic pencil (See Notes), should have
  eigenvalues sufficiently away from the unit circle.
</code></pre></div>


<p>Moreover, if <code>e</code> and <code>s</code> are not both precisely <code>None</code>, then the
generalized version of DARE</p>
<div>
<div class="MathJax_Preview">
      A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0
</div>
<script type="math/tex; mode=display">
      A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0
</script>
</div>
<p>is solved. When omitted, <code>e</code> is assumed to be the identity and <code>s</code>
is assumed to be the zero matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Square matrix</p>
</li>
<li>
<p><strong>b : (M, N) array_like</strong>
    Input</p>
</li>
<li>
<p><strong>q : (M, M) array_like</strong>
    Input</p>
</li>
<li>
<p><strong>r : (N, N) array_like</strong>
    Square matrix</p>
</li>
<li>
<p><strong>e : (M, M) array_like, optional</strong>
    Nonsingular square matrix</p>
</li>
<li>
<p><strong>s : (M, N) array_like, optional</strong>
    Input</p>
</li>
<li>
<p><strong>balanced : bool</strong>
    The boolean that indicates whether a balancing step is performed
    on the data. The default is set to True.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M, M) ndarray</strong>
    Solution to the discrete algebraic Riccati equation.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    For cases where the stable subspace of the pencil could not be
    isolated. See Notes section and the references for details.</p>
<h4>See Also</h4>
<ul>
<li><strong>solve_continuous_are : Solves the continuous algebraic Riccati equation</strong></li>
</ul>
<h4>Notes</h4>
<p>The equation is solved by forming the extended symplectic matrix pencil,
as described in [1]_, :math:<code>H - \lambda J</code> given by the block matrices ::</p>
<div class="codehilite"><pre><span></span><code>   [  A   0   B ]             [ E   0   B ]
   [ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ]
   [ S^H  0   R ]             [ 0 -B^H  0 ]
</code></pre></div>


<p>and using a QZ decomposition method.</p>
<p>In this algorithm, the fail conditions are linked to the symmetry
of the product :math:<code>U_2 U_1^{-1}</code> and condition number of
:math:<code>U_1</code>. Here, :math:<code>U</code> is the 2m-by-m matrix that holds the
eigenvectors spanning the stable subspace with 2-m rows and partitioned
into two m-row matrices. See [1]<em> and [2]</em> for more details.</p>
<p>In order to improve the QZ decomposition accuracy, the pencil goes
through a balancing step where the sum of absolute values of
:math:<code>H</code> and :math:<code>J</code> rows/cols (after removing the diagonal entries)
is balanced following the recipe given in [3]_. If the data has small
numerical noise, balancing may amplify their effects and some clean up
is required.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>References</h4>
<p>.. [1]  P. van Dooren , 'A Generalized Eigenvalue Approach For Solving
   Riccati Equations.', SIAM Journal on Scientific and Statistical
   Computing, Vol.2(2), DOI: 10.1137/0902010</p>
<p>.. [2] A.J. Laub, 'A Schur Method for Solving Algebraic Riccati
   Equations.', Massachusetts Institute of Technology. Laboratory for
   Information and Decision Systems. LIDS-R ; 859. Available online :</p>
<ul>
<li><strong>http://hdl.handle.net/1721.1/1301</strong></li>
</ul>
<p>.. [3] P. Benner, 'Symplectic Balancing of Hamiltonian Matrices', 2001,
   SIAM J. Sci. Comput., 2001, Vol.22(5), DOI: 10.1137/S1064827500367993</p>
<h4>Examples</h4>
<p>Given <code>a</code>, <code>b</code>, <code>q</code>, and <code>r</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_discrete_are</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="o">-</span><span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_discrete_lyapunov">solve_discrete_lyapunov<a class="headerlink" href="#solve_discrete_lyapunov" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_discrete_lyapunov</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_discrete_lyapunov</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">method_</span><span class="o">:[`</span><span class="nc">Direct</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bilinear</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the discrete Lyapunov equation :math:<code>AXA^H - X + Q = 0</code>.</p>
<h4>Parameters</h4>
<p>a, q : (M, M) array_like
    Square matrices corresponding to A and Q in the equation
    above respectively. Must have the same shape.</p>
<ul>
<li>
<p><strong>method : {'direct', 'bilinear'}, optional</strong>
    Type of solver.</p>
<p>If not given, chosen to be <code>direct</code> if <code>M</code> is less than 10 and
<code>bilinear</code> otherwise.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : ndarray</strong>
    Solution to the discrete Lyapunov equation</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>solve_continuous_lyapunov : computes the solution to the continuous-time</strong>
    Lyapunov equation</li>
</ul>
<h4>Notes</h4>
<p>This section describes the available solvers that can be selected by the
'method' parameter. The default method is <em>direct</em> if <code>M</code> is less than 10
and <code>bilinear</code> otherwise.</p>
<p>Method <em>direct</em> uses a direct analytical solution to the discrete Lyapunov
equation. The algorithm is given in, for example, [1]_. However, it requires
the linear solution of a system with dimension :math:<code>M^2</code> so that
performance degrades rapidly for even moderately sized matrices.</p>
<p>Method <em>bilinear</em> uses a bilinear transformation to convert the discrete
Lyapunov equation to a continuous Lyapunov equation :math:<code>(BX+XB'=-C)</code></p>
<ul>
<li><strong>where :math:<code>B=(A-I)(A+I)^{-1}</code> and</strong>
:math:<code>C=2(A' + I)^{-1} Q (A + I)^{-1}</code>. The continuous equation can be
efficiently solved since it is a special case of a Sylvester equation.
The transformation algorithm is from Popov (1964) as described in [2]_.</li>
</ul>
<p>.. versionadded:: 0.11.0</p>
<h4>References</h4>
<p>.. [1] Hamilton, James D. Time Series Analysis, Princeton: Princeton
   University Press, 1994.  265.  Print.</p>
<ul>
<li><strong>http://doc1.lbfl.li/aca/FLMF037168.pdf</strong>
.. [2] Gajic, Z., and M.T.J. Qureshi. 2008.
   Lyapunov Matrix Equation in System Stability and Control.
   Dover Books on Engineering Series. Dover Publications.</li>
</ul>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_discrete_lyapunov</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.70872893</span><span class="p">,</span>  <span class="mf">1.43518822</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.43518822</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4266315</span> <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_lyapunov">solve_lyapunov<a class="headerlink" href="#solve_lyapunov" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_lyapunov</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_lyapunov</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solves the continuous Lyapunov equation :math:<code>AX + XA^H = Q</code>.</p>
<p>Uses the Bartels-Stewart algorithm to find :math:<code>X</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : array_like</strong>
    A square matrix</p>
</li>
<li>
<p><strong>q : array_like</strong>
    Right-hand side square matrix</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : ndarray</strong>
    Solution to the continuous Lyapunov equation</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>solve_discrete_lyapunov : computes the solution to the discrete-time</strong>
    Lyapunov equation</p>
</li>
<li>
<p><strong>solve_sylvester : computes the solution to the Sylvester equation</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>The continuous Lyapunov equation is a special form of the Sylvester
equation, hence this solver relies on LAPACK routine ?TRSYL.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<p>Given <code>a</code> and <code>q</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_continuous_lyapunov</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">0.75</span>  <span class="p">,</span>   <span class="mf">0.875</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">3.75</span>  <span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.875</span> <span class="p">,</span>  <span class="o">-</span><span class="mf">1.375</span> <span class="p">,</span>   <span class="mf">5.3125</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">3.75</span>  <span class="p">,</span>   <span class="mf">5.3125</span><span class="p">,</span> <span class="o">-</span><span class="mf">27.0625</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_sylvester">solve_sylvester<a class="headerlink" href="#solve_sylvester" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_sylvester</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_sylvester</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">q</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Computes a solution (X) to the Sylvester equation :math:<code>AX + XB = Q</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    Leading matrix of the Sylvester equation</p>
</li>
<li>
<p><strong>b : (N, N) array_like</strong>
    Trailing matrix of the Sylvester equation</p>
</li>
<li>
<p><strong>q : (M, N) array_like</strong>
    Right-hand side</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M, N) ndarray</strong>
    The solution to the Sylvester equation.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If solution was not found</p>
<h4>Notes</h4>
<p>Computes a solution to the Sylvester matrix equation via the Bartels-
Stewart algorithm. The A and B matrices first undergo Schur
decompositions. The resulting matrices are used to construct an
alternative Sylvester equation (<code>RY + YS^T = F</code>) where the R and S
matrices are in quasi-triangular form (or, when R, S or F are complex,
triangular form). The simplified equation is then solved using
<code>*TRSYL</code> from LAPACK directly.</p>
<p>.. versionadded:: 0.11.0</p>
<h4>Examples</h4>
<p>Given <code>a</code>, <code>b</code>, and <code>q</code> solve for <code>x</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_sylvester</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.0625</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.5625</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.6875</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="solve_toeplitz_1">solve_toeplitz<a class="headerlink" href="#solve_toeplitz_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_toeplitz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_toeplitz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">c_or_cr</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Tuple_of_array_like_array_like_</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve a Toeplitz system using Levinson Recursion</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c_or_cr : array_like or tuple of (array_like, array_like)</strong>
    The vector <code>c</code>, or a tuple of arrays (<code>c</code>, <code>r</code>). Whatever the
    actual shape of <code>c</code>, it will be converted to a 1-D array. If not
    supplied, <code>r = conjugate(c)</code> is assumed; in this case, if c[0] is
    real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row
    of the Toeplitz matrix is <code>[c[0], r[1:]]</code>. Whatever the actual shape
    of <code>r</code>, it will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side in <code>T x = b</code>.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (result entirely NaNs) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system <code>T x = b</code>. Shape of return matches shape
    of <code>b</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li><strong>toeplitz : Toeplitz matrix</strong></li>
</ul>
<h4>Notes</h4>
<p>The solution is computed using Levinson-Durbin recursion, which is faster
than generic least-squares methods, but can be less numerically stable.</p>
<h4>Examples</h4>
<p>Solve the Toeplitz system T x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 1 -1 -2 -3]       [1]
T = [ 3  1 -1 -2]   b = [2]
    [ 6  3  1 -1]       [2]
    [10  6  3  1]       [5]
</code></pre></div>


<p>To specify the Toeplitz matrix, only the first column and the first
row are needed.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>    <span class="c1"># First column of T</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># First row of T</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_toeplitz</span><span class="p">,</span> <span class="n">toeplitz</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_toeplitz</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span>        <span class="p">,</span> <span class="o">-</span><span class="mf">2.66666667</span><span class="p">,</span>  <span class="mf">2.33333333</span><span class="p">])</span>
</code></pre></div>

<p>Check the result by creating the full Toeplitz matrix and
multiplying it by <code>x</code>.  We should get <code>b</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">toeplitz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solve_triangular_1">solve_triangular<a class="headerlink" href="#solve_triangular_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solve_triangular</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solve_triangular</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">trans</span><span class="o">:[`</span><span class="nc">N</span> <span class="o">|</span> <span class="o">`</span><span class="nc">C</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Two</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Zero</span> <span class="o">|</span> <span class="o">`</span><span class="nc">T</span> <span class="o">|</span> <span class="o">`</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">unit_diagonal</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">debug</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve the equation <code>a x = b</code> for <code>x</code>, assuming a is a triangular matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, M) array_like</strong>
    A triangular matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, N) array_like</strong>
    Right-hand side matrix in <code>a x = b</code></p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Use only data contained in the lower triangle of <code>a</code>.
    Default is to use upper triangle.</p>
</li>
<li>
<p><strong>trans : {0, 1, 2, 'N', 'T', 'C'}, optional</strong>
    Type of system to solve:</p>
<p>========  =========
trans     system
========  =========
0 or 'N'  a x  = b
1 or 'T'  a^T x = b
2 or 'C'  a^H x = b
========  =========</p>
</li>
<li>
<p><strong>unit_diagonal : bool, optional</strong>
    If True, diagonal elements of <code>a</code> are assumed to be 1 and
    will not be referenced.</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Allow overwriting data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, N) ndarray</strong>
    Solution to the system <code>a x = b</code>.  Shape of return matches <code>b</code>.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If <code>a</code> is singular</p>
<h4>Notes</h4>
<p>.. versionadded:: 0.9.0</p>
<h4>Examples</h4>
<p>Solve the lower triangular system a x = b, where::</p>
<div class="codehilite"><pre><span></span><code>     [3  0  0  0]       [4]
a =  [2  1  0  0]   b = [2]
     [1  0  1  0]       [4]
     [1  1  1  1]       [2]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_triangular</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solve_triangular</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.33333333</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.66666667</span><span class="p">,</span>  <span class="mf">2.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.33333333</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Check the result</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="solveh_banded_1">solveh_banded<a class="headerlink" href="#solveh_banded_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function solveh_banded</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">solveh_banded</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_ab</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_b</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lower</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">ab</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Solve equation a x = b. a is Hermitian positive-definite banded matrix.</p>
<p>The matrix a is stored in <code>ab</code> either in lower diagonal or upper
diagonal ordered form:</p>
<div class="codehilite"><pre><span></span><code>ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)
ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)
</code></pre></div>


<p>Example of <code>ab</code> (shape of a is (6, 6), <code>u</code> =2)::</p>
<div class="codehilite"><pre><span></span><code>upper form:
*   *   a02 a13 a24 a35
*   a01 a12 a23 a34 a45
a00 a11 a22 a33 a44 a55

lower form:
a00 a11 a22 a33 a44 a55
a10 a21 a32 a43 a54 *
a20 a31 a42 a53 *   *
</code></pre></div>


<p>Cells marked with * are not used.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>ab : (<code>u</code> + 1, M) array_like</strong>
    Banded matrix</p>
</li>
<li>
<p><strong>b : (M,) or (M, K) array_like</strong>
    Right-hand side</p>
</li>
<li>
<p><strong>overwrite_ab : bool, optional</strong>
    Discard data in <code>ab</code> (may enhance performance)</p>
</li>
<li>
<p><strong>overwrite_b : bool, optional</strong>
    Discard data in <code>b</code> (may enhance performance)</p>
</li>
<li>
<p><strong>lower : bool, optional</strong>
    Is the matrix in the lower form. (Default is upper form)</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrices contain only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>x : (M,) or (M, K) ndarray</strong>
    The solution to the system a x = b. Shape of return matches shape
    of <code>b</code>.</li>
</ul>
<h4>Examples</h4>
<p>Solve the banded system A x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 4  2 -1  0  0  0]       [1]
    [ 2  5  2 -1  0  0]       [2]
A = [-1  2  6  2 -1  0]   b = [2]
    [ 0 -1  2  7  2 -1]       [3]
    [ 0  0 -1  2  8  2]       [3]
    [ 0  0  0 -1  2  9]       [3]
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solveh_banded</span>
</code></pre></div>

<p><code>ab</code> contains the main diagonal and the nonzero diagonals below the
main diagonal. That is, we use the lower form:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solveh_banded</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.03431373</span><span class="p">,</span>  <span class="mf">0.45938375</span><span class="p">,</span>  <span class="mf">0.05602241</span><span class="p">,</span>  <span class="mf">0.47759104</span><span class="p">,</span>  <span class="mf">0.17577031</span><span class="p">,</span>
        <span class="mf">0.34733894</span><span class="p">])</span>
</code></pre></div>

<p>Solve the Hermitian banded system H x = b, where::</p>
<div class="codehilite"><pre><span></span><code>    [ 8   2-1j   0     0  ]        [ 1  ]
H = [2+1j  5     1j    0  ]    b = [1+1j]
    [ 0   -1j    9   -2-1j]        [1-2j]
    [ 0    0   -2+1j   6  ]        [ 0  ]
</code></pre></div>


<p>In this example, we put the upper diagonals in the array <code>hb</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span>
<span class="o">...</span>                <span class="p">[</span><span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>   <span class="mi">6</span>  <span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">solveh_banded</span><span class="p">(</span><span class="n">hb</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">0.07318536</span><span class="o">-</span><span class="mf">0.02939412</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.11877624</span><span class="o">+</span><span class="mf">0.17696461</span><span class="n">j</span><span class="p">,</span>
        <span class="mf">0.10077984</span><span class="o">-</span><span class="mf">0.23035393</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00479904</span><span class="o">-</span><span class="mf">0.09358128</span><span class="n">j</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="sqrtm_1">sqrtm<a class="headerlink" href="#sqrtm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function sqrtm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">sqrtm</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">disp</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">blocksize</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Matrix square root.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (N, N) array_like</strong>
    Matrix whose square root to evaluate</p>
</li>
<li>
<p><strong>disp : bool, optional</strong>
    Print warning if error in the result is estimated large
    instead of returning estimated error. (Default: True)</p>
</li>
<li>
<p><strong>blocksize : integer, optional</strong>
    If the blocksize is not degenerate with respect to the
    size of the input array, then use a blocked algorithm. (Default: 64)</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>sqrtm : (N, N) ndarray</strong>
    Value of the sqrt function at <code>A</code></p>
</li>
<li>
<p><strong>errest : float</strong>
    (if disp == False)</p>
<p>Frobenius norm of the estimated error, ||err||_F / ||A||_F</p>
</li>
</ul>
<h4>References</h4>
<p>.. [1] Edvin Deadman, Nicholas J. Higham, Rui Ralha (2013)
       'Blocked Schur Algorithms for Computing the Matrix Square Root,
       Lecture Notes in Computer Science, 7782. pp. 171-182.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.75592895</span><span class="p">,</span>  <span class="mf">1.13389342</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.37796447</span><span class="p">,</span>  <span class="mf">1.88982237</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="subspace_angles_1">subspace_angles<a class="headerlink" href="#subspace_angles_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function subspace_angles</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">subspace_angles</span> <span class="o">:</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">b</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the subspace angles between two matrices.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>A : (M, N) array_like</strong>
    The first input array.</p>
</li>
<li>
<p><strong>B : (M, K) array_like</strong>
    The second input array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>angles : ndarray, shape (min(N, K),)</strong>
    The subspace angles between the column spaces of <code>A</code> and <code>B</code> in
    descending order.</li>
</ul>
<h4>See Also</h4>
<p>orth
svd</p>
<h4>Notes</h4>
<p>This computes the subspace angles according to the formula
provided in [1]_. For equivalence with MATLAB and Octave behavior,
use <code>angles[0]</code>.</p>
<p>.. versionadded:: 1.0</p>
<h4>References</h4>
<p>.. [1] Knyazev A, Argentati M (2002) Principal Angles between Subspaces
       in an A-Based Scalar Product: Algorithms and Perturbation
       Estimates. SIAM J. Sci. Comput. 23:2008-2040.</p>
<h4>Examples</h4>
<p>An Hadamard matrix, which has orthogonal columns, so we expect that
the suspace angle to be :math:<code>\frac{\pi}{2}</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">hadamard</span><span class="p">,</span> <span class="n">subspace_angles</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">H</span> <span class="o">=</span> <span class="n">hadamard</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="p">[[</span> <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span>  <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">subspace_angles</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">H</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]))</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">90.</span><span class="p">,</span>  <span class="mf">90.</span><span class="p">])</span>
</code></pre></div>

<p>And the subspace angle of a matrix to itself should be zero:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">subspace_angles</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="n">array</span><span class="p">([</span> <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</code></pre></div>

<p>The angles between non-orthogonal subspaces are in between these extremes:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">subspace_angles</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">55.832</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="svd_2">svd<a class="headerlink" href="#svd_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function svd</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svd</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">full_matrices</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">compute_uv</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">lapack_driver</span><span class="o">:[`</span><span class="nc">Gesdd</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Gesvd</span><span class="o">]</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Singular Value Decomposition.</p>
<p>Factorizes the matrix <code>a</code> into two unitary matrices <code>U</code> and <code>Vh</code>, and
a 1-D array <code>s</code> of singular values (real, non-negative) such that
<code>a == U @ S @ Vh</code>, where <code>S</code> is a suitably shaped matrix of zeros with
main diagonal <code>s</code>.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to decompose.</p>
</li>
<li>
<p><strong>full_matrices : bool, optional</strong>
    If True (default), <code>U</code> and <code>Vh</code> are of shape <code>(M, M)</code>, <code>(N, N)</code>.
    If False, the shapes are <code>(M, K)</code> and <code>(K, N)</code>, where
    <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>compute_uv : bool, optional</strong>
    Whether to compute also <code>U</code> and <code>Vh</code> in addition to <code>s</code>.
    Default is True.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
<li>
<p><strong>lapack_driver : {'gesdd', 'gesvd'}, optional</strong>
    Whether to use the more efficient divide-and-conquer approach
    (<code>'gesdd'</code>) or general rectangular approach (<code>'gesvd'</code>)
    to compute the SVD. MATLAB and Octave use the <code>'gesvd'</code> approach.
    Default is <code>'gesdd'</code>.</p>
<p>.. versionadded:: 0.18</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li>
<p><strong>U : ndarray</strong>
    Unitary matrix having left singular vectors as columns.
    Of shape <code>(M, M)</code> or <code>(M, K)</code>, depending on <code>full_matrices</code>.</p>
</li>
<li>
<p><strong>s : ndarray</strong>
    The singular values, sorted in non-increasing order.
    Of shape (K,), with <code>K = min(M, N)</code>.</p>
</li>
<li>
<p><strong>Vh : ndarray</strong>
    Unitary matrix having right singular vectors as rows.
    Of shape <code>(N, N)</code> or <code>(K, N)</code> depending on <code>full_matrices</code>.</p>
</li>
</ul>
<p>For <code>compute_uv=False</code>, only <code>s</code> is returned.</p>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>See also</h4>
<ul>
<li>
<p><strong>svdvals : Compute singular values of a matrix.</strong></p>
</li>
<li>
<p><strong>diagsvd : Construct the Sigma matrix, given the vector s.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>

<p>Reconstruct the original matrix from the decomposition:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
<span class="o">...</span>     <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">Vh</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>Alternatively, use <code>full_matrices=False</code> (notice that the shape of
<code>U</code> is then <code>(m, n)</code> instead of <code>(m, m)</code>):</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vh</span><span class="o">.</span><span class="n">shape</span>
<span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Vh</span><span class="p">)))</span>
<span class="kc">True</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

</details>
<h3 id="svdvals_1">svdvals<a class="headerlink" href="#svdvals_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function svdvals</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">svdvals</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">overwrite_a</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span>
  <span class="n">a</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute singular values of a matrix.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>a : (M, N) array_like</strong>
    Matrix to decompose.</p>
</li>
<li>
<p><strong>overwrite_a : bool, optional</strong>
    Whether to overwrite <code>a</code>; may improve performance.
    Default is False.</p>
</li>
<li>
<p><strong>check_finite : bool, optional</strong>
    Whether to check that the input matrix contains only finite numbers.
    Disabling may give a performance gain, but may result in problems
    (crashes, non-termination) if the inputs do contain infinities or NaNs.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>s : (min(M, N),) ndarray</strong>
    The singular values, sorted in decreasing order.</li>
</ul>
<h4>Raises</h4>
<p>LinAlgError
    If SVD computation does not converge.</p>
<h4>Notes</h4>
<p><code>svdvals(a)</code> only differs from <code>svd(a, compute_uv=False)</code> by its
handling of the edge case of empty <code>a</code>, where it returns an
empty sequence:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svdvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float64</span><span class="p">)</span>
</code></pre></div>

<h4>See Also</h4>
<ul>
<li>
<p><strong>svd : Compute the full singular value decomposition of a matrix.</strong></p>
</li>
<li>
<p><strong>diagsvd : Construct the Sigma matrix, given the vector s.</strong></p>
</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svdvals</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
<span class="o">...</span>               <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">4.28091555</span><span class="p">,</span>  <span class="mf">1.63516424</span><span class="p">])</span>
</code></pre></div>

<p>We can verify the maximum singular value of <code>m</code> by computing the maximum
length of <code>m.dot(u)</code> over all the unit vectors <code>u</code> in the (x,y) plane.
We approximate 'all' the unit vectors with a large sample. Because
of linearity, we only need the unit vectors with angles in [0, pi].</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="mf">4.2809152422538475</span>
</code></pre></div>

<p><code>p</code> is a projection matrix with rank 1. With exact arithmetic,
its singular values would be [1, 0, 0, 0].</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">1.00000000e+00</span><span class="p">,</span>   <span class="mf">2.02021698e-17</span><span class="p">,</span>   <span class="mf">1.56692500e-17</span><span class="p">,</span>
         <span class="mf">8.15115104e-34</span><span class="p">])</span>
</code></pre></div>

<p>The singular values of an orthogonal matrix are all 1. Here, we
create a random orthogonal matrix by using the <code>rvs()</code> method of
<code>scipy.stats.ortho_group</code>.</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">ortho_group</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">orth</span> <span class="o">=</span> <span class="n">ortho_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">svdvals</span><span class="p">(</span><span class="n">orth</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">])</span>
</code></pre></div>

</details>
<h3 id="tanhm_1">tanhm<a class="headerlink" href="#tanhm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tanhm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanhm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the hyperbolic matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tanhm : (N, N) ndarray</strong>
    Hyperbolic matrix tangent of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanhm</span><span class="p">,</span> <span class="n">sinhm</span><span class="p">,</span> <span class="n">coshm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.3428582</span> <span class="p">,</span>  <span class="mf">0.51987926</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.17329309</span><span class="p">,</span>  <span class="mf">0.86273746</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanhm(a) = sinhm(a).dot(inv(coshm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinhm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">coshm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mf">2.72004641e-15</span><span class="p">,</span>   <span class="mf">4.55191440e-15</span><span class="p">],</span>
       <span class="p">[</span>  <span class="mf">0.00000000e+00</span><span class="p">,</span>  <span class="o">-</span><span class="mf">5.55111512e-16</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tanm_1">tanm<a class="headerlink" href="#tanm_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tanm</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tanm</span> <span class="o">:</span>
  <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute the matrix tangent.</p>
<p>This routine uses expm to compute the matrix exponentials.</p>
<h4>Parameters</h4>
<ul>
<li><strong>A : (N, N) array_like</strong>
    Input array.</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tanm : (N, N) ndarray</strong>
    Matrix tangent of <code>A</code></li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tanm</span><span class="p">,</span> <span class="n">sinm</span><span class="p">,</span> <span class="n">cosm</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">2.00876993</span><span class="p">,</span>  <span class="o">-</span><span class="mf">8.41880636</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">2.80626879</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.42757629</span><span class="p">]])</span>
</code></pre></div>

<p>Verify tanm(a) = sinm(a).dot(inv(cosm(a)))</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sinm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cosm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="o">-</span><span class="mf">2.00876993</span><span class="p">,</span>  <span class="o">-</span><span class="mf">8.41880636</span><span class="p">],</span>
       <span class="p">[</span> <span class="o">-</span><span class="mf">2.80626879</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.42757629</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="toeplitz_1">toeplitz<a class="headerlink" href="#toeplitz_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function toeplitz</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">toeplitz</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">c</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct a Toeplitz matrix.</p>
<p>The Toeplitz matrix has constant diagonals, with c as its first column
and r as its first row. If r is not given, <code>r == conjugate(c)</code> is
assumed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>c : array_like</strong>
    First column of the matrix.  Whatever the actual shape of <code>c</code>, it
    will be converted to a 1-D array.</p>
</li>
<li>
<p><strong>r : array_like, optional</strong>
    First row of the matrix. If None, <code>r = conjugate(c)</code> is assumed;
    in this case, if c[0] is real, the result is a Hermitian matrix.
    r[0] is ignored; the first row of the returned matrix is
    <code>[c[0], r[1:]]</code>.  Whatever the actual shape of <code>r</code>, it will be
    converted to a 1-D array.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>A : (len(c), len(r)) ndarray</strong>
    The Toeplitz matrix. Dtype is the same as <code>(c[0] + r[0]).dtype</code>.</li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<p><strong>circulant : circulant matrix</strong></p>
</li>
<li>
<p><strong>hankel : Hankel matrix</strong></p>
</li>
<li>
<p><strong>solve_toeplitz : Solve a Toeplitz system.</strong></p>
</li>
</ul>
<h4>Notes</h4>
<p>The behavior when <code>c</code> or <code>r</code> is a scalar, or when <code>c</code> is complex and
<code>r</code> is None, was changed in version 0.8.0. The behavior in previous
versions was undocumented and is no longer supported.</p>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">toeplitz</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">toeplitz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">toeplitz</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">4.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">4.</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tri_1">tri<a class="headerlink" href="#tri_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tri</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tri</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">m</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="o">?</span><span class="n">dtype</span><span class="o">:</span><span class="nn">Np</span><span class="p">.</span><span class="nn">Dtype</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="n">n</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Construct (N, M) matrix filled with ones at and below the kth diagonal.</p>
<p>The matrix has A[i,j] == 1 for i &lt;= j + k</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>N : int</strong>
    The size of the first dimension of the matrix.</p>
</li>
<li>
<p><strong>M : int or None, optional</strong>
    The size of the second dimension of the matrix. If <code>M</code> is None,
    <code>M = N</code> is assumed.</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Number of subdiagonal below which matrix is filled with ones.
    <code>k</code> = 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and <code>k</code> &gt; 0
    superdiagonal.</p>
</li>
<li>
<p><strong>dtype : dtype, optional</strong>
    Data type of the matrix.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tri : (N, M) ndarray</strong>
    Tri matrix.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tri</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="tril_1">tril<a class="headerlink" href="#tril_1" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function tril</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">tril</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements above the kth diagonal zeroed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>m : array_like</strong>
    Matrix whose elements to return</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal above which to zero elements.
    <code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
    <code>k</code> &gt; 0 superdiagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>tril : ndarray</strong>
    Return is the same shape and type as <code>m</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">tril</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tril</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</code></pre></div>

</details>
<h3 id="triu_2">triu<a class="headerlink" href="#triu_2" title="Permanent link">&para;</a></h3>
<details class="note" open="open"><summary>function triu</summary><div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">triu</span> <span class="o">:</span>
  <span class="o">?</span><span class="n">k</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span>
  <span class="n">m</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span>
  <span class="kt">unit</span> <span class="o">-&gt;</span>
  <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Make a copy of a matrix with elements below the kth diagonal zeroed.</p>
<h4>Parameters</h4>
<ul>
<li>
<p><strong>m : array_like</strong>
    Matrix whose elements to return</p>
</li>
<li>
<p><strong>k : int, optional</strong>
    Diagonal below which to zero elements.
    <code>k</code> == 0 is the main diagonal, <code>k</code> &lt; 0 subdiagonal and
    <code>k</code> &gt; 0 superdiagonal.</p>
</li>
</ul>
<h4>Returns</h4>
<ul>
<li><strong>triu : ndarray</strong>
    Return matrix with zeroed elements below the kth diagonal and has
    same shape and type as <code>m</code>.</li>
</ul>
<h4>Examples</h4>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">triu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">triu</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
</code></pre></div>

</details>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Io/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Io
              </div>
            </div>
          </a>
        
        
          <a href="../Misc/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Misc
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.0ac82a11.min.js"></script>
      <script src="../../assets/javascripts/bundle.f81dfb4d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ['instant', 'tabs'],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>