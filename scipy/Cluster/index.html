


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>Cluster - OCaml scikit-learn interface</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.a46bcfb3.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#parameters" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="OCaml scikit-learn interface" class="md-header-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            OCaml scikit-learn interface
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Cluster
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
          

  

<nav class="md-tabs md-tabs--active" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Home
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../np/" class="md-tabs__link">
          Np
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" class="md-tabs__link md-tabs__link--active">
          Scipy
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../sklearn/Base/" class="md-tabs__link">
          Sklearn
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="OCaml scikit-learn interface" class="md-nav__button md-logo" aria-label="OCaml scikit-learn interface">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    OCaml scikit-learn interface
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lehy/ocaml-sklearn/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    lehy/ocaml-sklearn
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Np
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Np" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Np
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/" title="Numpy for OCaml" class="md-nav__link">
      Numpy for OCaml
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/Numpy/" title="Numpy" class="md-nav__link">
      Numpy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/NumpyRaw/" title="NumpyRaw" class="md-nav__link">
      NumpyRaw
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/PyList/" title="PyList" class="md-nav__link">
      PyList
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/dtype/" title="Dtype" class="md-nav__link">
      Dtype
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../np/obj/" title="Obj" class="md-nav__link">
      Obj
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Scipy
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Scipy" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Scipy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="SciPy library for OCaml" class="md-nav__link">
      SciPy library for OCaml
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Cluster" class="md-nav__link md-nav__link--active">
      Cluster
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fft/" title="Fft" class="md-nav__link">
      Fft
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Fftpack/" title="Fftpack" class="md-nav__link">
      Fftpack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Integrate/" title="Integrate" class="md-nav__link">
      Integrate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interpolate/" title="Interpolate" class="md-nav__link">
      Interpolate
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Io/" title="Io" class="md-nav__link">
      Io
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Linalg/" title="Linalg" class="md-nav__link">
      Linalg
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Misc/" title="Misc" class="md-nav__link">
      Misc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Ndimage/" title="Ndimage" class="md-nav__link">
      Ndimage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Odr/" title="Odr" class="md-nav__link">
      Odr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Optimize/" title="Optimize" class="md-nav__link">
      Optimize
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Signal/" title="Signal" class="md-nav__link">
      Signal
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sparse/" title="Sparse" class="md-nav__link">
      Sparse
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Spatial/" title="Spatial" class="md-nav__link">
      Spatial
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Special/" title="Special" class="md-nav__link">
      Special
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stats/" title="Stats" class="md-nav__link">
      Stats
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Version/" title="Version" class="md-nav__link">
      Version
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Sklearn
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="Sklearn" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        Sklearn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Base/" title="Base" class="md-nav__link">
      Base
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Calibration/" title="Calibration" class="md-nav__link">
      Calibration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cluster/" title="Cluster" class="md-nav__link">
      Cluster
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Compose/" title="Compose" class="md-nav__link">
      Compose
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Conftest/" title="Conftest" class="md-nav__link">
      Conftest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Covariance/" title="Covariance" class="md-nav__link">
      Covariance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Cross_decomposition/" title="Cross decomposition" class="md-nav__link">
      Cross decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Datasets/" title="Datasets" class="md-nav__link">
      Datasets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Decomposition/" title="Decomposition" class="md-nav__link">
      Decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Discriminant_analysis/" title="Discriminant analysis" class="md-nav__link">
      Discriminant analysis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Dummy/" title="Dummy" class="md-nav__link">
      Dummy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Ensemble/" title="Ensemble" class="md-nav__link">
      Ensemble
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Exceptions/" title="Exceptions" class="md-nav__link">
      Exceptions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Experimental/" title="Experimental" class="md-nav__link">
      Experimental
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Externals/" title="Externals" class="md-nav__link">
      Externals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_extraction/" title="Feature extraction" class="md-nav__link">
      Feature extraction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Feature_selection/" title="Feature selection" class="md-nav__link">
      Feature selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Gaussian_process/" title="Gaussian process" class="md-nav__link">
      Gaussian process
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Impute/" title="Impute" class="md-nav__link">
      Impute
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Inspection/" title="Inspection" class="md-nav__link">
      Inspection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Isotonic/" title="Isotonic" class="md-nav__link">
      Isotonic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_approximation/" title="Kernel approximation" class="md-nav__link">
      Kernel approximation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Kernel_ridge/" title="Kernel ridge" class="md-nav__link">
      Kernel ridge
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Linear_model/" title="Linear model" class="md-nav__link">
      Linear model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Manifold/" title="Manifold" class="md-nav__link">
      Manifold
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Metrics/" title="Metrics" class="md-nav__link">
      Metrics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Mixture/" title="Mixture" class="md-nav__link">
      Mixture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Model_selection/" title="Model selection" class="md-nav__link">
      Model selection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multiclass/" title="Multiclass" class="md-nav__link">
      Multiclass
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Multioutput/" title="Multioutput" class="md-nav__link">
      Multioutput
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Naive_bayes/" title="Naive bayes" class="md-nav__link">
      Naive bayes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neighbors/" title="Neighbors" class="md-nav__link">
      Neighbors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Neural_network/" title="Neural network" class="md-nav__link">
      Neural network
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Pipeline/" title="Pipeline" class="md-nav__link">
      Pipeline
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Random_projection/" title="Random projection" class="md-nav__link">
      Random projection
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Semi_supervised/" title="Semi supervised" class="md-nav__link">
      Semi supervised
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Setup/" title="Setup" class="md-nav__link">
      Setup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Svm/" title="Svm" class="md-nav__link">
      Svm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tests/" title="Tests" class="md-nav__link">
      Tests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Tree/" title="Tree" class="md-nav__link">
      Tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/Utils/" title="Utils" class="md-nav__link">
      Utils
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/arr/" title="Arr" class="md-nav__link">
      Arr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/dict/" title="Dict" class="md-nav__link">
      Dict
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sklearn/wrap_version/" title="Wrap version" class="md-nav__link">
      Wrap version
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/lehy/ocaml-sklearn/edit/master/docs/scipy/Cluster.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">Hierarchy</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">ClusterNode</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ClusterNode</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ClusterNode</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="o">?</span><span class="n">left</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">right</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">dist</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">count</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">id</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>A tree node class for representing a cluster.</p>
<p>Leaf nodes correspond to original observations, while non-leaf nodes
correspond to non-singleton clusters.</p>
<p>The <code>to_tree</code> function converts a matrix returned by the linkage
function into an easy-to-use tree representation.</p>
<p>All parameter names are also attributes.</p>
<h2 id="parameters">Parameters<a class="headerlink" href="#parameters" title="Permanent link">&para;</a></h2>
<p>id : int
The node id.
left : ClusterNode instance, optional
The left child tree node.
right : ClusterNode instance, optional
The right child tree node.
dist : float, optional
Distance for this cluster in the linkage matrix.
count : int, optional
The number of samples in this cluster.</p>
<h2 id="see-also">See Also<a class="headerlink" href="#see-also" title="Permanent link">&para;</a></h2>
<p>to_tree : for converting a linkage matrix <code>Z</code> into a tree object.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_count</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>The number of leaf nodes (original observations) belonging to
the cluster node nd. If the target node is a leaf, 1 is
returned.</p>
<h2 id="returns">Returns<a class="headerlink" href="#returns" title="Permanent link">&para;</a></h2>
<p>get_count : int
The number of leaf nodes below the target node.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_id</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>The identifier of the target node.</p>
<p>For <code>0 &lt;= i &lt; n</code>, <code>i</code> corresponds to original observation i.
For <code>n &lt;= i &lt; 2n-1</code>, <code>i</code> corresponds to non-singleton cluster formed
at iteration <code>i-n</code>.</p>
<h2 id="returns_1">Returns<a class="headerlink" href="#returns_1" title="Permanent link">&para;</a></h2>
<p>id : int
The identifier of the target node.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_left</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a reference to the left child tree object.</p>
<h2 id="returns_2">Returns<a class="headerlink" href="#returns_2" title="Permanent link">&para;</a></h2>
<p>left : ClusterNode
The left child of the target node.  If the node is a leaf,
None is returned.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_right</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a reference to the right child tree object.</p>
<h2 id="returns_3">Returns<a class="headerlink" href="#returns_3" title="Permanent link">&para;</a></h2>
<p>right : ClusterNode
The left child of the target node.  If the node is a leaf,
None is returned.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_leaf</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Return True if the target node is a leaf.</p>
<h2 id="returns_4">Returns<a class="headerlink" href="#returns_4" title="Permanent link">&para;</a></h2>
<p>leafness : bool
True if the target node is a leaf node.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pre_order</span> <span class="o">:</span> <span class="o">?</span><span class="n">func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform pre-order traversal without recursive function calls.</p>
<p>When a leaf node is first encountered, <code>func</code> is called with
the leaf node as its argument, and its result is appended to
the list.</p>
<p>For example, the statement::</p>
<p>ids = root.pre_order(lambda x: x.id)</p>
<p>returns a list of the node ids corresponding to the leaf nodes
of the tree as they appear from left to right.</p>
<h2 id="parameters_1">Parameters<a class="headerlink" href="#parameters_1" title="Permanent link">&para;</a></h2>
<p>func : function
Applied to each leaf ClusterNode object in the pre-order traversal.
Given the <code>i</code>-th leaf node in the pre-order traversal <code>n[i]</code>,
the result of <code>func(n[i])</code> is stored in <code>L[i]</code>. If not
provided, the index of the original observation to which the node
corresponds is used.</p>
<h2 id="returns_5">Returns<a class="headerlink" href="#returns_5" title="Permanent link">&para;</a></h2>
<p>L : list
The pre-order traversal.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">ClusterWarning</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ClusterWarning</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ClusterWarning</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Deque</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Deque</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Deque</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set self[key] to value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">index</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.insert(index, object) -- insert object before index</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.remove(value) -- remove first occurrence of value.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Xrange</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Range</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Range</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.index(value) -&gt; integer -- return index of value.
Raise ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">average</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform average/UPGMA linkage on a condensed distance matrix.</p>
<h2 id="parameters_2">Parameters<a class="headerlink" href="#parameters_2" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The upper triangular of the distance matrix. The result of
<code>pdist</code> is returned in this form.</p>
<h2 id="returns_6">Returns<a class="headerlink" href="#returns_6" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix containing the hierarchical clustering. See
<code>linkage</code> for more information on its structure.</p>
<h2 id="see-also_1">See Also<a class="headerlink" href="#see-also_1" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import average, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = average(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.20710678,  3.        ],
[ 5.        , 13.        ,  1.20710678,  3.        ],
[ 8.        , 14.        ,  1.20710678,  3.        ],
[11.        , 15.        ,  1.20710678,  3.        ],
[16.        , 17.        ,  3.39675184,  6.        ],
[18.        , 19.        ,  3.39675184,  6.        ],
[20.        , 21.        ,  4.09206523, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
fcluster(Z, 1.5, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)
fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">centroid</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform centroid/UPGMC linkage.</p>
<p>See <code>linkage</code> for more information on the input matrix,
return structure, and algorithm.</p>
<p>The following are common calling conventions:</p>
<ol>
<li><code>Z = centroid(y)</code></li>
</ol>
<p>Performs centroid/UPGMC linkage on the condensed distance
matrix <code>y</code>.</p>
<ol>
<li><code>Z = centroid(X)</code></li>
</ol>
<p>Performs centroid/UPGMC linkage on the observation matrix <code>X</code>
using Euclidean distance as the distance metric.</p>
<h2 id="parameters_3">Parameters<a class="headerlink" href="#parameters_3" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A condensed distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
<code>pdist</code> returns. Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</p>
<h2 id="returns_7">Returns<a class="headerlink" href="#returns_7" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix containing the hierarchical clustering. See
the <code>linkage</code> function documentation for more information
on its structure.</p>
<h2 id="see-also_2">See Also<a class="headerlink" href="#see-also_2" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import centroid, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = centroid(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.11803399,  3.        ],
[ 5.        , 13.        ,  1.11803399,  3.        ],
[ 8.        , 15.        ,  1.11803399,  3.        ],
[11.        , 14.        ,  1.11803399,  3.        ],
[18.        , 19.        ,  3.33333333,  6.        ],
[16.        , 17.        ,  3.33333333,  6.        ],
[20.        , 21.        ,  3.33333333, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)
fcluster(Z, 1.1, criterion='distance')
array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)
fcluster(Z, 2, criterion='distance')
array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)
fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">complete</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform complete/max/farthest point linkage on a condensed distance matrix.</p>
<h2 id="parameters_4">Parameters<a class="headerlink" href="#parameters_4" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The upper triangular of the distance matrix. The result of
<code>pdist</code> is returned in this form.</p>
<h2 id="returns_8">Returns<a class="headerlink" href="#returns_8" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix containing the hierarchical clustering. See
the <code>linkage</code> function documentation for more information
on its structure.</p>
<h2 id="see-also_3">See Also<a class="headerlink" href="#see-also_3" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import complete, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = complete(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.41421356,  3.        ],
[ 5.        , 13.        ,  1.41421356,  3.        ],
[ 8.        , 14.        ,  1.41421356,  3.        ],
[11.        , 15.        ,  1.41421356,  3.        ],
[16.        , 17.        ,  4.12310563,  6.        ],
[18.        , 19.        ,  4.12310563,  6.        ],
[20.        , 21.        ,  5.65685425, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
fcluster(Z, 1.5, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
fcluster(Z, 4.5, criterion='distance')
array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32)
fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cophenet</span> <span class="o">:</span> <span class="o">?</span><span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Calculate the cophenetic distances between each observation in
the hierarchical clustering defined by the linkage <code>Z</code>.</p>
<p>Suppose <code>p</code> and <code>q</code> are original observations in
disjoint clusters <code>s</code> and <code>t</code>, respectively and
<code>s</code> and <code>t</code> are joined by a direct parent cluster
<code>u</code>. The cophenetic distance between observations
<code>i</code> and <code>j</code> is simply the distance between
clusters <code>s</code> and <code>t</code>.</p>
<h2 id="parameters_5">Parameters<a class="headerlink" href="#parameters_5" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as an array
(see <code>linkage</code> function).
Y : ndarray (optional)
Calculates the cophenetic correlation coefficient <code>c</code> of a
hierarchical clustering defined by the linkage matrix <code>Z</code>
of a set of :math:<code>n</code> observations in :math:<code>m</code>
dimensions. <code>Y</code> is the condensed distance matrix from which
<code>Z</code> was generated.</p>
<h2 id="returns_9">Returns<a class="headerlink" href="#returns_9" title="Permanent link">&para;</a></h2>
<p>c : ndarray
The cophentic correlation distance (if <code>Y</code> is passed).
d : ndarray
The cophenetic distance matrix in condensed form. The
:math:<code>ij</code> th entry is the cophenetic distance between
original observations :math:<code>i</code> and :math:<code>j</code>.</p>
<h2 id="see-also_4">See Also<a class="headerlink" href="#see-also_4" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
scipy.spatial.distance.squareform: transforming condensed matrices into square ones.</p>
<h2 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import single, cophenet
from scipy.spatial.distance import pdist, squareform</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a dataset <code>X</code> and a linkage matrix <code>Z</code>, the cophenetic distance
between two points of <code>X</code> is the distance between the largest two
distinct clusters that each of the points:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>X</code> corresponds to this dataset ::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = single(pdist(X))
Z
array([[ 0.,  1.,  1.,  2.],
[ 2., 12.,  1.,  3.],
[ 3.,  4.,  1.,  2.],
[ 5., 14.,  1.,  3.],
[ 6.,  7.,  1.,  2.],
[ 8., 16.,  1.,  3.],
[ 9., 10.,  1.,  2.],
[11., 18.,  1.,  3.],
[13., 15.,  2.,  6.],
[17., 20.,  2.,  9.],
[19., 21.,  2., 12.]])
cophenet(Z)
array([1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 2., 2., 2., 2., 2.,
2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 2., 2.,
2., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,
1., 1., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1.])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The output of the <code>scipy.cluster.hierarchy.cophenet</code> method is
represented in condensed form. We can use
<code>scipy.spatial.distance.squareform</code> to see the output as a
regular matrix (where each element <code>ij</code> denotes the cophenetic distance
between each <code>i</code>, <code>j</code> pair of points in <code>X</code>):</p>
<blockquote>
<blockquote>
<blockquote>
<p>squareform(cophenet(Z))
array([[0., 1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
[1., 0., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
[1., 1., 0., 2., 2., 2., 2., 2., 2., 2., 2., 2.],
[2., 2., 2., 0., 1., 1., 2., 2., 2., 2., 2., 2.],
[2., 2., 2., 1., 0., 1., 2., 2., 2., 2., 2., 2.],
[2., 2., 2., 1., 1., 0., 2., 2., 2., 2., 2., 2.],
[2., 2., 2., 2., 2., 2., 0., 1., 1., 2., 2., 2.],
[2., 2., 2., 2., 2., 2., 1., 0., 1., 2., 2., 2.],
[2., 2., 2., 2., 2., 2., 1., 1., 0., 2., 2., 2.],
[2., 2., 2., 2., 2., 2., 2., 2., 2., 0., 1., 1.],
[2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 0., 1.],
[2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 0.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this example, the cophenetic distance between points on <code>X</code> that are
very close (i.e. in the same corner) is 1. For other pairs of points is 2,
because the points will be located in clusters at different
corners - thus the distance between these clusters will be larger.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">correspond</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check for correspondence between linkage and condensed distance matrices.</p>
<p>They must have the same number of original observations for
the check to succeed.</p>
<p>This function is useful as a sanity check in algorithms that make
extensive use of linkage and distance matrices that must
correspond to the same set of original observations.</p>
<h2 id="parameters_6">Parameters<a class="headerlink" href="#parameters_6" title="Permanent link">&para;</a></h2>
<p>Z : array_like
The linkage matrix to check for correspondence.
Y : array_like
The condensed distance matrix to check for correspondence.</p>
<h2 id="returns_10">Returns<a class="headerlink" href="#returns_10" title="Permanent link">&para;</a></h2>
<p>b : bool
A boolean indicating whether the linkage matrix and distance
matrix could possibly correspond to one another.</p>
<h2 id="see-also_5">See Also<a class="headerlink" href="#see-also_5" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.</p>
<h2 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, correspond
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>This method can be used to check if a given linkage matrix <code>Z</code> has been
obtained from the application of a cluster method over a dataset <code>X</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]
X_condensed = pdist(X)
Z = ward(X_condensed)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here we can compare <code>Z</code> and <code>X</code> (in condensed form):</p>
<blockquote>
<blockquote>
<blockquote>
<p>correspond(Z, X_condensed)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">cut_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">n_clusters</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">height</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Given a linkage matrix Z, return the cut tree.</p>
<h2 id="parameters_7">Parameters<a class="headerlink" href="#parameters_7" title="Permanent link">&para;</a></h2>
<p>Z : scipy.cluster.linkage array
The linkage matrix.
n_clusters : array_like, optional
Number of clusters in the tree at the cut point.
height : array_like, optional
The height at which to cut the tree.  Only possible for ultrametric
trees.</p>
<h2 id="returns_11">Returns<a class="headerlink" href="#returns_11" title="Permanent link">&para;</a></h2>
<p>cutree : array
An array indicating group membership at each agglomeration step.  I.e.,
for a full cut tree, in the first column each data point is in its own
cluster.  At the next step, two nodes are merged.  Finally all
singleton and non-singleton clusters are in one group.  If <code>n_clusters</code>
or <code>height</code> is given, the columns correspond to the columns of
<code>n_clusters</code> or <code>height</code>.</p>
<h2 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy import cluster
np.random.seed(23)
X = np.random.randn(50, 4)
Z = cluster.hierarchy.ward(X)
cutree = cluster.hierarchy.cut_tree(Z, n_clusters=[5, 10])
cutree[:10]
array([[0, 0],
[1, 1],
[2, 2],
[3, 3],
[3, 4],
[2, 2],
[0, 0],
[1, 5],
[3, 6],
[4, 7]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">dendrogram</span> <span class="o">:</span> <span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">truncate_mode</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">color_threshold</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">get_leaves</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">orientation</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">labels</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">count_sort</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">distance_sort</span><span class="o">:[`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show_leaf_counts</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">no_plot</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">no_labels</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">leaf_font_size</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">leaf_rotation</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">leaf_label_func</span><span class="o">:[`</span><span class="nc">Lambda</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">show_contracted</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">link_color_func</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">ax</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">above_threshold_color</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Plot the hierarchical clustering as a dendrogram.</p>
<p>The dendrogram illustrates how each cluster is
composed by drawing a U-shaped link between a non-singleton
cluster and its children.  The top of the U-link indicates a
cluster merge.  The two legs of the U-link indicate which clusters
were merged.  The length of the two legs of the U-link represents
the distance between the child clusters.  It is also the
cophenetic distance between original observations in the two
children clusters.</p>
<h2 id="parameters_8">Parameters<a class="headerlink" href="#parameters_8" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The linkage matrix encoding the hierarchical clustering to
render as a dendrogram. See the <code>linkage</code> function for more
information on the format of <code>Z</code>.
p : int, optional
The <code>p</code> parameter for <code>truncate_mode</code>.
truncate_mode : str, optional
The dendrogram can be hard to read when the original
observation matrix from which the linkage is derived is
large. Truncation is used to condense the dendrogram. There
are several modes:</p>
<p><code>None</code>
No truncation is performed (default).
Note: <code>'none'</code> is an alias for <code>None</code> that's kept for
backward compatibility.</p>
<p><code>'lastp'</code>
The last <code>p</code> non-singleton clusters formed in the linkage are the
only non-leaf nodes in the linkage; they correspond to rows
<code>Z[n-p-2:end]</code> in <code>Z</code>. All other non-singleton clusters are
contracted into leaf nodes.</p>
<p><code>'level'</code>
No more than <code>p</code> levels of the dendrogram tree are displayed.
A 'level' includes all nodes with <code>p</code> merges from the last merge.</p>
<p>Note: <code>'mtica'</code> is an alias for <code>'level'</code> that's kept for
backward compatibility.</p>
<p>color_threshold : double, optional
For brevity, let :math:<code>t</code> be the <code>color_threshold</code>.
Colors all the descendent links below a cluster node
:math:<code>k</code> the same color if :math:<code>k</code> is the first node below
the cut threshold :math:<code>t</code>. All links connecting nodes with
distances greater than or equal to the threshold are colored
blue. If :math:<code>t</code> is less than or equal to zero, all nodes
are colored blue. If <code>color_threshold</code> is None or
'default', corresponding with MATLAB(TM) behavior, the
threshold is set to <code>0.7*max(Z[:,2])</code>.
get_leaves : bool, optional
Includes a list <code>R['leaves']=H</code> in the result
dictionary. For each :math:<code>i</code>, <code>H[i] == j</code>, cluster node
<code>j</code> appears in position <code>i</code> in the left-to-right traversal
of the leaves, where :math:<code>j &lt; 2n-1</code> and :math:<code>i &lt; n</code>.
orientation : str, optional
The direction to plot the dendrogram, which can be any
of the following strings:</p>
<p><code>'top'</code>
Plots the root at the top, and plot descendent links going downwards.
(default).</p>
<p><code>'bottom'</code>
Plots the root at the bottom, and plot descendent links going
upwards.</p>
<p><code>'left'</code>
Plots the root at the left, and plot descendent links going right.</p>
<p><code>'right'</code>
Plots the root at the right, and plot descendent links going left.</p>
<p>labels : ndarray, optional
By default <code>labels</code> is None so the index of the original observation
is used to label the leaf nodes.  Otherwise, this is an :math:<code>n</code>
-sized list (or tuple). The <code>labels[i]</code> value is the text to put
under the :math:<code>i</code> th leaf node only if it corresponds to an original
observation and not a non-singleton cluster.
count_sort : str or bool, optional
For each node n, the order (visually, from left-to-right) n's
two descendent links are plotted is determined by this
parameter, which can be any of the following values:</p>
<p><code>False</code>
Nothing is done.</p>
<p><code>'ascending'</code> or <code>True</code>
The child with the minimum number of original objects in its cluster
is plotted first.</p>
<p><code>'descending'</code>
The child with the maximum number of original objects in its cluster
is plotted first.</p>
<p>Note <code>distance_sort</code> and <code>count_sort</code> cannot both be True.
distance_sort : str or bool, optional
For each node n, the order (visually, from left-to-right) n's
two descendent links are plotted is determined by this
parameter, which can be any of the following values:</p>
<p><code>False</code>
Nothing is done.</p>
<p><code>'ascending'</code> or <code>True</code>
The child with the minimum distance between its direct descendents is
plotted first.</p>
<p><code>'descending'</code>
The child with the maximum distance between its direct descendents is
plotted first.</p>
<p>Note <code>distance_sort</code> and <code>count_sort</code> cannot both be True.
show_leaf_counts : bool, optional
When True, leaf nodes representing :math:<code>k&gt;1</code> original
observation are labeled with the number of observations they
contain in parentheses.
no_plot : bool, optional
When True, the final rendering is not performed. This is
useful if only the data structures computed for the rendering
are needed or if matplotlib is not available.
no_labels : bool, optional
When True, no labels appear next to the leaf nodes in the
rendering of the dendrogram.
leaf_rotation : double, optional
Specifies the angle (in degrees) to rotate the leaf
labels. When unspecified, the rotation is based on the number of
nodes in the dendrogram (default is 0).
leaf_font_size : int, optional
Specifies the font size (in points) of the leaf labels. When
unspecified, the size based on the number of nodes in the
dendrogram.
leaf_label_func : lambda or function, optional
When leaf_label_func is a callable function, for each
leaf with cluster index :math:<code>k &lt; 2n-1</code>. The function
is expected to return a string with the label for the
leaf.</p>
<p>Indices :math:<code>k &lt; n</code> correspond to original observations
while indices :math:<code>k \geq n</code> correspond to non-singleton
clusters.</p>
<p>For example, to label singletons with their node id and
non-singletons with their id, count, and inconsistency
coefficient, simply do::</p>
<h1 id="first-define-the-leaf-label-function">First define the leaf label function.<a class="headerlink" href="#first-define-the-leaf-label-function" title="Permanent link">&para;</a></h1>
<p>def llf(id):
if id &lt; n:
return str(id)
else:
return '[%d %d %1.2f]' % (id, count, R[n-id,3])</p>
<h1 id="the-text-for-the-leaf-nodes-is-going-to-be-big-so-force">The text for the leaf nodes is going to be big so force<a class="headerlink" href="#the-text-for-the-leaf-nodes-is-going-to-be-big-so-force" title="Permanent link">&para;</a></h1>
<h1 id="a-rotation-of-90-degrees">a rotation of 90 degrees.<a class="headerlink" href="#a-rotation-of-90-degrees" title="Permanent link">&para;</a></h1>
<p>dendrogram(Z, leaf_label_func=llf, leaf_rotation=90)</p>
<p>show_contracted : bool, optional
When True the heights of non-singleton nodes contracted
into a leaf node are plotted as crosses along the link
connecting that leaf node.  This really is only useful when
truncation is used (see <code>truncate_mode</code> parameter).
link_color_func : callable, optional
If given, <code>link_color_function</code> is called with each non-singleton id
corresponding to each U-shaped link it will paint. The function is
expected to return the color to paint the link, encoded as a matplotlib
color string code. For example::</p>
<p>dendrogram(Z, link_color_func=lambda k: colors[k])</p>
<p>colors the direct links below each untruncated non-singleton node
<code>k</code> using <code>colors[k]</code>.
ax : matplotlib Axes instance, optional
If None and <code>no_plot</code> is not True, the dendrogram will be plotted
on the current axes.  Otherwise if <code>no_plot</code> is not True the
dendrogram will be plotted on the given <code>Axes</code> instance. This can be
useful if the dendrogram is part of a more complex figure.
above_threshold_color : str, optional
This matplotlib color string sets the color of the links above the
color_threshold. The default is 'b'.</p>
<h2 id="returns_12">Returns<a class="headerlink" href="#returns_12" title="Permanent link">&para;</a></h2>
<p>R : dict
A dictionary of data structures computed to render the
dendrogram. Its has the following keys:</p>
<p><code>'color_list'</code>
A list of color names. The k'th element represents the color of the
k'th link.</p>
<p><code>'icoord'</code> and <code>'dcoord'</code>
Each of them is a list of lists. Let <code>icoord = [I1, I2, ..., Ip]</code>
where <code>Ik = [xk1, xk2, xk3, xk4]</code> and <code>dcoord = [D1, D2, ..., Dp]</code>
where <code>Dk = [yk1, yk2, yk3, yk4]</code>, then the k'th link painted is
<code>(xk1, yk1)</code> - <code>(xk2, yk2)</code> - <code>(xk3, yk3)</code> - <code>(xk4, yk4)</code>.</p>
<p><code>'ivl'</code>
A list of labels corresponding to the leaf nodes.</p>
<p><code>'leaves'</code>
For each i, <code>H[i] == j</code>, cluster node <code>j</code> appears in position
<code>i</code> in the left-to-right traversal of the leaves, where
:math:<code>j &lt; 2n-1</code> and :math:<code>i &lt; n</code>. If <code>j</code> is less than <code>n</code>, the
<code>i</code>-th leaf node corresponds to an original observation.
Otherwise, it corresponds to a non-singleton cluster.</p>
<h2 id="see-also_6">See Also<a class="headerlink" href="#see-also_6" title="Permanent link">&para;</a></h2>
<p>linkage, set_link_color_palette</p>
<h2 id="notes">Notes<a class="headerlink" href="#notes" title="Permanent link">&para;</a></h2>
<p>It is expected that the distances in <code>Z[:,2]</code> be monotonic, otherwise
crossings appear in the dendrogram.</p>
<h2 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster import hierarchy
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>A very basic example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,
...                    400., 754., 564., 138., 219., 869., 669.])
Z = hierarchy.linkage(ytdist, 'single')
plt.figure()
dn = hierarchy.dendrogram(Z)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now plot in given axes, improve the color scheme and use both vertical and
horizontal orientations:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hierarchy.set_link_color_palette(['m', 'c', 'y', 'k'])
fig, axes = plt.subplots(1, 2, figsize=(8, 3))
dn1 = hierarchy.dendrogram(Z, ax=axes[0], above_threshold_color='y',
...                            orientation='top')
dn2 = hierarchy.dendrogram(Z, ax=axes[1],
...                            above_threshold_color='#bcbddc',
...                            orientation='right')
hierarchy.set_link_color_palette(None)  # reset to default after use
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fcluster</span> <span class="o">:</span> <span class="o">?</span><span class="n">criterion</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">depth</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">monocrit</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Form flat clusters from the hierarchical clustering defined by
the given linkage matrix.</p>
<h2 id="parameters_9">Parameters<a class="headerlink" href="#parameters_9" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded with the matrix returned
by the <code>linkage</code> function.
t : scalar
For criteria 'inconsistent', 'distance' or 'monocrit',
this is the threshold to apply when forming flat clusters.
For 'maxclust' or 'maxclust_monocrit' criteria,
this would be max number of clusters requested.
criterion : str, optional
The criterion to use in forming flat clusters. This can
be any of the following values:</p>
<p><code>inconsistent</code> :
If a cluster node and all its
descendants have an inconsistent value less than or equal
to <code>t</code> then all its leaf descendants belong to the
same flat cluster. When no non-singleton cluster meets
this criterion, every node is assigned to its own
cluster. (Default)</p>
<p><code>distance</code> :
Forms flat clusters so that the original
observations in each flat cluster have no greater a
cophenetic distance than <code>t</code>.</p>
<p><code>maxclust</code> :
Finds a minimum threshold <code>r</code> so that
the cophenetic distance between any two original
observations in the same flat cluster is no more than
<code>r</code> and no more than <code>t</code> flat clusters are formed.</p>
<p><code>monocrit</code> :
Forms a flat cluster from a cluster node c
with index i when <code>monocrit[j] &lt;= t</code>.</p>
<p>For example, to threshold on the maximum mean distance
as computed in the inconsistency matrix R with a
threshold of 0.8 do::</p>
<p>MR = maxRstat(Z, R, 3)
cluster(Z, t=0.8, criterion='monocrit', monocrit=MR)</p>
<p><code>maxclust_monocrit</code> :
Forms a flat cluster from a
non-singleton cluster node <code>c</code> when <code>monocrit[i] &lt;=
r</code> for all cluster indices <code>i</code> below and including
<code>c</code>. <code>r</code> is minimized such that no more than <code>t</code>
flat clusters are formed. monocrit must be
monotonic. For example, to minimize the threshold t on
maximum inconsistency values so that no more than 3 flat
clusters are formed, do::</p>
<p>MI = maxinconsts(Z, R)
cluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI)</p>
<p>depth : int, optional
The maximum depth to perform the inconsistency calculation.
It has no meaning for the other criteria. Default is 2.
R : ndarray, optional
The inconsistency matrix to use for the 'inconsistent'
criterion. This matrix is computed if not provided.
monocrit : ndarray, optional
An array of length n-1. <code>monocrit[i]</code> is the
statistics upon which non-singleton i is thresholded. The
monocrit vector must be monotonic, i.e. given a node c with
index i, for all node indices j corresponding to nodes
below c, <code>monocrit[i] &gt;= monocrit[j]</code>.</p>
<h2 id="returns_13">Returns<a class="headerlink" href="#returns_13" title="Permanent link">&para;</a></h2>
<p>fcluster : ndarray
An array of length <code>n</code>. <code>T[i]</code> is the flat cluster number to
which original observation <code>i</code> belongs.</p>
<h2 id="see-also_7">See Also<a class="headerlink" href="#see-also_7" title="Permanent link">&para;</a></h2>
<p>linkage : for information about hierarchical clustering methods work.</p>
<h2 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>All cluster linkage methods - e.g. <code>scipy.cluster.hierarchy.ward</code>
generate a linkage matrix <code>Z</code> as their output:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))</p>
<p>Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>This matrix represents a dendrogram, where the first and second elements
are the two clusters merged at each step, the third element is the
distance between these clusters, and the fourth element is the size of
the new cluster - the number of original data points included.</p>
<p><code>scipy.cluster.hierarchy.fcluster</code> can be used to flatten the
dendrogram, obtaining as a result an assignation of the original data
points to single clusters.</p>
<p>This assignation mostly depends on a distance threshold <code>t</code> - the maximum
inter-cluster distance allowed:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, t=0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)</p>
<p>fcluster(Z, t=1.1, criterion='distance')
array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)</p>
<p>fcluster(Z, t=3, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</p>
<p>fcluster(Z, t=9, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>In the first case, the threshold <code>t</code> is too small to allow any two
samples in the data to form a cluster, so 12 different clusters are
returned.</p>
<p>In the second case, the threshold is large enough to allow the first
4 points to be merged with their nearest neighbors. So here only 8
clusters are returned.</p>
<p>The third case, with a much higher threshold, allows for up to 8 data
points to be connected - so 4 clusters are returned here.</p>
<p>Lastly, the threshold of the fourth case is large enough to allow for
all data points to be merged together - so a single cluster is returned.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">fclusterdata</span> <span class="o">:</span> <span class="o">?</span><span class="n">criterion</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">metric</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">depth</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[`</span><span class="nc">F</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Bool</span> <span class="k">of</span> <span class="kt">bool</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Cluster observation data using a given metric.</p>
<p>Clusters the original observations in the n-by-m data
matrix X (n observations in m dimensions), using the euclidean
distance metric to calculate distances between original observations,
performs hierarchical clustering using the single linkage algorithm,
and forms flat clusters using the inconsistency method with <code>t</code> as the
cut-off threshold.</p>
<p>A one-dimensional array <code>T</code> of length <code>n</code> is returned. <code>T[i]</code> is
the index of the flat cluster to which the original observation <code>i</code>
belongs.</p>
<h2 id="parameters_10">Parameters<a class="headerlink" href="#parameters_10" title="Permanent link">&para;</a></h2>
<p>X : (N, M) ndarray
N by M data matrix with N observations in M dimensions.
t : scalar
For criteria 'inconsistent', 'distance' or 'monocrit',
this is the threshold to apply when forming flat clusters.
For 'maxclust' or 'maxclust_monocrit' criteria,
this would be max number of clusters requested.
criterion : str, optional
Specifies the criterion for forming flat clusters.  Valid
values are 'inconsistent' (default), 'distance', or 'maxclust'
cluster formation algorithms. See <code>fcluster</code> for descriptions.
metric : str, optional
The distance metric for calculating pairwise distances. See
<code>distance.pdist</code> for descriptions and linkage to verify
compatibility with the linkage method.
depth : int, optional
The maximum depth for the inconsistency calculation. See
<code>inconsistent</code> for more information.
method : str, optional
The linkage method to use (single, complete, average,
weighted, median centroid, ward). See <code>linkage</code> for more
information. Default is 'single'.
R : ndarray, optional
The inconsistency matrix. It will be computed if necessary
if it is not passed.</p>
<h2 id="returns_14">Returns<a class="headerlink" href="#returns_14" title="Permanent link">&para;</a></h2>
<p>fclusterdata : ndarray
A vector of length n. T[i] is the flat cluster number to
which original observation i belongs.</p>
<h2 id="see-also_8">See Also<a class="headerlink" href="#see-also_8" title="Permanent link">&para;</a></h2>
<p>scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="notes_1">Notes<a class="headerlink" href="#notes_1" title="Permanent link">&para;</a></h2>
<p>This function is similar to the MATLAB function <code>clusterdata</code>.</p>
<h2 id="examples_8">Examples<a class="headerlink" href="#examples_8" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import fclusterdata</p>
</blockquote>
</blockquote>
</blockquote>
<p>This is a convenience method that abstracts all the steps to perform in a
typical SciPy's hierarchical clustering workflow.</p>
<ul>
<li>
<p>Transform the input data into a condensed matrix with <code>scipy.spatial.distance.pdist</code>.</p>
</li>
<li>
<p>Apply a clustering method.</p>
</li>
<li>
<p>Obtain flat clusters at a user defined distance threshold <code>t</code> using <code>scipy.cluster.hierarchy.fcluster</code>.</p>
</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>fclusterdata(X, t=1)
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The output here (for the dataset <code>X</code>, distance threshold <code>t</code>, and the
default settings) is four clusters with three data points each.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">from_mlab_linkage</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a linkage matrix generated by MATLAB(TM) to a new
linkage matrix compatible with this module.</p>
<p>The conversion does two things:</p>
<ul>
<li>
<p>the indices are converted from <code>1..N</code> to <code>0..(N-1)</code> form,
and</p>
</li>
<li>
<p>a fourth column <code>Z[:,3]</code> is added where <code>Z[i,3]</code> represents the
number of original observations (leaves) in the non-singleton
cluster <code>i</code>.</p>
</li>
</ul>
<p>This function is useful when loading in linkages from legacy data
files generated by MATLAB.</p>
<h2 id="parameters_11">Parameters<a class="headerlink" href="#parameters_11" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix generated by MATLAB(TM).</p>
<h2 id="returns_15">Returns<a class="headerlink" href="#returns_15" title="Permanent link">&para;</a></h2>
<p>ZS : ndarray
A linkage matrix compatible with <code>scipy.cluster.hierarchy</code>.</p>
<h2 id="see-also_9">See Also<a class="headerlink" href="#see-also_9" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
to_mlab_linkage: transform from SciPy to MATLAB format.</p>
<h2 id="examples_9">Examples<a class="headerlink" href="#examples_9" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
from scipy.cluster.hierarchy import ward, from_mlab_linkage</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a linkage matrix in MATLAB format <code>mZ</code>, we can use
<code>scipy.cluster.hierarchy.from_mlab_linkage</code> to import
it into SciPy format:</p>
<blockquote>
<blockquote>
<blockquote>
<p>mZ = np.array([[1, 2, 1], [4, 5, 1], [7, 8, 1],
...                [10, 11, 1], [3, 13, 1.29099445],
...                [6, 14, 1.29099445],
...                [9, 15, 1.29099445],
...                [12, 16, 1.29099445],
...                [17, 18, 5.77350269],
...                [19, 20, 5.77350269],
...                [21, 22,  8.16496581]])</p>
<p>Z = from_mlab_linkage(mZ)
Z
array([[  0.        ,   1.        ,   1.        ,   2.        ],
[  3.        ,   4.        ,   1.        ,   2.        ],
[  6.        ,   7.        ,   1.        ,   2.        ],
[  9.        ,  10.        ,   1.        ,   2.        ],
[  2.        ,  12.        ,   1.29099445,   3.        ],
[  5.        ,  13.        ,   1.29099445,   3.        ],
[  8.        ,  14.        ,   1.29099445,   3.        ],
[ 11.        ,  15.        ,   1.29099445,   3.        ],
[ 16.        ,  17.        ,   5.77350269,   6.        ],
[ 18.        ,  19.        ,   5.77350269,   6.        ],
[ 20.        ,  21.        ,   8.16496581,  12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>As expected, the linkage matrix <code>Z</code> returned includes an
additional column counting the number of original samples in
each cluster. Also, all cluster indexes are reduced by 1
(MATLAB format uses 1-indexing, whereas SciPy uses 0-indexing).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">inconsistent</span> <span class="o">:</span> <span class="o">?</span><span class="n">d</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Calculate inconsistency statistics on a linkage matrix.</p>
<h2 id="parameters_12">Parameters<a class="headerlink" href="#parameters_12" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The :math:<code>(n-1)</code> by 4 matrix encoding the linkage (hierarchical
clustering).  See <code>linkage</code> documentation for more information on its
form.
d : int, optional
The number of links up to <code>d</code> levels below each non-singleton cluster.</p>
<h2 id="returns_16">Returns<a class="headerlink" href="#returns_16" title="Permanent link">&para;</a></h2>
<p>R : ndarray
A :math:<code>(n-1)</code> by 4 matrix where the <code>i</code>'th row contains the link
statistics for the non-singleton cluster <code>i</code>. The link statistics are
computed over the link heights for links :math:<code>d</code> levels below the
cluster <code>i</code>. <code>R[i,0]</code> and <code>R[i,1]</code> are the mean and standard
deviation of the link heights, respectively; <code>R[i,2]</code> is the number
of links included in the calculation; and <code>R[i,3]</code> is the
inconsistency coefficient,</p>
<p>.. math:: \frac{\mathtt{Z[i,2]} - \mathtt{R[i,0]}} {R[i,1]}</p>
<h2 id="notes_2">Notes<a class="headerlink" href="#notes_2" title="Permanent link">&para;</a></h2>
<p>This function behaves similarly to the MATLAB(TM) <code>inconsistent</code>
function.</p>
<h2 id="examples_10">Examples<a class="headerlink" href="#examples_10" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import inconsistent, linkage
from matplotlib import pyplot as plt
X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]
Z = linkage(X, 'ward')
print(Z)
[[ 5.          6.          0.          2.        ]
[ 2.          7.          0.          2.        ]
[ 0.          4.          1.          2.        ]
[ 1.          8.          1.15470054  3.        ]
[ 9.         10.          2.12132034  4.        ]
[ 3.         12.          4.11096096  5.        ]
[11.         13.         14.07183949  8.        ]]
inconsistent(Z)
array([[ 0.        ,  0.        ,  1.        ,  0.        ],
[ 0.        ,  0.        ,  1.        ,  0.        ],
[ 1.        ,  0.        ,  1.        ,  0.        ],
[ 0.57735027,  0.81649658,  2.        ,  0.70710678],
[ 1.04044011,  1.06123822,  3.        ,  1.01850858],
[ 3.11614065,  1.40688837,  2.        ,  0.70710678],
[ 6.44583366,  6.76770586,  3.        ,  1.12682288]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_isomorphic</span> <span class="o">:</span> <span class="n">t1</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t2</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Determine if two different cluster assignments are equivalent.</p>
<h2 id="parameters_13">Parameters<a class="headerlink" href="#parameters_13" title="Permanent link">&para;</a></h2>
<p>T1 : array_like
An assignment of singleton cluster ids to flat cluster ids.
T2 : array_like
An assignment of singleton cluster ids to flat cluster ids.</p>
<h2 id="returns_17">Returns<a class="headerlink" href="#returns_17" title="Permanent link">&para;</a></h2>
<p>b : bool
Whether the flat cluster assignments <code>T1</code> and <code>T2</code> are
equivalent.</p>
<h2 id="see-also_10">See Also<a class="headerlink" href="#see-also_10" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
fcluster: for the creation of flat cluster assignments.</p>
<h2 id="examples_11">Examples<a class="headerlink" href="#examples_11" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import fcluster, is_isomorphic
from scipy.cluster.hierarchy import single, complete
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Two flat cluster assignments can be isomorphic if they represent the same
cluster assignment, with different labels.</p>
<p>For example, we can use the <code>scipy.cluster.hierarchy.single</code>: method
and flatten the output to four clusters:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = single(pdist(X))
T = fcluster(Z, 1, criterion='distance')
T
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can then do the same using the
<code>scipy.cluster.hierarchy.complete</code>: method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = complete(pdist(X))
T_ = fcluster(Z, 1.5, criterion='distance')
T_
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>As we can see, in both cases we obtain four clusters and all the data
points are distributed in the same way - the only thing that changes
are the flat cluster labels (3 =&gt; 1, 4 =&gt;2, 2 =&gt;3 and 4 =&gt;1), so both
cluster assignments are isomorphic:</p>
<blockquote>
<blockquote>
<blockquote>
<p>is_isomorphic(T, T_)
True</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_monotonic</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Return True if the linkage passed is monotonic.</p>
<p>The linkage is monotonic if for every cluster :math:<code>s</code> and :math:<code>t</code>
joined, the distance between them is no less than the distance
between any previously joined clusters.</p>
<h2 id="parameters_14">Parameters<a class="headerlink" href="#parameters_14" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The linkage matrix to check for monotonicity.</p>
<h2 id="returns_18">Returns<a class="headerlink" href="#returns_18" title="Permanent link">&para;</a></h2>
<p>b : bool
A boolean indicating whether the linkage is monotonic.</p>
<h2 id="see-also_11">See Also<a class="headerlink" href="#see-also_11" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.</p>
<h2 id="examples_12">Examples<a class="headerlink" href="#examples_12" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import median, ward, is_monotonic
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>By definition, some hierarchical clustering algorithms - such as
<code>scipy.cluster.hierarchy.ward</code> - produce monotonic assignments of
samples to clusters; however, this is not always true for other
hierarchical methods - e.g. <code>scipy.cluster.hierarchy.median</code>.</p>
<p>Given a linkage matrix <code>Z</code> (as the result of a hierarchical clustering
method) we can test programmatically whether if is has the monotonicity
property or not, using <code>scipy.cluster.hierarchy.is_monotonic</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])
is_monotonic(Z)
True</p>
<p>Z = median(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.11803399,  3.        ],
[ 5.        , 13.        ,  1.11803399,  3.        ],
[ 8.        , 15.        ,  1.11803399,  3.        ],
[11.        , 14.        ,  1.11803399,  3.        ],
[18.        , 19.        ,  3.        ,  6.        ],
[16.        , 17.        ,  3.5       ,  6.        ],
[20.        , 21.        ,  3.25      , 12.        ]])
is_monotonic(Z)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that this method is equivalent to just verifying that the distances
in the third column of the linkage matrix appear in a monotonically
increasing order.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_valid_im</span> <span class="o">:</span> <span class="o">?</span><span class="n">warning</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">throw</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Return True if the inconsistency matrix passed is valid.</p>
<p>It must be a :math:<code>n</code> by 4 array of doubles. The standard
deviations <code>R[:,1]</code> must be nonnegative. The link counts
<code>R[:,2]</code> must be positive and no greater than :math:<code>n-1</code>.</p>
<h2 id="parameters_15">Parameters<a class="headerlink" href="#parameters_15" title="Permanent link">&para;</a></h2>
<p>R : ndarray
The inconsistency matrix to check for validity.
warning : bool, optional
When True, issues a Python warning if the linkage
matrix passed is invalid.
throw : bool, optional
When True, throws a Python exception if the linkage
matrix passed is invalid.
name : str, optional
This string refers to the variable name of the invalid
linkage matrix.</p>
<h2 id="returns_19">Returns<a class="headerlink" href="#returns_19" title="Permanent link">&para;</a></h2>
<p>b : bool
True if the inconsistency matrix is valid.</p>
<h2 id="see-also_12">See Also<a class="headerlink" href="#see-also_12" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
inconsistent: for the creation of a inconsistency matrix.</p>
<h2 id="examples_13">Examples<a class="headerlink" href="#examples_13" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, inconsistent, is_valid_im
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a data set <code>X</code>, we can apply a clustering method to obtain a
linkage matrix <code>Z</code>. <code>scipy.cluster.hierarchy.inconsistent</code> can
be also used to obtain the inconsistency matrix <code>R</code> associated to
this clustering process:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))
R = inconsistent(Z)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])
R
array([[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.14549722, 0.20576415, 2.        , 0.70710678],
[1.14549722, 0.20576415, 2.        , 0.70710678],
[1.14549722, 0.20576415, 2.        , 0.70710678],
[1.14549722, 0.20576415, 2.        , 0.70710678],
[2.78516386, 2.58797734, 3.        , 1.15470054],
[2.78516386, 2.58797734, 3.        , 1.15470054],
[6.57065706, 1.38071187, 3.        , 1.15470054]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now we can use <code>scipy.cluster.hierarchy.is_valid_im</code> to verify that
<code>R</code> is correct:</p>
<blockquote>
<blockquote>
<blockquote>
<p>is_valid_im(R)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>However, if <code>R</code> is wrongly constructed (e.g one of the standard
deviations is set to a negative value) then the check will fail:</p>
<blockquote>
<blockquote>
<blockquote>
<p>R[-1,1] = R[-1,1] * -1
is_valid_im(R)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">is_valid_linkage</span> <span class="o">:</span> <span class="o">?</span><span class="n">warning</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">throw</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div>

<p>Check the validity of a linkage matrix.</p>
<p>A linkage matrix is valid if it is a two dimensional array (type double)
with :math:<code>n</code> rows and 4 columns.  The first two columns must contain
indices between 0 and :math:<code>2n-1</code>. For a given row <code>i</code>, the following
two expressions have to hold:</p>
<p>.. math::</p>
<p>0 \leq \mathtt{Z[i,0]} \leq i+n-1
0 \leq Z[i,1] \leq i+n-1</p>
<p>I.e. a cluster cannot join another cluster unless the cluster being joined
has been generated.</p>
<h2 id="parameters_16">Parameters<a class="headerlink" href="#parameters_16" title="Permanent link">&para;</a></h2>
<p>Z : array_like
Linkage matrix.
warning : bool, optional
When True, issues a Python warning if the linkage
matrix passed is invalid.
throw : bool, optional
When True, throws a Python exception if the linkage
matrix passed is invalid.
name : str, optional
This string refers to the variable name of the invalid
linkage matrix.</p>
<h2 id="returns_20">Returns<a class="headerlink" href="#returns_20" title="Permanent link">&para;</a></h2>
<p>b : bool
True if the inconsistency matrix is valid.</p>
<h2 id="see-also_13">See Also<a class="headerlink" href="#see-also_13" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.</p>
<h2 id="examples_14">Examples<a class="headerlink" href="#examples_14" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, is_valid_linkage
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>All linkage matrices generated by the clustering methods in this module
will be valid (i.e. they will have the appropriate dimensions and the two
required expressions will hold for all the rows).</p>
<p>We can check this using <code>scipy.cluster.hierarchy.is_valid_linkage</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])
is_valid_linkage(Z)
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>However, is we create a linkage matrix in a wrong way - or if we modify
a valid one in a way that any of the required expressions don't hold
anymore, then the check will fail:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z[3][1] = 20    # the cluster number 20 is not defined at this point
is_valid_linkage(Z)
False</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leaders</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Return the root nodes in a hierarchical clustering.</p>
<p>Returns the root nodes in a hierarchical clustering corresponding
to a cut defined by a flat cluster assignment vector <code>T</code>. See
the <code>fcluster</code> function for more information on the format of <code>T</code>.</p>
<p>For each flat cluster :math:<code>j</code> of the :math:<code>k</code> flat clusters
represented in the n-sized flat cluster assignment vector <code>T</code>,
this function finds the lowest cluster node :math:<code>i</code> in the linkage
tree Z such that:</p>
<ul>
<li>
<p>leaf descendants belong only to flat cluster j
(i.e. <code>T[p]==j</code> for all :math:<code>p</code> in :math:<code>S(i)</code> where
:math:<code>S(i)</code> is the set of leaf ids of descendant leaf nodes
with cluster node :math:<code>i</code>)</p>
</li>
<li>
<p>there does not exist a leaf that is not a descendant with
:math:<code>i</code> that also belongs to cluster :math:<code>j</code>
(i.e. <code>T[q]!=j</code> for all :math:<code>q</code> not in :math:<code>S(i)</code>).  If
this condition is violated, <code>T</code> is not a valid cluster
assignment vector, and an exception will be thrown.</p>
</li>
</ul>
<h2 id="parameters_17">Parameters<a class="headerlink" href="#parameters_17" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a matrix. See
<code>linkage</code> for more information.
T : ndarray
The flat cluster assignment vector.</p>
<h2 id="returns_21">Returns<a class="headerlink" href="#returns_21" title="Permanent link">&para;</a></h2>
<p>L : ndarray
The leader linkage node id's stored as a k-element 1-D array
where <code>k</code> is the number of flat clusters found in <code>T</code>.</p>
<p><code>L[j]=i</code> is the linkage cluster node id that is the
leader of flat cluster with id M[j].  If <code>i &lt; n</code>, <code>i</code>
corresponds to an original observation, otherwise it
corresponds to a non-singleton cluster.</p>
<p>M : ndarray
The leader linkage node id's stored as a k-element 1-D array where
<code>k</code> is the number of flat clusters found in <code>T</code>. This allows the
set of flat cluster ids to be any arbitrary set of <code>k</code> integers.</p>
<p>For example: if <code>L[3]=2</code> and <code>M[3]=8</code>, the flat cluster with
id 8's leader is linkage node 2.</p>
<h2 id="see-also_14">See Also<a class="headerlink" href="#see-also_14" title="Permanent link">&para;</a></h2>
<p>fcluster: for the creation of flat cluster assignments.</p>
<h2 id="examples_15">Examples<a class="headerlink" href="#examples_15" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, fcluster, leaders
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a linkage matrix <code>Z</code> - obtained after apply a clustering method
to a dataset <code>X</code> - and a flat cluster assignment array <code>T</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])</p>
<p>T = fcluster(Z, 3, criterion='distance')
T
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>scipy.cluster.hierarchy.leaders</code> returns the indexes of the nodes
in the dendrogram that are the leaders of each flat cluster:</p>
<blockquote>
<blockquote>
<blockquote>
<p>L, M = leaders(Z, T)
L
array([16, 17, 18, 19], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>(remember that indexes 0-11 point to the 12 data points in <code>X</code>
whereas indexes 12-22 point to the 11 rows of <code>Z</code>)</p>
<p><code>scipy.cluster.hierarchy.leaders</code> also returns the indexes of
the flat clusters in <code>T</code>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>M
array([1, 2, 3, 4], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">leaves_list</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return a list of leaf node ids.</p>
<p>The return corresponds to the observation vector index as it appears
in the tree from left to right. Z is a linkage matrix.</p>
<h2 id="parameters_18">Parameters<a class="headerlink" href="#parameters_18" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a matrix.  <code>Z</code> is
a linkage matrix.  See <code>linkage</code> for more information.</p>
<h2 id="returns_22">Returns<a class="headerlink" href="#returns_22" title="Permanent link">&para;</a></h2>
<p>leaves_list : ndarray
The list of leaf node ids.</p>
<h2 id="see-also_15">See Also<a class="headerlink" href="#see-also_15" title="Permanent link">&para;</a></h2>
<p>dendrogram: for information about dendrogram structure.</p>
<h2 id="examples_16">Examples<a class="headerlink" href="#examples_16" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, dendrogram, leaves_list
from scipy.spatial.distance import pdist
from matplotlib import pyplot as plt</p>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram, that is, a tree that
encodes the structure of the clustering performed.
<code>scipy.cluster.hierarchy.leaves_list</code> shows the mapping between
indexes in the <code>X</code> dataset and leaves in the dendrogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>leaves_list(Z)
array([ 2,  0,  1,  5,  3,  4,  8,  6,  7, 11,  9, 10], dtype=int32)</p>
<p>fig = plt.figure(figsize=(25, 10))
dn = dendrogram(Z)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">linkage</span> <span class="o">:</span> <span class="o">?</span><span class="n">method_</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">optimal_ordering</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform hierarchical/agglomerative clustering.</p>
<p>The input y may be either a 1d condensed distance matrix
or a 2d array of observation vectors.</p>
<p>If y is a 1d condensed distance matrix,
then y must be a :math:<code>\binom{n}{2}</code> sized
vector where n is the number of original observations paired
in the distance matrix. The behavior of this function is very
similar to the MATLAB linkage function.</p>
<p>A :math:<code>(n-1)</code> by 4 matrix <code>Z</code> is returned. At the
:math:<code>i</code>-th iteration, clusters with indices <code>Z[i, 0]</code> and
<code>Z[i, 1]</code> are combined to form cluster :math:<code>n + i</code>. A
cluster with an index less than :math:<code>n</code> corresponds to one of
the :math:<code>n</code> original observations. The distance between
clusters <code>Z[i, 0]</code> and <code>Z[i, 1]</code> is given by <code>Z[i, 2]</code>. The
fourth value <code>Z[i, 3]</code> represents the number of original
observations in the newly formed cluster.</p>
<p>The following linkage methods are used to compute the distance
:math:<code>d(s, t)</code> between two clusters :math:<code>s</code> and
:math:<code>t</code>. The algorithm begins with a forest of clusters that
have yet to be used in the hierarchy being formed. When two
clusters :math:<code>s</code> and :math:<code>t</code> from this forest are combined
into a single cluster :math:<code>u</code>, :math:<code>s</code> and :math:<code>t</code> are
removed from the forest, and :math:<code>u</code> is added to the
forest. When only one cluster remains in the forest, the algorithm
stops, and this cluster becomes the root.</p>
<p>A distance matrix is maintained at each iteration. The <code>d[i,j]</code>
entry corresponds to the distance between cluster :math:<code>i</code> and
:math:<code>j</code> in the original forest.</p>
<p>At each iteration, the algorithm must update the distance matrix
to reflect the distance of the newly formed cluster u with the
remaining clusters in the forest.</p>
<p>Suppose there are :math:<code>|u|</code> original observations
:math:<code>u[0], \ldots, u[|u|-1]</code> in cluster :math:<code>u</code> and
:math:<code>|v|</code> original objects :math:<code>v[0], \ldots, v[|v|-1]</code> in
cluster :math:<code>v</code>. Recall :math:<code>s</code> and :math:<code>t</code> are
combined to form cluster :math:<code>u</code>. Let :math:<code>v</code> be any
remaining cluster in the forest that is not :math:<code>u</code>.</p>
<p>The following are methods for calculating the distance between the
newly formed cluster :math:<code>u</code> and each :math:<code>v</code>.</p>
<ul>
<li>method='single' assigns</li>
</ul>
<p>.. math::
d(u,v) = \min(dist(u[i],v[j]))</p>
<p>for all points :math:<code>i</code> in cluster :math:<code>u</code> and
:math:<code>j</code> in cluster :math:<code>v</code>. This is also known as the
Nearest Point Algorithm.</p>
<ul>
<li>method='complete' assigns</li>
</ul>
<p>.. math::
d(u, v) = \max(dist(u[i],v[j]))</p>
<p>for all points :math:<code>i</code> in cluster u and :math:<code>j</code> in
cluster :math:<code>v</code>. This is also known by the Farthest Point
Algorithm or Voor Hees Algorithm.</p>
<ul>
<li>method='average' assigns</li>
</ul>
<p>.. math::
d(u,v) = \sum_{ij} \frac{d(u[i], v[j])}
{(|u|*|v|)}</p>
<p>for all points :math:<code>i</code> and :math:<code>j</code> where :math:<code>|u|</code>
and :math:<code>|v|</code> are the cardinalities of clusters :math:<code>u</code>
and :math:<code>v</code>, respectively. This is also called the UPGMA
algorithm.</p>
<ul>
<li>method='weighted' assigns</li>
</ul>
<p>.. math::
d(u,v) = (dist(s,v) + dist(t,v))/2</p>
<p>where cluster u was formed with cluster s and t and v
is a remaining cluster in the forest. (also called WPGMA)</p>
<ul>
<li>method='centroid' assigns</li>
</ul>
<p>.. math::
dist(s,t) = ||c_s-c_t||_2</p>
<p>where :math:<code>c_s</code> and :math:<code>c_t</code> are the centroids of
clusters :math:<code>s</code> and :math:<code>t</code>, respectively. When two
clusters :math:<code>s</code> and :math:<code>t</code> are combined into a new
cluster :math:<code>u</code>, the new centroid is computed over all the
original objects in clusters :math:<code>s</code> and :math:<code>t</code>. The
distance then becomes the Euclidean distance between the
centroid of :math:<code>u</code> and the centroid of a remaining cluster
:math:<code>v</code> in the forest. This is also known as the UPGMC
algorithm.</p>
<ul>
<li>
<p>method='median' assigns :math:<code>d(s,t)</code> like the <code>centroid</code>
method. When two clusters :math:<code>s</code> and :math:<code>t</code> are combined
into a new cluster :math:<code>u</code>, the average of centroids s and t
give the new centroid :math:<code>u</code>. This is also known as the
WPGMC algorithm.</p>
</li>
<li>
<p>method='ward' uses the Ward variance minimization algorithm.
The new entry :math:<code>d(u,v)</code> is computed as follows,</p>
</li>
</ul>
<p>.. math::</p>
<p>d(u,v) = \sqrt{\frac{ |v|+|s| }
{T}d(v,s)^2
+ \frac{ |v|+|t| }
{T}d(v,t)^2
- \frac{ |v| }
{T}d(s,t)^2}</p>
<p>where :math:<code>u</code> is the newly joined cluster consisting of
clusters :math:<code>s</code> and :math:<code>t</code>, :math:<code>v</code> is an unused
cluster in the forest, :math:<code>T=|v|+|s|+|t|</code>, and
:math:<code>|*|</code> is the cardinality of its argument. This is also
known as the incremental algorithm.</p>
<p>Warning: When the minimum distance pair in the forest is chosen, there
may be two or more pairs with the same minimum distance. This
implementation may choose a different minimum than the MATLAB
version.</p>
<h2 id="parameters_19">Parameters<a class="headerlink" href="#parameters_19" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A condensed distance matrix. A condensed distance matrix
is a flat array containing the upper triangular of the distance matrix.
This is the form that <code>pdist</code> returns. Alternatively, a collection of
:math:<code>m</code> observation vectors in :math:<code>n</code> dimensions may be passed as
an :math:<code>m</code> by :math:<code>n</code> array. All elements of the condensed distance
matrix must be finite, i.e. no NaNs or infs.
method : str, optional
The linkage algorithm to use. See the <code>Linkage Methods</code> section below
for full descriptions.
metric : str or function, optional
The distance metric to use in the case that y is a collection of
observation vectors; ignored otherwise. See the <code>pdist</code>
function for a list of valid distance metrics. A custom distance
function can also be used.
optimal_ordering : bool, optional
If True, the linkage matrix will be reordered so that the distance
between successive leaves is minimal. This results in a more intuitive
tree structure when the data are visualized. defaults to False, because
this algorithm can be slow, particularly on large datasets [2]_. See
also the <code>optimal_leaf_ordering</code> function.</p>
<p>.. versionadded:: 1.0.0</p>
<h2 id="returns_23">Returns<a class="headerlink" href="#returns_23" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a linkage matrix.</p>
<h2 id="notes_3">Notes<a class="headerlink" href="#notes_3" title="Permanent link">&para;</a></h2>
<ol>
<li>For method 'single' an optimized algorithm based on minimum spanning
tree is implemented. It has time complexity :math:<code>O(n^2)</code>.
For methods 'complete', 'average', 'weighted' and 'ward' an algorithm
called nearest-neighbors chain is implemented. It also has time
complexity :math:<code>O(n^2)</code>.
For other methods a naive algorithm is implemented with :math:<code>O(n^3)</code>
time complexity.
All algorithms use :math:<code>O(n^2)</code> memory.
Refer to [1]_ for details about the algorithms.</li>
<li>Methods 'centroid', 'median' and 'ward' are correctly defined only if
Euclidean pairwise metric is used. If <code>y</code> is passed as precomputed
pairwise distances, then it is a user responsibility to assure that
these distances are in fact Euclidean, otherwise the produced result
will be incorrect.</li>
</ol>
<h2 id="see-also_16">See Also<a class="headerlink" href="#see-also_16" title="Permanent link">&para;</a></h2>
<p>scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p>.. [1] Daniel Mullner, 'Modern hierarchical, agglomerative clustering
algorithms', :arXiv:<code>1109.2378v1</code>.
.. [2] Ziv Bar-Joseph, David K. Gifford, Tommi S. Jaakkola, 'Fast optimal
leaf ordering for hierarchical clustering', 2001. Bioinformatics
:doi:<code>10.1093/bioinformatics/17.suppl_1.S22</code></p>
<h2 id="examples_17">Examples<a class="headerlink" href="#examples_17" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import dendrogram, linkage
from matplotlib import pyplot as plt
X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]]</p>
<p>Z = linkage(X, 'ward')
fig = plt.figure(figsize=(25, 10))
dn = dendrogram(Z)</p>
<p>Z = linkage(X, 'single')
fig = plt.figure(figsize=(25, 10))
dn = dendrogram(Z)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxRstat</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum statistic for each non-singleton cluster and its
children.</p>
<h2 id="parameters_20">Parameters<a class="headerlink" href="#parameters_20" title="Permanent link">&para;</a></h2>
<p>Z : array_like
The hierarchical clustering encoded as a matrix. See <code>linkage</code> for more
information.
R : array_like
The inconsistency matrix.
i : int
The column of <code>R</code> to use as the statistic.</p>
<h2 id="returns_24">Returns<a class="headerlink" href="#returns_24" title="Permanent link">&para;</a></h2>
<p>MR : ndarray
Calculates the maximum statistic for the i'th column of the
inconsistency matrix <code>R</code> for each non-singleton cluster
node. <code>MR[j]</code> is the maximum over <code>R[Q(j)-n, i]</code> where
<code>Q(j)</code> the set of all node ids corresponding to nodes below
and including <code>j</code>.</p>
<h2 id="see-also_17">See Also<a class="headerlink" href="#see-also_17" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
inconsistent: for the creation of a inconsistency matrix.</p>
<h2 id="examples_18">Examples<a class="headerlink" href="#examples_18" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import median, inconsistent, maxRstat
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a data set <code>X</code>, we can apply a clustering method to obtain a
linkage matrix <code>Z</code>. <code>scipy.cluster.hierarchy.inconsistent</code> can
be also used to obtain the inconsistency matrix <code>R</code> associated to
this clustering process:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = median(pdist(X))
R = inconsistent(Z)
R
array([[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.74535599, 1.08655358, 3.        , 1.15470054],
[1.91202266, 1.37522872, 3.        , 1.15470054],
[3.25      , 0.25      , 3.        , 0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>scipy.cluster.hierarchy.maxRstat</code> can be used to compute
the maximum value of each column of <code>R</code>, for each non-singleton
cluster and its children:</p>
<blockquote>
<blockquote>
<blockquote>
<p>maxRstat(Z, R, 0)
array([1.        , 1.        , 1.        , 1.        , 1.05901699,
1.05901699, 1.05901699, 1.05901699, 1.74535599, 1.91202266,
3.25      ])
maxRstat(Z, R, 1)
array([0.        , 0.        , 0.        , 0.        , 0.08346263,
0.08346263, 0.08346263, 0.08346263, 1.08655358, 1.37522872,
1.37522872])
maxRstat(Z, R, 3)
array([0.        , 0.        , 0.        , 0.        , 0.70710678,
0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,
1.15470054])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxdists</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum distance between any non-singleton cluster.</p>
<h2 id="parameters_21">Parameters<a class="headerlink" href="#parameters_21" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a matrix. See
<code>linkage</code> for more information.</p>
<h2 id="returns_25">Returns<a class="headerlink" href="#returns_25" title="Permanent link">&para;</a></h2>
<p>maxdists : ndarray
A <code>(n-1)</code> sized numpy array of doubles; <code>MD[i]</code> represents
the maximum distance between any cluster (including
singletons) below and including the node with index i. More
specifically, <code>MD[i] = Z[Q(i)-n, 2].max()</code> where <code>Q(i)</code> is the
set of all node indices below and including node i.</p>
<h2 id="see-also_18">See Also<a class="headerlink" href="#see-also_18" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
is_monotonic: for testing for monotonicity of a linkage matrix.</p>
<h2 id="examples_19">Examples<a class="headerlink" href="#examples_19" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import median, maxdists
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a linkage matrix <code>Z</code>, <code>scipy.cluster.hierarchy.maxdists</code>
computes for each new cluster generated (i.e. for each row of the linkage
matrix) what is the maximum distance between any two child clusters.</p>
<p>Due to the nature of hierarchical clustering, in many cases this is going
to be just the distance between the two child clusters that were merged
to form the current one - that is, Z[:,2].</p>
<p>However, for non-monotonic cluster assignments such as
<code>scipy.cluster.hierarchy.median</code> clustering this is not always the
case: There may be cluster formations were the distance between the two
clusters merged is smaller than the distance between their children.</p>
<p>We can see this in an example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = median(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.11803399,  3.        ],
[ 5.        , 13.        ,  1.11803399,  3.        ],
[ 8.        , 15.        ,  1.11803399,  3.        ],
[11.        , 14.        ,  1.11803399,  3.        ],
[18.        , 19.        ,  3.        ,  6.        ],
[16.        , 17.        ,  3.5       ,  6.        ],
[20.        , 21.        ,  3.25      , 12.        ]])
maxdists(Z)
array([1.        , 1.        , 1.        , 1.        , 1.11803399,
1.11803399, 1.11803399, 1.11803399, 3.        , 3.5       ,
3.5       ])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Note that while the distance between the two clusters merged when creating the
last cluster is 3.25, there are two children (clusters 16 and 17) whose distance
is larger (3.5). Thus, <code>scipy.cluster.hierarchy.maxdists</code> returns 3.5 in
this case.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">maxinconsts</span> <span class="o">:</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return the maximum inconsistency coefficient for each
non-singleton cluster and its children.</p>
<h2 id="parameters_22">Parameters<a class="headerlink" href="#parameters_22" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a matrix. See
<code>linkage</code> for more information.
R : ndarray
The inconsistency matrix.</p>
<h2 id="returns_26">Returns<a class="headerlink" href="#returns_26" title="Permanent link">&para;</a></h2>
<p>MI : ndarray
A monotonic <code>(n-1)</code>-sized numpy array of doubles.</p>
<h2 id="see-also_19">See Also<a class="headerlink" href="#see-also_19" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
inconsistent: for the creation of a inconsistency matrix.</p>
<h2 id="examples_20">Examples<a class="headerlink" href="#examples_20" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import median, inconsistent, maxinconsts
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>Given a data set <code>X</code>, we can apply a clustering method to obtain a
linkage matrix <code>Z</code>. <code>scipy.cluster.hierarchy.inconsistent</code> can
be also used to obtain the inconsistency matrix <code>R</code> associated to
this clustering process:</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = median(pdist(X))
R = inconsistent(Z)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.11803399,  3.        ],
[ 5.        , 13.        ,  1.11803399,  3.        ],
[ 8.        , 15.        ,  1.11803399,  3.        ],
[11.        , 14.        ,  1.11803399,  3.        ],
[18.        , 19.        ,  3.        ,  6.        ],
[16.        , 17.        ,  3.5       ,  6.        ],
[20.        , 21.        ,  3.25      , 12.        ]])
R
array([[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.        , 0.        , 1.        , 0.        ],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.05901699, 0.08346263, 2.        , 0.70710678],
[1.74535599, 1.08655358, 3.        , 1.15470054],
[1.91202266, 1.37522872, 3.        , 1.15470054],
[3.25      , 0.25      , 3.        , 0.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here <code>scipy.cluster.hierarchy.maxinconsts</code> can be used to compute
the maximum value of the inconsistency statistic (the last column of
<code>R</code>) for each non-singleton cluster and its children:</p>
<blockquote>
<blockquote>
<blockquote>
<p>maxinconsts(Z, R)
array([0.        , 0.        , 0.        , 0.        , 0.70710678,
0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054,
1.15470054])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">median</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform median/WPGMC linkage.</p>
<p>See <code>linkage</code> for more information on the return structure
and algorithm.</p>
<p>The following are common calling conventions:</p>
<ol>
<li><code>Z = median(y)</code></li>
</ol>
<p>Performs median/WPGMC linkage on the condensed distance matrix
<code>y</code>.  See <code>linkage</code> for more information on the return
structure and algorithm.</p>
<ol>
<li><code>Z = median(X)</code></li>
</ol>
<p>Performs median/WPGMC linkage on the observation matrix <code>X</code>
using Euclidean distance as the distance metric. See <code>linkage</code>
for more information on the return structure and algorithm.</p>
<h2 id="parameters_23">Parameters<a class="headerlink" href="#parameters_23" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A condensed distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
<code>pdist</code> returns.  Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</p>
<h2 id="returns_27">Returns<a class="headerlink" href="#returns_27" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a linkage matrix.</p>
<h2 id="see-also_20">See Also<a class="headerlink" href="#see-also_20" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_21">Examples<a class="headerlink" href="#examples_21" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import median, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = median(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.11803399,  3.        ],
[ 5.        , 13.        ,  1.11803399,  3.        ],
[ 8.        , 15.        ,  1.11803399,  3.        ],
[11.        , 14.        ,  1.11803399,  3.        ],
[18.        , 19.        ,  3.        ,  6.        ],
[16.        , 17.        ,  3.5       ,  6.        ],
[20.        , 21.        ,  3.25      , 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32)
fcluster(Z, 1.1, criterion='distance')
array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32)
fcluster(Z, 2, criterion='distance')
array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32)
fcluster(Z, 4, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">num_obs_linkage</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</code></pre></div>

<p>Return the number of original observations of the linkage matrix passed.</p>
<h2 id="parameters_24">Parameters<a class="headerlink" href="#parameters_24" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The linkage matrix on which to perform the operation.</p>
<h2 id="returns_28">Returns<a class="headerlink" href="#returns_28" title="Permanent link">&para;</a></h2>
<p>n : int
The number of original observations in the linkage.</p>
<h2 id="examples_22">Examples<a class="headerlink" href="#examples_22" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, num_obs_linkage
from scipy.spatial.distance import pdist</p>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Z</code> is a linkage matrix obtained after using the Ward clustering method
with <code>X</code>, a dataset with 12 data points.</p>
<blockquote>
<blockquote>
<blockquote>
<p>num_obs_linkage(Z)
12</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">optimal_leaf_ordering</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Given a linkage matrix Z and distance, reorder the cut tree.</p>
<h2 id="parameters_25">Parameters<a class="headerlink" href="#parameters_25" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a linkage matrix. See
<code>linkage</code> for more information on the return structure and
algorithm.
y : ndarray
The condensed distance matrix from which Z was generated.
Alternatively, a collection of m observation vectors in n
dimensions may be passed as a m by n array.
metric : str or function, optional
The distance metric to use in the case that y is a collection of
observation vectors; ignored otherwise. See the <code>pdist</code>
function for a list of valid distance metrics. A custom distance
function can also be used.</p>
<h2 id="returns_29">Returns<a class="headerlink" href="#returns_29" title="Permanent link">&para;</a></h2>
<p>Z_ordered : ndarray
A copy of the linkage matrix Z, reordered to minimize the distance
between adjacent leaves.</p>
<h2 id="examples_23">Examples<a class="headerlink" href="#examples_23" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster import hierarchy
np.random.seed(23)
X = np.random.randn(10,10)
Z = hierarchy.ward(X)
hierarchy.leaves_list(Z)
array([0, 5, 3, 9, 6, 8, 1, 4, 2, 7], dtype=int32)
hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, X))
array([3, 9, 0, 5, 8, 2, 7, 4, 1, 6], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">set_link_color_palette</span> <span class="o">:</span> <span class="o">[`</span><span class="nc">StringList</span> <span class="k">of</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">|</span> <span class="o">`</span><span class="nc">None</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set list of matplotlib color codes for use by dendrogram.</p>
<p>Note that this palette is global (i.e. setting it once changes the colors
for all subsequent calls to <code>dendrogram</code>) and that it affects only the
the colors below <code>color_threshold</code>.</p>
<p>Note that <code>dendrogram</code> also accepts a custom coloring function through its
<code>link_color_func</code> keyword, which is more flexible and non-global.</p>
<h2 id="parameters_26">Parameters<a class="headerlink" href="#parameters_26" title="Permanent link">&para;</a></h2>
<p>palette : list of str or None
A list of matplotlib color codes.  The order of the color codes is the
order in which the colors are cycled through when color thresholding in
the dendrogram.</p>
<p>If <code>None</code>, resets the palette to its default (which is
<code>['g', 'r', 'c', 'm', 'y', 'k']</code>).</p>
<h2 id="returns_30">Returns<a class="headerlink" href="#returns_30" title="Permanent link">&para;</a></h2>
<p>None</p>
<h2 id="see-also_21">See Also<a class="headerlink" href="#see-also_21" title="Permanent link">&para;</a></h2>
<p>dendrogram</p>
<h2 id="notes_4">Notes<a class="headerlink" href="#notes_4" title="Permanent link">&para;</a></h2>
<p>Ability to reset the palette with <code>None</code> added in SciPy 0.17.0.</p>
<h2 id="examples_24">Examples<a class="headerlink" href="#examples_24" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster import hierarchy
ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268.,
...                    400., 754., 564., 138., 219., 869., 669.])
Z = hierarchy.linkage(ytdist, 'single')
dn = hierarchy.dendrogram(Z, no_plot=True)
dn['color_list']
['g', 'b', 'b', 'b', 'b']
hierarchy.set_link_color_palette(['c', 'm', 'y', 'k'])
dn = hierarchy.dendrogram(Z, no_plot=True)
dn['color_list']
['c', 'b', 'b', 'b', 'b']
dn = hierarchy.dendrogram(Z, no_plot=True, color_threshold=267,
...                           above_threshold_color='k')
dn['color_list']
['c', 'm', 'm', 'k', 'k']</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now reset the color palette to its default:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hierarchy.set_link_color_palette(None)</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">single</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform single/min/nearest linkage on the condensed distance matrix <code>y</code>.</p>
<h2 id="parameters_27">Parameters<a class="headerlink" href="#parameters_27" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The upper triangular of the distance matrix. The result of
<code>pdist</code> is returned in this form.</p>
<h2 id="returns_31">Returns<a class="headerlink" href="#returns_31" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The linkage matrix.</p>
<h2 id="see-also_22">See Also<a class="headerlink" href="#see-also_22" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_25">Examples<a class="headerlink" href="#examples_25" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import single, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = single(y)
Z
array([[ 0.,  1.,  1.,  2.],
[ 2., 12.,  1.,  3.],
[ 3.,  4.,  1.,  2.],
[ 5., 14.,  1.,  3.],
[ 6.,  7.,  1.,  2.],
[ 8., 16.,  1.,  3.],
[ 9., 10.,  1.,  2.],
[11., 18.,  1.,  3.],
[13., 15.,  2.,  6.],
[17., 20.,  2.,  9.],
[19., 21.,  2., 12.]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9, 10, 11, 12,  4,  5,  6,  1,  2,  3], dtype=int32)
fcluster(Z, 1, criterion='distance')
array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32)
fcluster(Z, 2, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_mlab_linkage</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a linkage matrix to a MATLAB(TM) compatible one.</p>
<p>Converts a linkage matrix <code>Z</code> generated by the linkage function
of this module to a MATLAB(TM) compatible one. The return linkage
matrix has the last column removed and the cluster indices are
converted to <code>1..N</code> indexing.</p>
<h2 id="parameters_28">Parameters<a class="headerlink" href="#parameters_28" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix generated by <code>scipy.cluster.hierarchy</code>.</p>
<h2 id="returns_32">Returns<a class="headerlink" href="#returns_32" title="Permanent link">&para;</a></h2>
<p>to_mlab_linkage : ndarray
A linkage matrix compatible with MATLAB(TM)'s hierarchical
clustering functions.</p>
<p>The return linkage matrix has the last column removed
and the cluster indices are converted to <code>1..N</code> indexing.</p>
<h2 id="see-also_23">See Also<a class="headerlink" href="#see-also_23" title="Permanent link">&para;</a></h2>
<p>linkage: for a description of what a linkage matrix is.
from_mlab_linkage: transform from Matlab to SciPy format.</p>
<h2 id="examples_26">Examples<a class="headerlink" href="#examples_26" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, to_mlab_linkage
from scipy.spatial.distance import pdist</p>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
<p>Z = ward(pdist(X))
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>After a linkage matrix <code>Z</code> has been created, we can use
<code>scipy.cluster.hierarchy.to_mlab_linkage</code> to convert it
into MATLAB format:</p>
<blockquote>
<blockquote>
<blockquote>
<p>mZ = to_mlab_linkage(Z)
mZ
array([[  1.        ,   2.        ,   1.        ],
[  4.        ,   5.        ,   1.        ],
[  7.        ,   8.        ,   1.        ],
[ 10.        ,  11.        ,   1.        ],
[  3.        ,  13.        ,   1.29099445],
[  6.        ,  14.        ,   1.29099445],
[  9.        ,  15.        ,   1.29099445],
[ 12.        ,  16.        ,   1.29099445],
[ 17.        ,  18.        ,   5.77350269],
[ 19.        ,  20.        ,   5.77350269],
[ 21.        ,  22.        ,   8.16496581]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The new linkage matrix <code>mZ</code> uses 1-indexing for all the
clusters (instead of 0-indexing). Also, the last column of
the original linkage matrix has been dropped.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_tree</span> <span class="o">:</span> <span class="o">?</span><span class="n">rd</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Convert a linkage matrix into an easy-to-use tree object.</p>
<p>The reference to the root <code>ClusterNode</code> object is returned (by default).</p>
<p>Each <code>ClusterNode</code> object has a <code>left</code>, <code>right</code>, <code>dist</code>, <code>id</code>,
and <code>count</code> attribute. The left and right attributes point to
ClusterNode objects that were combined to generate the cluster.
If both are None then the <code>ClusterNode</code> object is a leaf node, its count
must be 1, and its distance is meaningless but set to 0.</p>
<p><em>Note: This function is provided for the convenience of the library
user. ClusterNodes are not used as input to any of the functions in this
library.</em></p>
<h2 id="parameters_29">Parameters<a class="headerlink" href="#parameters_29" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The linkage matrix in proper form (see the <code>linkage</code>
function documentation).
rd : bool, optional
When False (default), a reference to the root <code>ClusterNode</code> object is
returned.  Otherwise, a tuple <code>(r, d)</code> is returned. <code>r</code> is a
reference to the root node while <code>d</code> is a list of <code>ClusterNode</code>
objects - one per original entry in the linkage matrix plus entries
for all clustering steps.  If a cluster id is
less than the number of samples <code>n</code> in the data that the linkage
matrix describes, then it corresponds to a singleton cluster (leaf
node).
See <code>linkage</code> for more information on the assignment of cluster ids
to clusters.</p>
<h2 id="returns_33">Returns<a class="headerlink" href="#returns_33" title="Permanent link">&para;</a></h2>
<p>tree : ClusterNode or tuple (ClusterNode, list of ClusterNode)
If <code>rd</code> is False, a <code>ClusterNode</code>.
If <code>rd</code> is True, a list of length <code>2*n - 1</code>, with <code>n</code> the number
of samples.  See the description of <code>rd</code> above for more details.</p>
<h2 id="see-also_24">See Also<a class="headerlink" href="#see-also_24" title="Permanent link">&para;</a></h2>
<p>linkage, is_valid_linkage, ClusterNode</p>
<h2 id="examples_27">Examples<a class="headerlink" href="#examples_27" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster import hierarchy
x = np.random.rand(10).reshape(5, 2)
Z = hierarchy.linkage(x)
hierarchy.to_tree(Z)
&lt;scipy.cluster.hierarchy.ClusterNode object at ...
rootnode, nodelist = hierarchy.to_tree(Z, rd=True)
rootnode
&lt;scipy.cluster.hierarchy.ClusterNode object at ...
len(nodelist)
9</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">ward</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform Ward's linkage on a condensed distance matrix.</p>
<p>See <code>linkage</code> for more information on the return structure
and algorithm.</p>
<p>The following are common calling conventions:</p>
<ol>
<li>
<p><code>Z = ward(y)</code>
Performs Ward's linkage on the condensed distance matrix <code>y</code>.</p>
</li>
<li>
<p><code>Z = ward(X)</code>
Performs Ward's linkage on the observation matrix <code>X</code> using
Euclidean distance as the distance metric.</p>
</li>
</ol>
<h2 id="parameters_30">Parameters<a class="headerlink" href="#parameters_30" title="Permanent link">&para;</a></h2>
<p>y : ndarray
A condensed distance matrix. A condensed
distance matrix is a flat array containing the upper
triangular of the distance matrix. This is the form that
<code>pdist</code> returns.  Alternatively, a collection of
m observation vectors in n dimensions may be passed as
a m by n array.</p>
<h2 id="returns_34">Returns<a class="headerlink" href="#returns_34" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
The hierarchical clustering encoded as a linkage matrix. See
<code>linkage</code> for more information on the return structure and
algorithm.</p>
<h2 id="see-also_25">See Also<a class="headerlink" href="#see-also_25" title="Permanent link">&para;</a></h2>
<p>linkage: for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_28">Examples<a class="headerlink" href="#examples_28" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import ward, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = ward(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 9.        , 10.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.29099445,  3.        ],
[ 5.        , 13.        ,  1.29099445,  3.        ],
[ 8.        , 14.        ,  1.29099445,  3.        ],
[11.        , 15.        ,  1.29099445,  3.        ],
[16.        , 17.        ,  5.77350269,  6.        ],
[18.        , 19.        ,  5.77350269,  6.        ],
[20.        , 21.        ,  8.16496581, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
fcluster(Z, 1.1, criterion='distance')
array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32)
fcluster(Z, 3, criterion='distance')
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32)
fcluster(Z, 9, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">weighted</span> <span class="o">:</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Perform weighted/WPGMA linkage on the condensed distance matrix.</p>
<p>See <code>linkage</code> for more information on the return
structure and algorithm.</p>
<h2 id="parameters_31">Parameters<a class="headerlink" href="#parameters_31" title="Permanent link">&para;</a></h2>
<p>y : ndarray
The upper triangular of the distance matrix. The result of
<code>pdist</code> is returned in this form.</p>
<h2 id="returns_35">Returns<a class="headerlink" href="#returns_35" title="Permanent link">&para;</a></h2>
<p>Z : ndarray
A linkage matrix containing the hierarchical clustering. See
<code>linkage</code> for more information on its structure.</p>
<h2 id="see-also_26">See Also<a class="headerlink" href="#see-also_26" title="Permanent link">&para;</a></h2>
<p>linkage : for advanced creation of hierarchical clusterings.
scipy.spatial.distance.pdist : pairwise distance metrics</p>
<h2 id="examples_29">Examples<a class="headerlink" href="#examples_29" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.hierarchy import weighted, fcluster
from scipy.spatial.distance import pdist</p>
</blockquote>
</blockquote>
</blockquote>
<p>First we need a toy dataset to play with::</p>
<p>x x    x x
x        x</p>
<p>x        x
x x    x x</p>
<blockquote>
<blockquote>
<blockquote>
<p>X = [[0, 0], [0, 1], [1, 0],
...      [0, 4], [0, 3], [1, 4],
...      [4, 0], [3, 0], [4, 1],
...      [4, 4], [3, 4], [4, 3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Then we get a condensed distance matrix from this dataset:</p>
<blockquote>
<blockquote>
<blockquote>
<p>y = pdist(X)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Finally, we can perform the clustering:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Z = weighted(y)
Z
array([[ 0.        ,  1.        ,  1.        ,  2.        ],
[ 6.        ,  7.        ,  1.        ,  2.        ],
[ 3.        ,  4.        ,  1.        ,  2.        ],
[ 9.        , 11.        ,  1.        ,  2.        ],
[ 2.        , 12.        ,  1.20710678,  3.        ],
[ 8.        , 13.        ,  1.20710678,  3.        ],
[ 5.        , 14.        ,  1.20710678,  3.        ],
[10.        , 15.        ,  1.20710678,  3.        ],
[18.        , 19.        ,  3.05595762,  6.        ],
[16.        , 17.        ,  3.32379407,  6.        ],
[20.        , 21.        ,  4.06357713, 12.        ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>The linkage matrix <code>Z</code> represents a dendrogram - see
<code>scipy.cluster.hierarchy.linkage</code> for a detailed explanation of its
contents.</p>
<p>We can use <code>scipy.cluster.hierarchy.fcluster</code> to see to which cluster
each initial point would belong given a distance threshold:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fcluster(Z, 0.9, criterion='distance')
array([ 7,  8,  9,  1,  2,  3, 10, 11, 12,  4,  6,  5], dtype=int32)
fcluster(Z, 1.5, criterion='distance')
array([3, 3, 3, 1, 1, 1, 4, 4, 4, 2, 2, 2], dtype=int32)
fcluster(Z, 4, criterion='distance')
array([2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1], dtype=int32)
fcluster(Z, 6, criterion='distance')
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also <code>scipy.cluster.hierarchy.dendrogram</code> can be used to generate a
plot of the dendrogram.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span> <span class="nc">Vq</span> <span class="o">:</span> <span class="k">sig</span>
</code></pre></div>

<p>Get an attribute of this module as a Py.Object.t.
This is useful to pass a Python function to another function.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">get_py</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">module</span> <span class="nc">ClusterError</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">ClusterError</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">BaseException</span> <span class="o">|</span> <span class="o">`</span><span class="nc">ClusterError</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">as_exception</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">BaseException</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">with_traceback</span> <span class="o">:</span> <span class="n">tb</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Exception.with_traceback(tb) --
set self.<strong>traceback</strong> to tb and return self.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Deque</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Deque</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Deque</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">setitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Set self[key] to value.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">index</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">object_</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.insert(index, object) -- insert object before index</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>D.remove(value) -- remove first occurrence of value.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">module</span> <span class="nc">Xrange</span> <span class="o">:</span> <span class="k">sig</span>
<span class="k">type</span> <span class="n">tag</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Range</span><span class="o">]</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[`</span><span class="nc">Object</span> <span class="o">|</span> <span class="o">`</span><span class="nc">Range</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
<span class="k">val</span> <span class="n">of_pyobject</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">to_pyobject</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>

<span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
</code></pre></div>

<p>range(stop) -&gt; range object
range(start, stop[, step]) -&gt; range object</p>
<p>Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">getitem__</span> <span class="o">:</span> <span class="n">key</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Return self[key].</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="o">__</span><span class="n">iter__</span> <span class="o">:</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Implement iter(self).</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">count</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.count(value) -&gt; integer -- return number of occurrences of value</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">index</span> <span class="o">:</span> <span class="k">value</span><span class="o">:</span><span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">[&gt;</span> <span class="n">tag</span><span class="o">]</span> <span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>rangeobject.index(value) -&gt; integer -- return index of value.
Raise ValueError if the value is not present.</p>
<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Print the object to a human-readable representation.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">show</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span>
</code></pre></div>

<p>Pretty-print the object to a formatter.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">pp</span> <span class="o">:</span> <span class="nn">Format</span><span class="p">.</span><span class="n">formatter</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">[@@</span><span class="n">ocaml</span><span class="o">.</span><span class="n">toplevel_printer</span><span class="o">]</span>



<span class="k">val</span> <span class="n">cdist</span> <span class="o">:</span> <span class="o">?</span><span class="n">metric</span><span class="o">:[`</span><span class="nc">Callable</span> <span class="k">of</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">S</span> <span class="k">of</span> <span class="kt">string</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">kwargs</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">xa</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">xb</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Compute distance between each pair of the two collections of inputs.</p>
<p>See Notes for common calling conventions.</p>
<h2 id="parameters_32">Parameters<a class="headerlink" href="#parameters_32" title="Permanent link">&para;</a></h2>
<p>XA : ndarray
An :math:<code>m_A</code> by :math:<code>n</code> array of :math:<code>m_A</code>
original observations in an :math:<code>n</code>-dimensional space.
Inputs are converted to float type.
XB : ndarray
An :math:<code>m_B</code> by :math:<code>n</code> array of :math:<code>m_B</code>
original observations in an :math:<code>n</code>-dimensional space.
Inputs are converted to float type.
metric : str or callable, optional
The distance metric to use.  If a string, the distance function can be
'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
'wminkowski', 'yule'.
<em>args : tuple. Deprecated.
Additional arguments should be passed as keyword arguments
</em>*kwargs : dict, optional
Extra arguments to <code>metric</code>: refer to each metric documentation for a
list of all possible arguments.</p>
<p>Some possible arguments:</p>
<p>p : scalar
The p-norm to apply for Minkowski, weighted and unweighted.
Default: 2.</p>
<p>w : ndarray
The weight vector for metrics that support weights (e.g., Minkowski).</p>
<p>V : ndarray
The variance vector for standardized Euclidean.
Default: var(vstack([XA, XB]), axis=0, ddof=1)</p>
<p>VI : ndarray
The inverse of the covariance matrix for Mahalanobis.
Default: inv(cov(vstack([XA, XB].T))).T</p>
<p>out : ndarray
The output array
If not None, the distance matrix Y is stored in this array.
Note: metric independent, it will become a regular keyword arg in a
future scipy version</p>
<h2 id="returns_36">Returns<a class="headerlink" href="#returns_36" title="Permanent link">&para;</a></h2>
<p>Y : ndarray
A :math:<code>m_A</code> by :math:<code>m_B</code> distance matrix is returned.
For each :math:<code>i</code> and :math:<code>j</code>, the metric
<code>dist(u=XA[i], v=XB[j])</code> is computed and stored in the
:math:<code>ij</code> th entry.</p>
<h2 id="raises">Raises<a class="headerlink" href="#raises" title="Permanent link">&para;</a></h2>
<p>ValueError
An exception is thrown if <code>XA</code> and <code>XB</code> do not have
the same number of columns.</p>
<h2 id="notes_5">Notes<a class="headerlink" href="#notes_5" title="Permanent link">&para;</a></h2>
<p>The following are common calling conventions:</p>
<ol>
<li><code>Y = cdist(XA, XB, 'euclidean')</code></li>
</ol>
<p>Computes the distance between :math:<code>m</code> points using
Euclidean distance (2-norm) as the distance metric between the
points. The points are arranged as :math:<code>m</code>
:math:<code>n</code>-dimensional row vectors in the matrix X.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'minkowski', p=2.)</code></li>
</ol>
<p>Computes the distances using the Minkowski distance
:math:<code>||u-v||_p</code> (:math:<code>p</code>-norm) where :math:<code>p \geq 1</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'cityblock')</code></li>
</ol>
<p>Computes the city block or Manhattan distance between the
points.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'seuclidean', V=None)</code></li>
</ol>
<p>Computes the standardized Euclidean distance. The standardized
Euclidean distance between two n-vectors <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>\sqrt{\sum {(u_i-v_i)^2 / V[x_i]}}.</p>
<p>V is the variance vector; V[i] is the variance computed over all
the i'th components of the points. If not passed, it is
automatically computed.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sqeuclidean')</code></li>
</ol>
<p>Computes the squared Euclidean distance :math:<code>||u-v||_2^2</code> between
the vectors.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'cosine')</code></li>
</ol>
<p>Computes the cosine distance between vectors u and v,</p>
<p>.. math::</p>
<p>1 - \frac{u \cdot v}
{{ ||u|| }_2 { ||v|| }_2}</p>
<p>where :math:<code>||*||_2</code> is the 2-norm of its argument <code>*</code>, and
:math:<code>u \cdot v</code> is the dot product of :math:<code>u</code> and :math:<code>v</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'correlation')</code></li>
</ol>
<p>Computes the correlation distance between vectors u and v. This is</p>
<p>.. math::</p>
<p>1 - \frac{(u - \bar{u}) \cdot (v - \bar{v})}
{{ ||(u - \bar{u})|| }_2 { ||(v - \bar{v})|| }_2}</p>
<p>where :math:<code>\bar{v}</code> is the mean of the elements of vector v,
and :math:<code>x \cdot y</code> is the dot product of :math:<code>x</code> and :math:<code>y</code>.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'hamming')</code></li>
</ol>
<p>Computes the normalized Hamming distance, or the proportion of
those vector elements between two n-vectors <code>u</code> and <code>v</code>
which disagree. To save memory, the matrix <code>X</code> can be of type
boolean.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'jaccard')</code></li>
</ol>
<p>Computes the Jaccard distance between the points. Given two
vectors, <code>u</code> and <code>v</code>, the Jaccard distance is the
proportion of those elements <code>u[i]</code> and <code>v[i]</code> that
disagree where at least one of them is non-zero.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'chebyshev')</code></li>
</ol>
<p>Computes the Chebyshev distance between the points. The
Chebyshev distance between two n-vectors <code>u</code> and <code>v</code> is the
maximum norm-1 distance between their respective elements. More
precisely, the distance is given by</p>
<p>.. math::</p>
<p>d(u,v) = \max_i { |u_i-v_i| }.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'canberra')</code></li>
</ol>
<p>Computes the Canberra distance between the points. The
Canberra distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \sum_i \frac{ |u_i-v_i| }
{ |u_i|+|v_i| }.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'braycurtis')</code></li>
</ol>
<p>Computes the Bray-Curtis distance between the points. The
Bray-Curtis distance between two points <code>u</code> and <code>v</code> is</p>
<p>.. math::</p>
<p>d(u,v) = \frac{\sum_i (|u_i-v_i|)}
{\sum_i (|u_i+v_i|)}</p>
<ol>
<li><code>Y = cdist(XA, XB, 'mahalanobis', VI=None)</code></li>
</ol>
<p>Computes the Mahalanobis distance between the points. The
Mahalanobis distance between two points <code>u</code> and <code>v</code> is
:math:<code>\sqrt{(u-v)(1/V)(u-v)^T}</code> where :math:<code>(1/V)</code> (the <code>VI</code>
variable) is the inverse covariance. If <code>VI</code> is not None,
<code>VI</code> will be used as the inverse covariance matrix.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'yule')</code></li>
</ol>
<p>Computes the Yule distance between the boolean
vectors. (see <code>yule</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'matching')</code></li>
</ol>
<p>Synonym for 'hamming'.</p>
<ol>
<li><code>Y = cdist(XA, XB, 'dice')</code></li>
</ol>
<p>Computes the Dice distance between the boolean vectors. (see
<code>dice</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'kulsinski')</code></li>
</ol>
<p>Computes the Kulsinski distance between the boolean
vectors. (see <code>kulsinski</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'rogerstanimoto')</code></li>
</ol>
<p>Computes the Rogers-Tanimoto distance between the boolean
vectors. (see <code>rogerstanimoto</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'russellrao')</code></li>
</ol>
<p>Computes the Russell-Rao distance between the boolean
vectors. (see <code>russellrao</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sokalmichener')</code></li>
</ol>
<p>Computes the Sokal-Michener distance between the boolean
vectors. (see <code>sokalmichener</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'sokalsneath')</code></li>
</ol>
<p>Computes the Sokal-Sneath distance between the vectors. (see
<code>sokalsneath</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, 'wminkowski', p=2., w=w)</code></li>
</ol>
<p>Computes the weighted Minkowski distance between the
vectors. (see <code>wminkowski</code> function documentation)</p>
<ol>
<li><code>Y = cdist(XA, XB, f)</code></li>
</ol>
<p>Computes the distance between all pairs of vectors in X
using the user supplied 2-arity function f. For example,
Euclidean distance between the vectors could be computed
as follows::</p>
<p>dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</p>
<p>Note that you should avoid passing a reference to one of
the distance functions defined in this library. For example,::</p>
<p>dm = cdist(XA, XB, sokalsneath)</p>
<p>would calculate the pair-wise distances between the vectors in
X using the Python function <code>sokalsneath</code>. This would result in
sokalsneath being called :math:<code>{n \choose 2}</code> times, which
is inefficient. Instead, the optimized C version is more
efficient, and we call it using the following syntax::</p>
<p>dm = cdist(XA, XB, 'sokalsneath')</p>
<h2 id="examples_30">Examples<a class="headerlink" href="#examples_30" title="Permanent link">&para;</a></h2>
<p>Find the Euclidean distances between four 2-D coordinates:</p>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.spatial import distance
coords = [(35.0456, -85.2672),
...           (35.1174, -89.9711),
...           (35.9728, -83.9422),
...           (36.1667, -86.7833)]
distance.cdist(coords, coords, 'euclidean')
array([[ 0.    ,  4.7044,  1.6172,  1.8856],
[ 4.7044,  0.    ,  6.0893,  3.3561],
[ 1.6172,  6.0893,  0.    ,  2.8477],
[ 1.8856,  3.3561,  2.8477,  0.    ]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Find the Manhattan distance from a 3-D point to the corners of the unit
cube:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = np.array([[0, 0, 0],
...               [0, 0, 1],
...               [0, 1, 0],
...               [0, 1, 1],
...               [1, 0, 0],
...               [1, 0, 1],
...               [1, 1, 0],
...               [1, 1, 1]])
b = np.array([[ 0.1,  0.2,  0.4]])
distance.cdist(a, b, 'cityblock')
array([[ 0.7],
[ 0.9],
[ 1.3],
[ 1.5],
[ 1.5],
[ 1.7],
[ 2.1],
[ 2.3]])</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kmeans</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">obs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k_or_guess</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="kt">float</span><span class="o">)</span>
</code></pre></div>

<p>Performs k-means on a set of observation vectors forming k clusters.</p>
<p>The k-means algorithm adjusts the classification of the observations
into clusters and updates the cluster centroids until the position of
the centroids is stable over successive iterations. In this
implementation of the algorithm, the stability of the centroids is
determined by comparing the absolute value of the change in the average
Euclidean distance between the observations and their corresponding
centroids against a threshold. This yields
a code book mapping centroids to codes and vice versa.</p>
<h2 id="parameters_33">Parameters<a class="headerlink" href="#parameters_33" title="Permanent link">&para;</a></h2>
<p>obs : ndarray
Each row of the M by N array is an observation vector. The
columns are the features seen during each observation.
The features must be whitened first with the <code>whiten</code> function.</p>
<p>k_or_guess : int or ndarray
The number of centroids to generate. A code is assigned to
each centroid, which is also the row index of the centroid
in the code_book matrix generated.</p>
<p>The initial k centroids are chosen by randomly selecting
observations from the observation matrix. Alternatively,
passing a k by N array specifies the initial k centroids.</p>
<p>iter : int, optional
The number of times to run k-means, returning the codebook
with the lowest distortion. This argument is ignored if
initial centroids are specified with an array for the
<code>k_or_guess</code> parameter. This parameter does not represent the
number of iterations of the k-means algorithm.</p>
<p>thresh : float, optional
Terminates the k-means algorithm if the change in
distortion since the last k-means iteration is less than
or equal to thresh.</p>
<p>check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_37">Returns<a class="headerlink" href="#returns_37" title="Permanent link">&para;</a></h2>
<p>codebook : ndarray
A k by N array of k centroids. The i'th centroid
codebook[i] is represented with the code i. The centroids
and codes generated represent the lowest distortion seen,
not necessarily the globally minimal distortion.</p>
<p>distortion : float
The mean (non-squared) Euclidean distance between the observations
passed and the centroids generated. Note the difference to the standard
definition of distortion in the context of the K-means algorithm, which
is the sum of the squared distances.</p>
<h2 id="see-also_27">See Also<a class="headerlink" href="#see-also_27" title="Permanent link">&para;</a></h2>
<p>kmeans2 : a different implementation of k-means clustering
with more methods for generating initial centroids but without
using a distortion change threshold as a stopping criterion.</p>
<p>whiten : must be called prior to passing an observation matrix
to kmeans.</p>
<h2 id="examples_31">Examples<a class="headerlink" href="#examples_31" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.cluster.vq import vq, kmeans, whiten
import matplotlib.pyplot as plt
features  = array([[ 1.9,2.3],
...                    [ 1.5,2.5],
...                    [ 0.8,0.6],
...                    [ 0.4,1.8],
...                    [ 0.1,0.1],
...                    [ 0.2,1.8],
...                    [ 2.0,0.5],
...                    [ 0.3,1.5],
...                    [ 1.0,1.0]])
whitened = whiten(features)
book = np.array((whitened[0],whitened[2]))
kmeans(whitened,book)
(array([[ 2.3110306 ,  2.86287398],    # random
[ 0.93218041,  1.24398691]]), 0.85684700941625547)</p>
<p>from numpy import random
random.seed((1000,2000))
codes = 3
kmeans(whitened,codes)
(array([[ 2.3110306 ,  2.86287398],    # random
[ 1.32544402,  0.65607529],
[ 0.40782893,  2.02786907]]), 0.5196582527686241)</p>
<h1 id="create-50-datapoints-in-two-clusters-a-and-b">Create 50 datapoints in two clusters a and b<a class="headerlink" href="#create-50-datapoints-in-two-clusters-a-and-b" title="Permanent link">&para;</a></h1>
<p>pts = 50
a = np.random.multivariate_normal([0, 0], [[4, 1], [1, 4]], size=pts)
b = np.random.multivariate_normal([30, 10],
...                                   [[10, 2], [2, 1]],
...                                   size=pts)
features = np.concatenate((a, b))</p>
<h1 id="whiten-data">Whiten data<a class="headerlink" href="#whiten-data" title="Permanent link">&para;</a></h1>
<p>whitened = whiten(features)</p>
<h1 id="find-2-clusters-in-the-data">Find 2 clusters in the data<a class="headerlink" href="#find-2-clusters-in-the-data" title="Permanent link">&para;</a></h1>
<p>codebook, distortion = kmeans(whitened, 2)</p>
<h1 id="plot-whitened-data-and-cluster-centers-in-red">Plot whitened data and cluster centers in red<a class="headerlink" href="#plot-whitened-data-and-cluster-centers-in-red" title="Permanent link">&para;</a></h1>
<p>plt.scatter(whitened[:, 0], whitened[:, 1])
plt.scatter(codebook[:, 0], codebook[:, 1], c='r')
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">kmeans2</span> <span class="o">:</span> <span class="o">?</span><span class="n">iter</span><span class="o">:</span><span class="kt">int</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">thresh</span><span class="o">:</span><span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">minit</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">missing</span><span class="o">:</span><span class="kt">string</span> <span class="o">-&gt;</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">:[`</span><span class="nc">Ndarray</span> <span class="k">of</span> <span class="o">[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">|</span> <span class="o">`</span><span class="nc">I</span> <span class="k">of</span> <span class="kt">int</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Classify a set of observations into k clusters using the k-means algorithm.</p>
<p>The algorithm attempts to minimize the Euclidian distance between
observations and centroids. Several initialization methods are
included.</p>
<h2 id="parameters_34">Parameters<a class="headerlink" href="#parameters_34" title="Permanent link">&para;</a></h2>
<p>data : ndarray
A 'M' by 'N' array of 'M' observations in 'N' dimensions or a length
'M' array of 'M' one-dimensional observations.
k : int or ndarray
The number of clusters to form as well as the number of
centroids to generate. If <code>minit</code> initialization string is
'matrix', or if a ndarray is given instead, it is
interpreted as initial cluster to use instead.
iter : int, optional
Number of iterations of the k-means algorithm to run. Note
that this differs in meaning from the iters parameter to
the kmeans function.
thresh : float, optional
(not used yet)
minit : str, optional
Method for initialization. Available methods are 'random',
'points', '++' and 'matrix':</p>
<p>'random': generate k centroids from a Gaussian with mean and
variance estimated from the data.</p>
<p>'points': choose k observations (rows) at random from data for
the initial centroids.</p>
<p>'++': choose k observations accordingly to the kmeans++ method
(careful seeding)</p>
<p>'matrix': interpret the k parameter as a k by M (or length k
array for one-dimensional data) array of initial centroids.
missing : str, optional
Method to deal with empty clusters. Available methods are
'warn' and 'raise':</p>
<p>'warn': give a warning and continue.</p>
<p>'raise': raise an ClusterError and terminate the algorithm.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_38">Returns<a class="headerlink" href="#returns_38" title="Permanent link">&para;</a></h2>
<p>centroid : ndarray
A 'k' by 'N' array of centroids found at the last iteration of
k-means.
label : ndarray
label[i] is the code or index of the centroid the
i'th observation is closest to.</p>
<h2 id="see-also_28">See Also<a class="headerlink" href="#see-also_28" title="Permanent link">&para;</a></h2>
<p>kmeans</p>
<h2 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h2>
<p>.. [1] D. Arthur and S. Vassilvitskii, 'k-means++: the advantages of
careful seeding', Proceedings of the Eighteenth Annual ACM-SIAM Symposium
on Discrete Algorithms, 2007.</p>
<h2 id="examples_32">Examples<a class="headerlink" href="#examples_32" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.vq import kmeans2
import matplotlib.pyplot as plt</p>
</blockquote>
</blockquote>
</blockquote>
<p>Create z, an array with shape (100, 2) containing a mixture of samples
from three multivariate normal distributions.</p>
<blockquote>
<blockquote>
<blockquote>
<p>np.random.seed(12345678)
a = np.random.multivariate_normal([0, 6], [[2, 1], [1, 1.5]], size=45)
b = np.random.multivariate_normal([2, 0], [[1, -1], [-1, 3]], size=30)
c = np.random.multivariate_normal([6, 4], [[5, 0], [0, 1.2]], size=25)
z = np.concatenate((a, b, c))
np.random.shuffle(z)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Compute three clusters.</p>
<blockquote>
<blockquote>
<blockquote>
<p>centroid, label = kmeans2(z, 3, minit='points')
centroid
array([[-0.35770296,  5.31342524],
[ 2.32210289, -0.50551972],
[ 6.17653859,  4.16719247]])</p>
</blockquote>
</blockquote>
</blockquote>
<p>How many points are in each cluster?</p>
<blockquote>
<blockquote>
<blockquote>
<p>counts = np.bincount(label)
counts
array([52, 27, 21])</p>
</blockquote>
</blockquote>
</blockquote>
<p>Plot the clusters.</p>
<blockquote>
<blockquote>
<blockquote>
<p>w0 = z[label == 0]
w1 = z[label == 1]
w2 = z[label == 2]
plt.plot(w0[:, 0], w0[:, 1], 'o', alpha=0.5, label='cluster 0')
plt.plot(w1[:, 0], w1[:, 1], 'd', alpha=0.5, label='cluster 1')
plt.plot(w2[:, 0], w2[:, 1], 's', alpha=0.5, label='cluster 2')
plt.plot(centroid[:, 0], centroid[:, 1], 'k*', label='centroids')
plt.axis('equal')
plt.legend(shadow=True)
plt.show()</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">py_vq</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">obs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">code_book</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Python version of vq algorithm.</p>
<p>The algorithm computes the euclidian distance between each
observation and every frame in the code_book.</p>
<h2 id="parameters_35">Parameters<a class="headerlink" href="#parameters_35" title="Permanent link">&para;</a></h2>
<p>obs : ndarray
Expects a rank 2 array. Each row is one observation.
code_book : ndarray
Code book to use. Same format than obs. Should have same number of
features (eg columns) than obs.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_39">Returns<a class="headerlink" href="#returns_39" title="Permanent link">&para;</a></h2>
<p>code : ndarray
code[i] gives the label of the ith obversation, that its code is
code_book[code[i]].
mind_dist : ndarray
min_dist[i] gives the distance between the ith observation and its
corresponding code.</p>
<h2 id="notes_6">Notes<a class="headerlink" href="#notes_6" title="Permanent link">&para;</a></h2>
<p>This function is slower than the C version but works for
all input types.  If the inputs have the wrong types for the
C versions of the function, this one is called as a last resort.</p>
<p>It is about 20 times slower than the C version.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">py_vq2</span> <span class="o">:</span> <span class="o">?</span><span class="n">kwds</span><span class="o">:(</span><span class="kt">string</span> <span class="o">*</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="nn">Py</span><span class="p">.</span><span class="nn">Object</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p><code>py_vq2</code> is deprecated, use <code>py_vq</code> instead!</p>
<p>Python version of vq algorithm.</p>
<p>The algorithm computes the euclidian distance between each
observation and every frame in the code_book.</p>
<h2 id="parameters_36">Parameters<a class="headerlink" href="#parameters_36" title="Permanent link">&para;</a></h2>
<p>obs : ndarray
Expects a rank 2 array. Each row is one observation.
code_book : ndarray
Code book to use. Same format than obs. Should have same number of
features (eg columns) than obs.
check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_40">Returns<a class="headerlink" href="#returns_40" title="Permanent link">&para;</a></h2>
<p>code : ndarray
code[i] gives the label of the ith obversation, that its code is
code_book[code[i]].
mind_dist : ndarray
min_dist[i] gives the distance between the ith observation and its
corresponding code.</p>
<h2 id="notes_7">Notes<a class="headerlink" href="#notes_7" title="Permanent link">&para;</a></h2>
<p>This function is slower than the C version but works for
all input types.  If the inputs have the wrong types for the
C versions of the function, this one is called as a last resort.</p>
<p>It is about 20 times slower than the C version.</p>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">vq</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">obs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">code_book</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">([`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span><span class="o">)</span>
</code></pre></div>

<p>Assign codes from a code book to observations.</p>
<p>Assigns a code from a code book to each observation. Each
observation vector in the 'M' by 'N' <code>obs</code> array is compared with the
centroids in the code book and assigned the code of the closest
centroid.</p>
<p>The features in <code>obs</code> should have unit variance, which can be
achieved by passing them through the whiten function.  The code
book can be created with the k-means algorithm or a different
encoding algorithm.</p>
<h2 id="parameters_37">Parameters<a class="headerlink" href="#parameters_37" title="Permanent link">&para;</a></h2>
<p>obs : ndarray
Each row of the 'M' x 'N' array is an observation.  The columns are
the 'features' seen during each observation. The features must be
whitened first using the whiten function or something equivalent.
code_book : ndarray
The code book is usually generated using the k-means algorithm.
Each row of the array holds a different code, and the columns are
the features of the code.</p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="f0-f1-f2-f3">f0    f1    f2   f3<a class="headerlink" href="#f0-f1-f2-f3" title="Permanent link">&para;</a></h1>
<p>code_book = [
...             [  1.,   2.,   3.,   4.],  #c0
...             [  1.,   2.,   3.,   4.],  #c1
...             [  1.,   2.,   3.,   4.]]  #c2</p>
</blockquote>
</blockquote>
</blockquote>
<p>check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_41">Returns<a class="headerlink" href="#returns_41" title="Permanent link">&para;</a></h2>
<p>code : ndarray
A length M array holding the code book index for each observation.
dist : ndarray
The distortion (distance) between the observation and its nearest
code.</p>
<h2 id="examples_33">Examples<a class="headerlink" href="#examples_33" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from numpy import array
from scipy.cluster.vq import vq
code_book = array([[1.,1.,1.],
...                    [2.,2.,2.]])
features  = array([[  1.9,2.3,1.7],
...                    [  1.5,2.5,2.2],
...                    [  0.8,0.6,1.7]])
vq(features,code_book)
(array([1, 1, 0],'i'), array([ 0.43588989,  0.73484692,  0.83066239]))</p>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">val</span> <span class="n">whiten</span> <span class="o">:</span> <span class="o">?</span><span class="n">check_finite</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="n">obs</span><span class="o">:[&gt;`</span><span class="nc">Ndarray</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">[`</span><span class="nc">ArrayLike</span><span class="o">|`</span><span class="nc">Ndarray</span><span class="o">|`</span><span class="nc">Object</span><span class="o">]</span> <span class="nn">Np</span><span class="p">.</span><span class="nn">Obj</span><span class="p">.</span><span class="n">t</span>
</code></pre></div>

<p>Normalize a group of observations on a per feature basis.</p>
<p>Before running k-means, it is beneficial to rescale each feature
dimension of the observation set with whitening. Each feature is
divided by its standard deviation across all observations to give
it unit variance.</p>
<h2 id="parameters_38">Parameters<a class="headerlink" href="#parameters_38" title="Permanent link">&para;</a></h2>
<p>obs : ndarray
Each row of the array is an observation.  The
columns are the features seen during each observation.</p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="f0-f1-f2">f0    f1    f2<a class="headerlink" href="#f0-f1-f2" title="Permanent link">&para;</a></h1>
<p>obs = [[  1.,   1.,   1.],  #o0
...        [  2.,   2.,   2.],  #o1
...        [  3.,   3.,   3.],  #o2
...        [  4.,   4.,   4.]]  #o3</p>
</blockquote>
</blockquote>
</blockquote>
<p>check_finite : bool, optional
Whether to check that the input matrices contain only finite numbers.
Disabling may give a performance gain, but may result in problems
(crashes, non-termination) if the inputs do contain infinities or NaNs.
Default: True</p>
<h2 id="returns_42">Returns<a class="headerlink" href="#returns_42" title="Permanent link">&para;</a></h2>
<p>result : ndarray
Contains the values in <code>obs</code> scaled by the standard deviation
of each column.</p>
<h2 id="examples_34">Examples<a class="headerlink" href="#examples_34" title="Permanent link">&para;</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>from scipy.cluster.vq import whiten
features  = np.array([[1.9, 2.3, 1.7],
...                       [1.5, 2.5, 2.2],
...                       [0.8, 0.6, 1.7,]])
whiten(features)
array([[ 4.17944278,  2.69811351,  7.21248917],
[ 3.29956009,  2.93273208,  9.33380951],
[ 1.75976538,  0.7038557 ,  7.21248917]])</p>
</blockquote>
</blockquote>
</blockquote>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../" title="SciPy library for OCaml" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                SciPy library for OCaml
              </div>
            </div>
          </a>
        
        
          <a href="../Conftest/" title="Conftest" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Conftest
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ["instant", "tabs"],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>